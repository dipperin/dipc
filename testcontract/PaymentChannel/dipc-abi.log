2019-11-15_10:04:47.430713: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:1026] dipc-abi  verbose  true

2019-11-15_10:04:47.432039: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:1027] dipc-abi argv  start ....

2019-11-15_10:04:47.432061: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:1029]   /Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/bin/dipc-abigen
2019-11-15_10:04:47.432072: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:1029]   -extra-arg=-std=c++17
2019-11-15_10:04:47.432081: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:1029]   -extra-arg=--target=wasm32
2019-11-15_10:04:47.432091: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:1029]   -extra-arg=-w
2019-11-15_10:04:47.432100: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:1029]   -extra-arg=-I/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/testcontract/PaymentChannel
2019-11-15_10:04:47.432109: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:1029]   -extra-arg=-I/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/bin/../include/libcxx
2019-11-15_10:04:47.432119: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:1029]   -extra-arg=-I/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/bin/../include/libc
2019-11-15_10:04:47.432128: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:1029]   -extra-arg=-I/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/bin/../include/rt
2019-11-15_10:04:47.432138: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:1029]   -extra-arg=-I/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/bin/../include/native/softfloat/include
2019-11-15_10:04:47.432148: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:1029]   -extra-arg=-I/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/bin/../include
2019-11-15_10:04:47.432157: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:1029]   PaymentChannel.cpp
2019-11-15_10:04:47.432166: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:1029]   -abigen_output=./PaymentChannel.cpp.abi.json
2019-11-15_10:04:47.432176: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:1029]   -exports_output=/var/folders/tt/8v4bb03x685c49jk_vkvr7s80000gp/T//PaymentChannel.cpp.exports
2019-11-15_10:04:47.432234: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:1029]   -abidef_output=
2019-11-15_10:04:47.432247: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:1029]   -log_path=./
2019-11-15_10:04:47.432257: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:1029]   -log_level=debug
2019-11-15_10:04:47.432266: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:1029]   -verbose
2019-11-15_10:04:47.432276: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:1029]   --
2019-11-15_10:04:47.432286: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:1029]   -w
2019-11-15_10:04:47.432314: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:1031]   dipc-abi argv end 

2019-11-15_10:04:47.432337: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:1037] start run
2019-11-15_10:04:47.432352: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:97] start create_find_macro_factory
2019-11-15_10:04:48.032014: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/tools/abi/AbiMacro.cpp:149] get macro:PAYABLE
2019-11-15_10:04:48.032326: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/tools/abi/AbiMacro.cpp:67] file_name : /Users/konggan/workspace/chain/dipperin/github-dipc/dipc/testcontract/PaymentChannel/PaymentChannel.hpp

2019-11-15_10:04:48.032346: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/tools/abi/AbiMacro.cpp:68] Export macrostr:PAYABLE; long str :PAYABLE; longstr :PAYABLE void init(char* _recipient, uint64_t duration, uint64_t _balance);
    //PAYABLE void init(std::string _recipient, uint64_t duration, uint64_t _balance);
    
    EXPORT void close(uint64_t amount, char* signature);
    EXPORT void extend(uint64_t newExpiration);
    EXPORT void claimTimeout();
    CONSTANT void getPaymentChannelStatus();
};

//DIPC_EVENT(PaymentChannelStatus, char *, uint64_t, uint64_t, bool);
DIPC_EVENT(PaymentChannelStatus, char *, uint64_t, uint64_t);
//DIPC_EVENT(PaymentChannelStatus, uint64_t, uint64_t);
2019-11-15_10:04:48.032733: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/tools/abi/AbiMacro.cpp:82] smatch[2].str : init(; action : init

2019-11-15_10:04:48.032757: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/tools/abi/AbiMacro.cpp:149] get macro:EXPORT
2019-11-15_10:04:48.032766: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/tools/abi/AbiMacro.cpp:67] file_name : /Users/konggan/workspace/chain/dipperin/github-dipc/dipc/testcontract/PaymentChannel/PaymentChannel.hpp

2019-11-15_10:04:48.032772: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/tools/abi/AbiMacro.cpp:68] Export macrostr:EXPORT; long str :EXPORT; longstr :EXPORT void close(uint64_t amount, char* signature);
    EXPORT void extend(uint64_t newExpiration);
    EXPORT void claimTimeout();
    CONSTANT void getPaymentChannelStatus();
};

//DIPC_EVENT(PaymentChannelStatus, char *, uint64_t, uint64_t, bool);
DIPC_EVENT(PaymentChannelStatus, char *, uint64_t, uint64_t);
//DIPC_EVENT(PaymentChannelStatus, uint64_t, uint64_t);
2019-11-15_10:04:48.032803: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/tools/abi/AbiMacro.cpp:82] smatch[2].str : close(; action : close

2019-11-15_10:04:48.032815: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/tools/abi/AbiMacro.cpp:149] get macro:EXPORT
2019-11-15_10:04:48.032822: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/tools/abi/AbiMacro.cpp:67] file_name : /Users/konggan/workspace/chain/dipperin/github-dipc/dipc/testcontract/PaymentChannel/PaymentChannel.hpp

2019-11-15_10:04:48.032827: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/tools/abi/AbiMacro.cpp:68] Export macrostr:EXPORT; long str :EXPORT; longstr :EXPORT void extend(uint64_t newExpiration);
    EXPORT void claimTimeout();
    CONSTANT void getPaymentChannelStatus();
};

//DIPC_EVENT(PaymentChannelStatus, char *, uint64_t, uint64_t, bool);
DIPC_EVENT(PaymentChannelStatus, char *, uint64_t, uint64_t);
//DIPC_EVENT(PaymentChannelStatus, uint64_t, uint64_t);
2019-11-15_10:04:48.032867: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/tools/abi/AbiMacro.cpp:82] smatch[2].str : extend(; action : extend

2019-11-15_10:04:48.032888: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/tools/abi/AbiMacro.cpp:149] get macro:EXPORT
2019-11-15_10:04:48.032897: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/tools/abi/AbiMacro.cpp:67] file_name : /Users/konggan/workspace/chain/dipperin/github-dipc/dipc/testcontract/PaymentChannel/PaymentChannel.hpp

2019-11-15_10:04:48.032904: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/tools/abi/AbiMacro.cpp:68] Export macrostr:EXPORT; long str :EXPORT; longstr :EXPORT void claimTimeout();
    CONSTANT void getPaymentChannelStatus();
};

//DIPC_EVENT(PaymentChannelStatus, char *, uint64_t, uint64_t, bool);
DIPC_EVENT(PaymentChannelStatus, char *, uint64_t, uint64_t);
//DIPC_EVENT(PaymentChannelStatus, uint64_t, uint64_t);
2019-11-15_10:04:48.032930: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/tools/abi/AbiMacro.cpp:82] smatch[2].str : claimTimeout(; action : claimTimeout

2019-11-15_10:04:48.032942: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/tools/abi/AbiMacro.cpp:149] get macro:CONSTANT
2019-11-15_10:04:48.032949: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/tools/abi/AbiMacro.cpp:67] file_name : /Users/konggan/workspace/chain/dipperin/github-dipc/dipc/testcontract/PaymentChannel/PaymentChannel.hpp

2019-11-15_10:04:48.032955: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/tools/abi/AbiMacro.cpp:68] Export macrostr:CONSTANT; long str :CONSTANT; longstr :CONSTANT void getPaymentChannelStatus();
};

//DIPC_EVENT(PaymentChannelStatus, char *, uint64_t, uint64_t, bool);
DIPC_EVENT(PaymentChannelStatus, char *, uint64_t, uint64_t);
//DIPC_EVENT(PaymentChannelStatus, uint64_t, uint64_t);
2019-11-15_10:04:48.032975: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/tools/abi/AbiMacro.cpp:82] smatch[2].str : getPaymentChannelStatus(; action : getPaymentChannelStatus

2019-11-15_10:04:48.032995: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/tools/abi/AbiMacro.cpp:143] get EVENT:DIPC_EVENT
2019-11-15_10:04:48.033166: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/tools/abi/AbiMacro.cpp:149] get macro:PAYABLE
2019-11-15_10:04:48.033176: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/tools/abi/AbiMacro.cpp:67] file_name : /Users/konggan/workspace/chain/dipperin/github-dipc/dipc/testcontract/PaymentChannel/PaymentChannel.cpp

2019-11-15_10:04:48.033182: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/tools/abi/AbiMacro.cpp:68] Export macrostr:PAYABLE; long str :PAYABLE; longstr :PAYABLE void PaymentChannel::init(char* _recipient, uint64_t duration, uint64_t _balance){
//PAYABLE void PaymentChannel::init(std::string _recipient, uint64_t duration, uint64_t _balance){
    *sender = caller();
    *recipient = _recipient;
    print("_recipient");
    print(_recipient);
    print("recipient");
    prints_l(&recipient.get()[0], recipient.get().size());
    *expiration = duration;
    *balance = _balance;
    DipcAssert(dipc::callValue() == _balance);
    DIPC_EMIT_EVENT(PaymentChannelStatus, recipient.get().data(), expiration.get(), balance.get());
}

EXPORT void PaymentChannel::close(uint64_t amount, char* signature){
    DipcAssert(!closed.get());
    Address callerAddr = caller();
    DipcAssert(callerAddr.toString() == recipient.get());
    std::string sign = signature;
    // joint contractAddr, amount, toAddress, use sha3()  encrypt
    Address contractAddr = dipc::address();
    std::string data = contractAddr.toString() + std::to_string(amount) + callerAddr.toString();
    h256 sha3Data = dipc::sha3(data);
    DipcAssert(dipc::getSignerAddress(sha3Data,sign).toString() == sender.get().toString());
    callTransfer(callerAddr, amount);
    DipcAssert(balance.get() -amount > 0);
    callTransfer(sender.get(), balance.get() - amount);
    *closed = true;
}

EXPORT void PaymentChannel::extend(uint64_t newExpiration) {
    DipcAssert(!closed.get());
    DipcAssert(caller().toString() == sender.get().toString());
    DipcAssert(newExpiration > expiration.get());
    *expiration = newExpiration;
}

EXPORT void PaymentChannel::claimTimeout(){
    DipcAssert(!closed.get());
    DipcAssert(dipc::timestamp() > expiration.get());
    callTransfer(sender.get(), balance.get());
    *closed = true;
}

CONSTANT void PaymentChannel::getPaymentChannelStatus(){

    //DIPC_EMIT_EVENT(PaymentChannelStatus, expiration.get(), balance.get());
    //DIPC_EMIT_EVENT(PaymentChannelStatus, 123456, expiration.get(), balance.get(), closed.get());
}
2019-11-15_10:04:48.033232: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/tools/abi/AbiMacro.cpp:82] smatch[2].str : PaymentChannel::init(; action : PaymentChannel::init

2019-11-15_10:04:48.033244: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/tools/abi/AbiMacro.cpp:131] Export macrostr:PAYABLE  contract:void  actions_str:init

2019-11-15_10:04:48.033283: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/tools/abi/AbiMacro.cpp:149] get macro:EXPORT
2019-11-15_10:04:48.033291: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/tools/abi/AbiMacro.cpp:67] file_name : /Users/konggan/workspace/chain/dipperin/github-dipc/dipc/testcontract/PaymentChannel/PaymentChannel.cpp

2019-11-15_10:04:48.033297: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/tools/abi/AbiMacro.cpp:68] Export macrostr:EXPORT; long str :EXPORT; longstr :EXPORT void PaymentChannel::close(uint64_t amount, char* signature){
    DipcAssert(!closed.get());
    Address callerAddr = caller();
    DipcAssert(callerAddr.toString() == recipient.get());
    std::string sign = signature;
    // joint contractAddr, amount, toAddress, use sha3()  encrypt
    Address contractAddr = dipc::address();
    std::string data = contractAddr.toString() + std::to_string(amount) + callerAddr.toString();
    h256 sha3Data = dipc::sha3(data);
    DipcAssert(dipc::getSignerAddress(sha3Data,sign).toString() == sender.get().toString());
    callTransfer(callerAddr, amount);
    DipcAssert(balance.get() -amount > 0);
    callTransfer(sender.get(), balance.get() - amount);
    *closed = true;
}

EXPORT void PaymentChannel::extend(uint64_t newExpiration) {
    DipcAssert(!closed.get());
    DipcAssert(caller().toString() == sender.get().toString());
    DipcAssert(newExpiration > expiration.get());
    *expiration = newExpiration;
}

EXPORT void PaymentChannel::claimTimeout(){
    DipcAssert(!closed.get());
    DipcAssert(dipc::timestamp() > expiration.get());
    callTransfer(sender.get(), balance.get());
    *closed = true;
}

CONSTANT void PaymentChannel::getPaymentChannelStatus(){

    //DIPC_EMIT_EVENT(PaymentChannelStatus, expiration.get(), balance.get());
    //DIPC_EMIT_EVENT(PaymentChannelStatus, 123456, expiration.get(), balance.get(), closed.get());
}
2019-11-15_10:04:48.033326: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/tools/abi/AbiMacro.cpp:82] smatch[2].str : PaymentChannel::close(; action : PaymentChannel::close

2019-11-15_10:04:48.033333: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/tools/abi/AbiMacro.cpp:131] Export macrostr:EXPORT  contract:void  actions_str:close

2019-11-15_10:04:48.033376: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/tools/abi/AbiMacro.cpp:149] get macro:EXPORT
2019-11-15_10:04:48.033384: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/tools/abi/AbiMacro.cpp:67] file_name : /Users/konggan/workspace/chain/dipperin/github-dipc/dipc/testcontract/PaymentChannel/PaymentChannel.cpp

2019-11-15_10:04:48.033390: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/tools/abi/AbiMacro.cpp:68] Export macrostr:EXPORT; long str :EXPORT; longstr :EXPORT void PaymentChannel::extend(uint64_t newExpiration) {
    DipcAssert(!closed.get());
    DipcAssert(caller().toString() == sender.get().toString());
    DipcAssert(newExpiration > expiration.get());
    *expiration = newExpiration;
}

EXPORT void PaymentChannel::claimTimeout(){
    DipcAssert(!closed.get());
    DipcAssert(dipc::timestamp() > expiration.get());
    callTransfer(sender.get(), balance.get());
    *closed = true;
}

CONSTANT void PaymentChannel::getPaymentChannelStatus(){

    //DIPC_EMIT_EVENT(PaymentChannelStatus, expiration.get(), balance.get());
    //DIPC_EMIT_EVENT(PaymentChannelStatus, 123456, expiration.get(), balance.get(), closed.get());
}
2019-11-15_10:04:48.033417: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/tools/abi/AbiMacro.cpp:82] smatch[2].str : PaymentChannel::extend(; action : PaymentChannel::extend

2019-11-15_10:04:48.033424: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/tools/abi/AbiMacro.cpp:131] Export macrostr:EXPORT  contract:void  actions_str:extend

2019-11-15_10:04:48.033453: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/tools/abi/AbiMacro.cpp:149] get macro:EXPORT
2019-11-15_10:04:48.033460: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/tools/abi/AbiMacro.cpp:67] file_name : /Users/konggan/workspace/chain/dipperin/github-dipc/dipc/testcontract/PaymentChannel/PaymentChannel.cpp

2019-11-15_10:04:48.033466: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/tools/abi/AbiMacro.cpp:68] Export macrostr:EXPORT; long str :EXPORT; longstr :EXPORT void PaymentChannel::claimTimeout(){
    DipcAssert(!closed.get());
    DipcAssert(dipc::timestamp() > expiration.get());
    callTransfer(sender.get(), balance.get());
    *closed = true;
}

CONSTANT void PaymentChannel::getPaymentChannelStatus(){

    //DIPC_EMIT_EVENT(PaymentChannelStatus, expiration.get(), balance.get());
    //DIPC_EMIT_EVENT(PaymentChannelStatus, 123456, expiration.get(), balance.get(), closed.get());
}
2019-11-15_10:04:48.033488: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/tools/abi/AbiMacro.cpp:82] smatch[2].str : PaymentChannel::claimTimeout(; action : PaymentChannel::claimTimeout

2019-11-15_10:04:48.033495: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/tools/abi/AbiMacro.cpp:131] Export macrostr:EXPORT  contract:void  actions_str:claimTimeout

2019-11-15_10:04:48.033514: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/tools/abi/AbiMacro.cpp:149] get macro:CONSTANT
2019-11-15_10:04:48.033521: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/tools/abi/AbiMacro.cpp:67] file_name : /Users/konggan/workspace/chain/dipperin/github-dipc/dipc/testcontract/PaymentChannel/PaymentChannel.cpp

2019-11-15_10:04:48.033526: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/tools/abi/AbiMacro.cpp:68] Export macrostr:CONSTANT; long str :CONSTANT; longstr :CONSTANT void PaymentChannel::getPaymentChannelStatus(){

    //DIPC_EMIT_EVENT(PaymentChannelStatus, expiration.get(), balance.get());
    //DIPC_EMIT_EVENT(PaymentChannelStatus, 123456, expiration.get(), balance.get(), closed.get());
}
2019-11-15_10:04:48.033551: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/tools/abi/AbiMacro.cpp:82] smatch[2].str : PaymentChannel::getPaymentChannelStatus(; action : PaymentChannel::getPaymentChannelStatus

2019-11-15_10:04:48.033559: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/tools/abi/AbiMacro.cpp:131] Export macrostr:CONSTANT  contract:void  actions_str:getPaymentChannelStatus

2019-11-15_10:04:48.037378: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:1047] result:0contract fullname:[PaymentChannel]
2019-11-15_10:04:49.766305: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/tools/abi/AbiGenerator.cpp:109] contract != Token
2019-11-15_10:04:49.766328: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/tools/abi/AbiGenerator.cpp:111] decl name:[PaymentChannel] contract:[PaymentChannel]
2019-11-15_10:04:49.766341: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/tools/abi/AbiGenerator.cpp:119] funcEntire : void init(char* _recipient, uint64_t duration, uint64_t _balance; funcEnd : );
    //PAYABLE void init(std::string _recipient, uint64_t duration, uint64_t _balance);
    
    EXPORT void close(uint64_t amount, char* signature);
    EXPORT void extend(uint64_t newExpiration);
    EXPORT void claimTimeout();
    CONSTANT void getPaymentChannelStatus();
};

//DIPC_EVENT(PaymentChannelStatus, char *, uint64_t, uint64_t, bool);
DIPC_EVENT(PaymentChannelStatus, char *, uint64_t, uint64_t);
//DIPC_EVENT(PaymentChannelStatus, uint64_t, uint64_t);
2019-11-15_10:04:49.766350: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/tools/abi/AbiGenerator.cpp:124] method :init
2019-11-15_10:04:49.766357: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/tools/abi/AbiGenerator.cpp:145] abi.methodName : init; abi.isConst : false; abi.isPayable :true; abi.isExport :false
2019-11-15_10:04:49.766383: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/tools/abi/AbiGenerator.cpp:47] typeName:  realTypeName:void
2019-11-15_10:04:49.766391: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/tools/abi/AbiGenerator.cpp:157] parame name:_recipient
2019-11-15_10:04:49.766404: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/tools/abi/AbiGenerator.cpp:47] typeName:  realTypeName:char *
2019-11-15_10:04:49.766432: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/tools/abi/AbiGenerator.cpp:157] parame name:duration
2019-11-15_10:04:49.766438: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/tools/abi/AbiGenerator.cpp:26] xxx:uint64_t
2019-11-15_10:04:49.766443: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/tools/abi/AbiGenerator.cpp:28] set typeName
2019-11-15_10:04:49.766455: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/tools/abi/AbiGenerator.cpp:47] typeName:uint64_t  realTypeName:unsigned long long
2019-11-15_10:04:49.766477: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/tools/abi/AbiGenerator.cpp:157] parame name:_balance
2019-11-15_10:04:49.766483: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/tools/abi/AbiGenerator.cpp:26] xxx:uint64_t
2019-11-15_10:04:49.766488: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/tools/abi/AbiGenerator.cpp:28] set typeName
2019-11-15_10:04:49.766499: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/tools/abi/AbiGenerator.cpp:47] typeName:uint64_t  realTypeName:unsigned long long
2019-11-15_10:04:49.766522: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/tools/abi/AbiGenerator.cpp:119] funcEntire : void close(uint64_t amount, char* signature; funcEnd : );
    EXPORT void extend(uint64_t newExpiration);
    EXPORT void claimTimeout();
    CONSTANT void getPaymentChannelStatus();
};

//DIPC_EVENT(PaymentChannelStatus, char *, uint64_t, uint64_t, bool);
DIPC_EVENT(PaymentChannelStatus, char *, uint64_t, uint64_t);
//DIPC_EVENT(PaymentChannelStatus, uint64_t, uint64_t);
2019-11-15_10:04:49.766529: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/tools/abi/AbiGenerator.cpp:124] method :close
2019-11-15_10:04:49.766535: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/tools/abi/AbiGenerator.cpp:145] abi.methodName : close; abi.isConst : false; abi.isPayable :false; abi.isExport :true
2019-11-15_10:04:49.766545: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/tools/abi/AbiGenerator.cpp:47] typeName:  realTypeName:void
2019-11-15_10:04:49.766550: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/tools/abi/AbiGenerator.cpp:157] parame name:amount
2019-11-15_10:04:49.766556: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/tools/abi/AbiGenerator.cpp:26] xxx:uint64_t
2019-11-15_10:04:49.766561: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/tools/abi/AbiGenerator.cpp:28] set typeName
2019-11-15_10:04:49.766572: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/tools/abi/AbiGenerator.cpp:47] typeName:uint64_t  realTypeName:unsigned long long
2019-11-15_10:04:49.766594: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/tools/abi/AbiGenerator.cpp:157] parame name:signature
2019-11-15_10:04:49.766605: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/tools/abi/AbiGenerator.cpp:47] typeName:  realTypeName:char *
2019-11-15_10:04:49.766633: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/tools/abi/AbiGenerator.cpp:119] funcEntire : void extend(uint64_t newExpiration; funcEnd : );
    EXPORT void claimTimeout();
    CONSTANT void getPaymentChannelStatus();
};

//DIPC_EVENT(PaymentChannelStatus, char *, uint64_t, uint64_t, bool);
DIPC_EVENT(PaymentChannelStatus, char *, uint64_t, uint64_t);
//DIPC_EVENT(PaymentChannelStatus, uint64_t, uint64_t);
2019-11-15_10:04:49.766644: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/tools/abi/AbiGenerator.cpp:124] method :extend
2019-11-15_10:04:49.766651: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/tools/abi/AbiGenerator.cpp:145] abi.methodName : extend; abi.isConst : false; abi.isPayable :false; abi.isExport :true
2019-11-15_10:04:49.766661: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/tools/abi/AbiGenerator.cpp:47] typeName:  realTypeName:void
2019-11-15_10:04:49.766666: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/tools/abi/AbiGenerator.cpp:157] parame name:newExpiration
2019-11-15_10:04:49.766672: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/tools/abi/AbiGenerator.cpp:26] xxx:uint64_t
2019-11-15_10:04:49.766677: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/tools/abi/AbiGenerator.cpp:28] set typeName
2019-11-15_10:04:49.766688: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/tools/abi/AbiGenerator.cpp:47] typeName:uint64_t  realTypeName:unsigned long long
2019-11-15_10:04:49.766711: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/tools/abi/AbiGenerator.cpp:119] funcEntire : void claimTimeout(; funcEnd : );
    CONSTANT void getPaymentChannelStatus();
};

//DIPC_EVENT(PaymentChannelStatus, char *, uint64_t, uint64_t, bool);
DIPC_EVENT(PaymentChannelStatus, char *, uint64_t, uint64_t);
//DIPC_EVENT(PaymentChannelStatus, uint64_t, uint64_t);
2019-11-15_10:04:49.766717: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/tools/abi/AbiGenerator.cpp:124] method :claimTimeout
2019-11-15_10:04:49.766723: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/tools/abi/AbiGenerator.cpp:145] abi.methodName : claimTimeout; abi.isConst : false; abi.isPayable :false; abi.isExport :true
2019-11-15_10:04:49.766732: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/tools/abi/AbiGenerator.cpp:47] typeName:  realTypeName:void
2019-11-15_10:04:49.766738: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/tools/abi/AbiGenerator.cpp:119] funcEntire : void getPaymentChannelStatus(; funcEnd : );
};

//DIPC_EVENT(PaymentChannelStatus, char *, uint64_t, uint64_t, bool);
DIPC_EVENT(PaymentChannelStatus, char *, uint64_t, uint64_t);
//DIPC_EVENT(PaymentChannelStatus, uint64_t, uint64_t);
2019-11-15_10:04:49.766745: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/tools/abi/AbiGenerator.cpp:124] method :getPaymentChannelStatus
2019-11-15_10:04:49.766751: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/tools/abi/AbiGenerator.cpp:145] abi.methodName : getPaymentChannelStatus; abi.isConst : true; abi.isPayable :false; abi.isExport :false
2019-11-15_10:04:49.766761: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/tools/abi/AbiGenerator.cpp:47] typeName:  realTypeName:void
2019-11-15_10:04:49.766768: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/tools/abi/AbiGenerator.cpp:119] funcEntire : ; funcEnd : PaymentChannel : public Contract {
private: 
   //String<senderc> sender;
   AddressStore<senderc> sender;
   String<recipientc> recipient;
   Uint64<balancec> balance; 
   Uint64<expirationc> expiration;
   Bool<closec> closed;
public:
    PAYABLE void init(char* _recipient, uint64_t duration, uint64_t _balance);
    //PAYABLE void init(std::string _recipient, uint64_t duration, uint64_t _balance);
    
    EXPORT void close(uint64_t amount, char* signature);
    EXPORT void extend(uint64_t newExpiration);
    EXPORT void claimTimeout();
    CONSTANT void getPaymentChannelStatus();
};

//DIPC_EVENT(PaymentChannelStatus, char *, uint64_t, uint64_t, bool);
DIPC_EVENT(PaymentChannelStatus, char *, uint64_t, uint64_t);
//DIPC_EVENT(PaymentChannelStatus, uint64_t, uint64_t);
2019-11-15_10:04:49.766774: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/tools/abi/AbiGenerator.cpp:119] funcEntire : ; funcEnd : PaymentChannel : public Contract {
private: 
   //String<senderc> sender;
   AddressStore<senderc> sender;
   String<recipientc> recipient;
   Uint64<balancec> balance; 
   Uint64<expirationc> expiration;
   Bool<closec> closed;
public:
    PAYABLE void init(char* _recipient, uint64_t duration, uint64_t _balance);
    //PAYABLE void init(std::string _recipient, uint64_t duration, uint64_t _balance);
    
    EXPORT void close(uint64_t amount, char* signature);
    EXPORT void extend(uint64_t newExpiration);
    EXPORT void claimTimeout();
    CONSTANT void getPaymentChannelStatus();
};

//DIPC_EVENT(PaymentChannelStatus, char *, uint64_t, uint64_t, bool);
DIPC_EVENT(PaymentChannelStatus, char *, uint64_t, uint64_t);
//DIPC_EVENT(PaymentChannelStatus, uint64_t, uint64_t);
2019-11-15_10:04:49.766784: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/tools/abi/AbiGenerator.cpp:119] funcEntire : ; funcEnd : PaymentChannel : public Contract {
private: 
   //String<senderc> sender;
   AddressStore<senderc> sender;
   String<recipientc> recipient;
   Uint64<balancec> balance; 
   Uint64<expirationc> expiration;
   Bool<closec> closed;
public:
    PAYABLE void init(char* _recipient, uint64_t duration, uint64_t _balance);
    //PAYABLE void init(std::string _recipient, uint64_t duration, uint64_t _balance);
    
    EXPORT void close(uint64_t amount, char* signature);
    EXPORT void extend(uint64_t newExpiration);
    EXPORT void claimTimeout();
    CONSTANT void getPaymentChannelStatus();
};

//DIPC_EVENT(PaymentChannelStatus, char *, uint64_t, uint64_t, bool);
DIPC_EVENT(PaymentChannelStatus, char *, uint64_t, uint64_t);
//DIPC_EVENT(PaymentChannelStatus, uint64_t, uint64_t);
2019-11-15_10:04:49.766791: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/tools/abi/AbiGenerator.cpp:119] funcEntire : ; funcEnd : PaymentChannel : public Contract {
private: 
   //String<senderc> sender;
   AddressStore<senderc> sender;
   String<recipientc> recipient;
   Uint64<balancec> balance; 
   Uint64<expirationc> expiration;
   Bool<closec> closed;
public:
    PAYABLE void init(char* _recipient, uint64_t duration, uint64_t _balance);
    //PAYABLE void init(std::string _recipient, uint64_t duration, uint64_t _balance);
    
    EXPORT void close(uint64_t amount, char* signature);
    EXPORT void extend(uint64_t newExpiration);
    EXPORT void claimTimeout();
    CONSTANT void getPaymentChannelStatus();
};

//DIPC_EVENT(PaymentChannelStatus, char *, uint64_t, uint64_t, bool);
DIPC_EVENT(PaymentChannelStatus, char *, uint64_t, uint64_t);
//DIPC_EVENT(PaymentChannelStatus, uint64_t, uint64_t);
2019-11-15_10:04:49.766797: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/tools/abi/AbiGenerator.cpp:169] abis size:5
2019-11-15_10:04:49.994173: <info> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:1064] find method successfind abi size:5
2019-11-15_10:04:49.994202: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:1069] methodName:init args:(
2019-11-15_10:04:49.994210: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:1076] name:_recipient, typeName: realTypeName:char *
2019-11-15_10:04:49.994216: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:1076] name:duration, typeName:uint64_t realTypeName:unsigned long long
2019-11-15_10:04:49.994222: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:1076] name:_balance, typeName:uint64_t realTypeName:unsigned long long
2019-11-15_10:04:49.994227: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:1080] )
2019-11-15_10:04:49.994233: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:1081] return typeName: realTypeName:void
2019-11-15_10:04:49.994238: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:1069] methodName:close args:(
2019-11-15_10:04:49.994249: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:1076] name:amount, typeName:uint64_t realTypeName:unsigned long long
2019-11-15_10:04:49.994255: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:1076] name:signature, typeName: realTypeName:char *
2019-11-15_10:04:49.994260: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:1080] )
2019-11-15_10:04:49.994265: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:1081] return typeName: realTypeName:void
2019-11-15_10:04:49.994270: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:1069] methodName:extend args:(
2019-11-15_10:04:49.994275: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:1076] name:newExpiration, typeName:uint64_t realTypeName:unsigned long long
2019-11-15_10:04:49.994280: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:1080] )
2019-11-15_10:04:49.994285: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:1081] return typeName: realTypeName:void
2019-11-15_10:04:49.994290: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:1069] methodName:claimTimeout args:(
2019-11-15_10:04:49.994295: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:1080] )
2019-11-15_10:04:49.994300: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:1081] return typeName: realTypeName:void
2019-11-15_10:04:49.994305: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:1069] methodName:getPaymentChannelStatus args:(
2019-11-15_10:04:49.994310: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:1080] )
2019-11-15_10:04:49.994315: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:1081] return typeName: realTypeName:void
2019-11-15_10:04:49.994320: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:1094] start create abi json
2019-11-15_10:04:49.994351: <error> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:715] random:[/var/folders/tt/8v4bb03x685c49jk_vkvr7s80000gp/T/ee0d8da8577e10g1g866] fileName:PaymentChannel.cpp.abi.json
2019-11-15_10:04:49.994359: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:717] tmpFile:[/var/folders/tt/8v4bb03x685c49jk_vkvr7s80000gp/T/ee0d8da8577e10g1g866/PaymentChannel.cpp.abi.json]
2019-11-15_10:04:49.994713: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:728] copy ::/var/folders/tt/8v4bb03x685c49jk_vkvr7s80000gp/T/ee0d8da8577e10g1g866/PaymentChannel.cpp.abi.json to ::./PaymentChannel.cpp.abi.json
2019-11-15_10:04:49.995557: <error> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:749] random:[/var/folders/tt/8v4bb03x685c49jk_vkvr7s80000gp/T/ee0d8da8577e10g1g866] fileName:PaymentChannel.cpp.exports
2019-11-15_10:04:49.995574: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:751] tmpFile:[/var/folders/tt/8v4bb03x685c49jk_vkvr7s80000gp/T/ee0d8da8577e10g1g866/PaymentChannel.cpp.exports]
2019-11-15_10:04:49.995795: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:766] copy ::/var/folders/tt/8v4bb03x685c49jk_vkvr7s80000gp/T/ee0d8da8577e10g1g866/PaymentChannel.cpp.exports to ::/var/folders/tt/8v4bb03x685c49jk_vkvr7s80000gp/T//PaymentChannel.cpp.exports
2019-11-15_10:04:49.996771: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:813] macrostr  =======::#include "PaymentChannel.hpp"

PAYABLE void PaymentChannel::init(char* _recipient, uint64_t duration, uint64_t _balance){
//PAYABLE void PaymentChannel::init(std::string _recipient, uint64_t duration, uint64_t _balance){
    *sender = caller();
    *recipient = _recipient;
    print("_recipient");
    print(_recipient);
    print("recipient");
    prints_l(&recipient.get()[0], recipient.get().size());
    *expiration = duration;
    *balance = _balance;
    DipcAssert(dipc::callValue() == _balance);
    DIPC_EMIT_EVENT(PaymentChannelStatus, recipient.get().data(), expiration.get(), balance.get());
}

EXPORT void PaymentChannel::close(uint64_t amount, char* signature){
    DipcAssert(!closed.get());
    Address callerAddr = caller();
    DipcAssert(callerAddr.toString() == recipient.get());
    std::string sign = signature;
    // joint contractAddr, amount, toAddress, use sha3()  encrypt
    Address contractAddr = dipc::address();
    std::string data = contractAddr.toString() + std::to_string(amount) + callerAddr.toString();
    h256 sha3Data = dipc::sha3(data);
    DipcAssert(dipc::getSignerAddress(sha3Data,sign).toString() == sender.get().toString());
    callTransfer(callerAddr, amount);
    DipcAssert(balance.get() -amount > 0);
    callTransfer(sender.get(), balance.get() - amount);
    *closed = true;
}

EXPORT void PaymentChannel::extend(uint64_t newExpiration) {
    DipcAssert(!closed.get());
    DipcAssert(caller().toString() == sender.get().toString());
    DipcAssert(newExpiration > expiration.get());
    *expiration = newExpiration;
}

EXPORT void PaymentChannel::claimTimeout(){
    DipcAssert(!closed.get());
    DipcAssert(dipc::timestamp() > expiration.get());
    callTransfer(sender.get(), balance.get());
    *closed = true;
}

CONSTANT void PaymentChannel::getPaymentChannelStatus(){

    //DIPC_EMIT_EVENT(PaymentChannelStatus, expiration.get(), balance.get());
    //DIPC_EMIT_EVENT(PaymentChannelStatus, 123456, expiration.get(), balance.get(), closed.get());
}

2019-11-15_10:04:49.996791: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:814] headerStr  =======::

2019-11-15_10:04:49.996813: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:817] removedComments  =======::#include "PaymentChannel.hpp"

PAYABLE void PaymentChannel::init(char* _recipient, uint64_t duration, uint64_t _balance){

    *sender = caller();
    *recipient = _recipient;
    print("_recipient");
    print(_recipient);
    print("recipient");
    prints_l(&recipient.get()[0], recipient.get().size());
    *expiration = duration;
    *balance = _balance;
    DipcAssert(dipc::callValue() == _balance);
    DIPC_EMIT_EVENT(PaymentChannelStatus, recipient.get().data(), expiration.get(), balance.get());
}

EXPORT void PaymentChannel::close(uint64_t amount, char* signature){
    DipcAssert(!closed.get());
    Address callerAddr = caller();
    DipcAssert(callerAddr.toString() == recipient.get());
    std::string sign = signature;
    
    Address contractAddr = dipc::address();
    std::string data = contractAddr.toString() + std::to_string(amount) + callerAddr.toString();
    h256 sha3Data = dipc::sha3(data);
    DipcAssert(dipc::getSignerAddress(sha3Data,sign).toString() == sender.get().toString());
    callTransfer(callerAddr, amount);
    DipcAssert(balance.get() -amount > 0);
    callTransfer(sender.get(), balance.get() - amount);
    *closed = true;
}

EXPORT void PaymentChannel::extend(uint64_t newExpiration) {
    DipcAssert(!closed.get());
    DipcAssert(caller().toString() == sender.get().toString());
    DipcAssert(newExpiration > expiration.get());
    *expiration = newExpiration;
}

EXPORT void PaymentChannel::claimTimeout(){
    DipcAssert(!closed.get());
    DipcAssert(dipc::timestamp() > expiration.get());
    callTransfer(sender.get(), balance.get());
    *closed = true;
}

CONSTANT void PaymentChannel::getPaymentChannelStatus(){

    
    
}

2019-11-15_10:04:49.996838: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:372] abis.ispayable :true

2019-11-15_10:04:49.996856: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:395] finalContract  this height   codetext height #include "PaymentChannel.hpp"

PAYABLE void PaymentChannel::init(char* _recipient, uint64_t duration, uint64_t _balance){

    *sender = caller();
    *recipient = _recipient;
    print("_recipient");
    print(_recipient);
    print("recipient");
    prints_l(&recipient.get()[0], recipient.get().size());
    *expiration = duration;
    *balance = _balance;
    DipcAssert(dipc::callValue() == _balance);
    DIPC_EMIT_EVENT(PaymentChannelStatus, recipient.get().data(), expiration.get(), balance.get());
}

EXPORT void PaymentChannel::close(uint64_t amount, char* signature){
    DipcAssert(!closed.get());
    Address callerAddr = caller();
    DipcAssert(callerAddr.toString() == recipient.get());
    std::string sign = signature;
    
    Address contractAddr = dipc::address();
    std::string data = contractAddr.toString() + std::to_string(amount) + callerAddr.toString();
    h256 sha3Data = dipc::sha3(data);
    DipcAssert(dipc::getSignerAddress(sha3Data,sign).toString() == sender.get().toString());
    callTransfer(callerAddr, amount);
    DipcAssert(balance.get() -amount > 0);
    callTransfer(sender.get(), balance.get() - amount);
    *closed = true;
}

EXPORT void PaymentChannel::extend(uint64_t newExpiration) {
    DipcAssert(!closed.get());
    DipcAssert(caller().toString() == sender.get().toString());
    DipcAssert(newExpiration > expiration.get());
    *expiration = newExpiration;
}

EXPORT void PaymentChannel::claimTimeout(){
    DipcAssert(!closed.get());
    DipcAssert(dipc::timestamp() > expiration.get());
    callTransfer(sender.get(), balance.get());
    *closed = true;
}

CONSTANT void PaymentChannel::getPaymentChannelStatus(){

    
    
}

2019-11-15_10:04:49.996863: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:398] searchContext  #include "PaymentChannel.hpp"

PAYABLE void PaymentChannel::init(char* _recipient, uint64_t duration, uint64_t _balance){

    *sender = caller();
    *recipient = _recipient;
    print("_recipient");
    print(_recipient);
    print("recipient");
    prints_l(&recipient.get()[0], recipient.get().size());
    *expiration = duration;
    *balance = _balance;
    DipcAssert(dipc::callValue() == _balance);
    DIPC_EMIT_EVENT(PaymentChannelStatus, recipient.get().data(), expiration.get(), balance.get());
}

EXPORT void PaymentChannel::close(uint64_t amount, char* signature){
    DipcAssert(!closed.get());
    Address callerAddr = caller();
    DipcAssert(callerAddr.toString() == recipient.get());
    std::string sign = signature;
    
    Address contractAddr = dipc::address();
    std::string data = contractAddr.toString() + std::to_string(amount) + callerAddr.toString();
    h256 sha3Data = dipc::sha3(data);
    DipcAssert(dipc::getSignerAddress(sha3Data,sign).toString() == sender.get().toString());
    callTransfer(callerAddr, amount);
    DipcAssert(balance.get() -amount > 0);
    callTransfer(sender.get(), balance.get() - amount);
    *closed = true;
}

EXPORT void PaymentChannel::extend(uint64_t newExpiration) {
    DipcAssert(!closed.get());
    DipcAssert(caller().toString() == sender.get().toString());
    DipcAssert(newExpiration > expiration.get());
    *expiration = newExpiration;
}

EXPORT void PaymentChannel::claimTimeout(){
    DipcAssert(!closed.get());
    DipcAssert(dipc::timestamp() > expiration.get());
    callTransfer(sender.get(), balance.get());
    *closed = true;
}

CONSTANT void PaymentChannel::getPaymentChannelStatus(){

    
    
}

2019-11-15_10:04:49.996917: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:422] log out out payable : PAYABLE void PaymentChannel::init(char* _recipient, uint64_t duration, uint64_t _balance){

    

2019-11-15_10:04:49.996925: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:428] name : init   pos1  0

2019-11-15_10:04:49.996934: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:440] pos2  31   pos1  31

2019-11-15_10:04:49.996941: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:471] pos2 after 508   pos1  31

2019-11-15_10:04:49.996947: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:480] finalContract  first #include "PaymentChannel.hpp"



2019-11-15_10:04:49.996953: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:481] codetext  first #include "PaymentChannel.hpp"

PAYABLE void PaymentChannel::init(char* _recipient, uint64_t duration, uint64_t _balance){

    *sender = caller();
    *recipient = _recipient;
    print("_recipient");
    print(_recipient);
    print("recipient");
    prints_l(&recipient.get()[0], recipient.get().size());
    *expiration = duration;
    *balance = _balance;
    DipcAssert(dipc::callValue() == _balance);
    DIPC_EMIT_EVENT(PaymentChannelStatus, recipient.get().data(), expiration.get(), balance.get());
}

EXPORT void PaymentChannel::close(uint64_t amount, char* signature){
    DipcAssert(!closed.get());
    Address callerAddr = caller();
    DipcAssert(callerAddr.toString() == recipient.get());
    std::string sign = signature;
    
    Address contractAddr = dipc::address();
    std::string data = contractAddr.toString() + std::to_string(amount) + callerAddr.toString();
    h256 sha3Data = dipc::sha3(data);
    DipcAssert(dipc::getSignerAddress(sha3Data,sign).toString() == sender.get().toString());
    callTransfer(callerAddr, amount);
    DipcAssert(balance.get() -amount > 0);
    callTransfer(sender.get(), balance.get() - amount);
    *closed = true;
}

EXPORT void PaymentChannel::extend(uint64_t newExpiration) {
    DipcAssert(!closed.get());
    DipcAssert(caller().toString() == sender.get().toString());
    DipcAssert(newExpiration > expiration.get());
    *expiration = newExpiration;
}

EXPORT void PaymentChannel::claimTimeout(){
    DipcAssert(!closed.get());
    DipcAssert(dipc::timestamp() > expiration.get());
    callTransfer(sender.get(), balance.get());
    *closed = true;
}

CONSTANT void PaymentChannel::getPaymentChannelStatus(){

    
    
}

2019-11-15_10:04:49.996959: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:484] s  first PAYABLE void PaymentChannel::init(char* _recipient, uint64_t duration, uint64_t _balance){

    *sender = caller();
    *recipient = _recipient;
    print("_recipient");
    print(_recipient);
    print("recipient");
    prints_l(&recipient.get()[0], recipient.get().size());
    *expiration = duration;
    *balance = _balance;
    DipcAssert(dipc::callValue() == _balance);
    DIPC_EMIT_EVENT(PaymentChannelStatus, recipient.get().data(), expiration.get(), balance.get());
}

2019-11-15_10:04:49.998018: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:570] search func : PAYABLE void PaymentChannel::init(char* _recipient, uint64_t duration, uint64_t _balance){

    *sender = caller();
    *recipient = _recipient;
    print("_recipient");
    print(_recipient);
    print("recipient");
    prints_l(&recipient.get()[0], recipient.get().size());
    *expiration = duration;
    *balance = _balance;
    DipcAssert(dipc::callValue() == _balance);
    DIPC_EMIT_EVENT(PaymentChannelStatus, recipient.get().data(), expiration.get(), balance.get());
}
2019-11-15_10:04:49.998025: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:395] finalContract  this height  #include "PaymentChannel.hpp"

PAYABLE void PaymentChannel::init(char* _recipient, uint64_t duration, uint64_t _balance){

    *sender = caller();
    *recipient = _recipient;
    print("_recipient");
    print(_recipient);
    print("recipient");
    prints_l(&recipient.get()[0], recipient.get().size());
    *expiration = duration;
    *balance = _balance;
    DipcAssert(dipc::callValue() == _balance);
    DIPC_EMIT_EVENT(PaymentChannelStatus, recipient.get().data(), expiration.get(), balance.get());
} codetext height #include "PaymentChannel.hpp"

PAYABLE void PaymentChannel::init(char* _recipient, uint64_t duration, uint64_t _balance){

    *sender = caller();
    *recipient = _recipient;
    print("_recipient");
    print(_recipient);
    print("recipient");
    prints_l(&recipient.get()[0], recipient.get().size());
    *expiration = duration;
    *balance = _balance;
    DipcAssert(dipc::callValue() == _balance);
    DIPC_EMIT_EVENT(PaymentChannelStatus, recipient.get().data(), expiration.get(), balance.get());
}

EXPORT void PaymentChannel::close(uint64_t amount, char* signature){
    DipcAssert(!closed.get());
    Address callerAddr = caller();
    DipcAssert(callerAddr.toString() == recipient.get());
    std::string sign = signature;
    
    Address contractAddr = dipc::address();
    std::string data = contractAddr.toString() + std::to_string(amount) + callerAddr.toString();
    h256 sha3Data = dipc::sha3(data);
    DipcAssert(dipc::getSignerAddress(sha3Data,sign).toString() == sender.get().toString());
    callTransfer(callerAddr, amount);
    DipcAssert(balance.get() -amount > 0);
    callTransfer(sender.get(), balance.get() - amount);
    *closed = true;
}

EXPORT void PaymentChannel::extend(uint64_t newExpiration) {
    DipcAssert(!closed.get());
    DipcAssert(caller().toString() == sender.get().toString());
    DipcAssert(newExpiration > expiration.get());
    *expiration = newExpiration;
}

EXPORT void PaymentChannel::claimTimeout(){
    DipcAssert(!closed.get());
    DipcAssert(dipc::timestamp() > expiration.get());
    callTransfer(sender.get(), balance.get());
    *closed = true;
}

CONSTANT void PaymentChannel::getPaymentChannelStatus(){

    
    
}

2019-11-15_10:04:49.998040: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:398] searchContext  

EXPORT void PaymentChannel::close(uint64_t amount, char* signature){
    DipcAssert(!closed.get());
    Address callerAddr = caller();
    DipcAssert(callerAddr.toString() == recipient.get());
    std::string sign = signature;
    
    Address contractAddr = dipc::address();
    std::string data = contractAddr.toString() + std::to_string(amount) + callerAddr.toString();
    h256 sha3Data = dipc::sha3(data);
    DipcAssert(dipc::getSignerAddress(sha3Data,sign).toString() == sender.get().toString());
    callTransfer(callerAddr, amount);
    DipcAssert(balance.get() -amount > 0);
    callTransfer(sender.get(), balance.get() - amount);
    *closed = true;
}

EXPORT void PaymentChannel::extend(uint64_t newExpiration) {
    DipcAssert(!closed.get());
    DipcAssert(caller().toString() == sender.get().toString());
    DipcAssert(newExpiration > expiration.get());
    *expiration = newExpiration;
}

EXPORT void PaymentChannel::claimTimeout(){
    DipcAssert(!closed.get());
    DipcAssert(dipc::timestamp() > expiration.get());
    callTransfer(sender.get(), balance.get());
    *closed = true;
}

CONSTANT void PaymentChannel::getPaymentChannelStatus(){

    
    
}

2019-11-15_10:04:49.998445: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:413] finalContract  this new  #include "PaymentChannel.hpp"

PAYABLE void PaymentChannel::init(char* _recipient, uint64_t duration, uint64_t _balance){

    *sender = caller();
    *recipient = _recipient;
    print("_recipient");
    print(_recipient);
    print("recipient");
    prints_l(&recipient.get()[0], recipient.get().size());
    *expiration = duration;
    *balance = _balance;
    DipcAssert(dipc::callValue() == _balance);
    DIPC_EMIT_EVENT(PaymentChannelStatus, recipient.get().data(), expiration.get(), balance.get());
} codetext new #include "PaymentChannel.hpp"

PAYABLE void PaymentChannel::init(char* _recipient, uint64_t duration, uint64_t _balance){

    *sender = caller();
    *recipient = _recipient;
    print("_recipient");
    print(_recipient);
    print("recipient");
    prints_l(&recipient.get()[0], recipient.get().size());
    *expiration = duration;
    *balance = _balance;
    DipcAssert(dipc::callValue() == _balance);
    DIPC_EMIT_EVENT(PaymentChannelStatus, recipient.get().data(), expiration.get(), balance.get());
}

EXPORT void PaymentChannel::close(uint64_t amount, char* signature){
    DipcAssert(!closed.get());
    Address callerAddr = caller();
    DipcAssert(callerAddr.toString() == recipient.get());
    std::string sign = signature;
    
    Address contractAddr = dipc::address();
    std::string data = contractAddr.toString() + std::to_string(amount) + callerAddr.toString();
    h256 sha3Data = dipc::sha3(data);
    DipcAssert(dipc::getSignerAddress(sha3Data,sign).toString() == sender.get().toString());
    callTransfer(callerAddr, amount);
    DipcAssert(balance.get() -amount > 0);
    callTransfer(sender.get(), balance.get() - amount);
    *closed = true;
}

EXPORT void PaymentChannel::extend(uint64_t newExpiration) {
    DipcAssert(!closed.get());
    DipcAssert(caller().toString() == sender.get().toString());
    DipcAssert(newExpiration > expiration.get());
    *expiration = newExpiration;
}

EXPORT void PaymentChannel::claimTimeout(){
    DipcAssert(!closed.get());
    DipcAssert(dipc::timestamp() > expiration.get());
    callTransfer(sender.get(), balance.get());
    *closed = true;
}

CONSTANT void PaymentChannel::getPaymentChannelStatus(){

    
    
}

2019-11-15_10:04:49.998456: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:575] finalContract  final content =======   : #include "PaymentChannel.hpp"

PAYABLE void PaymentChannel::init(char* _recipient, uint64_t duration, uint64_t _balance){

    *sender = caller();
    *recipient = _recipient;
    print("_recipient");
    print(_recipient);
    print("recipient");
    prints_l(&recipient.get()[0], recipient.get().size());
    *expiration = duration;
    *balance = _balance;
    DipcAssert(dipc::callValue() == _balance);
    DIPC_EMIT_EVENT(PaymentChannelStatus, recipient.get().data(), expiration.get(), balance.get());
}

EXPORT void PaymentChannel::close(uint64_t amount, char* signature){
    DipcAssert(!closed.get());
    Address callerAddr = caller();
    DipcAssert(callerAddr.toString() == recipient.get());
    std::string sign = signature;
    
    Address contractAddr = dipc::address();
    std::string data = contractAddr.toString() + std::to_string(amount) + callerAddr.toString();
    h256 sha3Data = dipc::sha3(data);
    DipcAssert(dipc::getSignerAddress(sha3Data,sign).toString() == sender.get().toString());
    callTransfer(callerAddr, amount);
    DipcAssert(balance.get() -amount > 0);
    callTransfer(sender.get(), balance.get() - amount);
    *closed = true;
}

EXPORT void PaymentChannel::extend(uint64_t newExpiration) {
    DipcAssert(!closed.get());
    DipcAssert(caller().toString() == sender.get().toString());
    DipcAssert(newExpiration > expiration.get());
    *expiration = newExpiration;
}

EXPORT void PaymentChannel::claimTimeout(){
    DipcAssert(!closed.get());
    DipcAssert(dipc::timestamp() > expiration.get());
    callTransfer(sender.get(), balance.get());
    *closed = true;
}

CONSTANT void PaymentChannel::getPaymentChannelStatus(){

    
    
}

2019-11-15_10:04:49.998463: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:372] abis.ispayable :false

2019-11-15_10:04:49.998477: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:395] finalContract  this height  #include "PaymentChannel.hpp"

PAYABLE void PaymentChannel::init(char* _recipient, uint64_t duration, uint64_t _balance){

    *sender = caller();
    *recipient = _recipient;
    print("_recipient");
    print(_recipient);
    print("recipient");
    prints_l(&recipient.get()[0], recipient.get().size());
    *expiration = duration;
    *balance = _balance;
    DipcAssert(dipc::callValue() == _balance);
    DIPC_EMIT_EVENT(PaymentChannelStatus, recipient.get().data(), expiration.get(), balance.get());
}

EXPORT void PaymentChannel::close(uint64_t amount, char* signature){
    DipcAssert(!closed.get());
    Address callerAddr = caller();
    DipcAssert(callerAddr.toString() == recipient.get());
    std::string sign = signature;
    
    Address contractAddr = dipc::address();
    std::string data = contractAddr.toString() + std::to_string(amount) + callerAddr.toString();
    h256 sha3Data = dipc::sha3(data);
    DipcAssert(dipc::getSignerAddress(sha3Data,sign).toString() == sender.get().toString());
    callTransfer(callerAddr, amount);
    DipcAssert(balance.get() -amount > 0);
    callTransfer(sender.get(), balance.get() - amount);
    *closed = true;
}

EXPORT void PaymentChannel::extend(uint64_t newExpiration) {
    DipcAssert(!closed.get());
    DipcAssert(caller().toString() == sender.get().toString());
    DipcAssert(newExpiration > expiration.get());
    *expiration = newExpiration;
}

EXPORT void PaymentChannel::claimTimeout(){
    DipcAssert(!closed.get());
    DipcAssert(dipc::timestamp() > expiration.get());
    callTransfer(sender.get(), balance.get());
    *closed = true;
}

CONSTANT void PaymentChannel::getPaymentChannelStatus(){

    
    
} codetext height #include "PaymentChannel.hpp"

PAYABLE void PaymentChannel::init(char* _recipient, uint64_t duration, uint64_t _balance){

    *sender = caller();
    *recipient = _recipient;
    print("_recipient");
    print(_recipient);
    print("recipient");
    prints_l(&recipient.get()[0], recipient.get().size());
    *expiration = duration;
    *balance = _balance;
    DipcAssert(dipc::callValue() == _balance);
    DIPC_EMIT_EVENT(PaymentChannelStatus, recipient.get().data(), expiration.get(), balance.get());
}

EXPORT void PaymentChannel::close(uint64_t amount, char* signature){
    DipcAssert(!closed.get());
    Address callerAddr = caller();
    DipcAssert(callerAddr.toString() == recipient.get());
    std::string sign = signature;
    
    Address contractAddr = dipc::address();
    std::string data = contractAddr.toString() + std::to_string(amount) + callerAddr.toString();
    h256 sha3Data = dipc::sha3(data);
    DipcAssert(dipc::getSignerAddress(sha3Data,sign).toString() == sender.get().toString());
    callTransfer(callerAddr, amount);
    DipcAssert(balance.get() -amount > 0);
    callTransfer(sender.get(), balance.get() - amount);
    *closed = true;
}

EXPORT void PaymentChannel::extend(uint64_t newExpiration) {
    DipcAssert(!closed.get());
    DipcAssert(caller().toString() == sender.get().toString());
    DipcAssert(newExpiration > expiration.get());
    *expiration = newExpiration;
}

EXPORT void PaymentChannel::claimTimeout(){
    DipcAssert(!closed.get());
    DipcAssert(dipc::timestamp() > expiration.get());
    callTransfer(sender.get(), balance.get());
    *closed = true;
}

CONSTANT void PaymentChannel::getPaymentChannelStatus(){

    
    
}

2019-11-15_10:04:49.998487: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:398] searchContext  #include "PaymentChannel.hpp"

PAYABLE void PaymentChannel::init(char* _recipient, uint64_t duration, uint64_t _balance){

    *sender = caller();
    *recipient = _recipient;
    print("_recipient");
    print(_recipient);
    print("recipient");
    prints_l(&recipient.get()[0], recipient.get().size());
    *expiration = duration;
    *balance = _balance;
    DipcAssert(dipc::callValue() == _balance);
    DIPC_EMIT_EVENT(PaymentChannelStatus, recipient.get().data(), expiration.get(), balance.get());
}

EXPORT void PaymentChannel::close(uint64_t amount, char* signature){
    DipcAssert(!closed.get());
    Address callerAddr = caller();
    DipcAssert(callerAddr.toString() == recipient.get());
    std::string sign = signature;
    
    Address contractAddr = dipc::address();
    std::string data = contractAddr.toString() + std::to_string(amount) + callerAddr.toString();
    h256 sha3Data = dipc::sha3(data);
    DipcAssert(dipc::getSignerAddress(sha3Data,sign).toString() == sender.get().toString());
    callTransfer(callerAddr, amount);
    DipcAssert(balance.get() -amount > 0);
    callTransfer(sender.get(), balance.get() - amount);
    *closed = true;
}

EXPORT void PaymentChannel::extend(uint64_t newExpiration) {
    DipcAssert(!closed.get());
    DipcAssert(caller().toString() == sender.get().toString());
    DipcAssert(newExpiration > expiration.get());
    *expiration = newExpiration;
}

EXPORT void PaymentChannel::claimTimeout(){
    DipcAssert(!closed.get());
    DipcAssert(dipc::timestamp() > expiration.get());
    callTransfer(sender.get(), balance.get());
    *closed = true;
}

CONSTANT void PaymentChannel::getPaymentChannelStatus(){

    
    
}

2019-11-15_10:04:50.003451: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:422] log out out  Export :

EXPORT void PaymentChannel::close(uint64_t amount, char* signature){
    

2019-11-15_10:04:50.003463: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:428] name : close   pos1  0

2019-11-15_10:04:50.003470: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:440] pos2  508   pos1  508

2019-11-15_10:04:50.003477: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:471] pos2 after 1172   pos1  508

2019-11-15_10:04:50.003483: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:480] finalContract  first #include "PaymentChannel.hpp"

PAYABLE void PaymentChannel::init(char* _recipient, uint64_t duration, uint64_t _balance){

    *sender = caller();
    *recipient = _recipient;
    print("_recipient");
    print(_recipient);
    print("recipient");
    prints_l(&recipient.get()[0], recipient.get().size());
    *expiration = duration;
    *balance = _balance;
    DipcAssert(dipc::callValue() == _balance);
    DIPC_EMIT_EVENT(PaymentChannelStatus, recipient.get().data(), expiration.get(), balance.get());
}

2019-11-15_10:04:50.003489: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:481] codetext  first #include "PaymentChannel.hpp"

PAYABLE void PaymentChannel::init(char* _recipient, uint64_t duration, uint64_t _balance){

    *sender = caller();
    *recipient = _recipient;
    print("_recipient");
    print(_recipient);
    print("recipient");
    prints_l(&recipient.get()[0], recipient.get().size());
    *expiration = duration;
    *balance = _balance;
    DipcAssert(dipc::callValue() == _balance);
    DIPC_EMIT_EVENT(PaymentChannelStatus, recipient.get().data(), expiration.get(), balance.get());
}

EXPORT void PaymentChannel::close(uint64_t amount, char* signature){
    DipcAssert(!closed.get());
    Address callerAddr = caller();
    DipcAssert(callerAddr.toString() == recipient.get());
    std::string sign = signature;
    
    Address contractAddr = dipc::address();
    std::string data = contractAddr.toString() + std::to_string(amount) + callerAddr.toString();
    h256 sha3Data = dipc::sha3(data);
    DipcAssert(dipc::getSignerAddress(sha3Data,sign).toString() == sender.get().toString());
    callTransfer(callerAddr, amount);
    DipcAssert(balance.get() -amount > 0);
    callTransfer(sender.get(), balance.get() - amount);
    *closed = true;
}

EXPORT void PaymentChannel::extend(uint64_t newExpiration) {
    DipcAssert(!closed.get());
    DipcAssert(caller().toString() == sender.get().toString());
    DipcAssert(newExpiration > expiration.get());
    *expiration = newExpiration;
}

EXPORT void PaymentChannel::claimTimeout(){
    DipcAssert(!closed.get());
    DipcAssert(dipc::timestamp() > expiration.get());
    callTransfer(sender.get(), balance.get());
    *closed = true;
}

CONSTANT void PaymentChannel::getPaymentChannelStatus(){

    
    
}

2019-11-15_10:04:50.003494: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:484] s  first 

EXPORT void PaymentChannel::close(uint64_t amount, char* signature){
    DipcAssert(!closed.get());
    Address callerAddr = caller();
    DipcAssert(callerAddr.toString() == recipient.get());
    std::string sign = signature;
    
    Address contractAddr = dipc::address();
    std::string data = contractAddr.toString() + std::to_string(amount) + callerAddr.toString();
    h256 sha3Data = dipc::sha3(data);
    DipcAssert(dipc::getSignerAddress(sha3Data,sign).toString() == sender.get().toString());
    callTransfer(callerAddr, amount);
    DipcAssert(balance.get() -amount > 0);
    callTransfer(sender.get(), balance.get() - amount);
    *closed = true;
}

2019-11-15_10:04:50.003556: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:564] calledFunc temp export: 

EXPORT void PaymentChannel::close(uint64_t amount, char* signature){
    u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
DipcAssert(!closed.get());
    Address callerAddr = caller();
    DipcAssert(callerAddr.toString() == recipient.get());
    std::string sign = signature;
    
    Address contractAddr = dipc::address();
    std::string data = contractAddr.toString() + std::to_string(amount) + callerAddr.toString();
    h256 sha3Data = dipc::sha3(data);
    DipcAssert(dipc::getSignerAddress(sha3Data,sign).toString() == sender.get().toString());
    callTransfer(callerAddr, amount);
    DipcAssert(balance.get() -amount > 0);
    callTransfer(sender.get(), balance.get() - amount);
    *closed = true;
}

2019-11-15_10:04:50.003565: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:570] search func : 

EXPORT void PaymentChannel::close(uint64_t amount, char* signature){
    u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
DipcAssert(!closed.get());
    Address callerAddr = caller();
    DipcAssert(callerAddr.toString() == recipient.get());
    std::string sign = signature;
    
    Address contractAddr = dipc::address();
    std::string data = contractAddr.toString() + std::to_string(amount) + callerAddr.toString();
    h256 sha3Data = dipc::sha3(data);
    DipcAssert(dipc::getSignerAddress(sha3Data,sign).toString() == sender.get().toString());
    callTransfer(callerAddr, amount);
    DipcAssert(balance.get() -amount > 0);
    callTransfer(sender.get(), balance.get() - amount);
    *closed = true;
}
2019-11-15_10:04:50.003571: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:395] finalContract  this height  #include "PaymentChannel.hpp"

PAYABLE void PaymentChannel::init(char* _recipient, uint64_t duration, uint64_t _balance){

    *sender = caller();
    *recipient = _recipient;
    print("_recipient");
    print(_recipient);
    print("recipient");
    prints_l(&recipient.get()[0], recipient.get().size());
    *expiration = duration;
    *balance = _balance;
    DipcAssert(dipc::callValue() == _balance);
    DIPC_EMIT_EVENT(PaymentChannelStatus, recipient.get().data(), expiration.get(), balance.get());
}

EXPORT void PaymentChannel::close(uint64_t amount, char* signature){
    u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
DipcAssert(!closed.get());
    Address callerAddr = caller();
    DipcAssert(callerAddr.toString() == recipient.get());
    std::string sign = signature;
    
    Address contractAddr = dipc::address();
    std::string data = contractAddr.toString() + std::to_string(amount) + callerAddr.toString();
    h256 sha3Data = dipc::sha3(data);
    DipcAssert(dipc::getSignerAddress(sha3Data,sign).toString() == sender.get().toString());
    callTransfer(callerAddr, amount);
    DipcAssert(balance.get() -amount > 0);
    callTransfer(sender.get(), balance.get() - amount);
    *closed = true;
} codetext height #include "PaymentChannel.hpp"

PAYABLE void PaymentChannel::init(char* _recipient, uint64_t duration, uint64_t _balance){

    *sender = caller();
    *recipient = _recipient;
    print("_recipient");
    print(_recipient);
    print("recipient");
    prints_l(&recipient.get()[0], recipient.get().size());
    *expiration = duration;
    *balance = _balance;
    DipcAssert(dipc::callValue() == _balance);
    DIPC_EMIT_EVENT(PaymentChannelStatus, recipient.get().data(), expiration.get(), balance.get());
}

EXPORT void PaymentChannel::close(uint64_t amount, char* signature){
    DipcAssert(!closed.get());
    Address callerAddr = caller();
    DipcAssert(callerAddr.toString() == recipient.get());
    std::string sign = signature;
    
    Address contractAddr = dipc::address();
    std::string data = contractAddr.toString() + std::to_string(amount) + callerAddr.toString();
    h256 sha3Data = dipc::sha3(data);
    DipcAssert(dipc::getSignerAddress(sha3Data,sign).toString() == sender.get().toString());
    callTransfer(callerAddr, amount);
    DipcAssert(balance.get() -amount > 0);
    callTransfer(sender.get(), balance.get() - amount);
    *closed = true;
}

EXPORT void PaymentChannel::extend(uint64_t newExpiration) {
    DipcAssert(!closed.get());
    DipcAssert(caller().toString() == sender.get().toString());
    DipcAssert(newExpiration > expiration.get());
    *expiration = newExpiration;
}

EXPORT void PaymentChannel::claimTimeout(){
    DipcAssert(!closed.get());
    DipcAssert(dipc::timestamp() > expiration.get());
    callTransfer(sender.get(), balance.get());
    *closed = true;
}

CONSTANT void PaymentChannel::getPaymentChannelStatus(){

    
    
}

2019-11-15_10:04:50.003579: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:398] searchContext  

EXPORT void PaymentChannel::extend(uint64_t newExpiration) {
    DipcAssert(!closed.get());
    DipcAssert(caller().toString() == sender.get().toString());
    DipcAssert(newExpiration > expiration.get());
    *expiration = newExpiration;
}

EXPORT void PaymentChannel::claimTimeout(){
    DipcAssert(!closed.get());
    DipcAssert(dipc::timestamp() > expiration.get());
    callTransfer(sender.get(), balance.get());
    *closed = true;
}

CONSTANT void PaymentChannel::getPaymentChannelStatus(){

    
    
}

2019-11-15_10:04:50.007784: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:413] finalContract  this new  #include "PaymentChannel.hpp"

PAYABLE void PaymentChannel::init(char* _recipient, uint64_t duration, uint64_t _balance){

    *sender = caller();
    *recipient = _recipient;
    print("_recipient");
    print(_recipient);
    print("recipient");
    prints_l(&recipient.get()[0], recipient.get().size());
    *expiration = duration;
    *balance = _balance;
    DipcAssert(dipc::callValue() == _balance);
    DIPC_EMIT_EVENT(PaymentChannelStatus, recipient.get().data(), expiration.get(), balance.get());
}

EXPORT void PaymentChannel::close(uint64_t amount, char* signature){
    u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
DipcAssert(!closed.get());
    Address callerAddr = caller();
    DipcAssert(callerAddr.toString() == recipient.get());
    std::string sign = signature;
    
    Address contractAddr = dipc::address();
    std::string data = contractAddr.toString() + std::to_string(amount) + callerAddr.toString();
    h256 sha3Data = dipc::sha3(data);
    DipcAssert(dipc::getSignerAddress(sha3Data,sign).toString() == sender.get().toString());
    callTransfer(callerAddr, amount);
    DipcAssert(balance.get() -amount > 0);
    callTransfer(sender.get(), balance.get() - amount);
    *closed = true;
} codetext new #include "PaymentChannel.hpp"

PAYABLE void PaymentChannel::init(char* _recipient, uint64_t duration, uint64_t _balance){

    *sender = caller();
    *recipient = _recipient;
    print("_recipient");
    print(_recipient);
    print("recipient");
    prints_l(&recipient.get()[0], recipient.get().size());
    *expiration = duration;
    *balance = _balance;
    DipcAssert(dipc::callValue() == _balance);
    DIPC_EMIT_EVENT(PaymentChannelStatus, recipient.get().data(), expiration.get(), balance.get());
}

EXPORT void PaymentChannel::close(uint64_t amount, char* signature){
    DipcAssert(!closed.get());
    Address callerAddr = caller();
    DipcAssert(callerAddr.toString() == recipient.get());
    std::string sign = signature;
    
    Address contractAddr = dipc::address();
    std::string data = contractAddr.toString() + std::to_string(amount) + callerAddr.toString();
    h256 sha3Data = dipc::sha3(data);
    DipcAssert(dipc::getSignerAddress(sha3Data,sign).toString() == sender.get().toString());
    callTransfer(callerAddr, amount);
    DipcAssert(balance.get() -amount > 0);
    callTransfer(sender.get(), balance.get() - amount);
    *closed = true;
}

EXPORT void PaymentChannel::extend(uint64_t newExpiration) {
    DipcAssert(!closed.get());
    DipcAssert(caller().toString() == sender.get().toString());
    DipcAssert(newExpiration > expiration.get());
    *expiration = newExpiration;
}

EXPORT void PaymentChannel::claimTimeout(){
    DipcAssert(!closed.get());
    DipcAssert(dipc::timestamp() > expiration.get());
    callTransfer(sender.get(), balance.get());
    *closed = true;
}

CONSTANT void PaymentChannel::getPaymentChannelStatus(){

    
    
}

2019-11-15_10:04:50.007803: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:575] finalContract  final content =======   : #include "PaymentChannel.hpp"

PAYABLE void PaymentChannel::init(char* _recipient, uint64_t duration, uint64_t _balance){

    *sender = caller();
    *recipient = _recipient;
    print("_recipient");
    print(_recipient);
    print("recipient");
    prints_l(&recipient.get()[0], recipient.get().size());
    *expiration = duration;
    *balance = _balance;
    DipcAssert(dipc::callValue() == _balance);
    DIPC_EMIT_EVENT(PaymentChannelStatus, recipient.get().data(), expiration.get(), balance.get());
}

EXPORT void PaymentChannel::close(uint64_t amount, char* signature){
    u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
DipcAssert(!closed.get());
    Address callerAddr = caller();
    DipcAssert(callerAddr.toString() == recipient.get());
    std::string sign = signature;
    
    Address contractAddr = dipc::address();
    std::string data = contractAddr.toString() + std::to_string(amount) + callerAddr.toString();
    h256 sha3Data = dipc::sha3(data);
    DipcAssert(dipc::getSignerAddress(sha3Data,sign).toString() == sender.get().toString());
    callTransfer(callerAddr, amount);
    DipcAssert(balance.get() -amount > 0);
    callTransfer(sender.get(), balance.get() - amount);
    *closed = true;
}

EXPORT void PaymentChannel::extend(uint64_t newExpiration) {
    DipcAssert(!closed.get());
    DipcAssert(caller().toString() == sender.get().toString());
    DipcAssert(newExpiration > expiration.get());
    *expiration = newExpiration;
}

EXPORT void PaymentChannel::claimTimeout(){
    DipcAssert(!closed.get());
    DipcAssert(dipc::timestamp() > expiration.get());
    callTransfer(sender.get(), balance.get());
    *closed = true;
}

CONSTANT void PaymentChannel::getPaymentChannelStatus(){

    
    
}

2019-11-15_10:04:50.007811: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:372] abis.ispayable :false

2019-11-15_10:04:50.007826: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:395] finalContract  this height  #include "PaymentChannel.hpp"

PAYABLE void PaymentChannel::init(char* _recipient, uint64_t duration, uint64_t _balance){

    *sender = caller();
    *recipient = _recipient;
    print("_recipient");
    print(_recipient);
    print("recipient");
    prints_l(&recipient.get()[0], recipient.get().size());
    *expiration = duration;
    *balance = _balance;
    DipcAssert(dipc::callValue() == _balance);
    DIPC_EMIT_EVENT(PaymentChannelStatus, recipient.get().data(), expiration.get(), balance.get());
}

EXPORT void PaymentChannel::close(uint64_t amount, char* signature){
    u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
DipcAssert(!closed.get());
    Address callerAddr = caller();
    DipcAssert(callerAddr.toString() == recipient.get());
    std::string sign = signature;
    
    Address contractAddr = dipc::address();
    std::string data = contractAddr.toString() + std::to_string(amount) + callerAddr.toString();
    h256 sha3Data = dipc::sha3(data);
    DipcAssert(dipc::getSignerAddress(sha3Data,sign).toString() == sender.get().toString());
    callTransfer(callerAddr, amount);
    DipcAssert(balance.get() -amount > 0);
    callTransfer(sender.get(), balance.get() - amount);
    *closed = true;
}

EXPORT void PaymentChannel::extend(uint64_t newExpiration) {
    DipcAssert(!closed.get());
    DipcAssert(caller().toString() == sender.get().toString());
    DipcAssert(newExpiration > expiration.get());
    *expiration = newExpiration;
}

EXPORT void PaymentChannel::claimTimeout(){
    DipcAssert(!closed.get());
    DipcAssert(dipc::timestamp() > expiration.get());
    callTransfer(sender.get(), balance.get());
    *closed = true;
}

CONSTANT void PaymentChannel::getPaymentChannelStatus(){

    
    
} codetext height #include "PaymentChannel.hpp"

PAYABLE void PaymentChannel::init(char* _recipient, uint64_t duration, uint64_t _balance){

    *sender = caller();
    *recipient = _recipient;
    print("_recipient");
    print(_recipient);
    print("recipient");
    prints_l(&recipient.get()[0], recipient.get().size());
    *expiration = duration;
    *balance = _balance;
    DipcAssert(dipc::callValue() == _balance);
    DIPC_EMIT_EVENT(PaymentChannelStatus, recipient.get().data(), expiration.get(), balance.get());
}

EXPORT void PaymentChannel::close(uint64_t amount, char* signature){
    u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
DipcAssert(!closed.get());
    Address callerAddr = caller();
    DipcAssert(callerAddr.toString() == recipient.get());
    std::string sign = signature;
    
    Address contractAddr = dipc::address();
    std::string data = contractAddr.toString() + std::to_string(amount) + callerAddr.toString();
    h256 sha3Data = dipc::sha3(data);
    DipcAssert(dipc::getSignerAddress(sha3Data,sign).toString() == sender.get().toString());
    callTransfer(callerAddr, amount);
    DipcAssert(balance.get() -amount > 0);
    callTransfer(sender.get(), balance.get() - amount);
    *closed = true;
}

EXPORT void PaymentChannel::extend(uint64_t newExpiration) {
    DipcAssert(!closed.get());
    DipcAssert(caller().toString() == sender.get().toString());
    DipcAssert(newExpiration > expiration.get());
    *expiration = newExpiration;
}

EXPORT void PaymentChannel::claimTimeout(){
    DipcAssert(!closed.get());
    DipcAssert(dipc::timestamp() > expiration.get());
    callTransfer(sender.get(), balance.get());
    *closed = true;
}

CONSTANT void PaymentChannel::getPaymentChannelStatus(){

    
    
}

2019-11-15_10:04:50.007833: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:398] searchContext  #include "PaymentChannel.hpp"

PAYABLE void PaymentChannel::init(char* _recipient, uint64_t duration, uint64_t _balance){

    *sender = caller();
    *recipient = _recipient;
    print("_recipient");
    print(_recipient);
    print("recipient");
    prints_l(&recipient.get()[0], recipient.get().size());
    *expiration = duration;
    *balance = _balance;
    DipcAssert(dipc::callValue() == _balance);
    DIPC_EMIT_EVENT(PaymentChannelStatus, recipient.get().data(), expiration.get(), balance.get());
}

EXPORT void PaymentChannel::close(uint64_t amount, char* signature){
    u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
DipcAssert(!closed.get());
    Address callerAddr = caller();
    DipcAssert(callerAddr.toString() == recipient.get());
    std::string sign = signature;
    
    Address contractAddr = dipc::address();
    std::string data = contractAddr.toString() + std::to_string(amount) + callerAddr.toString();
    h256 sha3Data = dipc::sha3(data);
    DipcAssert(dipc::getSignerAddress(sha3Data,sign).toString() == sender.get().toString());
    callTransfer(callerAddr, amount);
    DipcAssert(balance.get() -amount > 0);
    callTransfer(sender.get(), balance.get() - amount);
    *closed = true;
}

EXPORT void PaymentChannel::extend(uint64_t newExpiration) {
    DipcAssert(!closed.get());
    DipcAssert(caller().toString() == sender.get().toString());
    DipcAssert(newExpiration > expiration.get());
    *expiration = newExpiration;
}

EXPORT void PaymentChannel::claimTimeout(){
    DipcAssert(!closed.get());
    DipcAssert(dipc::timestamp() > expiration.get());
    callTransfer(sender.get(), balance.get());
    *closed = true;
}

CONSTANT void PaymentChannel::getPaymentChannelStatus(){

    
    
}

2019-11-15_10:04:50.019626: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:422] log out out  Export :

EXPORT void PaymentChannel::extend(uint64_t newExpiration) {
    

2019-11-15_10:04:50.019637: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:428] name : extend   pos1  0

2019-11-15_10:04:50.019644: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:440] pos2  1231   pos1  1231

2019-11-15_10:04:50.019651: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:471] pos2 after 1473   pos1  1231

2019-11-15_10:04:50.019658: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:480] finalContract  first #include "PaymentChannel.hpp"

PAYABLE void PaymentChannel::init(char* _recipient, uint64_t duration, uint64_t _balance){

    *sender = caller();
    *recipient = _recipient;
    print("_recipient");
    print(_recipient);
    print("recipient");
    prints_l(&recipient.get()[0], recipient.get().size());
    *expiration = duration;
    *balance = _balance;
    DipcAssert(dipc::callValue() == _balance);
    DIPC_EMIT_EVENT(PaymentChannelStatus, recipient.get().data(), expiration.get(), balance.get());
}

EXPORT void PaymentChannel::close(uint64_t amount, char* signature){
    u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
DipcAssert(!closed.get());
    Address callerAddr = caller();
    DipcAssert(callerAddr.toString() == recipient.get());
    std::string sign = signature;
    
    Address contractAddr = dipc::address();
    std::string data = contractAddr.toString() + std::to_string(amount) + callerAddr.toString();
    h256 sha3Data = dipc::sha3(data);
    DipcAssert(dipc::getSignerAddress(sha3Data,sign).toString() == sender.get().toString());
    callTransfer(callerAddr, amount);
    DipcAssert(balance.get() -amount > 0);
    callTransfer(sender.get(), balance.get() - amount);
    *closed = true;
}

2019-11-15_10:04:50.019664: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:481] codetext  first #include "PaymentChannel.hpp"

PAYABLE void PaymentChannel::init(char* _recipient, uint64_t duration, uint64_t _balance){

    *sender = caller();
    *recipient = _recipient;
    print("_recipient");
    print(_recipient);
    print("recipient");
    prints_l(&recipient.get()[0], recipient.get().size());
    *expiration = duration;
    *balance = _balance;
    DipcAssert(dipc::callValue() == _balance);
    DIPC_EMIT_EVENT(PaymentChannelStatus, recipient.get().data(), expiration.get(), balance.get());
}

EXPORT void PaymentChannel::close(uint64_t amount, char* signature){
    u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
DipcAssert(!closed.get());
    Address callerAddr = caller();
    DipcAssert(callerAddr.toString() == recipient.get());
    std::string sign = signature;
    
    Address contractAddr = dipc::address();
    std::string data = contractAddr.toString() + std::to_string(amount) + callerAddr.toString();
    h256 sha3Data = dipc::sha3(data);
    DipcAssert(dipc::getSignerAddress(sha3Data,sign).toString() == sender.get().toString());
    callTransfer(callerAddr, amount);
    DipcAssert(balance.get() -amount > 0);
    callTransfer(sender.get(), balance.get() - amount);
    *closed = true;
}

EXPORT void PaymentChannel::extend(uint64_t newExpiration) {
    DipcAssert(!closed.get());
    DipcAssert(caller().toString() == sender.get().toString());
    DipcAssert(newExpiration > expiration.get());
    *expiration = newExpiration;
}

EXPORT void PaymentChannel::claimTimeout(){
    DipcAssert(!closed.get());
    DipcAssert(dipc::timestamp() > expiration.get());
    callTransfer(sender.get(), balance.get());
    *closed = true;
}

CONSTANT void PaymentChannel::getPaymentChannelStatus(){

    
    
}

2019-11-15_10:04:50.019670: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:484] s  first 

EXPORT void PaymentChannel::extend(uint64_t newExpiration) {
    DipcAssert(!closed.get());
    DipcAssert(caller().toString() == sender.get().toString());
    DipcAssert(newExpiration > expiration.get());
    *expiration = newExpiration;
}

2019-11-15_10:04:50.019677: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:564] calledFunc temp export: 

EXPORT void PaymentChannel::extend(uint64_t newExpiration) {
    u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
DipcAssert(!closed.get());
    DipcAssert(caller().toString() == sender.get().toString());
    DipcAssert(newExpiration > expiration.get());
    *expiration = newExpiration;
}

2019-11-15_10:04:50.019684: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:570] search func : 

EXPORT void PaymentChannel::extend(uint64_t newExpiration) {
    u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
DipcAssert(!closed.get());
    DipcAssert(caller().toString() == sender.get().toString());
    DipcAssert(newExpiration > expiration.get());
    *expiration = newExpiration;
}
2019-11-15_10:04:50.019690: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:395] finalContract  this height  #include "PaymentChannel.hpp"

PAYABLE void PaymentChannel::init(char* _recipient, uint64_t duration, uint64_t _balance){

    *sender = caller();
    *recipient = _recipient;
    print("_recipient");
    print(_recipient);
    print("recipient");
    prints_l(&recipient.get()[0], recipient.get().size());
    *expiration = duration;
    *balance = _balance;
    DipcAssert(dipc::callValue() == _balance);
    DIPC_EMIT_EVENT(PaymentChannelStatus, recipient.get().data(), expiration.get(), balance.get());
}

EXPORT void PaymentChannel::close(uint64_t amount, char* signature){
    u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
DipcAssert(!closed.get());
    Address callerAddr = caller();
    DipcAssert(callerAddr.toString() == recipient.get());
    std::string sign = signature;
    
    Address contractAddr = dipc::address();
    std::string data = contractAddr.toString() + std::to_string(amount) + callerAddr.toString();
    h256 sha3Data = dipc::sha3(data);
    DipcAssert(dipc::getSignerAddress(sha3Data,sign).toString() == sender.get().toString());
    callTransfer(callerAddr, amount);
    DipcAssert(balance.get() -amount > 0);
    callTransfer(sender.get(), balance.get() - amount);
    *closed = true;
}

EXPORT void PaymentChannel::extend(uint64_t newExpiration) {
    u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
DipcAssert(!closed.get());
    DipcAssert(caller().toString() == sender.get().toString());
    DipcAssert(newExpiration > expiration.get());
    *expiration = newExpiration;
} codetext height #include "PaymentChannel.hpp"

PAYABLE void PaymentChannel::init(char* _recipient, uint64_t duration, uint64_t _balance){

    *sender = caller();
    *recipient = _recipient;
    print("_recipient");
    print(_recipient);
    print("recipient");
    prints_l(&recipient.get()[0], recipient.get().size());
    *expiration = duration;
    *balance = _balance;
    DipcAssert(dipc::callValue() == _balance);
    DIPC_EMIT_EVENT(PaymentChannelStatus, recipient.get().data(), expiration.get(), balance.get());
}

EXPORT void PaymentChannel::close(uint64_t amount, char* signature){
    u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
DipcAssert(!closed.get());
    Address callerAddr = caller();
    DipcAssert(callerAddr.toString() == recipient.get());
    std::string sign = signature;
    
    Address contractAddr = dipc::address();
    std::string data = contractAddr.toString() + std::to_string(amount) + callerAddr.toString();
    h256 sha3Data = dipc::sha3(data);
    DipcAssert(dipc::getSignerAddress(sha3Data,sign).toString() == sender.get().toString());
    callTransfer(callerAddr, amount);
    DipcAssert(balance.get() -amount > 0);
    callTransfer(sender.get(), balance.get() - amount);
    *closed = true;
}

EXPORT void PaymentChannel::extend(uint64_t newExpiration) {
    DipcAssert(!closed.get());
    DipcAssert(caller().toString() == sender.get().toString());
    DipcAssert(newExpiration > expiration.get());
    *expiration = newExpiration;
}

EXPORT void PaymentChannel::claimTimeout(){
    DipcAssert(!closed.get());
    DipcAssert(dipc::timestamp() > expiration.get());
    callTransfer(sender.get(), balance.get());
    *closed = true;
}

CONSTANT void PaymentChannel::getPaymentChannelStatus(){

    
    
}

2019-11-15_10:04:50.019698: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:398] searchContext  

EXPORT void PaymentChannel::claimTimeout(){
    DipcAssert(!closed.get());
    DipcAssert(dipc::timestamp() > expiration.get());
    callTransfer(sender.get(), balance.get());
    *closed = true;
}

CONSTANT void PaymentChannel::getPaymentChannelStatus(){

    
    
}

2019-11-15_10:04:50.022262: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:413] finalContract  this new  #include "PaymentChannel.hpp"

PAYABLE void PaymentChannel::init(char* _recipient, uint64_t duration, uint64_t _balance){

    *sender = caller();
    *recipient = _recipient;
    print("_recipient");
    print(_recipient);
    print("recipient");
    prints_l(&recipient.get()[0], recipient.get().size());
    *expiration = duration;
    *balance = _balance;
    DipcAssert(dipc::callValue() == _balance);
    DIPC_EMIT_EVENT(PaymentChannelStatus, recipient.get().data(), expiration.get(), balance.get());
}

EXPORT void PaymentChannel::close(uint64_t amount, char* signature){
    u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
DipcAssert(!closed.get());
    Address callerAddr = caller();
    DipcAssert(callerAddr.toString() == recipient.get());
    std::string sign = signature;
    
    Address contractAddr = dipc::address();
    std::string data = contractAddr.toString() + std::to_string(amount) + callerAddr.toString();
    h256 sha3Data = dipc::sha3(data);
    DipcAssert(dipc::getSignerAddress(sha3Data,sign).toString() == sender.get().toString());
    callTransfer(callerAddr, amount);
    DipcAssert(balance.get() -amount > 0);
    callTransfer(sender.get(), balance.get() - amount);
    *closed = true;
}

EXPORT void PaymentChannel::extend(uint64_t newExpiration) {
    u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
DipcAssert(!closed.get());
    DipcAssert(caller().toString() == sender.get().toString());
    DipcAssert(newExpiration > expiration.get());
    *expiration = newExpiration;
} codetext new #include "PaymentChannel.hpp"

PAYABLE void PaymentChannel::init(char* _recipient, uint64_t duration, uint64_t _balance){

    *sender = caller();
    *recipient = _recipient;
    print("_recipient");
    print(_recipient);
    print("recipient");
    prints_l(&recipient.get()[0], recipient.get().size());
    *expiration = duration;
    *balance = _balance;
    DipcAssert(dipc::callValue() == _balance);
    DIPC_EMIT_EVENT(PaymentChannelStatus, recipient.get().data(), expiration.get(), balance.get());
}

EXPORT void PaymentChannel::close(uint64_t amount, char* signature){
    u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
DipcAssert(!closed.get());
    Address callerAddr = caller();
    DipcAssert(callerAddr.toString() == recipient.get());
    std::string sign = signature;
    
    Address contractAddr = dipc::address();
    std::string data = contractAddr.toString() + std::to_string(amount) + callerAddr.toString();
    h256 sha3Data = dipc::sha3(data);
    DipcAssert(dipc::getSignerAddress(sha3Data,sign).toString() == sender.get().toString());
    callTransfer(callerAddr, amount);
    DipcAssert(balance.get() -amount > 0);
    callTransfer(sender.get(), balance.get() - amount);
    *closed = true;
}

EXPORT void PaymentChannel::extend(uint64_t newExpiration) {
    DipcAssert(!closed.get());
    DipcAssert(caller().toString() == sender.get().toString());
    DipcAssert(newExpiration > expiration.get());
    *expiration = newExpiration;
}

EXPORT void PaymentChannel::claimTimeout(){
    DipcAssert(!closed.get());
    DipcAssert(dipc::timestamp() > expiration.get());
    callTransfer(sender.get(), balance.get());
    *closed = true;
}

CONSTANT void PaymentChannel::getPaymentChannelStatus(){

    
    
}

2019-11-15_10:04:50.022299: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:575] finalContract  final content =======   : #include "PaymentChannel.hpp"

PAYABLE void PaymentChannel::init(char* _recipient, uint64_t duration, uint64_t _balance){

    *sender = caller();
    *recipient = _recipient;
    print("_recipient");
    print(_recipient);
    print("recipient");
    prints_l(&recipient.get()[0], recipient.get().size());
    *expiration = duration;
    *balance = _balance;
    DipcAssert(dipc::callValue() == _balance);
    DIPC_EMIT_EVENT(PaymentChannelStatus, recipient.get().data(), expiration.get(), balance.get());
}

EXPORT void PaymentChannel::close(uint64_t amount, char* signature){
    u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
DipcAssert(!closed.get());
    Address callerAddr = caller();
    DipcAssert(callerAddr.toString() == recipient.get());
    std::string sign = signature;
    
    Address contractAddr = dipc::address();
    std::string data = contractAddr.toString() + std::to_string(amount) + callerAddr.toString();
    h256 sha3Data = dipc::sha3(data);
    DipcAssert(dipc::getSignerAddress(sha3Data,sign).toString() == sender.get().toString());
    callTransfer(callerAddr, amount);
    DipcAssert(balance.get() -amount > 0);
    callTransfer(sender.get(), balance.get() - amount);
    *closed = true;
}

EXPORT void PaymentChannel::extend(uint64_t newExpiration) {
    u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
DipcAssert(!closed.get());
    DipcAssert(caller().toString() == sender.get().toString());
    DipcAssert(newExpiration > expiration.get());
    *expiration = newExpiration;
}

EXPORT void PaymentChannel::claimTimeout(){
    DipcAssert(!closed.get());
    DipcAssert(dipc::timestamp() > expiration.get());
    callTransfer(sender.get(), balance.get());
    *closed = true;
}

CONSTANT void PaymentChannel::getPaymentChannelStatus(){

    
    
}

2019-11-15_10:04:50.022321: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:372] abis.ispayable :false

2019-11-15_10:04:50.022337: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:395] finalContract  this height  #include "PaymentChannel.hpp"

PAYABLE void PaymentChannel::init(char* _recipient, uint64_t duration, uint64_t _balance){

    *sender = caller();
    *recipient = _recipient;
    print("_recipient");
    print(_recipient);
    print("recipient");
    prints_l(&recipient.get()[0], recipient.get().size());
    *expiration = duration;
    *balance = _balance;
    DipcAssert(dipc::callValue() == _balance);
    DIPC_EMIT_EVENT(PaymentChannelStatus, recipient.get().data(), expiration.get(), balance.get());
}

EXPORT void PaymentChannel::close(uint64_t amount, char* signature){
    u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
DipcAssert(!closed.get());
    Address callerAddr = caller();
    DipcAssert(callerAddr.toString() == recipient.get());
    std::string sign = signature;
    
    Address contractAddr = dipc::address();
    std::string data = contractAddr.toString() + std::to_string(amount) + callerAddr.toString();
    h256 sha3Data = dipc::sha3(data);
    DipcAssert(dipc::getSignerAddress(sha3Data,sign).toString() == sender.get().toString());
    callTransfer(callerAddr, amount);
    DipcAssert(balance.get() -amount > 0);
    callTransfer(sender.get(), balance.get() - amount);
    *closed = true;
}

EXPORT void PaymentChannel::extend(uint64_t newExpiration) {
    u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
DipcAssert(!closed.get());
    DipcAssert(caller().toString() == sender.get().toString());
    DipcAssert(newExpiration > expiration.get());
    *expiration = newExpiration;
}

EXPORT void PaymentChannel::claimTimeout(){
    DipcAssert(!closed.get());
    DipcAssert(dipc::timestamp() > expiration.get());
    callTransfer(sender.get(), balance.get());
    *closed = true;
}

CONSTANT void PaymentChannel::getPaymentChannelStatus(){

    
    
} codetext height #include "PaymentChannel.hpp"

PAYABLE void PaymentChannel::init(char* _recipient, uint64_t duration, uint64_t _balance){

    *sender = caller();
    *recipient = _recipient;
    print("_recipient");
    print(_recipient);
    print("recipient");
    prints_l(&recipient.get()[0], recipient.get().size());
    *expiration = duration;
    *balance = _balance;
    DipcAssert(dipc::callValue() == _balance);
    DIPC_EMIT_EVENT(PaymentChannelStatus, recipient.get().data(), expiration.get(), balance.get());
}

EXPORT void PaymentChannel::close(uint64_t amount, char* signature){
    u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
DipcAssert(!closed.get());
    Address callerAddr = caller();
    DipcAssert(callerAddr.toString() == recipient.get());
    std::string sign = signature;
    
    Address contractAddr = dipc::address();
    std::string data = contractAddr.toString() + std::to_string(amount) + callerAddr.toString();
    h256 sha3Data = dipc::sha3(data);
    DipcAssert(dipc::getSignerAddress(sha3Data,sign).toString() == sender.get().toString());
    callTransfer(callerAddr, amount);
    DipcAssert(balance.get() -amount > 0);
    callTransfer(sender.get(), balance.get() - amount);
    *closed = true;
}

EXPORT void PaymentChannel::extend(uint64_t newExpiration) {
    u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
DipcAssert(!closed.get());
    DipcAssert(caller().toString() == sender.get().toString());
    DipcAssert(newExpiration > expiration.get());
    *expiration = newExpiration;
}

EXPORT void PaymentChannel::claimTimeout(){
    DipcAssert(!closed.get());
    DipcAssert(dipc::timestamp() > expiration.get());
    callTransfer(sender.get(), balance.get());
    *closed = true;
}

CONSTANT void PaymentChannel::getPaymentChannelStatus(){

    
    
}

2019-11-15_10:04:50.022345: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:398] searchContext  #include "PaymentChannel.hpp"

PAYABLE void PaymentChannel::init(char* _recipient, uint64_t duration, uint64_t _balance){

    *sender = caller();
    *recipient = _recipient;
    print("_recipient");
    print(_recipient);
    print("recipient");
    prints_l(&recipient.get()[0], recipient.get().size());
    *expiration = duration;
    *balance = _balance;
    DipcAssert(dipc::callValue() == _balance);
    DIPC_EMIT_EVENT(PaymentChannelStatus, recipient.get().data(), expiration.get(), balance.get());
}

EXPORT void PaymentChannel::close(uint64_t amount, char* signature){
    u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
DipcAssert(!closed.get());
    Address callerAddr = caller();
    DipcAssert(callerAddr.toString() == recipient.get());
    std::string sign = signature;
    
    Address contractAddr = dipc::address();
    std::string data = contractAddr.toString() + std::to_string(amount) + callerAddr.toString();
    h256 sha3Data = dipc::sha3(data);
    DipcAssert(dipc::getSignerAddress(sha3Data,sign).toString() == sender.get().toString());
    callTransfer(callerAddr, amount);
    DipcAssert(balance.get() -amount > 0);
    callTransfer(sender.get(), balance.get() - amount);
    *closed = true;
}

EXPORT void PaymentChannel::extend(uint64_t newExpiration) {
    u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
DipcAssert(!closed.get());
    DipcAssert(caller().toString() == sender.get().toString());
    DipcAssert(newExpiration > expiration.get());
    *expiration = newExpiration;
}

EXPORT void PaymentChannel::claimTimeout(){
    DipcAssert(!closed.get());
    DipcAssert(dipc::timestamp() > expiration.get());
    callTransfer(sender.get(), balance.get());
    *closed = true;
}

CONSTANT void PaymentChannel::getPaymentChannelStatus(){

    
    
}

2019-11-15_10:04:50.036880: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:422] log out out  Export :

EXPORT void PaymentChannel::claimTimeout(){
    

2019-11-15_10:04:50.036900: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:428] name : claimTimeout   pos1  0

2019-11-15_10:04:50.036909: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:440] pos2  1532   pos1  1532

2019-11-15_10:04:50.036915: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:471] pos2 after 1731   pos1  1532

2019-11-15_10:04:50.036922: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:480] finalContract  first #include "PaymentChannel.hpp"

PAYABLE void PaymentChannel::init(char* _recipient, uint64_t duration, uint64_t _balance){

    *sender = caller();
    *recipient = _recipient;
    print("_recipient");
    print(_recipient);
    print("recipient");
    prints_l(&recipient.get()[0], recipient.get().size());
    *expiration = duration;
    *balance = _balance;
    DipcAssert(dipc::callValue() == _balance);
    DIPC_EMIT_EVENT(PaymentChannelStatus, recipient.get().data(), expiration.get(), balance.get());
}

EXPORT void PaymentChannel::close(uint64_t amount, char* signature){
    u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
DipcAssert(!closed.get());
    Address callerAddr = caller();
    DipcAssert(callerAddr.toString() == recipient.get());
    std::string sign = signature;
    
    Address contractAddr = dipc::address();
    std::string data = contractAddr.toString() + std::to_string(amount) + callerAddr.toString();
    h256 sha3Data = dipc::sha3(data);
    DipcAssert(dipc::getSignerAddress(sha3Data,sign).toString() == sender.get().toString());
    callTransfer(callerAddr, amount);
    DipcAssert(balance.get() -amount > 0);
    callTransfer(sender.get(), balance.get() - amount);
    *closed = true;
}

EXPORT void PaymentChannel::extend(uint64_t newExpiration) {
    u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
DipcAssert(!closed.get());
    DipcAssert(caller().toString() == sender.get().toString());
    DipcAssert(newExpiration > expiration.get());
    *expiration = newExpiration;
}

2019-11-15_10:04:50.036928: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:481] codetext  first #include "PaymentChannel.hpp"

PAYABLE void PaymentChannel::init(char* _recipient, uint64_t duration, uint64_t _balance){

    *sender = caller();
    *recipient = _recipient;
    print("_recipient");
    print(_recipient);
    print("recipient");
    prints_l(&recipient.get()[0], recipient.get().size());
    *expiration = duration;
    *balance = _balance;
    DipcAssert(dipc::callValue() == _balance);
    DIPC_EMIT_EVENT(PaymentChannelStatus, recipient.get().data(), expiration.get(), balance.get());
}

EXPORT void PaymentChannel::close(uint64_t amount, char* signature){
    u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
DipcAssert(!closed.get());
    Address callerAddr = caller();
    DipcAssert(callerAddr.toString() == recipient.get());
    std::string sign = signature;
    
    Address contractAddr = dipc::address();
    std::string data = contractAddr.toString() + std::to_string(amount) + callerAddr.toString();
    h256 sha3Data = dipc::sha3(data);
    DipcAssert(dipc::getSignerAddress(sha3Data,sign).toString() == sender.get().toString());
    callTransfer(callerAddr, amount);
    DipcAssert(balance.get() -amount > 0);
    callTransfer(sender.get(), balance.get() - amount);
    *closed = true;
}

EXPORT void PaymentChannel::extend(uint64_t newExpiration) {
    u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
DipcAssert(!closed.get());
    DipcAssert(caller().toString() == sender.get().toString());
    DipcAssert(newExpiration > expiration.get());
    *expiration = newExpiration;
}

EXPORT void PaymentChannel::claimTimeout(){
    DipcAssert(!closed.get());
    DipcAssert(dipc::timestamp() > expiration.get());
    callTransfer(sender.get(), balance.get());
    *closed = true;
}

CONSTANT void PaymentChannel::getPaymentChannelStatus(){

    
    
}

2019-11-15_10:04:50.036935: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:484] s  first 

EXPORT void PaymentChannel::claimTimeout(){
    DipcAssert(!closed.get());
    DipcAssert(dipc::timestamp() > expiration.get());
    callTransfer(sender.get(), balance.get());
    *closed = true;
}

2019-11-15_10:04:50.036943: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:564] calledFunc temp export: 

EXPORT void PaymentChannel::claimTimeout(){
    u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
DipcAssert(!closed.get());
    DipcAssert(dipc::timestamp() > expiration.get());
    callTransfer(sender.get(), balance.get());
    *closed = true;
}

2019-11-15_10:04:50.036951: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:570] search func : 

EXPORT void PaymentChannel::claimTimeout(){
    u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
DipcAssert(!closed.get());
    DipcAssert(dipc::timestamp() > expiration.get());
    callTransfer(sender.get(), balance.get());
    *closed = true;
}
2019-11-15_10:04:50.036958: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:395] finalContract  this height  #include "PaymentChannel.hpp"

PAYABLE void PaymentChannel::init(char* _recipient, uint64_t duration, uint64_t _balance){

    *sender = caller();
    *recipient = _recipient;
    print("_recipient");
    print(_recipient);
    print("recipient");
    prints_l(&recipient.get()[0], recipient.get().size());
    *expiration = duration;
    *balance = _balance;
    DipcAssert(dipc::callValue() == _balance);
    DIPC_EMIT_EVENT(PaymentChannelStatus, recipient.get().data(), expiration.get(), balance.get());
}

EXPORT void PaymentChannel::close(uint64_t amount, char* signature){
    u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
DipcAssert(!closed.get());
    Address callerAddr = caller();
    DipcAssert(callerAddr.toString() == recipient.get());
    std::string sign = signature;
    
    Address contractAddr = dipc::address();
    std::string data = contractAddr.toString() + std::to_string(amount) + callerAddr.toString();
    h256 sha3Data = dipc::sha3(data);
    DipcAssert(dipc::getSignerAddress(sha3Data,sign).toString() == sender.get().toString());
    callTransfer(callerAddr, amount);
    DipcAssert(balance.get() -amount > 0);
    callTransfer(sender.get(), balance.get() - amount);
    *closed = true;
}

EXPORT void PaymentChannel::extend(uint64_t newExpiration) {
    u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
DipcAssert(!closed.get());
    DipcAssert(caller().toString() == sender.get().toString());
    DipcAssert(newExpiration > expiration.get());
    *expiration = newExpiration;
}

EXPORT void PaymentChannel::claimTimeout(){
    u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
DipcAssert(!closed.get());
    DipcAssert(dipc::timestamp() > expiration.get());
    callTransfer(sender.get(), balance.get());
    *closed = true;
} codetext height #include "PaymentChannel.hpp"

PAYABLE void PaymentChannel::init(char* _recipient, uint64_t duration, uint64_t _balance){

    *sender = caller();
    *recipient = _recipient;
    print("_recipient");
    print(_recipient);
    print("recipient");
    prints_l(&recipient.get()[0], recipient.get().size());
    *expiration = duration;
    *balance = _balance;
    DipcAssert(dipc::callValue() == _balance);
    DIPC_EMIT_EVENT(PaymentChannelStatus, recipient.get().data(), expiration.get(), balance.get());
}

EXPORT void PaymentChannel::close(uint64_t amount, char* signature){
    u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
DipcAssert(!closed.get());
    Address callerAddr = caller();
    DipcAssert(callerAddr.toString() == recipient.get());
    std::string sign = signature;
    
    Address contractAddr = dipc::address();
    std::string data = contractAddr.toString() + std::to_string(amount) + callerAddr.toString();
    h256 sha3Data = dipc::sha3(data);
    DipcAssert(dipc::getSignerAddress(sha3Data,sign).toString() == sender.get().toString());
    callTransfer(callerAddr, amount);
    DipcAssert(balance.get() -amount > 0);
    callTransfer(sender.get(), balance.get() - amount);
    *closed = true;
}

EXPORT void PaymentChannel::extend(uint64_t newExpiration) {
    u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
DipcAssert(!closed.get());
    DipcAssert(caller().toString() == sender.get().toString());
    DipcAssert(newExpiration > expiration.get());
    *expiration = newExpiration;
}

EXPORT void PaymentChannel::claimTimeout(){
    DipcAssert(!closed.get());
    DipcAssert(dipc::timestamp() > expiration.get());
    callTransfer(sender.get(), balance.get());
    *closed = true;
}

CONSTANT void PaymentChannel::getPaymentChannelStatus(){

    
    
}

2019-11-15_10:04:50.036965: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:398] searchContext  

CONSTANT void PaymentChannel::getPaymentChannelStatus(){

    
    
}

2019-11-15_10:04:50.037454: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:413] finalContract  this new  #include "PaymentChannel.hpp"

PAYABLE void PaymentChannel::init(char* _recipient, uint64_t duration, uint64_t _balance){

    *sender = caller();
    *recipient = _recipient;
    print("_recipient");
    print(_recipient);
    print("recipient");
    prints_l(&recipient.get()[0], recipient.get().size());
    *expiration = duration;
    *balance = _balance;
    DipcAssert(dipc::callValue() == _balance);
    DIPC_EMIT_EVENT(PaymentChannelStatus, recipient.get().data(), expiration.get(), balance.get());
}

EXPORT void PaymentChannel::close(uint64_t amount, char* signature){
    u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
DipcAssert(!closed.get());
    Address callerAddr = caller();
    DipcAssert(callerAddr.toString() == recipient.get());
    std::string sign = signature;
    
    Address contractAddr = dipc::address();
    std::string data = contractAddr.toString() + std::to_string(amount) + callerAddr.toString();
    h256 sha3Data = dipc::sha3(data);
    DipcAssert(dipc::getSignerAddress(sha3Data,sign).toString() == sender.get().toString());
    callTransfer(callerAddr, amount);
    DipcAssert(balance.get() -amount > 0);
    callTransfer(sender.get(), balance.get() - amount);
    *closed = true;
}

EXPORT void PaymentChannel::extend(uint64_t newExpiration) {
    u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
DipcAssert(!closed.get());
    DipcAssert(caller().toString() == sender.get().toString());
    DipcAssert(newExpiration > expiration.get());
    *expiration = newExpiration;
}

EXPORT void PaymentChannel::claimTimeout(){
    u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
DipcAssert(!closed.get());
    DipcAssert(dipc::timestamp() > expiration.get());
    callTransfer(sender.get(), balance.get());
    *closed = true;
} codetext new #include "PaymentChannel.hpp"

PAYABLE void PaymentChannel::init(char* _recipient, uint64_t duration, uint64_t _balance){

    *sender = caller();
    *recipient = _recipient;
    print("_recipient");
    print(_recipient);
    print("recipient");
    prints_l(&recipient.get()[0], recipient.get().size());
    *expiration = duration;
    *balance = _balance;
    DipcAssert(dipc::callValue() == _balance);
    DIPC_EMIT_EVENT(PaymentChannelStatus, recipient.get().data(), expiration.get(), balance.get());
}

EXPORT void PaymentChannel::close(uint64_t amount, char* signature){
    u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
DipcAssert(!closed.get());
    Address callerAddr = caller();
    DipcAssert(callerAddr.toString() == recipient.get());
    std::string sign = signature;
    
    Address contractAddr = dipc::address();
    std::string data = contractAddr.toString() + std::to_string(amount) + callerAddr.toString();
    h256 sha3Data = dipc::sha3(data);
    DipcAssert(dipc::getSignerAddress(sha3Data,sign).toString() == sender.get().toString());
    callTransfer(callerAddr, amount);
    DipcAssert(balance.get() -amount > 0);
    callTransfer(sender.get(), balance.get() - amount);
    *closed = true;
}

EXPORT void PaymentChannel::extend(uint64_t newExpiration) {
    u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
DipcAssert(!closed.get());
    DipcAssert(caller().toString() == sender.get().toString());
    DipcAssert(newExpiration > expiration.get());
    *expiration = newExpiration;
}

EXPORT void PaymentChannel::claimTimeout(){
    DipcAssert(!closed.get());
    DipcAssert(dipc::timestamp() > expiration.get());
    callTransfer(sender.get(), balance.get());
    *closed = true;
}

CONSTANT void PaymentChannel::getPaymentChannelStatus(){

    
    
}

2019-11-15_10:04:50.037462: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:575] finalContract  final content =======   : #include "PaymentChannel.hpp"

PAYABLE void PaymentChannel::init(char* _recipient, uint64_t duration, uint64_t _balance){

    *sender = caller();
    *recipient = _recipient;
    print("_recipient");
    print(_recipient);
    print("recipient");
    prints_l(&recipient.get()[0], recipient.get().size());
    *expiration = duration;
    *balance = _balance;
    DipcAssert(dipc::callValue() == _balance);
    DIPC_EMIT_EVENT(PaymentChannelStatus, recipient.get().data(), expiration.get(), balance.get());
}

EXPORT void PaymentChannel::close(uint64_t amount, char* signature){
    u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
DipcAssert(!closed.get());
    Address callerAddr = caller();
    DipcAssert(callerAddr.toString() == recipient.get());
    std::string sign = signature;
    
    Address contractAddr = dipc::address();
    std::string data = contractAddr.toString() + std::to_string(amount) + callerAddr.toString();
    h256 sha3Data = dipc::sha3(data);
    DipcAssert(dipc::getSignerAddress(sha3Data,sign).toString() == sender.get().toString());
    callTransfer(callerAddr, amount);
    DipcAssert(balance.get() -amount > 0);
    callTransfer(sender.get(), balance.get() - amount);
    *closed = true;
}

EXPORT void PaymentChannel::extend(uint64_t newExpiration) {
    u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
DipcAssert(!closed.get());
    DipcAssert(caller().toString() == sender.get().toString());
    DipcAssert(newExpiration > expiration.get());
    *expiration = newExpiration;
}

EXPORT void PaymentChannel::claimTimeout(){
    u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
DipcAssert(!closed.get());
    DipcAssert(dipc::timestamp() > expiration.get());
    callTransfer(sender.get(), balance.get());
    *closed = true;
}

CONSTANT void PaymentChannel::getPaymentChannelStatus(){

    
    
}

2019-11-15_10:04:50.037469: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:372] abis.ispayable :false

2019-11-15_10:04:50.037485: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:395] finalContract  this height  #include "PaymentChannel.hpp"

PAYABLE void PaymentChannel::init(char* _recipient, uint64_t duration, uint64_t _balance){

    *sender = caller();
    *recipient = _recipient;
    print("_recipient");
    print(_recipient);
    print("recipient");
    prints_l(&recipient.get()[0], recipient.get().size());
    *expiration = duration;
    *balance = _balance;
    DipcAssert(dipc::callValue() == _balance);
    DIPC_EMIT_EVENT(PaymentChannelStatus, recipient.get().data(), expiration.get(), balance.get());
}

EXPORT void PaymentChannel::close(uint64_t amount, char* signature){
    u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
DipcAssert(!closed.get());
    Address callerAddr = caller();
    DipcAssert(callerAddr.toString() == recipient.get());
    std::string sign = signature;
    
    Address contractAddr = dipc::address();
    std::string data = contractAddr.toString() + std::to_string(amount) + callerAddr.toString();
    h256 sha3Data = dipc::sha3(data);
    DipcAssert(dipc::getSignerAddress(sha3Data,sign).toString() == sender.get().toString());
    callTransfer(callerAddr, amount);
    DipcAssert(balance.get() -amount > 0);
    callTransfer(sender.get(), balance.get() - amount);
    *closed = true;
}

EXPORT void PaymentChannel::extend(uint64_t newExpiration) {
    u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
DipcAssert(!closed.get());
    DipcAssert(caller().toString() == sender.get().toString());
    DipcAssert(newExpiration > expiration.get());
    *expiration = newExpiration;
}

EXPORT void PaymentChannel::claimTimeout(){
    u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
DipcAssert(!closed.get());
    DipcAssert(dipc::timestamp() > expiration.get());
    callTransfer(sender.get(), balance.get());
    *closed = true;
}

CONSTANT void PaymentChannel::getPaymentChannelStatus(){

    
    
} codetext height #include "PaymentChannel.hpp"

PAYABLE void PaymentChannel::init(char* _recipient, uint64_t duration, uint64_t _balance){

    *sender = caller();
    *recipient = _recipient;
    print("_recipient");
    print(_recipient);
    print("recipient");
    prints_l(&recipient.get()[0], recipient.get().size());
    *expiration = duration;
    *balance = _balance;
    DipcAssert(dipc::callValue() == _balance);
    DIPC_EMIT_EVENT(PaymentChannelStatus, recipient.get().data(), expiration.get(), balance.get());
}

EXPORT void PaymentChannel::close(uint64_t amount, char* signature){
    u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
DipcAssert(!closed.get());
    Address callerAddr = caller();
    DipcAssert(callerAddr.toString() == recipient.get());
    std::string sign = signature;
    
    Address contractAddr = dipc::address();
    std::string data = contractAddr.toString() + std::to_string(amount) + callerAddr.toString();
    h256 sha3Data = dipc::sha3(data);
    DipcAssert(dipc::getSignerAddress(sha3Data,sign).toString() == sender.get().toString());
    callTransfer(callerAddr, amount);
    DipcAssert(balance.get() -amount > 0);
    callTransfer(sender.get(), balance.get() - amount);
    *closed = true;
}

EXPORT void PaymentChannel::extend(uint64_t newExpiration) {
    u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
DipcAssert(!closed.get());
    DipcAssert(caller().toString() == sender.get().toString());
    DipcAssert(newExpiration > expiration.get());
    *expiration = newExpiration;
}

EXPORT void PaymentChannel::claimTimeout(){
    u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
DipcAssert(!closed.get());
    DipcAssert(dipc::timestamp() > expiration.get());
    callTransfer(sender.get(), balance.get());
    *closed = true;
}

CONSTANT void PaymentChannel::getPaymentChannelStatus(){

    
    
}

2019-11-15_10:04:50.037492: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:398] searchContext  #include "PaymentChannel.hpp"

PAYABLE void PaymentChannel::init(char* _recipient, uint64_t duration, uint64_t _balance){

    *sender = caller();
    *recipient = _recipient;
    print("_recipient");
    print(_recipient);
    print("recipient");
    prints_l(&recipient.get()[0], recipient.get().size());
    *expiration = duration;
    *balance = _balance;
    DipcAssert(dipc::callValue() == _balance);
    DIPC_EMIT_EVENT(PaymentChannelStatus, recipient.get().data(), expiration.get(), balance.get());
}

EXPORT void PaymentChannel::close(uint64_t amount, char* signature){
    u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
DipcAssert(!closed.get());
    Address callerAddr = caller();
    DipcAssert(callerAddr.toString() == recipient.get());
    std::string sign = signature;
    
    Address contractAddr = dipc::address();
    std::string data = contractAddr.toString() + std::to_string(amount) + callerAddr.toString();
    h256 sha3Data = dipc::sha3(data);
    DipcAssert(dipc::getSignerAddress(sha3Data,sign).toString() == sender.get().toString());
    callTransfer(callerAddr, amount);
    DipcAssert(balance.get() -amount > 0);
    callTransfer(sender.get(), balance.get() - amount);
    *closed = true;
}

EXPORT void PaymentChannel::extend(uint64_t newExpiration) {
    u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
DipcAssert(!closed.get());
    DipcAssert(caller().toString() == sender.get().toString());
    DipcAssert(newExpiration > expiration.get());
    *expiration = newExpiration;
}

EXPORT void PaymentChannel::claimTimeout(){
    u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
DipcAssert(!closed.get());
    DipcAssert(dipc::timestamp() > expiration.get());
    callTransfer(sender.get(), balance.get());
    *closed = true;
}

CONSTANT void PaymentChannel::getPaymentChannelStatus(){

    
    
}

2019-11-15_10:04:50.055910: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:422] log out out  Export :

CONSTANT void PaymentChannel::getPaymentChannelStatus(){

    
    


2019-11-15_10:04:50.055931: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:428] name : getPaymentChannelStatus   pos1  0

2019-11-15_10:04:50.055941: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:440] pos2  1790   pos1  1790

2019-11-15_10:04:50.055953: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:471] pos2 after 1861   pos1  1790

2019-11-15_10:04:50.055960: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:480] finalContract  first #include "PaymentChannel.hpp"

PAYABLE void PaymentChannel::init(char* _recipient, uint64_t duration, uint64_t _balance){

    *sender = caller();
    *recipient = _recipient;
    print("_recipient");
    print(_recipient);
    print("recipient");
    prints_l(&recipient.get()[0], recipient.get().size());
    *expiration = duration;
    *balance = _balance;
    DipcAssert(dipc::callValue() == _balance);
    DIPC_EMIT_EVENT(PaymentChannelStatus, recipient.get().data(), expiration.get(), balance.get());
}

EXPORT void PaymentChannel::close(uint64_t amount, char* signature){
    u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
DipcAssert(!closed.get());
    Address callerAddr = caller();
    DipcAssert(callerAddr.toString() == recipient.get());
    std::string sign = signature;
    
    Address contractAddr = dipc::address();
    std::string data = contractAddr.toString() + std::to_string(amount) + callerAddr.toString();
    h256 sha3Data = dipc::sha3(data);
    DipcAssert(dipc::getSignerAddress(sha3Data,sign).toString() == sender.get().toString());
    callTransfer(callerAddr, amount);
    DipcAssert(balance.get() -amount > 0);
    callTransfer(sender.get(), balance.get() - amount);
    *closed = true;
}

EXPORT void PaymentChannel::extend(uint64_t newExpiration) {
    u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
DipcAssert(!closed.get());
    DipcAssert(caller().toString() == sender.get().toString());
    DipcAssert(newExpiration > expiration.get());
    *expiration = newExpiration;
}

EXPORT void PaymentChannel::claimTimeout(){
    u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
DipcAssert(!closed.get());
    DipcAssert(dipc::timestamp() > expiration.get());
    callTransfer(sender.get(), balance.get());
    *closed = true;
}

2019-11-15_10:04:50.055967: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:481] codetext  first #include "PaymentChannel.hpp"

PAYABLE void PaymentChannel::init(char* _recipient, uint64_t duration, uint64_t _balance){

    *sender = caller();
    *recipient = _recipient;
    print("_recipient");
    print(_recipient);
    print("recipient");
    prints_l(&recipient.get()[0], recipient.get().size());
    *expiration = duration;
    *balance = _balance;
    DipcAssert(dipc::callValue() == _balance);
    DIPC_EMIT_EVENT(PaymentChannelStatus, recipient.get().data(), expiration.get(), balance.get());
}

EXPORT void PaymentChannel::close(uint64_t amount, char* signature){
    u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
DipcAssert(!closed.get());
    Address callerAddr = caller();
    DipcAssert(callerAddr.toString() == recipient.get());
    std::string sign = signature;
    
    Address contractAddr = dipc::address();
    std::string data = contractAddr.toString() + std::to_string(amount) + callerAddr.toString();
    h256 sha3Data = dipc::sha3(data);
    DipcAssert(dipc::getSignerAddress(sha3Data,sign).toString() == sender.get().toString());
    callTransfer(callerAddr, amount);
    DipcAssert(balance.get() -amount > 0);
    callTransfer(sender.get(), balance.get() - amount);
    *closed = true;
}

EXPORT void PaymentChannel::extend(uint64_t newExpiration) {
    u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
DipcAssert(!closed.get());
    DipcAssert(caller().toString() == sender.get().toString());
    DipcAssert(newExpiration > expiration.get());
    *expiration = newExpiration;
}

EXPORT void PaymentChannel::claimTimeout(){
    u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
DipcAssert(!closed.get());
    DipcAssert(dipc::timestamp() > expiration.get());
    callTransfer(sender.get(), balance.get());
    *closed = true;
}

CONSTANT void PaymentChannel::getPaymentChannelStatus(){

    
    
}

2019-11-15_10:04:50.055974: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:484] s  first 

CONSTANT void PaymentChannel::getPaymentChannelStatus(){

    
    
}

2019-11-15_10:04:50.055982: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:564] calledFunc temp export: 

CONSTANT void PaymentChannel::getPaymentChannelStatus(){

    
    
u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
}

2019-11-15_10:04:50.055989: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:570] search func : 

CONSTANT void PaymentChannel::getPaymentChannelStatus(){

    
    
u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
}
2019-11-15_10:04:50.055996: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:395] finalContract  this height  #include "PaymentChannel.hpp"

PAYABLE void PaymentChannel::init(char* _recipient, uint64_t duration, uint64_t _balance){

    *sender = caller();
    *recipient = _recipient;
    print("_recipient");
    print(_recipient);
    print("recipient");
    prints_l(&recipient.get()[0], recipient.get().size());
    *expiration = duration;
    *balance = _balance;
    DipcAssert(dipc::callValue() == _balance);
    DIPC_EMIT_EVENT(PaymentChannelStatus, recipient.get().data(), expiration.get(), balance.get());
}

EXPORT void PaymentChannel::close(uint64_t amount, char* signature){
    u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
DipcAssert(!closed.get());
    Address callerAddr = caller();
    DipcAssert(callerAddr.toString() == recipient.get());
    std::string sign = signature;
    
    Address contractAddr = dipc::address();
    std::string data = contractAddr.toString() + std::to_string(amount) + callerAddr.toString();
    h256 sha3Data = dipc::sha3(data);
    DipcAssert(dipc::getSignerAddress(sha3Data,sign).toString() == sender.get().toString());
    callTransfer(callerAddr, amount);
    DipcAssert(balance.get() -amount > 0);
    callTransfer(sender.get(), balance.get() - amount);
    *closed = true;
}

EXPORT void PaymentChannel::extend(uint64_t newExpiration) {
    u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
DipcAssert(!closed.get());
    DipcAssert(caller().toString() == sender.get().toString());
    DipcAssert(newExpiration > expiration.get());
    *expiration = newExpiration;
}

EXPORT void PaymentChannel::claimTimeout(){
    u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
DipcAssert(!closed.get());
    DipcAssert(dipc::timestamp() > expiration.get());
    callTransfer(sender.get(), balance.get());
    *closed = true;
}

CONSTANT void PaymentChannel::getPaymentChannelStatus(){

    
    
u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
} codetext height #include "PaymentChannel.hpp"

PAYABLE void PaymentChannel::init(char* _recipient, uint64_t duration, uint64_t _balance){

    *sender = caller();
    *recipient = _recipient;
    print("_recipient");
    print(_recipient);
    print("recipient");
    prints_l(&recipient.get()[0], recipient.get().size());
    *expiration = duration;
    *balance = _balance;
    DipcAssert(dipc::callValue() == _balance);
    DIPC_EMIT_EVENT(PaymentChannelStatus, recipient.get().data(), expiration.get(), balance.get());
}

EXPORT void PaymentChannel::close(uint64_t amount, char* signature){
    u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
DipcAssert(!closed.get());
    Address callerAddr = caller();
    DipcAssert(callerAddr.toString() == recipient.get());
    std::string sign = signature;
    
    Address contractAddr = dipc::address();
    std::string data = contractAddr.toString() + std::to_string(amount) + callerAddr.toString();
    h256 sha3Data = dipc::sha3(data);
    DipcAssert(dipc::getSignerAddress(sha3Data,sign).toString() == sender.get().toString());
    callTransfer(callerAddr, amount);
    DipcAssert(balance.get() -amount > 0);
    callTransfer(sender.get(), balance.get() - amount);
    *closed = true;
}

EXPORT void PaymentChannel::extend(uint64_t newExpiration) {
    u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
DipcAssert(!closed.get());
    DipcAssert(caller().toString() == sender.get().toString());
    DipcAssert(newExpiration > expiration.get());
    *expiration = newExpiration;
}

EXPORT void PaymentChannel::claimTimeout(){
    u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
DipcAssert(!closed.get());
    DipcAssert(dipc::timestamp() > expiration.get());
    callTransfer(sender.get(), balance.get());
    *closed = true;
}

CONSTANT void PaymentChannel::getPaymentChannelStatus(){

    
    
}

2019-11-15_10:04:50.056066: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:398] searchContext  

2019-11-15_10:04:50.056076: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:413] finalContract  this new  #include "PaymentChannel.hpp"

PAYABLE void PaymentChannel::init(char* _recipient, uint64_t duration, uint64_t _balance){

    *sender = caller();
    *recipient = _recipient;
    print("_recipient");
    print(_recipient);
    print("recipient");
    prints_l(&recipient.get()[0], recipient.get().size());
    *expiration = duration;
    *balance = _balance;
    DipcAssert(dipc::callValue() == _balance);
    DIPC_EMIT_EVENT(PaymentChannelStatus, recipient.get().data(), expiration.get(), balance.get());
}

EXPORT void PaymentChannel::close(uint64_t amount, char* signature){
    u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
DipcAssert(!closed.get());
    Address callerAddr = caller();
    DipcAssert(callerAddr.toString() == recipient.get());
    std::string sign = signature;
    
    Address contractAddr = dipc::address();
    std::string data = contractAddr.toString() + std::to_string(amount) + callerAddr.toString();
    h256 sha3Data = dipc::sha3(data);
    DipcAssert(dipc::getSignerAddress(sha3Data,sign).toString() == sender.get().toString());
    callTransfer(callerAddr, amount);
    DipcAssert(balance.get() -amount > 0);
    callTransfer(sender.get(), balance.get() - amount);
    *closed = true;
}

EXPORT void PaymentChannel::extend(uint64_t newExpiration) {
    u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
DipcAssert(!closed.get());
    DipcAssert(caller().toString() == sender.get().toString());
    DipcAssert(newExpiration > expiration.get());
    *expiration = newExpiration;
}

EXPORT void PaymentChannel::claimTimeout(){
    u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
DipcAssert(!closed.get());
    DipcAssert(dipc::timestamp() > expiration.get());
    callTransfer(sender.get(), balance.get());
    *closed = true;
}

CONSTANT void PaymentChannel::getPaymentChannelStatus(){

    
    
u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
} codetext new #include "PaymentChannel.hpp"

PAYABLE void PaymentChannel::init(char* _recipient, uint64_t duration, uint64_t _balance){

    *sender = caller();
    *recipient = _recipient;
    print("_recipient");
    print(_recipient);
    print("recipient");
    prints_l(&recipient.get()[0], recipient.get().size());
    *expiration = duration;
    *balance = _balance;
    DipcAssert(dipc::callValue() == _balance);
    DIPC_EMIT_EVENT(PaymentChannelStatus, recipient.get().data(), expiration.get(), balance.get());
}

EXPORT void PaymentChannel::close(uint64_t amount, char* signature){
    u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
DipcAssert(!closed.get());
    Address callerAddr = caller();
    DipcAssert(callerAddr.toString() == recipient.get());
    std::string sign = signature;
    
    Address contractAddr = dipc::address();
    std::string data = contractAddr.toString() + std::to_string(amount) + callerAddr.toString();
    h256 sha3Data = dipc::sha3(data);
    DipcAssert(dipc::getSignerAddress(sha3Data,sign).toString() == sender.get().toString());
    callTransfer(callerAddr, amount);
    DipcAssert(balance.get() -amount > 0);
    callTransfer(sender.get(), balance.get() - amount);
    *closed = true;
}

EXPORT void PaymentChannel::extend(uint64_t newExpiration) {
    u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
DipcAssert(!closed.get());
    DipcAssert(caller().toString() == sender.get().toString());
    DipcAssert(newExpiration > expiration.get());
    *expiration = newExpiration;
}

EXPORT void PaymentChannel::claimTimeout(){
    u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
DipcAssert(!closed.get());
    DipcAssert(dipc::timestamp() > expiration.get());
    callTransfer(sender.get(), balance.get());
    *closed = true;
}

CONSTANT void PaymentChannel::getPaymentChannelStatus(){

    
    
}

2019-11-15_10:04:50.056084: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:575] finalContract  final content =======   : #include "PaymentChannel.hpp"

PAYABLE void PaymentChannel::init(char* _recipient, uint64_t duration, uint64_t _balance){

    *sender = caller();
    *recipient = _recipient;
    print("_recipient");
    print(_recipient);
    print("recipient");
    prints_l(&recipient.get()[0], recipient.get().size());
    *expiration = duration;
    *balance = _balance;
    DipcAssert(dipc::callValue() == _balance);
    DIPC_EMIT_EVENT(PaymentChannelStatus, recipient.get().data(), expiration.get(), balance.get());
}

EXPORT void PaymentChannel::close(uint64_t amount, char* signature){
    u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
DipcAssert(!closed.get());
    Address callerAddr = caller();
    DipcAssert(callerAddr.toString() == recipient.get());
    std::string sign = signature;
    
    Address contractAddr = dipc::address();
    std::string data = contractAddr.toString() + std::to_string(amount) + callerAddr.toString();
    h256 sha3Data = dipc::sha3(data);
    DipcAssert(dipc::getSignerAddress(sha3Data,sign).toString() == sender.get().toString());
    callTransfer(callerAddr, amount);
    DipcAssert(balance.get() -amount > 0);
    callTransfer(sender.get(), balance.get() - amount);
    *closed = true;
}

EXPORT void PaymentChannel::extend(uint64_t newExpiration) {
    u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
DipcAssert(!closed.get());
    DipcAssert(caller().toString() == sender.get().toString());
    DipcAssert(newExpiration > expiration.get());
    *expiration = newExpiration;
}

EXPORT void PaymentChannel::claimTimeout(){
    u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
DipcAssert(!closed.get());
    DipcAssert(dipc::timestamp() > expiration.get());
    callTransfer(sender.get(), balance.get());
    *closed = true;
}

CONSTANT void PaymentChannel::getPaymentChannelStatus(){

    
    
u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
}

2019-11-15_10:04:50.056104: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:584] finalContract  final content  last =======   : #include "PaymentChannel.hpp"

PAYABLE void PaymentChannel::init(char* _recipient, uint64_t duration, uint64_t _balance){

    *sender = caller();
    *recipient = _recipient;
    print("_recipient");
    print(_recipient);
    print("recipient");
    prints_l(&recipient.get()[0], recipient.get().size());
    *expiration = duration;
    *balance = _balance;
    DipcAssert(dipc::callValue() == _balance);
    DIPC_EMIT_EVENT(PaymentChannelStatus, recipient.get().data(), expiration.get(), balance.get());
}

EXPORT void PaymentChannel::close(uint64_t amount, char* signature){
    u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
DipcAssert(!closed.get());
    Address callerAddr = caller();
    DipcAssert(callerAddr.toString() == recipient.get());
    std::string sign = signature;
    
    Address contractAddr = dipc::address();
    std::string data = contractAddr.toString() + std::to_string(amount) + callerAddr.toString();
    h256 sha3Data = dipc::sha3(data);
    DipcAssert(dipc::getSignerAddress(sha3Data,sign).toString() == sender.get().toString());
    callTransfer(callerAddr, amount);
    DipcAssert(balance.get() -amount > 0);
    callTransfer(sender.get(), balance.get() - amount);
    *closed = true;
}

EXPORT void PaymentChannel::extend(uint64_t newExpiration) {
    u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
DipcAssert(!closed.get());
    DipcAssert(caller().toString() == sender.get().toString());
    DipcAssert(newExpiration > expiration.get());
    *expiration = newExpiration;
}

EXPORT void PaymentChannel::claimTimeout(){
    u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
DipcAssert(!closed.get());
    DipcAssert(dipc::timestamp() > expiration.get());
    callTransfer(sender.get(), balance.get());
    *closed = true;
}

CONSTANT void PaymentChannel::getPaymentChannelStatus(){

    
    
u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
}

2019-11-15_10:04:50.056116: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:819] removedComments end  =======::#include "PaymentChannel.hpp"

PAYABLE void PaymentChannel::init(char* _recipient, uint64_t duration, uint64_t _balance){

    *sender = caller();
    *recipient = _recipient;
    print("_recipient");
    print(_recipient);
    print("recipient");
    prints_l(&recipient.get()[0], recipient.get().size());
    *expiration = duration;
    *balance = _balance;
    DipcAssert(dipc::callValue() == _balance);
    DIPC_EMIT_EVENT(PaymentChannelStatus, recipient.get().data(), expiration.get(), balance.get());
}

EXPORT void PaymentChannel::close(uint64_t amount, char* signature){
    u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
DipcAssert(!closed.get());
    Address callerAddr = caller();
    DipcAssert(callerAddr.toString() == recipient.get());
    std::string sign = signature;
    
    Address contractAddr = dipc::address();
    std::string data = contractAddr.toString() + std::to_string(amount) + callerAddr.toString();
    h256 sha3Data = dipc::sha3(data);
    DipcAssert(dipc::getSignerAddress(sha3Data,sign).toString() == sender.get().toString());
    callTransfer(callerAddr, amount);
    DipcAssert(balance.get() -amount > 0);
    callTransfer(sender.get(), balance.get() - amount);
    *closed = true;
}

EXPORT void PaymentChannel::extend(uint64_t newExpiration) {
    u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
DipcAssert(!closed.get());
    DipcAssert(caller().toString() == sender.get().toString());
    DipcAssert(newExpiration > expiration.get());
    *expiration = newExpiration;
}

EXPORT void PaymentChannel::claimTimeout(){
    u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
DipcAssert(!closed.get());
    DipcAssert(dipc::timestamp() > expiration.get());
    callTransfer(sender.get(), balance.get());
    *closed = true;
}

CONSTANT void PaymentChannel::getPaymentChannelStatus(){

    
    
u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
}

2019-11-15_10:04:50.056127: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:823] str ============
2019-11-15_10:04:50.056134: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:824] str ============class\s*PaymentChannel\s*\{
2019-11-15_10:04:50.056145: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:829] findClass end  =======::

2019-11-15_10:04:50.056151: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:832] claSma end  =======::

2019-11-15_10:04:50.056813: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:590] CompareHeaderAndImplFileMacro  start 

2019-11-15_10:04:50.056821: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:595] searchStr \s*PAYABLE\s*void\s*PaymentChannel::init code_text #include "PaymentChannel.hpp"

PAYABLE void PaymentChannel::init(char* _recipient, uint64_t duration, uint64_t _balance){

    *sender = caller();
    *recipient = _recipient;
    print("_recipient");
    print(_recipient);
    print("recipient");
    prints_l(&recipient.get()[0], recipient.get().size());
    *expiration = duration;
    *balance = _balance;
    DipcAssert(dipc::callValue() == _balance);
    DIPC_EMIT_EVENT(PaymentChannelStatus, recipient.get().data(), expiration.get(), balance.get());
}

EXPORT void PaymentChannel::close(uint64_t amount, char* signature){
    u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
DipcAssert(!closed.get());
    Address callerAddr = caller();
    DipcAssert(callerAddr.toString() == recipient.get());
    std::string sign = signature;
    
    Address contractAddr = dipc::address();
    std::string data = contractAddr.toString() + std::to_string(amount) + callerAddr.toString();
    h256 sha3Data = dipc::sha3(data);
    DipcAssert(dipc::getSignerAddress(sha3Data,sign).toString() == sender.get().toString());
    callTransfer(callerAddr, amount);
    DipcAssert(balance.get() -amount > 0);
    callTransfer(sender.get(), balance.get() - amount);
    *closed = true;
}

EXPORT void PaymentChannel::extend(uint64_t newExpiration) {
    u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
DipcAssert(!closed.get());
    DipcAssert(caller().toString() == sender.get().toString());
    DipcAssert(newExpiration > expiration.get());
    *expiration = newExpiration;
}

EXPORT void PaymentChannel::claimTimeout(){
    u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
DipcAssert(!closed.get());
    DipcAssert(dipc::timestamp() > expiration.get());
    callTransfer(sender.get(), balance.get());
    *closed = true;
}

CONSTANT void PaymentChannel::getPaymentChannelStatus(){

    
    
u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
}

2019-11-15_10:04:50.056827: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:596] searchStr \s*PAYABLE\s*void\s*PaymentChannel::init

2019-11-15_10:04:50.056863: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:595] searchStr \s*EXPORT\s*void\s*PaymentChannel::close code_text #include "PaymentChannel.hpp"

PAYABLE void PaymentChannel::init(char* _recipient, uint64_t duration, uint64_t _balance){

    *sender = caller();
    *recipient = _recipient;
    print("_recipient");
    print(_recipient);
    print("recipient");
    prints_l(&recipient.get()[0], recipient.get().size());
    *expiration = duration;
    *balance = _balance;
    DipcAssert(dipc::callValue() == _balance);
    DIPC_EMIT_EVENT(PaymentChannelStatus, recipient.get().data(), expiration.get(), balance.get());
}

EXPORT void PaymentChannel::close(uint64_t amount, char* signature){
    u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
DipcAssert(!closed.get());
    Address callerAddr = caller();
    DipcAssert(callerAddr.toString() == recipient.get());
    std::string sign = signature;
    
    Address contractAddr = dipc::address();
    std::string data = contractAddr.toString() + std::to_string(amount) + callerAddr.toString();
    h256 sha3Data = dipc::sha3(data);
    DipcAssert(dipc::getSignerAddress(sha3Data,sign).toString() == sender.get().toString());
    callTransfer(callerAddr, amount);
    DipcAssert(balance.get() -amount > 0);
    callTransfer(sender.get(), balance.get() - amount);
    *closed = true;
}

EXPORT void PaymentChannel::extend(uint64_t newExpiration) {
    u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
DipcAssert(!closed.get());
    DipcAssert(caller().toString() == sender.get().toString());
    DipcAssert(newExpiration > expiration.get());
    *expiration = newExpiration;
}

EXPORT void PaymentChannel::claimTimeout(){
    u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
DipcAssert(!closed.get());
    DipcAssert(dipc::timestamp() > expiration.get());
    callTransfer(sender.get(), balance.get());
    *closed = true;
}

CONSTANT void PaymentChannel::getPaymentChannelStatus(){

    
    
u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
}

2019-11-15_10:04:50.056871: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:596] searchStr \s*EXPORT\s*void\s*PaymentChannel::close

2019-11-15_10:04:50.057186: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:595] searchStr \s*EXPORT\s*void\s*PaymentChannel::extend code_text #include "PaymentChannel.hpp"

PAYABLE void PaymentChannel::init(char* _recipient, uint64_t duration, uint64_t _balance){

    *sender = caller();
    *recipient = _recipient;
    print("_recipient");
    print(_recipient);
    print("recipient");
    prints_l(&recipient.get()[0], recipient.get().size());
    *expiration = duration;
    *balance = _balance;
    DipcAssert(dipc::callValue() == _balance);
    DIPC_EMIT_EVENT(PaymentChannelStatus, recipient.get().data(), expiration.get(), balance.get());
}

EXPORT void PaymentChannel::close(uint64_t amount, char* signature){
    u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
DipcAssert(!closed.get());
    Address callerAddr = caller();
    DipcAssert(callerAddr.toString() == recipient.get());
    std::string sign = signature;
    
    Address contractAddr = dipc::address();
    std::string data = contractAddr.toString() + std::to_string(amount) + callerAddr.toString();
    h256 sha3Data = dipc::sha3(data);
    DipcAssert(dipc::getSignerAddress(sha3Data,sign).toString() == sender.get().toString());
    callTransfer(callerAddr, amount);
    DipcAssert(balance.get() -amount > 0);
    callTransfer(sender.get(), balance.get() - amount);
    *closed = true;
}

EXPORT void PaymentChannel::extend(uint64_t newExpiration) {
    u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
DipcAssert(!closed.get());
    DipcAssert(caller().toString() == sender.get().toString());
    DipcAssert(newExpiration > expiration.get());
    *expiration = newExpiration;
}

EXPORT void PaymentChannel::claimTimeout(){
    u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
DipcAssert(!closed.get());
    DipcAssert(dipc::timestamp() > expiration.get());
    callTransfer(sender.get(), balance.get());
    *closed = true;
}

CONSTANT void PaymentChannel::getPaymentChannelStatus(){

    
    
u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
}

2019-11-15_10:04:50.057193: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:596] searchStr \s*EXPORT\s*void\s*PaymentChannel::extend

2019-11-15_10:04:50.057923: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:595] searchStr \s*EXPORT\s*void\s*PaymentChannel::claimTimeout code_text #include "PaymentChannel.hpp"

PAYABLE void PaymentChannel::init(char* _recipient, uint64_t duration, uint64_t _balance){

    *sender = caller();
    *recipient = _recipient;
    print("_recipient");
    print(_recipient);
    print("recipient");
    prints_l(&recipient.get()[0], recipient.get().size());
    *expiration = duration;
    *balance = _balance;
    DipcAssert(dipc::callValue() == _balance);
    DIPC_EMIT_EVENT(PaymentChannelStatus, recipient.get().data(), expiration.get(), balance.get());
}

EXPORT void PaymentChannel::close(uint64_t amount, char* signature){
    u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
DipcAssert(!closed.get());
    Address callerAddr = caller();
    DipcAssert(callerAddr.toString() == recipient.get());
    std::string sign = signature;
    
    Address contractAddr = dipc::address();
    std::string data = contractAddr.toString() + std::to_string(amount) + callerAddr.toString();
    h256 sha3Data = dipc::sha3(data);
    DipcAssert(dipc::getSignerAddress(sha3Data,sign).toString() == sender.get().toString());
    callTransfer(callerAddr, amount);
    DipcAssert(balance.get() -amount > 0);
    callTransfer(sender.get(), balance.get() - amount);
    *closed = true;
}

EXPORT void PaymentChannel::extend(uint64_t newExpiration) {
    u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
DipcAssert(!closed.get());
    DipcAssert(caller().toString() == sender.get().toString());
    DipcAssert(newExpiration > expiration.get());
    *expiration = newExpiration;
}

EXPORT void PaymentChannel::claimTimeout(){
    u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
DipcAssert(!closed.get());
    DipcAssert(dipc::timestamp() > expiration.get());
    callTransfer(sender.get(), balance.get());
    *closed = true;
}

CONSTANT void PaymentChannel::getPaymentChannelStatus(){

    
    
u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
}

2019-11-15_10:04:50.057931: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:596] searchStr \s*EXPORT\s*void\s*PaymentChannel::claimTimeout

2019-11-15_10:04:50.058816: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:595] searchStr \s*CONSTANT\s*void\s*PaymentChannel::getPaymentChannelStatus code_text #include "PaymentChannel.hpp"

PAYABLE void PaymentChannel::init(char* _recipient, uint64_t duration, uint64_t _balance){

    *sender = caller();
    *recipient = _recipient;
    print("_recipient");
    print(_recipient);
    print("recipient");
    prints_l(&recipient.get()[0], recipient.get().size());
    *expiration = duration;
    *balance = _balance;
    DipcAssert(dipc::callValue() == _balance);
    DIPC_EMIT_EVENT(PaymentChannelStatus, recipient.get().data(), expiration.get(), balance.get());
}

EXPORT void PaymentChannel::close(uint64_t amount, char* signature){
    u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
DipcAssert(!closed.get());
    Address callerAddr = caller();
    DipcAssert(callerAddr.toString() == recipient.get());
    std::string sign = signature;
    
    Address contractAddr = dipc::address();
    std::string data = contractAddr.toString() + std::to_string(amount) + callerAddr.toString();
    h256 sha3Data = dipc::sha3(data);
    DipcAssert(dipc::getSignerAddress(sha3Data,sign).toString() == sender.get().toString());
    callTransfer(callerAddr, amount);
    DipcAssert(balance.get() -amount > 0);
    callTransfer(sender.get(), balance.get() - amount);
    *closed = true;
}

EXPORT void PaymentChannel::extend(uint64_t newExpiration) {
    u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
DipcAssert(!closed.get());
    DipcAssert(caller().toString() == sender.get().toString());
    DipcAssert(newExpiration > expiration.get());
    *expiration = newExpiration;
}

EXPORT void PaymentChannel::claimTimeout(){
    u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
DipcAssert(!closed.get());
    DipcAssert(dipc::timestamp() > expiration.get());
    callTransfer(sender.get(), balance.get());
    *closed = true;
}

CONSTANT void PaymentChannel::getPaymentChannelStatus(){

    
    
u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
}

2019-11-15_10:04:50.058823: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:596] searchStr \s*CONSTANT\s*void\s*PaymentChannel::getPaymentChannelStatus

2019-11-15_10:04:50.060124: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:607] CompareHeaderAndImplFileMacro end  

2019-11-15_10:04:50.060184: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:847] hppPath  :  PaymentChannel.hpp
2019-11-15_10:04:50.060228: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:851] hppOutPath  :  /var/folders/tt/8v4bb03x685c49jk_vkvr7s80000gp/T//PaymentChanneltemp.hpp
2019-11-15_10:04:50.060264: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:859] abaabaab ======== : 
2019-11-15_10:04:50.060276: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:860] contractName ======== : PaymentChannel
2019-11-15_10:04:50.060285: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:862] randomDir ======== : /var/folders/tt/8v4bb03x685c49jk_vkvr7s80000gp/T/ee0d8da8577e10g1g866
2019-11-15_10:04:50.060299: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:863] hppOutPath ======== : /var/folders/tt/8v4bb03x685c49jk_vkvr7s80000gp/T//PaymentChanneltemp.hpp
2019-11-15_10:04:50.060307: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:614] InsertFuncToHeaderFile start....

2019-11-15_10:04:50.060360: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:620] InsertFuncToHeaderFile new ....

2019-11-15_10:04:50.060482: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:622] InsertFuncToHeaderFile result ....true

2019-11-15_10:04:50.060499: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:629] claSma[0].str()  :    class PaymentChannel : public Contract {

2019-11-15_10:04:50.060512: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:631] pos2  :    194

2019-11-15_10:04:50.060521: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:663] tempText   :  #include <dipc/dipc.hpp>
using namespace dipc;

char senderc[] = "sender";
char recipientc[] = "recipient";
char expirationc[] = "expiration";
char balancec[] = "bal";
char closec[] = "close";

class PaymentChannel : public Contract {
private: 
   //String<senderc> sender;
   AddressStore<senderc> sender;
   String<recipientc> recipient;
   Uint64<balancec> balance; 
   Uint64<expirationc> expiration;
   Bool<closec> closed;
public:
    PAYABLE void init(char* _recipient, uint64_t duration, uint64_t _balance);
    //PAYABLE void init(std::string _recipient, uint64_t duration, uint64_t _balance);
    
    EXPORT void close(uint64_t amount, char* signature);
    EXPORT void extend(uint64_t newExpiration);
    EXPORT void claimTimeout();
    CONSTANT void getPaymentChannelStatus();


2019-11-15_10:04:50.060529: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:666] filename   :  PaymentChannel.cpp

2019-11-15_10:04:50.060904: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:686] tempText  end :  #include <dipc/dipc.hpp>
using namespace dipc;

char senderc[] = "sender";
char recipientc[] = "recipient";
char expirationc[] = "expiration";
char balancec[] = "bal";
char closec[] = "close";

class PaymentChannel : public Contract {
private: 
   //String<senderc> sender;
   AddressStore<senderc> sender;
   String<recipientc> recipient;
   Uint64<balancec> balance; 
   Uint64<expirationc> expiration;
   Bool<closec> closed;
public:
    PAYABLE void init(char* _recipient, uint64_t duration, uint64_t _balance);
    //PAYABLE void init(std::string _recipient, uint64_t duration, uint64_t _balance);
    
    EXPORT void close(uint64_t amount, char* signature);
    EXPORT void extend(uint64_t newExpiration);
    EXPORT void claimTimeout();
    CONSTANT void getPaymentChannelStatus();
};

//DIPC_EVENT(PaymentChannelStatus, char *, uint64_t, uint64_t, bool);
DIPC_EVENT(PaymentChannelStatus, char *, uint64_t, uint64_t);
//DIPC_EVENT(PaymentChannelStatus, uint64_t, uint64_t);

2019-11-15_10:04:50.061346: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:872] headerStr removedComments  ======== : #include "PaymentChanneltemp.hpp"

PAYABLE void PaymentChannel::init(char* _recipient, uint64_t duration, uint64_t _balance){

    *sender = caller();
    *recipient = _recipient;
    print("_recipient");
    print(_recipient);
    print("recipient");
    prints_l(&recipient.get()[0], recipient.get().size());
    *expiration = duration;
    *balance = _balance;
    DipcAssert(dipc::callValue() == _balance);
    DIPC_EMIT_EVENT(PaymentChannelStatus, recipient.get().data(), expiration.get(), balance.get());
}

EXPORT void PaymentChannel::close(uint64_t amount, char* signature){
    u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
DipcAssert(!closed.get());
    Address callerAddr = caller();
    DipcAssert(callerAddr.toString() == recipient.get());
    std::string sign = signature;
    
    Address contractAddr = dipc::address();
    std::string data = contractAddr.toString() + std::to_string(amount) + callerAddr.toString();
    h256 sha3Data = dipc::sha3(data);
    DipcAssert(dipc::getSignerAddress(sha3Data,sign).toString() == sender.get().toString());
    callTransfer(callerAddr, amount);
    DipcAssert(balance.get() -amount > 0);
    callTransfer(sender.get(), balance.get() - amount);
    *closed = true;
}

EXPORT void PaymentChannel::extend(uint64_t newExpiration) {
    u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
DipcAssert(!closed.get());
    DipcAssert(caller().toString() == sender.get().toString());
    DipcAssert(newExpiration > expiration.get());
    *expiration = newExpiration;
}

EXPORT void PaymentChannel::claimTimeout(){
    u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
DipcAssert(!closed.get());
    DipcAssert(dipc::timestamp() > expiration.get());
    callTransfer(sender.get(), balance.get());
    *closed = true;
}

CONSTANT void PaymentChannel::getPaymentChannelStatus(){

    
    
u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
}

2019-11-15_10:04:50.061538: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:911] swap src::PaymentChannel.cpp tmp::/var/folders/tt/8v4bb03x685c49jk_vkvr7s80000gp/T/ee0d8da8577e10g1g866/PaymentChannel.cpp
2019-11-15_10:04:50.061564: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:915] std::string(res.c_str()) + "/" + abidef_filename      /var/folders/tt/8v4bb03x685c49jk_vkvr7s80000gp/T//PaymentChannel.cpp

