2019-12-19_15:14:48.169033: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:1100] dipc-abi  verbose  true

2019-12-19_15:14:48.169945: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:1101] dipc-abi argv  start ....

2019-12-19_15:14:48.169963: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:1103]   /Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/bin/dipc-abigen
2019-12-19_15:14:48.169970: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:1103]   -extra-arg=-std=c++17
2019-12-19_15:14:48.169976: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:1103]   -extra-arg=--target=wasm32
2019-12-19_15:14:48.169982: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:1103]   -extra-arg=-w
2019-12-19_15:14:48.169990: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:1103]   -extra-arg=-I/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/testcontract/PortfolioManage
2019-12-19_15:14:48.169998: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:1103]   -extra-arg=-I/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/bin/../include/libcxx
2019-12-19_15:14:48.170006: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:1103]   -extra-arg=-I/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/bin/../include/libc
2019-12-19_15:14:48.170015: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:1103]   -extra-arg=-I/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/bin/../include/rt
2019-12-19_15:14:48.170024: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:1103]   -extra-arg=-I/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/bin/../include/native/softfloat/include
2019-12-19_15:14:48.170033: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:1103]   -extra-arg=-I/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/bin/../include
2019-12-19_15:14:48.170041: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:1103]   PortfolioManage.cpp
2019-12-19_15:14:48.170047: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:1103]   -abigen_output=./PortfolioManage.cpp.abi.json
2019-12-19_15:14:48.170053: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:1103]   -exports_output=/var/folders/tt/8v4bb03x685c49jk_vkvr7s80000gp/T//PortfolioManage.cpp.exports
2019-12-19_15:14:48.170059: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:1103]   -abidef_output=
2019-12-19_15:14:48.170068: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:1103]   -log_path=./
2019-12-19_15:14:48.170077: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:1103]   -log_level=debug
2019-12-19_15:14:48.170086: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:1103]   -verbose
2019-12-19_15:14:48.170096: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:1103]   --
2019-12-19_15:14:48.170117: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:1103]   -w
2019-12-19_15:14:48.170129: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:1105]   dipc-abi argv end 

2019-12-19_15:14:48.170138: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:1111] start run
2019-12-19_15:14:48.170155: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:99] start create_find_macro_factory
2019-12-19_15:14:48.862460: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/tools/abi/AbiMacro.cpp:149] get macro:PAYABLE
2019-12-19_15:14:48.862835: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/tools/abi/AbiMacro.cpp:67] file_name : /Users/konggan/workspace/chain/dipperin/github-dipc/dipc/testcontract/PortfolioManage/PortfolioManage.hpp

2019-12-19_15:14:48.862849: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/tools/abi/AbiMacro.cpp:68] Export macrostr:PAYABLE; long str :PAYABLE; longstr :PAYABLE void init();
    EXPORT void setChangeRate(uint64_t _changeRate);
    EXPORT void setUserCanWithdraw(bool _canWithdraw);
    PAYABLE void createPortfolio(char* _portfolioName, char* _portfolioDesc);
    PAYABLE void depositPortfolio(char* _portfolioName);
    PAYABLE void createOrder(char* _portfolioName, char* _orderId, uint16_t _orderType, char* _stockCode, uint64_t _stockPrice, uint64_t _stockAmount, uint64_t _endTime);
    EXPORT void dealOrder(char* _portfolioName, char* _orderId);
    EXPORT void revocationOrder(char* _portfolioName, char* _orderId);
    EXPORT void withdrawPortfolio(char* _portfolioName, uint64_t _withdrawBalance);
    EXPORT void withdrawPool(uint64_t _balance);
    PAYABLE void depositPool(uint64_t _depositValue);
    CONSTANT uint64_t queryTotalToken();
    CONSTANT uint64_t queryPortfolioBalance(char* _portfolioName);
    CONSTANT bool queryPortfolioNameIfUsed(char* _portfolioName);
    CONSTANT uint64_t queryChangeRate();
};
DIPC_EVENT(initEvent, const char* ,uint64_t);
DIPC_EVENT(tokenCount, const char* ,uint64_t, const char*, uint64_t);
DIPC_EVENT(portfolioInfo, const char*, const char* ,const char* , uint64_t);
DIPC_EVENT(createOrder, const char*, const char*, const char*, const char*, const char*, uint64_t);
DIPC_EVENT(depositPortfolio, const char*, const char*, const char*, uint64_t);
DIPC_EVENT(revocationPortfolio, const char*, const char*, const char*, const char*);
DIPC_EVENT(dealPortfolio, const char*, const char*, const char*, const char*);
DIPC_EVENT(ErrEvent, const char*, const char*);
2019-12-19_15:14:48.863214: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/tools/abi/AbiMacro.cpp:82] smatch[2].str : init(; action : init

2019-12-19_15:14:48.863240: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/tools/abi/AbiMacro.cpp:149] get macro:EXPORT
2019-12-19_15:14:48.863249: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/tools/abi/AbiMacro.cpp:67] file_name : /Users/konggan/workspace/chain/dipperin/github-dipc/dipc/testcontract/PortfolioManage/PortfolioManage.hpp

2019-12-19_15:14:48.863255: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/tools/abi/AbiMacro.cpp:68] Export macrostr:EXPORT; long str :EXPORT; longstr :EXPORT void setChangeRate(uint64_t _changeRate);
    EXPORT void setUserCanWithdraw(bool _canWithdraw);
    PAYABLE void createPortfolio(char* _portfolioName, char* _portfolioDesc);
    PAYABLE void depositPortfolio(char* _portfolioName);
    PAYABLE void createOrder(char* _portfolioName, char* _orderId, uint16_t _orderType, char* _stockCode, uint64_t _stockPrice, uint64_t _stockAmount, uint64_t _endTime);
    EXPORT void dealOrder(char* _portfolioName, char* _orderId);
    EXPORT void revocationOrder(char* _portfolioName, char* _orderId);
    EXPORT void withdrawPortfolio(char* _portfolioName, uint64_t _withdrawBalance);
    EXPORT void withdrawPool(uint64_t _balance);
    PAYABLE void depositPool(uint64_t _depositValue);
    CONSTANT uint64_t queryTotalToken();
    CONSTANT uint64_t queryPortfolioBalance(char* _portfolioName);
    CONSTANT bool queryPortfolioNameIfUsed(char* _portfolioName);
    CONSTANT uint64_t queryChangeRate();
};
DIPC_EVENT(initEvent, const char* ,uint64_t);
DIPC_EVENT(tokenCount, const char* ,uint64_t, const char*, uint64_t);
DIPC_EVENT(portfolioInfo, const char*, const char* ,const char* , uint64_t);
DIPC_EVENT(createOrder, const char*, const char*, const char*, const char*, const char*, uint64_t);
DIPC_EVENT(depositPortfolio, const char*, const char*, const char*, uint64_t);
DIPC_EVENT(revocationPortfolio, const char*, const char*, const char*, const char*);
DIPC_EVENT(dealPortfolio, const char*, const char*, const char*, const char*);
DIPC_EVENT(ErrEvent, const char*, const char*);
2019-12-19_15:14:48.863289: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/tools/abi/AbiMacro.cpp:82] smatch[2].str : setChangeRate(; action : setChangeRate

2019-12-19_15:14:48.863301: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/tools/abi/AbiMacro.cpp:149] get macro:EXPORT
2019-12-19_15:14:48.863308: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/tools/abi/AbiMacro.cpp:67] file_name : /Users/konggan/workspace/chain/dipperin/github-dipc/dipc/testcontract/PortfolioManage/PortfolioManage.hpp

2019-12-19_15:14:48.863314: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/tools/abi/AbiMacro.cpp:68] Export macrostr:EXPORT; long str :EXPORT; longstr :EXPORT void setUserCanWithdraw(bool _canWithdraw);
    PAYABLE void createPortfolio(char* _portfolioName, char* _portfolioDesc);
    PAYABLE void depositPortfolio(char* _portfolioName);
    PAYABLE void createOrder(char* _portfolioName, char* _orderId, uint16_t _orderType, char* _stockCode, uint64_t _stockPrice, uint64_t _stockAmount, uint64_t _endTime);
    EXPORT void dealOrder(char* _portfolioName, char* _orderId);
    EXPORT void revocationOrder(char* _portfolioName, char* _orderId);
    EXPORT void withdrawPortfolio(char* _portfolioName, uint64_t _withdrawBalance);
    EXPORT void withdrawPool(uint64_t _balance);
    PAYABLE void depositPool(uint64_t _depositValue);
    CONSTANT uint64_t queryTotalToken();
    CONSTANT uint64_t queryPortfolioBalance(char* _portfolioName);
    CONSTANT bool queryPortfolioNameIfUsed(char* _portfolioName);
    CONSTANT uint64_t queryChangeRate();
};
DIPC_EVENT(initEvent, const char* ,uint64_t);
DIPC_EVENT(tokenCount, const char* ,uint64_t, const char*, uint64_t);
DIPC_EVENT(portfolioInfo, const char*, const char* ,const char* , uint64_t);
DIPC_EVENT(createOrder, const char*, const char*, const char*, const char*, const char*, uint64_t);
DIPC_EVENT(depositPortfolio, const char*, const char*, const char*, uint64_t);
DIPC_EVENT(revocationPortfolio, const char*, const char*, const char*, const char*);
DIPC_EVENT(dealPortfolio, const char*, const char*, const char*, const char*);
DIPC_EVENT(ErrEvent, const char*, const char*);
2019-12-19_15:14:48.863337: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/tools/abi/AbiMacro.cpp:82] smatch[2].str : setUserCanWithdraw(; action : setUserCanWithdraw

2019-12-19_15:14:48.863348: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/tools/abi/AbiMacro.cpp:149] get macro:PAYABLE
2019-12-19_15:14:48.863354: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/tools/abi/AbiMacro.cpp:67] file_name : /Users/konggan/workspace/chain/dipperin/github-dipc/dipc/testcontract/PortfolioManage/PortfolioManage.hpp

2019-12-19_15:14:48.863359: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/tools/abi/AbiMacro.cpp:68] Export macrostr:PAYABLE; long str :PAYABLE; longstr :PAYABLE void createPortfolio(char* _portfolioName, char* _portfolioDesc);
    PAYABLE void depositPortfolio(char* _portfolioName);
    PAYABLE void createOrder(char* _portfolioName, char* _orderId, uint16_t _orderType, char* _stockCode, uint64_t _stockPrice, uint64_t _stockAmount, uint64_t _endTime);
    EXPORT void dealOrder(char* _portfolioName, char* _orderId);
    EXPORT void revocationOrder(char* _portfolioName, char* _orderId);
    EXPORT void withdrawPortfolio(char* _portfolioName, uint64_t _withdrawBalance);
    EXPORT void withdrawPool(uint64_t _balance);
    PAYABLE void depositPool(uint64_t _depositValue);
    CONSTANT uint64_t queryTotalToken();
    CONSTANT uint64_t queryPortfolioBalance(char* _portfolioName);
    CONSTANT bool queryPortfolioNameIfUsed(char* _portfolioName);
    CONSTANT uint64_t queryChangeRate();
};
DIPC_EVENT(initEvent, const char* ,uint64_t);
DIPC_EVENT(tokenCount, const char* ,uint64_t, const char*, uint64_t);
DIPC_EVENT(portfolioInfo, const char*, const char* ,const char* , uint64_t);
DIPC_EVENT(createOrder, const char*, const char*, const char*, const char*, const char*, uint64_t);
DIPC_EVENT(depositPortfolio, const char*, const char*, const char*, uint64_t);
DIPC_EVENT(revocationPortfolio, const char*, const char*, const char*, const char*);
DIPC_EVENT(dealPortfolio, const char*, const char*, const char*, const char*);
DIPC_EVENT(ErrEvent, const char*, const char*);
2019-12-19_15:14:48.863393: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/tools/abi/AbiMacro.cpp:82] smatch[2].str : createPortfolio(; action : createPortfolio

2019-12-19_15:14:48.863404: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/tools/abi/AbiMacro.cpp:149] get macro:PAYABLE
2019-12-19_15:14:48.863411: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/tools/abi/AbiMacro.cpp:67] file_name : /Users/konggan/workspace/chain/dipperin/github-dipc/dipc/testcontract/PortfolioManage/PortfolioManage.hpp

2019-12-19_15:14:48.863416: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/tools/abi/AbiMacro.cpp:68] Export macrostr:PAYABLE; long str :PAYABLE; longstr :PAYABLE void depositPortfolio(char* _portfolioName);
    PAYABLE void createOrder(char* _portfolioName, char* _orderId, uint16_t _orderType, char* _stockCode, uint64_t _stockPrice, uint64_t _stockAmount, uint64_t _endTime);
    EXPORT void dealOrder(char* _portfolioName, char* _orderId);
    EXPORT void revocationOrder(char* _portfolioName, char* _orderId);
    EXPORT void withdrawPortfolio(char* _portfolioName, uint64_t _withdrawBalance);
    EXPORT void withdrawPool(uint64_t _balance);
    PAYABLE void depositPool(uint64_t _depositValue);
    CONSTANT uint64_t queryTotalToken();
    CONSTANT uint64_t queryPortfolioBalance(char* _portfolioName);
    CONSTANT bool queryPortfolioNameIfUsed(char* _portfolioName);
    CONSTANT uint64_t queryChangeRate();
};
DIPC_EVENT(initEvent, const char* ,uint64_t);
DIPC_EVENT(tokenCount, const char* ,uint64_t, const char*, uint64_t);
DIPC_EVENT(portfolioInfo, const char*, const char* ,const char* , uint64_t);
DIPC_EVENT(createOrder, const char*, const char*, const char*, const char*, const char*, uint64_t);
DIPC_EVENT(depositPortfolio, const char*, const char*, const char*, uint64_t);
DIPC_EVENT(revocationPortfolio, const char*, const char*, const char*, const char*);
DIPC_EVENT(dealPortfolio, const char*, const char*, const char*, const char*);
DIPC_EVENT(ErrEvent, const char*, const char*);
2019-12-19_15:14:48.863439: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/tools/abi/AbiMacro.cpp:82] smatch[2].str : depositPortfolio(; action : depositPortfolio

2019-12-19_15:14:48.863449: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/tools/abi/AbiMacro.cpp:149] get macro:PAYABLE
2019-12-19_15:14:48.863455: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/tools/abi/AbiMacro.cpp:67] file_name : /Users/konggan/workspace/chain/dipperin/github-dipc/dipc/testcontract/PortfolioManage/PortfolioManage.hpp

2019-12-19_15:14:48.863460: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/tools/abi/AbiMacro.cpp:68] Export macrostr:PAYABLE; long str :PAYABLE; longstr :PAYABLE void createOrder(char* _portfolioName, char* _orderId, uint16_t _orderType, char* _stockCode, uint64_t _stockPrice, uint64_t _stockAmount, uint64_t _endTime);
    EXPORT void dealOrder(char* _portfolioName, char* _orderId);
    EXPORT void revocationOrder(char* _portfolioName, char* _orderId);
    EXPORT void withdrawPortfolio(char* _portfolioName, uint64_t _withdrawBalance);
    EXPORT void withdrawPool(uint64_t _balance);
    PAYABLE void depositPool(uint64_t _depositValue);
    CONSTANT uint64_t queryTotalToken();
    CONSTANT uint64_t queryPortfolioBalance(char* _portfolioName);
    CONSTANT bool queryPortfolioNameIfUsed(char* _portfolioName);
    CONSTANT uint64_t queryChangeRate();
};
DIPC_EVENT(initEvent, const char* ,uint64_t);
DIPC_EVENT(tokenCount, const char* ,uint64_t, const char*, uint64_t);
DIPC_EVENT(portfolioInfo, const char*, const char* ,const char* , uint64_t);
DIPC_EVENT(createOrder, const char*, const char*, const char*, const char*, const char*, uint64_t);
DIPC_EVENT(depositPortfolio, const char*, const char*, const char*, uint64_t);
DIPC_EVENT(revocationPortfolio, const char*, const char*, const char*, const char*);
DIPC_EVENT(dealPortfolio, const char*, const char*, const char*, const char*);
DIPC_EVENT(ErrEvent, const char*, const char*);
2019-12-19_15:14:48.863543: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/tools/abi/AbiMacro.cpp:82] smatch[2].str : createOrder(; action : createOrder

2019-12-19_15:14:48.863556: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/tools/abi/AbiMacro.cpp:149] get macro:EXPORT
2019-12-19_15:14:48.863562: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/tools/abi/AbiMacro.cpp:67] file_name : /Users/konggan/workspace/chain/dipperin/github-dipc/dipc/testcontract/PortfolioManage/PortfolioManage.hpp

2019-12-19_15:14:48.863567: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/tools/abi/AbiMacro.cpp:68] Export macrostr:EXPORT; long str :EXPORT; longstr :EXPORT void dealOrder(char* _portfolioName, char* _orderId);
    EXPORT void revocationOrder(char* _portfolioName, char* _orderId);
    EXPORT void withdrawPortfolio(char* _portfolioName, uint64_t _withdrawBalance);
    EXPORT void withdrawPool(uint64_t _balance);
    PAYABLE void depositPool(uint64_t _depositValue);
    CONSTANT uint64_t queryTotalToken();
    CONSTANT uint64_t queryPortfolioBalance(char* _portfolioName);
    CONSTANT bool queryPortfolioNameIfUsed(char* _portfolioName);
    CONSTANT uint64_t queryChangeRate();
};
DIPC_EVENT(initEvent, const char* ,uint64_t);
DIPC_EVENT(tokenCount, const char* ,uint64_t, const char*, uint64_t);
DIPC_EVENT(portfolioInfo, const char*, const char* ,const char* , uint64_t);
DIPC_EVENT(createOrder, const char*, const char*, const char*, const char*, const char*, uint64_t);
DIPC_EVENT(depositPortfolio, const char*, const char*, const char*, uint64_t);
DIPC_EVENT(revocationPortfolio, const char*, const char*, const char*, const char*);
DIPC_EVENT(dealPortfolio, const char*, const char*, const char*, const char*);
DIPC_EVENT(ErrEvent, const char*, const char*);
2019-12-19_15:14:48.863592: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/tools/abi/AbiMacro.cpp:82] smatch[2].str : dealOrder(; action : dealOrder

2019-12-19_15:14:48.863602: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/tools/abi/AbiMacro.cpp:149] get macro:EXPORT
2019-12-19_15:14:48.863608: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/tools/abi/AbiMacro.cpp:67] file_name : /Users/konggan/workspace/chain/dipperin/github-dipc/dipc/testcontract/PortfolioManage/PortfolioManage.hpp

2019-12-19_15:14:48.863613: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/tools/abi/AbiMacro.cpp:68] Export macrostr:EXPORT; long str :EXPORT; longstr :EXPORT void revocationOrder(char* _portfolioName, char* _orderId);
    EXPORT void withdrawPortfolio(char* _portfolioName, uint64_t _withdrawBalance);
    EXPORT void withdrawPool(uint64_t _balance);
    PAYABLE void depositPool(uint64_t _depositValue);
    CONSTANT uint64_t queryTotalToken();
    CONSTANT uint64_t queryPortfolioBalance(char* _portfolioName);
    CONSTANT bool queryPortfolioNameIfUsed(char* _portfolioName);
    CONSTANT uint64_t queryChangeRate();
};
DIPC_EVENT(initEvent, const char* ,uint64_t);
DIPC_EVENT(tokenCount, const char* ,uint64_t, const char*, uint64_t);
DIPC_EVENT(portfolioInfo, const char*, const char* ,const char* , uint64_t);
DIPC_EVENT(createOrder, const char*, const char*, const char*, const char*, const char*, uint64_t);
DIPC_EVENT(depositPortfolio, const char*, const char*, const char*, uint64_t);
DIPC_EVENT(revocationPortfolio, const char*, const char*, const char*, const char*);
DIPC_EVENT(dealPortfolio, const char*, const char*, const char*, const char*);
DIPC_EVENT(ErrEvent, const char*, const char*);
2019-12-19_15:14:48.863645: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/tools/abi/AbiMacro.cpp:82] smatch[2].str : revocationOrder(; action : revocationOrder

2019-12-19_15:14:48.863655: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/tools/abi/AbiMacro.cpp:149] get macro:EXPORT
2019-12-19_15:14:48.863661: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/tools/abi/AbiMacro.cpp:67] file_name : /Users/konggan/workspace/chain/dipperin/github-dipc/dipc/testcontract/PortfolioManage/PortfolioManage.hpp

2019-12-19_15:14:48.863667: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/tools/abi/AbiMacro.cpp:68] Export macrostr:EXPORT; long str :EXPORT; longstr :EXPORT void withdrawPortfolio(char* _portfolioName, uint64_t _withdrawBalance);
    EXPORT void withdrawPool(uint64_t _balance);
    PAYABLE void depositPool(uint64_t _depositValue);
    CONSTANT uint64_t queryTotalToken();
    CONSTANT uint64_t queryPortfolioBalance(char* _portfolioName);
    CONSTANT bool queryPortfolioNameIfUsed(char* _portfolioName);
    CONSTANT uint64_t queryChangeRate();
};
DIPC_EVENT(initEvent, const char* ,uint64_t);
DIPC_EVENT(tokenCount, const char* ,uint64_t, const char*, uint64_t);
DIPC_EVENT(portfolioInfo, const char*, const char* ,const char* , uint64_t);
DIPC_EVENT(createOrder, const char*, const char*, const char*, const char*, const char*, uint64_t);
DIPC_EVENT(depositPortfolio, const char*, const char*, const char*, uint64_t);
DIPC_EVENT(revocationPortfolio, const char*, const char*, const char*, const char*);
DIPC_EVENT(dealPortfolio, const char*, const char*, const char*, const char*);
DIPC_EVENT(ErrEvent, const char*, const char*);
2019-12-19_15:14:48.863697: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/tools/abi/AbiMacro.cpp:82] smatch[2].str : withdrawPortfolio(; action : withdrawPortfolio

2019-12-19_15:14:48.863707: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/tools/abi/AbiMacro.cpp:149] get macro:EXPORT
2019-12-19_15:14:48.863713: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/tools/abi/AbiMacro.cpp:67] file_name : /Users/konggan/workspace/chain/dipperin/github-dipc/dipc/testcontract/PortfolioManage/PortfolioManage.hpp

2019-12-19_15:14:48.863718: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/tools/abi/AbiMacro.cpp:68] Export macrostr:EXPORT; long str :EXPORT; longstr :EXPORT void withdrawPool(uint64_t _balance);
    PAYABLE void depositPool(uint64_t _depositValue);
    CONSTANT uint64_t queryTotalToken();
    CONSTANT uint64_t queryPortfolioBalance(char* _portfolioName);
    CONSTANT bool queryPortfolioNameIfUsed(char* _portfolioName);
    CONSTANT uint64_t queryChangeRate();
};
DIPC_EVENT(initEvent, const char* ,uint64_t);
DIPC_EVENT(tokenCount, const char* ,uint64_t, const char*, uint64_t);
DIPC_EVENT(portfolioInfo, const char*, const char* ,const char* , uint64_t);
DIPC_EVENT(createOrder, const char*, const char*, const char*, const char*, const char*, uint64_t);
DIPC_EVENT(depositPortfolio, const char*, const char*, const char*, uint64_t);
DIPC_EVENT(revocationPortfolio, const char*, const char*, const char*, const char*);
DIPC_EVENT(dealPortfolio, const char*, const char*, const char*, const char*);
DIPC_EVENT(ErrEvent, const char*, const char*);
2019-12-19_15:14:48.863739: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/tools/abi/AbiMacro.cpp:82] smatch[2].str : withdrawPool(; action : withdrawPool

2019-12-19_15:14:48.863748: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/tools/abi/AbiMacro.cpp:149] get macro:PAYABLE
2019-12-19_15:14:48.863754: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/tools/abi/AbiMacro.cpp:67] file_name : /Users/konggan/workspace/chain/dipperin/github-dipc/dipc/testcontract/PortfolioManage/PortfolioManage.hpp

2019-12-19_15:14:48.863760: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/tools/abi/AbiMacro.cpp:68] Export macrostr:PAYABLE; long str :PAYABLE; longstr :PAYABLE void depositPool(uint64_t _depositValue);
    CONSTANT uint64_t queryTotalToken();
    CONSTANT uint64_t queryPortfolioBalance(char* _portfolioName);
    CONSTANT bool queryPortfolioNameIfUsed(char* _portfolioName);
    CONSTANT uint64_t queryChangeRate();
};
DIPC_EVENT(initEvent, const char* ,uint64_t);
DIPC_EVENT(tokenCount, const char* ,uint64_t, const char*, uint64_t);
DIPC_EVENT(portfolioInfo, const char*, const char* ,const char* , uint64_t);
DIPC_EVENT(createOrder, const char*, const char*, const char*, const char*, const char*, uint64_t);
DIPC_EVENT(depositPortfolio, const char*, const char*, const char*, uint64_t);
DIPC_EVENT(revocationPortfolio, const char*, const char*, const char*, const char*);
DIPC_EVENT(dealPortfolio, const char*, const char*, const char*, const char*);
DIPC_EVENT(ErrEvent, const char*, const char*);
2019-12-19_15:14:48.863786: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/tools/abi/AbiMacro.cpp:82] smatch[2].str : depositPool(; action : depositPool

2019-12-19_15:14:48.863797: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/tools/abi/AbiMacro.cpp:149] get macro:CONSTANT
2019-12-19_15:14:48.863803: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/tools/abi/AbiMacro.cpp:67] file_name : /Users/konggan/workspace/chain/dipperin/github-dipc/dipc/testcontract/PortfolioManage/PortfolioManage.hpp

2019-12-19_15:14:48.863809: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/tools/abi/AbiMacro.cpp:68] Export macrostr:CONSTANT; long str :CONSTANT; longstr :CONSTANT uint64_t queryTotalToken();
    CONSTANT uint64_t queryPortfolioBalance(char* _portfolioName);
    CONSTANT bool queryPortfolioNameIfUsed(char* _portfolioName);
    CONSTANT uint64_t queryChangeRate();
};
DIPC_EVENT(initEvent, const char* ,uint64_t);
DIPC_EVENT(tokenCount, const char* ,uint64_t, const char*, uint64_t);
DIPC_EVENT(portfolioInfo, const char*, const char* ,const char* , uint64_t);
DIPC_EVENT(createOrder, const char*, const char*, const char*, const char*, const char*, uint64_t);
DIPC_EVENT(depositPortfolio, const char*, const char*, const char*, uint64_t);
DIPC_EVENT(revocationPortfolio, const char*, const char*, const char*, const char*);
DIPC_EVENT(dealPortfolio, const char*, const char*, const char*, const char*);
DIPC_EVENT(ErrEvent, const char*, const char*);
2019-12-19_15:14:48.863826: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/tools/abi/AbiMacro.cpp:82] smatch[2].str : queryTotalToken(; action : queryTotalToken

2019-12-19_15:14:48.863836: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/tools/abi/AbiMacro.cpp:149] get macro:CONSTANT
2019-12-19_15:14:48.863841: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/tools/abi/AbiMacro.cpp:67] file_name : /Users/konggan/workspace/chain/dipperin/github-dipc/dipc/testcontract/PortfolioManage/PortfolioManage.hpp

2019-12-19_15:14:48.863847: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/tools/abi/AbiMacro.cpp:68] Export macrostr:CONSTANT; long str :CONSTANT; longstr :CONSTANT uint64_t queryPortfolioBalance(char* _portfolioName);
    CONSTANT bool queryPortfolioNameIfUsed(char* _portfolioName);
    CONSTANT uint64_t queryChangeRate();
};
DIPC_EVENT(initEvent, const char* ,uint64_t);
DIPC_EVENT(tokenCount, const char* ,uint64_t, const char*, uint64_t);
DIPC_EVENT(portfolioInfo, const char*, const char* ,const char* , uint64_t);
DIPC_EVENT(createOrder, const char*, const char*, const char*, const char*, const char*, uint64_t);
DIPC_EVENT(depositPortfolio, const char*, const char*, const char*, uint64_t);
DIPC_EVENT(revocationPortfolio, const char*, const char*, const char*, const char*);
DIPC_EVENT(dealPortfolio, const char*, const char*, const char*, const char*);
DIPC_EVENT(ErrEvent, const char*, const char*);
2019-12-19_15:14:48.863871: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/tools/abi/AbiMacro.cpp:82] smatch[2].str : queryPortfolioBalance(; action : queryPortfolioBalance

2019-12-19_15:14:48.863886: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/tools/abi/AbiMacro.cpp:149] get macro:CONSTANT
2019-12-19_15:14:48.863892: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/tools/abi/AbiMacro.cpp:67] file_name : /Users/konggan/workspace/chain/dipperin/github-dipc/dipc/testcontract/PortfolioManage/PortfolioManage.hpp

2019-12-19_15:14:48.863897: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/tools/abi/AbiMacro.cpp:68] Export macrostr:CONSTANT; long str :CONSTANT; longstr :CONSTANT bool queryPortfolioNameIfUsed(char* _portfolioName);
    CONSTANT uint64_t queryChangeRate();
};
DIPC_EVENT(initEvent, const char* ,uint64_t);
DIPC_EVENT(tokenCount, const char* ,uint64_t, const char*, uint64_t);
DIPC_EVENT(portfolioInfo, const char*, const char* ,const char* , uint64_t);
DIPC_EVENT(createOrder, const char*, const char*, const char*, const char*, const char*, uint64_t);
DIPC_EVENT(depositPortfolio, const char*, const char*, const char*, uint64_t);
DIPC_EVENT(revocationPortfolio, const char*, const char*, const char*, const char*);
DIPC_EVENT(dealPortfolio, const char*, const char*, const char*, const char*);
DIPC_EVENT(ErrEvent, const char*, const char*);
2019-12-19_15:14:48.863922: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/tools/abi/AbiMacro.cpp:82] smatch[2].str : queryPortfolioNameIfUsed(; action : queryPortfolioNameIfUsed

2019-12-19_15:14:48.863932: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/tools/abi/AbiMacro.cpp:149] get macro:CONSTANT
2019-12-19_15:14:48.863938: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/tools/abi/AbiMacro.cpp:67] file_name : /Users/konggan/workspace/chain/dipperin/github-dipc/dipc/testcontract/PortfolioManage/PortfolioManage.hpp

2019-12-19_15:14:48.863943: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/tools/abi/AbiMacro.cpp:68] Export macrostr:CONSTANT; long str :CONSTANT; longstr :CONSTANT uint64_t queryChangeRate();
};
DIPC_EVENT(initEvent, const char* ,uint64_t);
DIPC_EVENT(tokenCount, const char* ,uint64_t, const char*, uint64_t);
DIPC_EVENT(portfolioInfo, const char*, const char* ,const char* , uint64_t);
DIPC_EVENT(createOrder, const char*, const char*, const char*, const char*, const char*, uint64_t);
DIPC_EVENT(depositPortfolio, const char*, const char*, const char*, uint64_t);
DIPC_EVENT(revocationPortfolio, const char*, const char*, const char*, const char*);
DIPC_EVENT(dealPortfolio, const char*, const char*, const char*, const char*);
DIPC_EVENT(ErrEvent, const char*, const char*);
2019-12-19_15:14:48.863961: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/tools/abi/AbiMacro.cpp:82] smatch[2].str : queryChangeRate(; action : queryChangeRate

2019-12-19_15:14:48.863973: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/tools/abi/AbiMacro.cpp:143] get EVENT:DIPC_EVENT
2019-12-19_15:14:48.864114: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/tools/abi/AbiMacro.cpp:143] get EVENT:DIPC_EVENT
2019-12-19_15:14:48.864304: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/tools/abi/AbiMacro.cpp:143] get EVENT:DIPC_EVENT
2019-12-19_15:14:48.864497: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/tools/abi/AbiMacro.cpp:143] get EVENT:DIPC_EVENT
2019-12-19_15:14:48.864778: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/tools/abi/AbiMacro.cpp:143] get EVENT:DIPC_EVENT
2019-12-19_15:14:48.864967: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/tools/abi/AbiMacro.cpp:143] get EVENT:DIPC_EVENT
2019-12-19_15:14:48.865172: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/tools/abi/AbiMacro.cpp:143] get EVENT:DIPC_EVENT
2019-12-19_15:14:48.865367: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/tools/abi/AbiMacro.cpp:143] get EVENT:DIPC_EVENT
2019-12-19_15:14:48.865489: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/tools/abi/AbiMacro.cpp:149] get macro:PAYABLE
2019-12-19_15:14:48.865504: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/tools/abi/AbiMacro.cpp:67] file_name : /Users/konggan/workspace/chain/dipperin/github-dipc/dipc/testcontract/PortfolioManage/PortfolioManage.cpp

2019-12-19_15:14:48.865511: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/tools/abi/AbiMacro.cpp:68] Export macrostr:PAYABLE; long str :PAYABLE; longstr :PAYABLE void PortfolioManage::init(){
        *owner = caller().toString();
        *changeRate = 10000;
        *userCanWithdraw = false;
        uint64_t tokenBalance = getTotalBalance();
        //DipcAssert(depositValue == callValue());
        *ownerTotalToken = tokenBalance;
        *totalToken = ownerTotalToken.get();
        //print("tokenBalance");
        //print(tokenBalance);
        DIPC_EMIT_EVENT(initEvent, "ownerTotalToken" ,tokenBalance);
    }
    
     /**
     * @brief set the change rate between DIP and current token
     * @param _changeRate: the change rate between DIP and current token
     * @return void
     */
    EXPORT void PortfolioManage::setChangeRate(uint64_t _changeRate){
        isOwner();
        *changeRate = _changeRate;
    }
     /**
     * @brief set whether the user can withdraw token by himself 
     * @param _canWithdraw: true or false -- whether the user can withdraw token by himself 
     * @return void
     */
    EXPORT void PortfolioManage::setUserCanWithdraw(bool _canWithdraw){
        isOwner();
        *userCanWithdraw = _canWithdraw;
    }

    /**
     * @brief create a portfolio
     * @param _portfolioName: the name of current portfolio
     * @param _portfolioDesc: the description of current portfolio
     * @return void
     */
    PAYABLE void PortfolioManage::createPortfolio(char* _portfolioName, char* _portfolioDesc){
        if(portfolioStorge.get()[_portfolioName] != ""){
            DIPC_EMIT_EVENT(ErrEvent, "Current portfolio exist: ", _portfolioName);
            return;
        } 
        std::string callerAddr = caller().toString();
        uint64_t tokenBalance = getTotalBalance();
        // changeU256ToUint64WithChangeRate(callValue(), changeRate.get());
        PortfolioInfo info(_portfolioName, _portfolioDesc, &callerAddr[0]);
        std::string portfolioStr = info.toJson();
        //print("createPortfolio");
        //print(portfolioStr);
        //print(info.getPortfolioResult());

        (*portfolioStorge)[_portfolioName] = portfolioStr;
        DipcAssert(totalToken.get() + tokenBalance > totalToken);
        (*portfolioBalance)[_portfolioName] = tokenBalance;
        *totalToken = totalToken.get() + tokenBalance; 
        //u256 callV = callValue();
        DIPC_EMIT_EVENT(portfolioInfo, _portfolioName, &portfolioStr[0], "portfolioBalance", tokenBalance);
    }

    /**
     * @brief deposit a portfolio
     * @param _portfolioName: the name of the portfolio  want to deposit
     * @return void
     */
    PAYABLE void PortfolioManage::depositPortfolio(char* _portfolioName){
        uint64_t tokenBalance = getTotalBalance();
        //uint64_t tokenBalance = changeU256ToUint64WithChangeRate(callValue(), changeRate.get());
        uint64_t currentBalance = portfolioBalance.get()[_portfolioName];
        uint64_t finalBalance  = currentBalance + tokenBalance;
        DipcAssert(totalToken.get() + tokenBalance > totalToken);
        DipcAssert(finalBalance > currentBalance);
        (*portfolioBalance)[_portfolioName] = finalBalance;
        *totalToken = totalToken.get() + finalBalance; 
        DIPC_EMIT_EVENT(depositPortfolio, "portfolioName", _portfolioName, "portfolioBalance", finalBalance);
    }
    /**
     * @brief create a order
     * @param _portfolioName: the name of the portfolio  current order blong to   
     * @param _orderId: orderId used by application
     * @param _orderType
     * @param _stockCode
     * @param _stockPrice: unit is token
     * @param _stockAmount: uint is one share 
     * @param _endTime: nanoseconds the order expire
     * @return void
     */
    PAYABLE void PortfolioManage::createOrder(char* _portfolioName, char* _orderId, uint16_t _orderType, char* _stockCode, uint64_t _stockPrice, uint64_t _stockAmount, uint64_t _endTime){
        uint64_t tokenBalance = getTotalBalance();
        DIPC_EMIT_EVENT(createOrder, "portfolioName", _portfolioName, "OrderInfo", "ignore", "tokenBalance", tokenBalance);
        uint64_t spent = 0;
        if(_orderType == 1){
            spent = _stockPrice * _stockAmount;
            DipcAssert((portfolioBalance.get()[_portfolioName] + tokenBalance) > spent);
        }
        struct Order order{_orderId, _orderType, _stockCode, _stockPrice, _stockAmount, _endTime, 0};
        std::string pInfo = portfolioStorge.get()[_portfolioName];
        //print("identity start");
        //print(pInfo);
        //print(tokenBalance);
        if(pInfo == "") {
            DIPC_EMIT_EVENT(ErrEvent, "Current portfolio  doesn't exist: ", _portfolioName);
            return;
        }
        PortfolioInfo info;
        info.parseJson(pInfo);
        if(info.getOrder(_orderId).orderId != ""){
            DIPC_EMIT_EVENT(ErrEvent, "Current order exist: ", _orderId);
            return;
        }
        info.addOrder(order);
        pInfo = info.toJson();

        uint64_t currentBalance = portfolioBalance.get()[_portfolioName] ;
        uint64_t finalBalance = currentBalance + tokenBalance - spent;
        DipcAssert(totalToken.get() + tokenBalance > totalToken);
        //DipcAssert(finalBalance > currentBalance);
        DipcAssert(ownerTotalToken.get() < ownerTotalToken.get() + spent);
        (*portfolioStorge)[_portfolioName] = &pInfo[0];
        //print("identity ten");
        //print(pInfo);
        //print(finalBalance);
        //print(spent);


        (*portfolioBalance)[_portfolioName] = finalBalance;
        *totalToken = totalToken.get() + finalBalance; 
        *ownerTotalToken = ownerTotalToken.get() + spent;
        DIPC_EMIT_EVENT(createOrder, "portfolioName", _portfolioName, "OrderInfo", &order.toJson()[0], "portfolioBalance", finalBalance);
    }

    /**
     * @brief 
     * 
     * 
     * 
     */
    EXPORT void PortfolioManage::dealOrder(char* _portfolioName, char* _orderId){
        isOwner();
        std::string pInfo = portfolioStorge.get()[_portfolioName];
        //print("dealOrder  pInfo");
        //print(pInfo);
        PortfolioInfo info;
        info.parseJson(pInfo);
        //print("dealOrder  start");

        //print(info.toJson());
         Order ord = info.getOrder(_orderId);
         //print("dealOrder");
         //print(ord.toJson());
        if(ord.orderId != "" && ord.orderStatus == 0){
            //DipcAssert(info.getOwnerAddress() == caller().toString());
            uint64_t timenow = dipc::timestamp();
            if(ord.endTime > timenow){
                ord.orderStatus = 1;
            }else {
                ord.orderStatus = 3;
            }
        } else {
          // print("dealOrder  return ");

            return;
        }
        // print("dealOrder  one ");

        uint64_t sellValue = 0;
        if(ord.orderType == 0){
            sellValue = ord.stockAmount * ord.stockPrice;
        }
        uint64_t currentBalance =  portfolioBalance.get()[_portfolioName];
        // print("dealOrder  two");

        DipcAssert(currentBalance + sellValue >= currentBalance);
        DipcAssert((ownerTotalToken.get() - sellValue) <= ownerTotalToken.get());
        


        (*portfolioBalance)[_portfolioName] = currentBalance + sellValue;
        *ownerTotalToken = ownerTotalToken.get() - sellValue;
        (*portfolioStorge)[_portfolioName] = &info.toJson()[0];
        //print("dealOrder  three");
        //print(info.toJson());
        //print(currentBalance + sellValue);
        //print(ownerTotalToken.get());

        DIPC_EMIT_EVENT(dealPortfolio, "orderId", _orderId, "orderInfo", &ord.toJson()[0]);
    }
    /**
     * @brief 
     * 
     * 
     * 
     */
    EXPORT void PortfolioManage::revocationOrder(char* _portfolioName, char* _orderId){
        std::string pInfo = portfolioStorge.get()[_portfolioName];
        //print("pInfo");
        //print(pInfo);
        PortfolioInfo info;
        info.parseJson(pInfo);
        Order ord = info.getOrder(_orderId);
        //print("ordInfo");
        //print(ord.toJson());
        if(ord.orderId != "" && ord.orderStatus == 0){
            std::string callerStr = caller().toString();
            //print("revocationOrder start");
            //print(info.getOwnerAddress());
            //print(callerStr);
            DipcAssert(info.getOwnerAddress() == caller().toString());
            //print("revocationOrder end");

            uint64_t timenow = dipc::timestamp();
            if(ord.endTime > timenow){
                ord.orderStatus = 2;
            }else {
                ord.orderStatus = 3;
            }
        } else {
            return;
        }
        uint64_t lockToken = 0;
        if(ord.orderType == 1){
            lockToken = ord.stockPrice * ord.stockAmount;
        }
        uint64_t currentBalance =  portfolioBalance.get()[_portfolioName];
        //print("revocationOrder can see");
        //print(currentBalance);
        // print(ownerTotalToken.get());
        // print(lockToken);

        DipcAssert(currentBalance + lockToken >= currentBalance);
        DipcAssert(ownerTotalToken.get() - lockToken <= ownerTotalToken.get());

        //print("revocationOrder can see  two");
        (*portfolioBalance)[_portfolioName] = currentBalance + lockToken;
        *ownerTotalToken = ownerTotalToken.get() - lockToken;
        (*portfolioStorge)[_portfolioName] = &info.toJson()[0];
        DIPC_EMIT_EVENT(revocationPortfolio, "orderId", _orderId, "orderInfo", &ord.toJson()[0]);
    }
    /**
     * @brief 
     * @param _withdrawBalance:  the unit is token
     * 
     * 
     */
    EXPORT void PortfolioManage::withdrawPortfolio(char* _portfolioName, uint64_t _withdrawBalance){
         if(!userCanWithdraw.get()){
             return;
         }
         uint64_t currentBalance =  portfolioBalance.get()[_portfolioName];
         DipcAssert(currentBalance - _withdrawBalance < currentBalance);
         auto coinBalance = changeUint64ToU256WithChangeRate(currentBalance, changeRate.get());
         (*portfolioBalance)[_portfolioName] = currentBalance - _withdrawBalance;
         callTransfer(caller(), coinBalance);
    }
    /**
     * @brief owner deposit to the contract address to get more token
     * @param _depositValue: the value num transfer to the contract address
     */
    EXPORT void PortfolioManage::withdrawPool(uint64_t _balance){
        isOwner();
        Address ownerAddr = Address(owner.get()); 
        callTransfer(ownerAddr, _balance);
        *ownerTotalToken = ownerTotalToken.get() - _balance * changeRate.get();
        *totalToken = totalToken.get() - _balance * changeRate.get();
        DIPC_EMIT_EVENT(tokenCount, "ownerTotalToken", ownerTotalToken.get(), "totalToken", totalToken.get());
    }
    /**
     * @brief owner deposit to the contract address to get more token
     * @param _depositValue: the value num transfer to the contract address
     */
    PAYABLE void PortfolioManage::depositPool(uint64_t _depositValue){
        isOwner();
        //DipcAssert(_depositValue == dipc::callValue());
        uint64_t tokenBalance = changeU256ToUint64WithChangeRate(callValue(), changeRate.get()); 
        *ownerTotalToken = ownerTotalToken.get() + tokenBalance;
        *totalToken = totalToken.get() + tokenBalance;
        DIPC_EMIT_EVENT(tokenCount, "ownerTotalToken", ownerTotalToken.get(), "totalToken", totalToken.get());
    }
     /**
     * @brief query the total token in the contract
     * @return the total token int the contract
     */
    CONSTANT uint64_t PortfolioManage::queryTotalToken(){
        return totalToken.get();
    }

     /**
     * @brief query the token balance of the portfolio
     * @param _portfolioName : the portfolio name
     * @return the balance of the portfolio, the unit is token
     */
    CONSTANT uint64_t PortfolioManage::queryPortfolioBalance(char* _portfolioName){
        return portfolioBalance.get()[_portfolioName];
    }

    /**
     * @brief query the portfolio name  whether  used or not 
     * @return true is used, false is not used
     */
    CONSTANT bool PortfolioManage::queryPortfolioNameIfUsed(char* _portfolioName){
        if(portfolioStorge.get()[_portfolioName] != ""){
            return true;
        } 
        return false;
    }

    /**
     * @brief query the change rate between DIP and current token
     * @return the change rate between DIP and current token
     */
    CONSTANT uint64_t PortfolioManage::queryChangeRate(){
        return changeRate.get();
    }
2019-12-19_15:14:48.865587: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/tools/abi/AbiMacro.cpp:82] smatch[2].str : PortfolioManage::init(; action : PortfolioManage::init

2019-12-19_15:14:48.865594: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/tools/abi/AbiMacro.cpp:131] Export macrostr:PAYABLE  contract:void  actions_str:init

2019-12-19_15:14:48.865617: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/tools/abi/AbiMacro.cpp:149] get macro:EXPORT
2019-12-19_15:14:48.865625: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/tools/abi/AbiMacro.cpp:67] file_name : /Users/konggan/workspace/chain/dipperin/github-dipc/dipc/testcontract/PortfolioManage/PortfolioManage.cpp

2019-12-19_15:14:48.865630: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/tools/abi/AbiMacro.cpp:68] Export macrostr:EXPORT; long str :EXPORT; longstr :EXPORT void PortfolioManage::setChangeRate(uint64_t _changeRate){
        isOwner();
        *changeRate = _changeRate;
    }
     /**
     * @brief set whether the user can withdraw token by himself 
     * @param _canWithdraw: true or false -- whether the user can withdraw token by himself 
     * @return void
     */
    EXPORT void PortfolioManage::setUserCanWithdraw(bool _canWithdraw){
        isOwner();
        *userCanWithdraw = _canWithdraw;
    }

    /**
     * @brief create a portfolio
     * @param _portfolioName: the name of current portfolio
     * @param _portfolioDesc: the description of current portfolio
     * @return void
     */
    PAYABLE void PortfolioManage::createPortfolio(char* _portfolioName, char* _portfolioDesc){
        if(portfolioStorge.get()[_portfolioName] != ""){
            DIPC_EMIT_EVENT(ErrEvent, "Current portfolio exist: ", _portfolioName);
            return;
        } 
        std::string callerAddr = caller().toString();
        uint64_t tokenBalance = getTotalBalance();
        // changeU256ToUint64WithChangeRate(callValue(), changeRate.get());
        PortfolioInfo info(_portfolioName, _portfolioDesc, &callerAddr[0]);
        std::string portfolioStr = info.toJson();
        //print("createPortfolio");
        //print(portfolioStr);
        //print(info.getPortfolioResult());

        (*portfolioStorge)[_portfolioName] = portfolioStr;
        DipcAssert(totalToken.get() + tokenBalance > totalToken);
        (*portfolioBalance)[_portfolioName] = tokenBalance;
        *totalToken = totalToken.get() + tokenBalance; 
        //u256 callV = callValue();
        DIPC_EMIT_EVENT(portfolioInfo, _portfolioName, &portfolioStr[0], "portfolioBalance", tokenBalance);
    }

    /**
     * @brief deposit a portfolio
     * @param _portfolioName: the name of the portfolio  want to deposit
     * @return void
     */
    PAYABLE void PortfolioManage::depositPortfolio(char* _portfolioName){
        uint64_t tokenBalance = getTotalBalance();
        //uint64_t tokenBalance = changeU256ToUint64WithChangeRate(callValue(), changeRate.get());
        uint64_t currentBalance = portfolioBalance.get()[_portfolioName];
        uint64_t finalBalance  = currentBalance + tokenBalance;
        DipcAssert(totalToken.get() + tokenBalance > totalToken);
        DipcAssert(finalBalance > currentBalance);
        (*portfolioBalance)[_portfolioName] = finalBalance;
        *totalToken = totalToken.get() + finalBalance; 
        DIPC_EMIT_EVENT(depositPortfolio, "portfolioName", _portfolioName, "portfolioBalance", finalBalance);
    }
    /**
     * @brief create a order
     * @param _portfolioName: the name of the portfolio  current order blong to   
     * @param _orderId: orderId used by application
     * @param _orderType
     * @param _stockCode
     * @param _stockPrice: unit is token
     * @param _stockAmount: uint is one share 
     * @param _endTime: nanoseconds the order expire
     * @return void
     */
    PAYABLE void PortfolioManage::createOrder(char* _portfolioName, char* _orderId, uint16_t _orderType, char* _stockCode, uint64_t _stockPrice, uint64_t _stockAmount, uint64_t _endTime){
        uint64_t tokenBalance = getTotalBalance();
        DIPC_EMIT_EVENT(createOrder, "portfolioName", _portfolioName, "OrderInfo", "ignore", "tokenBalance", tokenBalance);
        uint64_t spent = 0;
        if(_orderType == 1){
            spent = _stockPrice * _stockAmount;
            DipcAssert((portfolioBalance.get()[_portfolioName] + tokenBalance) > spent);
        }
        struct Order order{_orderId, _orderType, _stockCode, _stockPrice, _stockAmount, _endTime, 0};
        std::string pInfo = portfolioStorge.get()[_portfolioName];
        //print("identity start");
        //print(pInfo);
        //print(tokenBalance);
        if(pInfo == "") {
            DIPC_EMIT_EVENT(ErrEvent, "Current portfolio  doesn't exist: ", _portfolioName);
            return;
        }
        PortfolioInfo info;
        info.parseJson(pInfo);
        if(info.getOrder(_orderId).orderId != ""){
            DIPC_EMIT_EVENT(ErrEvent, "Current order exist: ", _orderId);
            return;
        }
        info.addOrder(order);
        pInfo = info.toJson();

        uint64_t currentBalance = portfolioBalance.get()[_portfolioName] ;
        uint64_t finalBalance = currentBalance + tokenBalance - spent;
        DipcAssert(totalToken.get() + tokenBalance > totalToken);
        //DipcAssert(finalBalance > currentBalance);
        DipcAssert(ownerTotalToken.get() < ownerTotalToken.get() + spent);
        (*portfolioStorge)[_portfolioName] = &pInfo[0];
        //print("identity ten");
        //print(pInfo);
        //print(finalBalance);
        //print(spent);


        (*portfolioBalance)[_portfolioName] = finalBalance;
        *totalToken = totalToken.get() + finalBalance; 
        *ownerTotalToken = ownerTotalToken.get() + spent;
        DIPC_EMIT_EVENT(createOrder, "portfolioName", _portfolioName, "OrderInfo", &order.toJson()[0], "portfolioBalance", finalBalance);
    }

    /**
     * @brief 
     * 
     * 
     * 
     */
    EXPORT void PortfolioManage::dealOrder(char* _portfolioName, char* _orderId){
        isOwner();
        std::string pInfo = portfolioStorge.get()[_portfolioName];
        //print("dealOrder  pInfo");
        //print(pInfo);
        PortfolioInfo info;
        info.parseJson(pInfo);
        //print("dealOrder  start");

        //print(info.toJson());
         Order ord = info.getOrder(_orderId);
         //print("dealOrder");
         //print(ord.toJson());
        if(ord.orderId != "" && ord.orderStatus == 0){
            //DipcAssert(info.getOwnerAddress() == caller().toString());
            uint64_t timenow = dipc::timestamp();
            if(ord.endTime > timenow){
                ord.orderStatus = 1;
            }else {
                ord.orderStatus = 3;
            }
        } else {
          // print("dealOrder  return ");

            return;
        }
        // print("dealOrder  one ");

        uint64_t sellValue = 0;
        if(ord.orderType == 0){
            sellValue = ord.stockAmount * ord.stockPrice;
        }
        uint64_t currentBalance =  portfolioBalance.get()[_portfolioName];
        // print("dealOrder  two");

        DipcAssert(currentBalance + sellValue >= currentBalance);
        DipcAssert((ownerTotalToken.get() - sellValue) <= ownerTotalToken.get());
        


        (*portfolioBalance)[_portfolioName] = currentBalance + sellValue;
        *ownerTotalToken = ownerTotalToken.get() - sellValue;
        (*portfolioStorge)[_portfolioName] = &info.toJson()[0];
        //print("dealOrder  three");
        //print(info.toJson());
        //print(currentBalance + sellValue);
        //print(ownerTotalToken.get());

        DIPC_EMIT_EVENT(dealPortfolio, "orderId", _orderId, "orderInfo", &ord.toJson()[0]);
    }
    /**
     * @brief 
     * 
     * 
     * 
     */
    EXPORT void PortfolioManage::revocationOrder(char* _portfolioName, char* _orderId){
        std::string pInfo = portfolioStorge.get()[_portfolioName];
        //print("pInfo");
        //print(pInfo);
        PortfolioInfo info;
        info.parseJson(pInfo);
        Order ord = info.getOrder(_orderId);
        //print("ordInfo");
        //print(ord.toJson());
        if(ord.orderId != "" && ord.orderStatus == 0){
            std::string callerStr = caller().toString();
            //print("revocationOrder start");
            //print(info.getOwnerAddress());
            //print(callerStr);
            DipcAssert(info.getOwnerAddress() == caller().toString());
            //print("revocationOrder end");

            uint64_t timenow = dipc::timestamp();
            if(ord.endTime > timenow){
                ord.orderStatus = 2;
            }else {
                ord.orderStatus = 3;
            }
        } else {
            return;
        }
        uint64_t lockToken = 0;
        if(ord.orderType == 1){
            lockToken = ord.stockPrice * ord.stockAmount;
        }
        uint64_t currentBalance =  portfolioBalance.get()[_portfolioName];
        //print("revocationOrder can see");
        //print(currentBalance);
        // print(ownerTotalToken.get());
        // print(lockToken);

        DipcAssert(currentBalance + lockToken >= currentBalance);
        DipcAssert(ownerTotalToken.get() - lockToken <= ownerTotalToken.get());

        //print("revocationOrder can see  two");
        (*portfolioBalance)[_portfolioName] = currentBalance + lockToken;
        *ownerTotalToken = ownerTotalToken.get() - lockToken;
        (*portfolioStorge)[_portfolioName] = &info.toJson()[0];
        DIPC_EMIT_EVENT(revocationPortfolio, "orderId", _orderId, "orderInfo", &ord.toJson()[0]);
    }
    /**
     * @brief 
     * @param _withdrawBalance:  the unit is token
     * 
     * 
     */
    EXPORT void PortfolioManage::withdrawPortfolio(char* _portfolioName, uint64_t _withdrawBalance){
         if(!userCanWithdraw.get()){
             return;
         }
         uint64_t currentBalance =  portfolioBalance.get()[_portfolioName];
         DipcAssert(currentBalance - _withdrawBalance < currentBalance);
         auto coinBalance = changeUint64ToU256WithChangeRate(currentBalance, changeRate.get());
         (*portfolioBalance)[_portfolioName] = currentBalance - _withdrawBalance;
         callTransfer(caller(), coinBalance);
    }
    /**
     * @brief owner deposit to the contract address to get more token
     * @param _depositValue: the value num transfer to the contract address
     */
    EXPORT void PortfolioManage::withdrawPool(uint64_t _balance){
        isOwner();
        Address ownerAddr = Address(owner.get()); 
        callTransfer(ownerAddr, _balance);
        *ownerTotalToken = ownerTotalToken.get() - _balance * changeRate.get();
        *totalToken = totalToken.get() - _balance * changeRate.get();
        DIPC_EMIT_EVENT(tokenCount, "ownerTotalToken", ownerTotalToken.get(), "totalToken", totalToken.get());
    }
    /**
     * @brief owner deposit to the contract address to get more token
     * @param _depositValue: the value num transfer to the contract address
     */
    PAYABLE void PortfolioManage::depositPool(uint64_t _depositValue){
        isOwner();
        //DipcAssert(_depositValue == dipc::callValue());
        uint64_t tokenBalance = changeU256ToUint64WithChangeRate(callValue(), changeRate.get()); 
        *ownerTotalToken = ownerTotalToken.get() + tokenBalance;
        *totalToken = totalToken.get() + tokenBalance;
        DIPC_EMIT_EVENT(tokenCount, "ownerTotalToken", ownerTotalToken.get(), "totalToken", totalToken.get());
    }
     /**
     * @brief query the total token in the contract
     * @return the total token int the contract
     */
    CONSTANT uint64_t PortfolioManage::queryTotalToken(){
        return totalToken.get();
    }

     /**
     * @brief query the token balance of the portfolio
     * @param _portfolioName : the portfolio name
     * @return the balance of the portfolio, the unit is token
     */
    CONSTANT uint64_t PortfolioManage::queryPortfolioBalance(char* _portfolioName){
        return portfolioBalance.get()[_portfolioName];
    }

    /**
     * @brief query the portfolio name  whether  used or not 
     * @return true is used, false is not used
     */
    CONSTANT bool PortfolioManage::queryPortfolioNameIfUsed(char* _portfolioName){
        if(portfolioStorge.get()[_portfolioName] != ""){
            return true;
        } 
        return false;
    }

    /**
     * @brief query the change rate between DIP and current token
     * @return the change rate between DIP and current token
     */
    CONSTANT uint64_t PortfolioManage::queryChangeRate(){
        return changeRate.get();
    }
2019-12-19_15:14:48.865669: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/tools/abi/AbiMacro.cpp:82] smatch[2].str : PortfolioManage::setChangeRate(; action : PortfolioManage::setChangeRate

2019-12-19_15:14:48.865677: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/tools/abi/AbiMacro.cpp:131] Export macrostr:EXPORT  contract:void  actions_str:setChangeRate

2019-12-19_15:14:48.865688: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/tools/abi/AbiMacro.cpp:149] get macro:EXPORT
2019-12-19_15:14:48.865694: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/tools/abi/AbiMacro.cpp:67] file_name : /Users/konggan/workspace/chain/dipperin/github-dipc/dipc/testcontract/PortfolioManage/PortfolioManage.cpp

2019-12-19_15:14:48.865700: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/tools/abi/AbiMacro.cpp:68] Export macrostr:EXPORT; long str :EXPORT; longstr :EXPORT void PortfolioManage::setUserCanWithdraw(bool _canWithdraw){
        isOwner();
        *userCanWithdraw = _canWithdraw;
    }

    /**
     * @brief create a portfolio
     * @param _portfolioName: the name of current portfolio
     * @param _portfolioDesc: the description of current portfolio
     * @return void
     */
    PAYABLE void PortfolioManage::createPortfolio(char* _portfolioName, char* _portfolioDesc){
        if(portfolioStorge.get()[_portfolioName] != ""){
            DIPC_EMIT_EVENT(ErrEvent, "Current portfolio exist: ", _portfolioName);
            return;
        } 
        std::string callerAddr = caller().toString();
        uint64_t tokenBalance = getTotalBalance();
        // changeU256ToUint64WithChangeRate(callValue(), changeRate.get());
        PortfolioInfo info(_portfolioName, _portfolioDesc, &callerAddr[0]);
        std::string portfolioStr = info.toJson();
        //print("createPortfolio");
        //print(portfolioStr);
        //print(info.getPortfolioResult());

        (*portfolioStorge)[_portfolioName] = portfolioStr;
        DipcAssert(totalToken.get() + tokenBalance > totalToken);
        (*portfolioBalance)[_portfolioName] = tokenBalance;
        *totalToken = totalToken.get() + tokenBalance; 
        //u256 callV = callValue();
        DIPC_EMIT_EVENT(portfolioInfo, _portfolioName, &portfolioStr[0], "portfolioBalance", tokenBalance);
    }

    /**
     * @brief deposit a portfolio
     * @param _portfolioName: the name of the portfolio  want to deposit
     * @return void
     */
    PAYABLE void PortfolioManage::depositPortfolio(char* _portfolioName){
        uint64_t tokenBalance = getTotalBalance();
        //uint64_t tokenBalance = changeU256ToUint64WithChangeRate(callValue(), changeRate.get());
        uint64_t currentBalance = portfolioBalance.get()[_portfolioName];
        uint64_t finalBalance  = currentBalance + tokenBalance;
        DipcAssert(totalToken.get() + tokenBalance > totalToken);
        DipcAssert(finalBalance > currentBalance);
        (*portfolioBalance)[_portfolioName] = finalBalance;
        *totalToken = totalToken.get() + finalBalance; 
        DIPC_EMIT_EVENT(depositPortfolio, "portfolioName", _portfolioName, "portfolioBalance", finalBalance);
    }
    /**
     * @brief create a order
     * @param _portfolioName: the name of the portfolio  current order blong to   
     * @param _orderId: orderId used by application
     * @param _orderType
     * @param _stockCode
     * @param _stockPrice: unit is token
     * @param _stockAmount: uint is one share 
     * @param _endTime: nanoseconds the order expire
     * @return void
     */
    PAYABLE void PortfolioManage::createOrder(char* _portfolioName, char* _orderId, uint16_t _orderType, char* _stockCode, uint64_t _stockPrice, uint64_t _stockAmount, uint64_t _endTime){
        uint64_t tokenBalance = getTotalBalance();
        DIPC_EMIT_EVENT(createOrder, "portfolioName", _portfolioName, "OrderInfo", "ignore", "tokenBalance", tokenBalance);
        uint64_t spent = 0;
        if(_orderType == 1){
            spent = _stockPrice * _stockAmount;
            DipcAssert((portfolioBalance.get()[_portfolioName] + tokenBalance) > spent);
        }
        struct Order order{_orderId, _orderType, _stockCode, _stockPrice, _stockAmount, _endTime, 0};
        std::string pInfo = portfolioStorge.get()[_portfolioName];
        //print("identity start");
        //print(pInfo);
        //print(tokenBalance);
        if(pInfo == "") {
            DIPC_EMIT_EVENT(ErrEvent, "Current portfolio  doesn't exist: ", _portfolioName);
            return;
        }
        PortfolioInfo info;
        info.parseJson(pInfo);
        if(info.getOrder(_orderId).orderId != ""){
            DIPC_EMIT_EVENT(ErrEvent, "Current order exist: ", _orderId);
            return;
        }
        info.addOrder(order);
        pInfo = info.toJson();

        uint64_t currentBalance = portfolioBalance.get()[_portfolioName] ;
        uint64_t finalBalance = currentBalance + tokenBalance - spent;
        DipcAssert(totalToken.get() + tokenBalance > totalToken);
        //DipcAssert(finalBalance > currentBalance);
        DipcAssert(ownerTotalToken.get() < ownerTotalToken.get() + spent);
        (*portfolioStorge)[_portfolioName] = &pInfo[0];
        //print("identity ten");
        //print(pInfo);
        //print(finalBalance);
        //print(spent);


        (*portfolioBalance)[_portfolioName] = finalBalance;
        *totalToken = totalToken.get() + finalBalance; 
        *ownerTotalToken = ownerTotalToken.get() + spent;
        DIPC_EMIT_EVENT(createOrder, "portfolioName", _portfolioName, "OrderInfo", &order.toJson()[0], "portfolioBalance", finalBalance);
    }

    /**
     * @brief 
     * 
     * 
     * 
     */
    EXPORT void PortfolioManage::dealOrder(char* _portfolioName, char* _orderId){
        isOwner();
        std::string pInfo = portfolioStorge.get()[_portfolioName];
        //print("dealOrder  pInfo");
        //print(pInfo);
        PortfolioInfo info;
        info.parseJson(pInfo);
        //print("dealOrder  start");

        //print(info.toJson());
         Order ord = info.getOrder(_orderId);
         //print("dealOrder");
         //print(ord.toJson());
        if(ord.orderId != "" && ord.orderStatus == 0){
            //DipcAssert(info.getOwnerAddress() == caller().toString());
            uint64_t timenow = dipc::timestamp();
            if(ord.endTime > timenow){
                ord.orderStatus = 1;
            }else {
                ord.orderStatus = 3;
            }
        } else {
          // print("dealOrder  return ");

            return;
        }
        // print("dealOrder  one ");

        uint64_t sellValue = 0;
        if(ord.orderType == 0){
            sellValue = ord.stockAmount * ord.stockPrice;
        }
        uint64_t currentBalance =  portfolioBalance.get()[_portfolioName];
        // print("dealOrder  two");

        DipcAssert(currentBalance + sellValue >= currentBalance);
        DipcAssert((ownerTotalToken.get() - sellValue) <= ownerTotalToken.get());
        


        (*portfolioBalance)[_portfolioName] = currentBalance + sellValue;
        *ownerTotalToken = ownerTotalToken.get() - sellValue;
        (*portfolioStorge)[_portfolioName] = &info.toJson()[0];
        //print("dealOrder  three");
        //print(info.toJson());
        //print(currentBalance + sellValue);
        //print(ownerTotalToken.get());

        DIPC_EMIT_EVENT(dealPortfolio, "orderId", _orderId, "orderInfo", &ord.toJson()[0]);
    }
    /**
     * @brief 
     * 
     * 
     * 
     */
    EXPORT void PortfolioManage::revocationOrder(char* _portfolioName, char* _orderId){
        std::string pInfo = portfolioStorge.get()[_portfolioName];
        //print("pInfo");
        //print(pInfo);
        PortfolioInfo info;
        info.parseJson(pInfo);
        Order ord = info.getOrder(_orderId);
        //print("ordInfo");
        //print(ord.toJson());
        if(ord.orderId != "" && ord.orderStatus == 0){
            std::string callerStr = caller().toString();
            //print("revocationOrder start");
            //print(info.getOwnerAddress());
            //print(callerStr);
            DipcAssert(info.getOwnerAddress() == caller().toString());
            //print("revocationOrder end");

            uint64_t timenow = dipc::timestamp();
            if(ord.endTime > timenow){
                ord.orderStatus = 2;
            }else {
                ord.orderStatus = 3;
            }
        } else {
            return;
        }
        uint64_t lockToken = 0;
        if(ord.orderType == 1){
            lockToken = ord.stockPrice * ord.stockAmount;
        }
        uint64_t currentBalance =  portfolioBalance.get()[_portfolioName];
        //print("revocationOrder can see");
        //print(currentBalance);
        // print(ownerTotalToken.get());
        // print(lockToken);

        DipcAssert(currentBalance + lockToken >= currentBalance);
        DipcAssert(ownerTotalToken.get() - lockToken <= ownerTotalToken.get());

        //print("revocationOrder can see  two");
        (*portfolioBalance)[_portfolioName] = currentBalance + lockToken;
        *ownerTotalToken = ownerTotalToken.get() - lockToken;
        (*portfolioStorge)[_portfolioName] = &info.toJson()[0];
        DIPC_EMIT_EVENT(revocationPortfolio, "orderId", _orderId, "orderInfo", &ord.toJson()[0]);
    }
    /**
     * @brief 
     * @param _withdrawBalance:  the unit is token
     * 
     * 
     */
    EXPORT void PortfolioManage::withdrawPortfolio(char* _portfolioName, uint64_t _withdrawBalance){
         if(!userCanWithdraw.get()){
             return;
         }
         uint64_t currentBalance =  portfolioBalance.get()[_portfolioName];
         DipcAssert(currentBalance - _withdrawBalance < currentBalance);
         auto coinBalance = changeUint64ToU256WithChangeRate(currentBalance, changeRate.get());
         (*portfolioBalance)[_portfolioName] = currentBalance - _withdrawBalance;
         callTransfer(caller(), coinBalance);
    }
    /**
     * @brief owner deposit to the contract address to get more token
     * @param _depositValue: the value num transfer to the contract address
     */
    EXPORT void PortfolioManage::withdrawPool(uint64_t _balance){
        isOwner();
        Address ownerAddr = Address(owner.get()); 
        callTransfer(ownerAddr, _balance);
        *ownerTotalToken = ownerTotalToken.get() - _balance * changeRate.get();
        *totalToken = totalToken.get() - _balance * changeRate.get();
        DIPC_EMIT_EVENT(tokenCount, "ownerTotalToken", ownerTotalToken.get(), "totalToken", totalToken.get());
    }
    /**
     * @brief owner deposit to the contract address to get more token
     * @param _depositValue: the value num transfer to the contract address
     */
    PAYABLE void PortfolioManage::depositPool(uint64_t _depositValue){
        isOwner();
        //DipcAssert(_depositValue == dipc::callValue());
        uint64_t tokenBalance = changeU256ToUint64WithChangeRate(callValue(), changeRate.get()); 
        *ownerTotalToken = ownerTotalToken.get() + tokenBalance;
        *totalToken = totalToken.get() + tokenBalance;
        DIPC_EMIT_EVENT(tokenCount, "ownerTotalToken", ownerTotalToken.get(), "totalToken", totalToken.get());
    }
     /**
     * @brief query the total token in the contract
     * @return the total token int the contract
     */
    CONSTANT uint64_t PortfolioManage::queryTotalToken(){
        return totalToken.get();
    }

     /**
     * @brief query the token balance of the portfolio
     * @param _portfolioName : the portfolio name
     * @return the balance of the portfolio, the unit is token
     */
    CONSTANT uint64_t PortfolioManage::queryPortfolioBalance(char* _portfolioName){
        return portfolioBalance.get()[_portfolioName];
    }

    /**
     * @brief query the portfolio name  whether  used or not 
     * @return true is used, false is not used
     */
    CONSTANT bool PortfolioManage::queryPortfolioNameIfUsed(char* _portfolioName){
        if(portfolioStorge.get()[_portfolioName] != ""){
            return true;
        } 
        return false;
    }

    /**
     * @brief query the change rate between DIP and current token
     * @return the change rate between DIP and current token
     */
    CONSTANT uint64_t PortfolioManage::queryChangeRate(){
        return changeRate.get();
    }
2019-12-19_15:14:48.865807: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/tools/abi/AbiMacro.cpp:82] smatch[2].str : PortfolioManage::setUserCanWithdraw(; action : PortfolioManage::setUserCanWithdraw

2019-12-19_15:14:48.865816: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/tools/abi/AbiMacro.cpp:131] Export macrostr:EXPORT  contract:void  actions_str:setUserCanWithdraw

2019-12-19_15:14:48.865828: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/tools/abi/AbiMacro.cpp:149] get macro:PAYABLE
2019-12-19_15:14:48.865834: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/tools/abi/AbiMacro.cpp:67] file_name : /Users/konggan/workspace/chain/dipperin/github-dipc/dipc/testcontract/PortfolioManage/PortfolioManage.cpp

2019-12-19_15:14:48.865840: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/tools/abi/AbiMacro.cpp:68] Export macrostr:PAYABLE; long str :PAYABLE; longstr :PAYABLE void PortfolioManage::createPortfolio(char* _portfolioName, char* _portfolioDesc){
        if(portfolioStorge.get()[_portfolioName] != ""){
            DIPC_EMIT_EVENT(ErrEvent, "Current portfolio exist: ", _portfolioName);
            return;
        } 
        std::string callerAddr = caller().toString();
        uint64_t tokenBalance = getTotalBalance();
        // changeU256ToUint64WithChangeRate(callValue(), changeRate.get());
        PortfolioInfo info(_portfolioName, _portfolioDesc, &callerAddr[0]);
        std::string portfolioStr = info.toJson();
        //print("createPortfolio");
        //print(portfolioStr);
        //print(info.getPortfolioResult());

        (*portfolioStorge)[_portfolioName] = portfolioStr;
        DipcAssert(totalToken.get() + tokenBalance > totalToken);
        (*portfolioBalance)[_portfolioName] = tokenBalance;
        *totalToken = totalToken.get() + tokenBalance; 
        //u256 callV = callValue();
        DIPC_EMIT_EVENT(portfolioInfo, _portfolioName, &portfolioStr[0], "portfolioBalance", tokenBalance);
    }

    /**
     * @brief deposit a portfolio
     * @param _portfolioName: the name of the portfolio  want to deposit
     * @return void
     */
    PAYABLE void PortfolioManage::depositPortfolio(char* _portfolioName){
        uint64_t tokenBalance = getTotalBalance();
        //uint64_t tokenBalance = changeU256ToUint64WithChangeRate(callValue(), changeRate.get());
        uint64_t currentBalance = portfolioBalance.get()[_portfolioName];
        uint64_t finalBalance  = currentBalance + tokenBalance;
        DipcAssert(totalToken.get() + tokenBalance > totalToken);
        DipcAssert(finalBalance > currentBalance);
        (*portfolioBalance)[_portfolioName] = finalBalance;
        *totalToken = totalToken.get() + finalBalance; 
        DIPC_EMIT_EVENT(depositPortfolio, "portfolioName", _portfolioName, "portfolioBalance", finalBalance);
    }
    /**
     * @brief create a order
     * @param _portfolioName: the name of the portfolio  current order blong to   
     * @param _orderId: orderId used by application
     * @param _orderType
     * @param _stockCode
     * @param _stockPrice: unit is token
     * @param _stockAmount: uint is one share 
     * @param _endTime: nanoseconds the order expire
     * @return void
     */
    PAYABLE void PortfolioManage::createOrder(char* _portfolioName, char* _orderId, uint16_t _orderType, char* _stockCode, uint64_t _stockPrice, uint64_t _stockAmount, uint64_t _endTime){
        uint64_t tokenBalance = getTotalBalance();
        DIPC_EMIT_EVENT(createOrder, "portfolioName", _portfolioName, "OrderInfo", "ignore", "tokenBalance", tokenBalance);
        uint64_t spent = 0;
        if(_orderType == 1){
            spent = _stockPrice * _stockAmount;
            DipcAssert((portfolioBalance.get()[_portfolioName] + tokenBalance) > spent);
        }
        struct Order order{_orderId, _orderType, _stockCode, _stockPrice, _stockAmount, _endTime, 0};
        std::string pInfo = portfolioStorge.get()[_portfolioName];
        //print("identity start");
        //print(pInfo);
        //print(tokenBalance);
        if(pInfo == "") {
            DIPC_EMIT_EVENT(ErrEvent, "Current portfolio  doesn't exist: ", _portfolioName);
            return;
        }
        PortfolioInfo info;
        info.parseJson(pInfo);
        if(info.getOrder(_orderId).orderId != ""){
            DIPC_EMIT_EVENT(ErrEvent, "Current order exist: ", _orderId);
            return;
        }
        info.addOrder(order);
        pInfo = info.toJson();

        uint64_t currentBalance = portfolioBalance.get()[_portfolioName] ;
        uint64_t finalBalance = currentBalance + tokenBalance - spent;
        DipcAssert(totalToken.get() + tokenBalance > totalToken);
        //DipcAssert(finalBalance > currentBalance);
        DipcAssert(ownerTotalToken.get() < ownerTotalToken.get() + spent);
        (*portfolioStorge)[_portfolioName] = &pInfo[0];
        //print("identity ten");
        //print(pInfo);
        //print(finalBalance);
        //print(spent);


        (*portfolioBalance)[_portfolioName] = finalBalance;
        *totalToken = totalToken.get() + finalBalance; 
        *ownerTotalToken = ownerTotalToken.get() + spent;
        DIPC_EMIT_EVENT(createOrder, "portfolioName", _portfolioName, "OrderInfo", &order.toJson()[0], "portfolioBalance", finalBalance);
    }

    /**
     * @brief 
     * 
     * 
     * 
     */
    EXPORT void PortfolioManage::dealOrder(char* _portfolioName, char* _orderId){
        isOwner();
        std::string pInfo = portfolioStorge.get()[_portfolioName];
        //print("dealOrder  pInfo");
        //print(pInfo);
        PortfolioInfo info;
        info.parseJson(pInfo);
        //print("dealOrder  start");

        //print(info.toJson());
         Order ord = info.getOrder(_orderId);
         //print("dealOrder");
         //print(ord.toJson());
        if(ord.orderId != "" && ord.orderStatus == 0){
            //DipcAssert(info.getOwnerAddress() == caller().toString());
            uint64_t timenow = dipc::timestamp();
            if(ord.endTime > timenow){
                ord.orderStatus = 1;
            }else {
                ord.orderStatus = 3;
            }
        } else {
          // print("dealOrder  return ");

            return;
        }
        // print("dealOrder  one ");

        uint64_t sellValue = 0;
        if(ord.orderType == 0){
            sellValue = ord.stockAmount * ord.stockPrice;
        }
        uint64_t currentBalance =  portfolioBalance.get()[_portfolioName];
        // print("dealOrder  two");

        DipcAssert(currentBalance + sellValue >= currentBalance);
        DipcAssert((ownerTotalToken.get() - sellValue) <= ownerTotalToken.get());
        


        (*portfolioBalance)[_portfolioName] = currentBalance + sellValue;
        *ownerTotalToken = ownerTotalToken.get() - sellValue;
        (*portfolioStorge)[_portfolioName] = &info.toJson()[0];
        //print("dealOrder  three");
        //print(info.toJson());
        //print(currentBalance + sellValue);
        //print(ownerTotalToken.get());

        DIPC_EMIT_EVENT(dealPortfolio, "orderId", _orderId, "orderInfo", &ord.toJson()[0]);
    }
    /**
     * @brief 
     * 
     * 
     * 
     */
    EXPORT void PortfolioManage::revocationOrder(char* _portfolioName, char* _orderId){
        std::string pInfo = portfolioStorge.get()[_portfolioName];
        //print("pInfo");
        //print(pInfo);
        PortfolioInfo info;
        info.parseJson(pInfo);
        Order ord = info.getOrder(_orderId);
        //print("ordInfo");
        //print(ord.toJson());
        if(ord.orderId != "" && ord.orderStatus == 0){
            std::string callerStr = caller().toString();
            //print("revocationOrder start");
            //print(info.getOwnerAddress());
            //print(callerStr);
            DipcAssert(info.getOwnerAddress() == caller().toString());
            //print("revocationOrder end");

            uint64_t timenow = dipc::timestamp();
            if(ord.endTime > timenow){
                ord.orderStatus = 2;
            }else {
                ord.orderStatus = 3;
            }
        } else {
            return;
        }
        uint64_t lockToken = 0;
        if(ord.orderType == 1){
            lockToken = ord.stockPrice * ord.stockAmount;
        }
        uint64_t currentBalance =  portfolioBalance.get()[_portfolioName];
        //print("revocationOrder can see");
        //print(currentBalance);
        // print(ownerTotalToken.get());
        // print(lockToken);

        DipcAssert(currentBalance + lockToken >= currentBalance);
        DipcAssert(ownerTotalToken.get() - lockToken <= ownerTotalToken.get());

        //print("revocationOrder can see  two");
        (*portfolioBalance)[_portfolioName] = currentBalance + lockToken;
        *ownerTotalToken = ownerTotalToken.get() - lockToken;
        (*portfolioStorge)[_portfolioName] = &info.toJson()[0];
        DIPC_EMIT_EVENT(revocationPortfolio, "orderId", _orderId, "orderInfo", &ord.toJson()[0]);
    }
    /**
     * @brief 
     * @param _withdrawBalance:  the unit is token
     * 
     * 
     */
    EXPORT void PortfolioManage::withdrawPortfolio(char* _portfolioName, uint64_t _withdrawBalance){
         if(!userCanWithdraw.get()){
             return;
         }
         uint64_t currentBalance =  portfolioBalance.get()[_portfolioName];
         DipcAssert(currentBalance - _withdrawBalance < currentBalance);
         auto coinBalance = changeUint64ToU256WithChangeRate(currentBalance, changeRate.get());
         (*portfolioBalance)[_portfolioName] = currentBalance - _withdrawBalance;
         callTransfer(caller(), coinBalance);
    }
    /**
     * @brief owner deposit to the contract address to get more token
     * @param _depositValue: the value num transfer to the contract address
     */
    EXPORT void PortfolioManage::withdrawPool(uint64_t _balance){
        isOwner();
        Address ownerAddr = Address(owner.get()); 
        callTransfer(ownerAddr, _balance);
        *ownerTotalToken = ownerTotalToken.get() - _balance * changeRate.get();
        *totalToken = totalToken.get() - _balance * changeRate.get();
        DIPC_EMIT_EVENT(tokenCount, "ownerTotalToken", ownerTotalToken.get(), "totalToken", totalToken.get());
    }
    /**
     * @brief owner deposit to the contract address to get more token
     * @param _depositValue: the value num transfer to the contract address
     */
    PAYABLE void PortfolioManage::depositPool(uint64_t _depositValue){
        isOwner();
        //DipcAssert(_depositValue == dipc::callValue());
        uint64_t tokenBalance = changeU256ToUint64WithChangeRate(callValue(), changeRate.get()); 
        *ownerTotalToken = ownerTotalToken.get() + tokenBalance;
        *totalToken = totalToken.get() + tokenBalance;
        DIPC_EMIT_EVENT(tokenCount, "ownerTotalToken", ownerTotalToken.get(), "totalToken", totalToken.get());
    }
     /**
     * @brief query the total token in the contract
     * @return the total token int the contract
     */
    CONSTANT uint64_t PortfolioManage::queryTotalToken(){
        return totalToken.get();
    }

     /**
     * @brief query the token balance of the portfolio
     * @param _portfolioName : the portfolio name
     * @return the balance of the portfolio, the unit is token
     */
    CONSTANT uint64_t PortfolioManage::queryPortfolioBalance(char* _portfolioName){
        return portfolioBalance.get()[_portfolioName];
    }

    /**
     * @brief query the portfolio name  whether  used or not 
     * @return true is used, false is not used
     */
    CONSTANT bool PortfolioManage::queryPortfolioNameIfUsed(char* _portfolioName){
        if(portfolioStorge.get()[_portfolioName] != ""){
            return true;
        } 
        return false;
    }

    /**
     * @brief query the change rate between DIP and current token
     * @return the change rate between DIP and current token
     */
    CONSTANT uint64_t PortfolioManage::queryChangeRate(){
        return changeRate.get();
    }
2019-12-19_15:14:48.865875: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/tools/abi/AbiMacro.cpp:82] smatch[2].str : PortfolioManage::createPortfolio(; action : PortfolioManage::createPortfolio

2019-12-19_15:14:48.865882: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/tools/abi/AbiMacro.cpp:131] Export macrostr:PAYABLE  contract:void  actions_str:createPortfolio

2019-12-19_15:14:48.865938: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/tools/abi/AbiMacro.cpp:149] get macro:PAYABLE
2019-12-19_15:14:48.865947: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/tools/abi/AbiMacro.cpp:67] file_name : /Users/konggan/workspace/chain/dipperin/github-dipc/dipc/testcontract/PortfolioManage/PortfolioManage.cpp

2019-12-19_15:14:48.865953: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/tools/abi/AbiMacro.cpp:68] Export macrostr:PAYABLE; long str :PAYABLE; longstr :PAYABLE void PortfolioManage::depositPortfolio(char* _portfolioName){
        uint64_t tokenBalance = getTotalBalance();
        //uint64_t tokenBalance = changeU256ToUint64WithChangeRate(callValue(), changeRate.get());
        uint64_t currentBalance = portfolioBalance.get()[_portfolioName];
        uint64_t finalBalance  = currentBalance + tokenBalance;
        DipcAssert(totalToken.get() + tokenBalance > totalToken);
        DipcAssert(finalBalance > currentBalance);
        (*portfolioBalance)[_portfolioName] = finalBalance;
        *totalToken = totalToken.get() + finalBalance; 
        DIPC_EMIT_EVENT(depositPortfolio, "portfolioName", _portfolioName, "portfolioBalance", finalBalance);
    }
    /**
     * @brief create a order
     * @param _portfolioName: the name of the portfolio  current order blong to   
     * @param _orderId: orderId used by application
     * @param _orderType
     * @param _stockCode
     * @param _stockPrice: unit is token
     * @param _stockAmount: uint is one share 
     * @param _endTime: nanoseconds the order expire
     * @return void
     */
    PAYABLE void PortfolioManage::createOrder(char* _portfolioName, char* _orderId, uint16_t _orderType, char* _stockCode, uint64_t _stockPrice, uint64_t _stockAmount, uint64_t _endTime){
        uint64_t tokenBalance = getTotalBalance();
        DIPC_EMIT_EVENT(createOrder, "portfolioName", _portfolioName, "OrderInfo", "ignore", "tokenBalance", tokenBalance);
        uint64_t spent = 0;
        if(_orderType == 1){
            spent = _stockPrice * _stockAmount;
            DipcAssert((portfolioBalance.get()[_portfolioName] + tokenBalance) > spent);
        }
        struct Order order{_orderId, _orderType, _stockCode, _stockPrice, _stockAmount, _endTime, 0};
        std::string pInfo = portfolioStorge.get()[_portfolioName];
        //print("identity start");
        //print(pInfo);
        //print(tokenBalance);
        if(pInfo == "") {
            DIPC_EMIT_EVENT(ErrEvent, "Current portfolio  doesn't exist: ", _portfolioName);
            return;
        }
        PortfolioInfo info;
        info.parseJson(pInfo);
        if(info.getOrder(_orderId).orderId != ""){
            DIPC_EMIT_EVENT(ErrEvent, "Current order exist: ", _orderId);
            return;
        }
        info.addOrder(order);
        pInfo = info.toJson();

        uint64_t currentBalance = portfolioBalance.get()[_portfolioName] ;
        uint64_t finalBalance = currentBalance + tokenBalance - spent;
        DipcAssert(totalToken.get() + tokenBalance > totalToken);
        //DipcAssert(finalBalance > currentBalance);
        DipcAssert(ownerTotalToken.get() < ownerTotalToken.get() + spent);
        (*portfolioStorge)[_portfolioName] = &pInfo[0];
        //print("identity ten");
        //print(pInfo);
        //print(finalBalance);
        //print(spent);


        (*portfolioBalance)[_portfolioName] = finalBalance;
        *totalToken = totalToken.get() + finalBalance; 
        *ownerTotalToken = ownerTotalToken.get() + spent;
        DIPC_EMIT_EVENT(createOrder, "portfolioName", _portfolioName, "OrderInfo", &order.toJson()[0], "portfolioBalance", finalBalance);
    }

    /**
     * @brief 
     * 
     * 
     * 
     */
    EXPORT void PortfolioManage::dealOrder(char* _portfolioName, char* _orderId){
        isOwner();
        std::string pInfo = portfolioStorge.get()[_portfolioName];
        //print("dealOrder  pInfo");
        //print(pInfo);
        PortfolioInfo info;
        info.parseJson(pInfo);
        //print("dealOrder  start");

        //print(info.toJson());
         Order ord = info.getOrder(_orderId);
         //print("dealOrder");
         //print(ord.toJson());
        if(ord.orderId != "" && ord.orderStatus == 0){
            //DipcAssert(info.getOwnerAddress() == caller().toString());
            uint64_t timenow = dipc::timestamp();
            if(ord.endTime > timenow){
                ord.orderStatus = 1;
            }else {
                ord.orderStatus = 3;
            }
        } else {
          // print("dealOrder  return ");

            return;
        }
        // print("dealOrder  one ");

        uint64_t sellValue = 0;
        if(ord.orderType == 0){
            sellValue = ord.stockAmount * ord.stockPrice;
        }
        uint64_t currentBalance =  portfolioBalance.get()[_portfolioName];
        // print("dealOrder  two");

        DipcAssert(currentBalance + sellValue >= currentBalance);
        DipcAssert((ownerTotalToken.get() - sellValue) <= ownerTotalToken.get());
        


        (*portfolioBalance)[_portfolioName] = currentBalance + sellValue;
        *ownerTotalToken = ownerTotalToken.get() - sellValue;
        (*portfolioStorge)[_portfolioName] = &info.toJson()[0];
        //print("dealOrder  three");
        //print(info.toJson());
        //print(currentBalance + sellValue);
        //print(ownerTotalToken.get());

        DIPC_EMIT_EVENT(dealPortfolio, "orderId", _orderId, "orderInfo", &ord.toJson()[0]);
    }
    /**
     * @brief 
     * 
     * 
     * 
     */
    EXPORT void PortfolioManage::revocationOrder(char* _portfolioName, char* _orderId){
        std::string pInfo = portfolioStorge.get()[_portfolioName];
        //print("pInfo");
        //print(pInfo);
        PortfolioInfo info;
        info.parseJson(pInfo);
        Order ord = info.getOrder(_orderId);
        //print("ordInfo");
        //print(ord.toJson());
        if(ord.orderId != "" && ord.orderStatus == 0){
            std::string callerStr = caller().toString();
            //print("revocationOrder start");
            //print(info.getOwnerAddress());
            //print(callerStr);
            DipcAssert(info.getOwnerAddress() == caller().toString());
            //print("revocationOrder end");

            uint64_t timenow = dipc::timestamp();
            if(ord.endTime > timenow){
                ord.orderStatus = 2;
            }else {
                ord.orderStatus = 3;
            }
        } else {
            return;
        }
        uint64_t lockToken = 0;
        if(ord.orderType == 1){
            lockToken = ord.stockPrice * ord.stockAmount;
        }
        uint64_t currentBalance =  portfolioBalance.get()[_portfolioName];
        //print("revocationOrder can see");
        //print(currentBalance);
        // print(ownerTotalToken.get());
        // print(lockToken);

        DipcAssert(currentBalance + lockToken >= currentBalance);
        DipcAssert(ownerTotalToken.get() - lockToken <= ownerTotalToken.get());

        //print("revocationOrder can see  two");
        (*portfolioBalance)[_portfolioName] = currentBalance + lockToken;
        *ownerTotalToken = ownerTotalToken.get() - lockToken;
        (*portfolioStorge)[_portfolioName] = &info.toJson()[0];
        DIPC_EMIT_EVENT(revocationPortfolio, "orderId", _orderId, "orderInfo", &ord.toJson()[0]);
    }
    /**
     * @brief 
     * @param _withdrawBalance:  the unit is token
     * 
     * 
     */
    EXPORT void PortfolioManage::withdrawPortfolio(char* _portfolioName, uint64_t _withdrawBalance){
         if(!userCanWithdraw.get()){
             return;
         }
         uint64_t currentBalance =  portfolioBalance.get()[_portfolioName];
         DipcAssert(currentBalance - _withdrawBalance < currentBalance);
         auto coinBalance = changeUint64ToU256WithChangeRate(currentBalance, changeRate.get());
         (*portfolioBalance)[_portfolioName] = currentBalance - _withdrawBalance;
         callTransfer(caller(), coinBalance);
    }
    /**
     * @brief owner deposit to the contract address to get more token
     * @param _depositValue: the value num transfer to the contract address
     */
    EXPORT void PortfolioManage::withdrawPool(uint64_t _balance){
        isOwner();
        Address ownerAddr = Address(owner.get()); 
        callTransfer(ownerAddr, _balance);
        *ownerTotalToken = ownerTotalToken.get() - _balance * changeRate.get();
        *totalToken = totalToken.get() - _balance * changeRate.get();
        DIPC_EMIT_EVENT(tokenCount, "ownerTotalToken", ownerTotalToken.get(), "totalToken", totalToken.get());
    }
    /**
     * @brief owner deposit to the contract address to get more token
     * @param _depositValue: the value num transfer to the contract address
     */
    PAYABLE void PortfolioManage::depositPool(uint64_t _depositValue){
        isOwner();
        //DipcAssert(_depositValue == dipc::callValue());
        uint64_t tokenBalance = changeU256ToUint64WithChangeRate(callValue(), changeRate.get()); 
        *ownerTotalToken = ownerTotalToken.get() + tokenBalance;
        *totalToken = totalToken.get() + tokenBalance;
        DIPC_EMIT_EVENT(tokenCount, "ownerTotalToken", ownerTotalToken.get(), "totalToken", totalToken.get());
    }
     /**
     * @brief query the total token in the contract
     * @return the total token int the contract
     */
    CONSTANT uint64_t PortfolioManage::queryTotalToken(){
        return totalToken.get();
    }

     /**
     * @brief query the token balance of the portfolio
     * @param _portfolioName : the portfolio name
     * @return the balance of the portfolio, the unit is token
     */
    CONSTANT uint64_t PortfolioManage::queryPortfolioBalance(char* _portfolioName){
        return portfolioBalance.get()[_portfolioName];
    }

    /**
     * @brief query the portfolio name  whether  used or not 
     * @return true is used, false is not used
     */
    CONSTANT bool PortfolioManage::queryPortfolioNameIfUsed(char* _portfolioName){
        if(portfolioStorge.get()[_portfolioName] != ""){
            return true;
        } 
        return false;
    }

    /**
     * @brief query the change rate between DIP and current token
     * @return the change rate between DIP and current token
     */
    CONSTANT uint64_t PortfolioManage::queryChangeRate(){
        return changeRate.get();
    }
2019-12-19_15:14:48.865982: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/tools/abi/AbiMacro.cpp:82] smatch[2].str : PortfolioManage::depositPortfolio(; action : PortfolioManage::depositPortfolio

2019-12-19_15:14:48.865990: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/tools/abi/AbiMacro.cpp:131] Export macrostr:PAYABLE  contract:void  actions_str:depositPortfolio

2019-12-19_15:14:48.866016: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/tools/abi/AbiMacro.cpp:149] get macro:PAYABLE
2019-12-19_15:14:48.866024: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/tools/abi/AbiMacro.cpp:67] file_name : /Users/konggan/workspace/chain/dipperin/github-dipc/dipc/testcontract/PortfolioManage/PortfolioManage.cpp

2019-12-19_15:14:48.866030: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/tools/abi/AbiMacro.cpp:68] Export macrostr:PAYABLE; long str :PAYABLE; longstr :PAYABLE void PortfolioManage::createOrder(char* _portfolioName, char* _orderId, uint16_t _orderType, char* _stockCode, uint64_t _stockPrice, uint64_t _stockAmount, uint64_t _endTime){
        uint64_t tokenBalance = getTotalBalance();
        DIPC_EMIT_EVENT(createOrder, "portfolioName", _portfolioName, "OrderInfo", "ignore", "tokenBalance", tokenBalance);
        uint64_t spent = 0;
        if(_orderType == 1){
            spent = _stockPrice * _stockAmount;
            DipcAssert((portfolioBalance.get()[_portfolioName] + tokenBalance) > spent);
        }
        struct Order order{_orderId, _orderType, _stockCode, _stockPrice, _stockAmount, _endTime, 0};
        std::string pInfo = portfolioStorge.get()[_portfolioName];
        //print("identity start");
        //print(pInfo);
        //print(tokenBalance);
        if(pInfo == "") {
            DIPC_EMIT_EVENT(ErrEvent, "Current portfolio  doesn't exist: ", _portfolioName);
            return;
        }
        PortfolioInfo info;
        info.parseJson(pInfo);
        if(info.getOrder(_orderId).orderId != ""){
            DIPC_EMIT_EVENT(ErrEvent, "Current order exist: ", _orderId);
            return;
        }
        info.addOrder(order);
        pInfo = info.toJson();

        uint64_t currentBalance = portfolioBalance.get()[_portfolioName] ;
        uint64_t finalBalance = currentBalance + tokenBalance - spent;
        DipcAssert(totalToken.get() + tokenBalance > totalToken);
        //DipcAssert(finalBalance > currentBalance);
        DipcAssert(ownerTotalToken.get() < ownerTotalToken.get() + spent);
        (*portfolioStorge)[_portfolioName] = &pInfo[0];
        //print("identity ten");
        //print(pInfo);
        //print(finalBalance);
        //print(spent);


        (*portfolioBalance)[_portfolioName] = finalBalance;
        *totalToken = totalToken.get() + finalBalance; 
        *ownerTotalToken = ownerTotalToken.get() + spent;
        DIPC_EMIT_EVENT(createOrder, "portfolioName", _portfolioName, "OrderInfo", &order.toJson()[0], "portfolioBalance", finalBalance);
    }

    /**
     * @brief 
     * 
     * 
     * 
     */
    EXPORT void PortfolioManage::dealOrder(char* _portfolioName, char* _orderId){
        isOwner();
        std::string pInfo = portfolioStorge.get()[_portfolioName];
        //print("dealOrder  pInfo");
        //print(pInfo);
        PortfolioInfo info;
        info.parseJson(pInfo);
        //print("dealOrder  start");

        //print(info.toJson());
         Order ord = info.getOrder(_orderId);
         //print("dealOrder");
         //print(ord.toJson());
        if(ord.orderId != "" && ord.orderStatus == 0){
            //DipcAssert(info.getOwnerAddress() == caller().toString());
            uint64_t timenow = dipc::timestamp();
            if(ord.endTime > timenow){
                ord.orderStatus = 1;
            }else {
                ord.orderStatus = 3;
            }
        } else {
          // print("dealOrder  return ");

            return;
        }
        // print("dealOrder  one ");

        uint64_t sellValue = 0;
        if(ord.orderType == 0){
            sellValue = ord.stockAmount * ord.stockPrice;
        }
        uint64_t currentBalance =  portfolioBalance.get()[_portfolioName];
        // print("dealOrder  two");

        DipcAssert(currentBalance + sellValue >= currentBalance);
        DipcAssert((ownerTotalToken.get() - sellValue) <= ownerTotalToken.get());
        


        (*portfolioBalance)[_portfolioName] = currentBalance + sellValue;
        *ownerTotalToken = ownerTotalToken.get() - sellValue;
        (*portfolioStorge)[_portfolioName] = &info.toJson()[0];
        //print("dealOrder  three");
        //print(info.toJson());
        //print(currentBalance + sellValue);
        //print(ownerTotalToken.get());

        DIPC_EMIT_EVENT(dealPortfolio, "orderId", _orderId, "orderInfo", &ord.toJson()[0]);
    }
    /**
     * @brief 
     * 
     * 
     * 
     */
    EXPORT void PortfolioManage::revocationOrder(char* _portfolioName, char* _orderId){
        std::string pInfo = portfolioStorge.get()[_portfolioName];
        //print("pInfo");
        //print(pInfo);
        PortfolioInfo info;
        info.parseJson(pInfo);
        Order ord = info.getOrder(_orderId);
        //print("ordInfo");
        //print(ord.toJson());
        if(ord.orderId != "" && ord.orderStatus == 0){
            std::string callerStr = caller().toString();
            //print("revocationOrder start");
            //print(info.getOwnerAddress());
            //print(callerStr);
            DipcAssert(info.getOwnerAddress() == caller().toString());
            //print("revocationOrder end");

            uint64_t timenow = dipc::timestamp();
            if(ord.endTime > timenow){
                ord.orderStatus = 2;
            }else {
                ord.orderStatus = 3;
            }
        } else {
            return;
        }
        uint64_t lockToken = 0;
        if(ord.orderType == 1){
            lockToken = ord.stockPrice * ord.stockAmount;
        }
        uint64_t currentBalance =  portfolioBalance.get()[_portfolioName];
        //print("revocationOrder can see");
        //print(currentBalance);
        // print(ownerTotalToken.get());
        // print(lockToken);

        DipcAssert(currentBalance + lockToken >= currentBalance);
        DipcAssert(ownerTotalToken.get() - lockToken <= ownerTotalToken.get());

        //print("revocationOrder can see  two");
        (*portfolioBalance)[_portfolioName] = currentBalance + lockToken;
        *ownerTotalToken = ownerTotalToken.get() - lockToken;
        (*portfolioStorge)[_portfolioName] = &info.toJson()[0];
        DIPC_EMIT_EVENT(revocationPortfolio, "orderId", _orderId, "orderInfo", &ord.toJson()[0]);
    }
    /**
     * @brief 
     * @param _withdrawBalance:  the unit is token
     * 
     * 
     */
    EXPORT void PortfolioManage::withdrawPortfolio(char* _portfolioName, uint64_t _withdrawBalance){
         if(!userCanWithdraw.get()){
             return;
         }
         uint64_t currentBalance =  portfolioBalance.get()[_portfolioName];
         DipcAssert(currentBalance - _withdrawBalance < currentBalance);
         auto coinBalance = changeUint64ToU256WithChangeRate(currentBalance, changeRate.get());
         (*portfolioBalance)[_portfolioName] = currentBalance - _withdrawBalance;
         callTransfer(caller(), coinBalance);
    }
    /**
     * @brief owner deposit to the contract address to get more token
     * @param _depositValue: the value num transfer to the contract address
     */
    EXPORT void PortfolioManage::withdrawPool(uint64_t _balance){
        isOwner();
        Address ownerAddr = Address(owner.get()); 
        callTransfer(ownerAddr, _balance);
        *ownerTotalToken = ownerTotalToken.get() - _balance * changeRate.get();
        *totalToken = totalToken.get() - _balance * changeRate.get();
        DIPC_EMIT_EVENT(tokenCount, "ownerTotalToken", ownerTotalToken.get(), "totalToken", totalToken.get());
    }
    /**
     * @brief owner deposit to the contract address to get more token
     * @param _depositValue: the value num transfer to the contract address
     */
    PAYABLE void PortfolioManage::depositPool(uint64_t _depositValue){
        isOwner();
        //DipcAssert(_depositValue == dipc::callValue());
        uint64_t tokenBalance = changeU256ToUint64WithChangeRate(callValue(), changeRate.get()); 
        *ownerTotalToken = ownerTotalToken.get() + tokenBalance;
        *totalToken = totalToken.get() + tokenBalance;
        DIPC_EMIT_EVENT(tokenCount, "ownerTotalToken", ownerTotalToken.get(), "totalToken", totalToken.get());
    }
     /**
     * @brief query the total token in the contract
     * @return the total token int the contract
     */
    CONSTANT uint64_t PortfolioManage::queryTotalToken(){
        return totalToken.get();
    }

     /**
     * @brief query the token balance of the portfolio
     * @param _portfolioName : the portfolio name
     * @return the balance of the portfolio, the unit is token
     */
    CONSTANT uint64_t PortfolioManage::queryPortfolioBalance(char* _portfolioName){
        return portfolioBalance.get()[_portfolioName];
    }

    /**
     * @brief query the portfolio name  whether  used or not 
     * @return true is used, false is not used
     */
    CONSTANT bool PortfolioManage::queryPortfolioNameIfUsed(char* _portfolioName){
        if(portfolioStorge.get()[_portfolioName] != ""){
            return true;
        } 
        return false;
    }

    /**
     * @brief query the change rate between DIP and current token
     * @return the change rate between DIP and current token
     */
    CONSTANT uint64_t PortfolioManage::queryChangeRate(){
        return changeRate.get();
    }
2019-12-19_15:14:48.866093: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/tools/abi/AbiMacro.cpp:82] smatch[2].str : PortfolioManage::createOrder(; action : PortfolioManage::createOrder

2019-12-19_15:14:48.866100: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/tools/abi/AbiMacro.cpp:131] Export macrostr:PAYABLE  contract:void  actions_str:createOrder

2019-12-19_15:14:48.866152: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/tools/abi/AbiMacro.cpp:149] get macro:EXPORT
2019-12-19_15:14:48.866159: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/tools/abi/AbiMacro.cpp:67] file_name : /Users/konggan/workspace/chain/dipperin/github-dipc/dipc/testcontract/PortfolioManage/PortfolioManage.cpp

2019-12-19_15:14:48.866165: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/tools/abi/AbiMacro.cpp:68] Export macrostr:EXPORT; long str :EXPORT; longstr :EXPORT void PortfolioManage::dealOrder(char* _portfolioName, char* _orderId){
        isOwner();
        std::string pInfo = portfolioStorge.get()[_portfolioName];
        //print("dealOrder  pInfo");
        //print(pInfo);
        PortfolioInfo info;
        info.parseJson(pInfo);
        //print("dealOrder  start");

        //print(info.toJson());
         Order ord = info.getOrder(_orderId);
         //print("dealOrder");
         //print(ord.toJson());
        if(ord.orderId != "" && ord.orderStatus == 0){
            //DipcAssert(info.getOwnerAddress() == caller().toString());
            uint64_t timenow = dipc::timestamp();
            if(ord.endTime > timenow){
                ord.orderStatus = 1;
            }else {
                ord.orderStatus = 3;
            }
        } else {
          // print("dealOrder  return ");

            return;
        }
        // print("dealOrder  one ");

        uint64_t sellValue = 0;
        if(ord.orderType == 0){
            sellValue = ord.stockAmount * ord.stockPrice;
        }
        uint64_t currentBalance =  portfolioBalance.get()[_portfolioName];
        // print("dealOrder  two");

        DipcAssert(currentBalance + sellValue >= currentBalance);
        DipcAssert((ownerTotalToken.get() - sellValue) <= ownerTotalToken.get());
        


        (*portfolioBalance)[_portfolioName] = currentBalance + sellValue;
        *ownerTotalToken = ownerTotalToken.get() - sellValue;
        (*portfolioStorge)[_portfolioName] = &info.toJson()[0];
        //print("dealOrder  three");
        //print(info.toJson());
        //print(currentBalance + sellValue);
        //print(ownerTotalToken.get());

        DIPC_EMIT_EVENT(dealPortfolio, "orderId", _orderId, "orderInfo", &ord.toJson()[0]);
    }
    /**
     * @brief 
     * 
     * 
     * 
     */
    EXPORT void PortfolioManage::revocationOrder(char* _portfolioName, char* _orderId){
        std::string pInfo = portfolioStorge.get()[_portfolioName];
        //print("pInfo");
        //print(pInfo);
        PortfolioInfo info;
        info.parseJson(pInfo);
        Order ord = info.getOrder(_orderId);
        //print("ordInfo");
        //print(ord.toJson());
        if(ord.orderId != "" && ord.orderStatus == 0){
            std::string callerStr = caller().toString();
            //print("revocationOrder start");
            //print(info.getOwnerAddress());
            //print(callerStr);
            DipcAssert(info.getOwnerAddress() == caller().toString());
            //print("revocationOrder end");

            uint64_t timenow = dipc::timestamp();
            if(ord.endTime > timenow){
                ord.orderStatus = 2;
            }else {
                ord.orderStatus = 3;
            }
        } else {
            return;
        }
        uint64_t lockToken = 0;
        if(ord.orderType == 1){
            lockToken = ord.stockPrice * ord.stockAmount;
        }
        uint64_t currentBalance =  portfolioBalance.get()[_portfolioName];
        //print("revocationOrder can see");
        //print(currentBalance);
        // print(ownerTotalToken.get());
        // print(lockToken);

        DipcAssert(currentBalance + lockToken >= currentBalance);
        DipcAssert(ownerTotalToken.get() - lockToken <= ownerTotalToken.get());

        //print("revocationOrder can see  two");
        (*portfolioBalance)[_portfolioName] = currentBalance + lockToken;
        *ownerTotalToken = ownerTotalToken.get() - lockToken;
        (*portfolioStorge)[_portfolioName] = &info.toJson()[0];
        DIPC_EMIT_EVENT(revocationPortfolio, "orderId", _orderId, "orderInfo", &ord.toJson()[0]);
    }
    /**
     * @brief 
     * @param _withdrawBalance:  the unit is token
     * 
     * 
     */
    EXPORT void PortfolioManage::withdrawPortfolio(char* _portfolioName, uint64_t _withdrawBalance){
         if(!userCanWithdraw.get()){
             return;
         }
         uint64_t currentBalance =  portfolioBalance.get()[_portfolioName];
         DipcAssert(currentBalance - _withdrawBalance < currentBalance);
         auto coinBalance = changeUint64ToU256WithChangeRate(currentBalance, changeRate.get());
         (*portfolioBalance)[_portfolioName] = currentBalance - _withdrawBalance;
         callTransfer(caller(), coinBalance);
    }
    /**
     * @brief owner deposit to the contract address to get more token
     * @param _depositValue: the value num transfer to the contract address
     */
    EXPORT void PortfolioManage::withdrawPool(uint64_t _balance){
        isOwner();
        Address ownerAddr = Address(owner.get()); 
        callTransfer(ownerAddr, _balance);
        *ownerTotalToken = ownerTotalToken.get() - _balance * changeRate.get();
        *totalToken = totalToken.get() - _balance * changeRate.get();
        DIPC_EMIT_EVENT(tokenCount, "ownerTotalToken", ownerTotalToken.get(), "totalToken", totalToken.get());
    }
    /**
     * @brief owner deposit to the contract address to get more token
     * @param _depositValue: the value num transfer to the contract address
     */
    PAYABLE void PortfolioManage::depositPool(uint64_t _depositValue){
        isOwner();
        //DipcAssert(_depositValue == dipc::callValue());
        uint64_t tokenBalance = changeU256ToUint64WithChangeRate(callValue(), changeRate.get()); 
        *ownerTotalToken = ownerTotalToken.get() + tokenBalance;
        *totalToken = totalToken.get() + tokenBalance;
        DIPC_EMIT_EVENT(tokenCount, "ownerTotalToken", ownerTotalToken.get(), "totalToken", totalToken.get());
    }
     /**
     * @brief query the total token in the contract
     * @return the total token int the contract
     */
    CONSTANT uint64_t PortfolioManage::queryTotalToken(){
        return totalToken.get();
    }

     /**
     * @brief query the token balance of the portfolio
     * @param _portfolioName : the portfolio name
     * @return the balance of the portfolio, the unit is token
     */
    CONSTANT uint64_t PortfolioManage::queryPortfolioBalance(char* _portfolioName){
        return portfolioBalance.get()[_portfolioName];
    }

    /**
     * @brief query the portfolio name  whether  used or not 
     * @return true is used, false is not used
     */
    CONSTANT bool PortfolioManage::queryPortfolioNameIfUsed(char* _portfolioName){
        if(portfolioStorge.get()[_portfolioName] != ""){
            return true;
        } 
        return false;
    }

    /**
     * @brief query the change rate between DIP and current token
     * @return the change rate between DIP and current token
     */
    CONSTANT uint64_t PortfolioManage::queryChangeRate(){
        return changeRate.get();
    }
2019-12-19_15:14:48.866197: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/tools/abi/AbiMacro.cpp:82] smatch[2].str : PortfolioManage::dealOrder(; action : PortfolioManage::dealOrder

2019-12-19_15:14:48.866203: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/tools/abi/AbiMacro.cpp:131] Export macrostr:EXPORT  contract:void  actions_str:dealOrder

2019-12-19_15:14:48.866239: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/tools/abi/AbiMacro.cpp:149] get macro:EXPORT
2019-12-19_15:14:48.866245: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/tools/abi/AbiMacro.cpp:67] file_name : /Users/konggan/workspace/chain/dipperin/github-dipc/dipc/testcontract/PortfolioManage/PortfolioManage.cpp

2019-12-19_15:14:48.866251: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/tools/abi/AbiMacro.cpp:68] Export macrostr:EXPORT; long str :EXPORT; longstr :EXPORT void PortfolioManage::revocationOrder(char* _portfolioName, char* _orderId){
        std::string pInfo = portfolioStorge.get()[_portfolioName];
        //print("pInfo");
        //print(pInfo);
        PortfolioInfo info;
        info.parseJson(pInfo);
        Order ord = info.getOrder(_orderId);
        //print("ordInfo");
        //print(ord.toJson());
        if(ord.orderId != "" && ord.orderStatus == 0){
            std::string callerStr = caller().toString();
            //print("revocationOrder start");
            //print(info.getOwnerAddress());
            //print(callerStr);
            DipcAssert(info.getOwnerAddress() == caller().toString());
            //print("revocationOrder end");

            uint64_t timenow = dipc::timestamp();
            if(ord.endTime > timenow){
                ord.orderStatus = 2;
            }else {
                ord.orderStatus = 3;
            }
        } else {
            return;
        }
        uint64_t lockToken = 0;
        if(ord.orderType == 1){
            lockToken = ord.stockPrice * ord.stockAmount;
        }
        uint64_t currentBalance =  portfolioBalance.get()[_portfolioName];
        //print("revocationOrder can see");
        //print(currentBalance);
        // print(ownerTotalToken.get());
        // print(lockToken);

        DipcAssert(currentBalance + lockToken >= currentBalance);
        DipcAssert(ownerTotalToken.get() - lockToken <= ownerTotalToken.get());

        //print("revocationOrder can see  two");
        (*portfolioBalance)[_portfolioName] = currentBalance + lockToken;
        *ownerTotalToken = ownerTotalToken.get() - lockToken;
        (*portfolioStorge)[_portfolioName] = &info.toJson()[0];
        DIPC_EMIT_EVENT(revocationPortfolio, "orderId", _orderId, "orderInfo", &ord.toJson()[0]);
    }
    /**
     * @brief 
     * @param _withdrawBalance:  the unit is token
     * 
     * 
     */
    EXPORT void PortfolioManage::withdrawPortfolio(char* _portfolioName, uint64_t _withdrawBalance){
         if(!userCanWithdraw.get()){
             return;
         }
         uint64_t currentBalance =  portfolioBalance.get()[_portfolioName];
         DipcAssert(currentBalance - _withdrawBalance < currentBalance);
         auto coinBalance = changeUint64ToU256WithChangeRate(currentBalance, changeRate.get());
         (*portfolioBalance)[_portfolioName] = currentBalance - _withdrawBalance;
         callTransfer(caller(), coinBalance);
    }
    /**
     * @brief owner deposit to the contract address to get more token
     * @param _depositValue: the value num transfer to the contract address
     */
    EXPORT void PortfolioManage::withdrawPool(uint64_t _balance){
        isOwner();
        Address ownerAddr = Address(owner.get()); 
        callTransfer(ownerAddr, _balance);
        *ownerTotalToken = ownerTotalToken.get() - _balance * changeRate.get();
        *totalToken = totalToken.get() - _balance * changeRate.get();
        DIPC_EMIT_EVENT(tokenCount, "ownerTotalToken", ownerTotalToken.get(), "totalToken", totalToken.get());
    }
    /**
     * @brief owner deposit to the contract address to get more token
     * @param _depositValue: the value num transfer to the contract address
     */
    PAYABLE void PortfolioManage::depositPool(uint64_t _depositValue){
        isOwner();
        //DipcAssert(_depositValue == dipc::callValue());
        uint64_t tokenBalance = changeU256ToUint64WithChangeRate(callValue(), changeRate.get()); 
        *ownerTotalToken = ownerTotalToken.get() + tokenBalance;
        *totalToken = totalToken.get() + tokenBalance;
        DIPC_EMIT_EVENT(tokenCount, "ownerTotalToken", ownerTotalToken.get(), "totalToken", totalToken.get());
    }
     /**
     * @brief query the total token in the contract
     * @return the total token int the contract
     */
    CONSTANT uint64_t PortfolioManage::queryTotalToken(){
        return totalToken.get();
    }

     /**
     * @brief query the token balance of the portfolio
     * @param _portfolioName : the portfolio name
     * @return the balance of the portfolio, the unit is token
     */
    CONSTANT uint64_t PortfolioManage::queryPortfolioBalance(char* _portfolioName){
        return portfolioBalance.get()[_portfolioName];
    }

    /**
     * @brief query the portfolio name  whether  used or not 
     * @return true is used, false is not used
     */
    CONSTANT bool PortfolioManage::queryPortfolioNameIfUsed(char* _portfolioName){
        if(portfolioStorge.get()[_portfolioName] != ""){
            return true;
        } 
        return false;
    }

    /**
     * @brief query the change rate between DIP and current token
     * @return the change rate between DIP and current token
     */
    CONSTANT uint64_t PortfolioManage::queryChangeRate(){
        return changeRate.get();
    }
2019-12-19_15:14:48.866284: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/tools/abi/AbiMacro.cpp:82] smatch[2].str : PortfolioManage::revocationOrder(; action : PortfolioManage::revocationOrder

2019-12-19_15:14:48.866291: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/tools/abi/AbiMacro.cpp:131] Export macrostr:EXPORT  contract:void  actions_str:revocationOrder

2019-12-19_15:14:48.866325: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/tools/abi/AbiMacro.cpp:149] get macro:EXPORT
2019-12-19_15:14:48.866332: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/tools/abi/AbiMacro.cpp:67] file_name : /Users/konggan/workspace/chain/dipperin/github-dipc/dipc/testcontract/PortfolioManage/PortfolioManage.cpp

2019-12-19_15:14:48.866337: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/tools/abi/AbiMacro.cpp:68] Export macrostr:EXPORT; long str :EXPORT; longstr :EXPORT void PortfolioManage::withdrawPortfolio(char* _portfolioName, uint64_t _withdrawBalance){
         if(!userCanWithdraw.get()){
             return;
         }
         uint64_t currentBalance =  portfolioBalance.get()[_portfolioName];
         DipcAssert(currentBalance - _withdrawBalance < currentBalance);
         auto coinBalance = changeUint64ToU256WithChangeRate(currentBalance, changeRate.get());
         (*portfolioBalance)[_portfolioName] = currentBalance - _withdrawBalance;
         callTransfer(caller(), coinBalance);
    }
    /**
     * @brief owner deposit to the contract address to get more token
     * @param _depositValue: the value num transfer to the contract address
     */
    EXPORT void PortfolioManage::withdrawPool(uint64_t _balance){
        isOwner();
        Address ownerAddr = Address(owner.get()); 
        callTransfer(ownerAddr, _balance);
        *ownerTotalToken = ownerTotalToken.get() - _balance * changeRate.get();
        *totalToken = totalToken.get() - _balance * changeRate.get();
        DIPC_EMIT_EVENT(tokenCount, "ownerTotalToken", ownerTotalToken.get(), "totalToken", totalToken.get());
    }
    /**
     * @brief owner deposit to the contract address to get more token
     * @param _depositValue: the value num transfer to the contract address
     */
    PAYABLE void PortfolioManage::depositPool(uint64_t _depositValue){
        isOwner();
        //DipcAssert(_depositValue == dipc::callValue());
        uint64_t tokenBalance = changeU256ToUint64WithChangeRate(callValue(), changeRate.get()); 
        *ownerTotalToken = ownerTotalToken.get() + tokenBalance;
        *totalToken = totalToken.get() + tokenBalance;
        DIPC_EMIT_EVENT(tokenCount, "ownerTotalToken", ownerTotalToken.get(), "totalToken", totalToken.get());
    }
     /**
     * @brief query the total token in the contract
     * @return the total token int the contract
     */
    CONSTANT uint64_t PortfolioManage::queryTotalToken(){
        return totalToken.get();
    }

     /**
     * @brief query the token balance of the portfolio
     * @param _portfolioName : the portfolio name
     * @return the balance of the portfolio, the unit is token
     */
    CONSTANT uint64_t PortfolioManage::queryPortfolioBalance(char* _portfolioName){
        return portfolioBalance.get()[_portfolioName];
    }

    /**
     * @brief query the portfolio name  whether  used or not 
     * @return true is used, false is not used
     */
    CONSTANT bool PortfolioManage::queryPortfolioNameIfUsed(char* _portfolioName){
        if(portfolioStorge.get()[_portfolioName] != ""){
            return true;
        } 
        return false;
    }

    /**
     * @brief query the change rate between DIP and current token
     * @return the change rate between DIP and current token
     */
    CONSTANT uint64_t PortfolioManage::queryChangeRate(){
        return changeRate.get();
    }
2019-12-19_15:14:48.866373: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/tools/abi/AbiMacro.cpp:82] smatch[2].str : PortfolioManage::withdrawPortfolio(; action : PortfolioManage::withdrawPortfolio

2019-12-19_15:14:48.866380: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/tools/abi/AbiMacro.cpp:131] Export macrostr:EXPORT  contract:void  actions_str:withdrawPortfolio

2019-12-19_15:14:48.866398: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/tools/abi/AbiMacro.cpp:149] get macro:EXPORT
2019-12-19_15:14:48.866404: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/tools/abi/AbiMacro.cpp:67] file_name : /Users/konggan/workspace/chain/dipperin/github-dipc/dipc/testcontract/PortfolioManage/PortfolioManage.cpp

2019-12-19_15:14:48.866410: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/tools/abi/AbiMacro.cpp:68] Export macrostr:EXPORT; long str :EXPORT; longstr :EXPORT void PortfolioManage::withdrawPool(uint64_t _balance){
        isOwner();
        Address ownerAddr = Address(owner.get()); 
        callTransfer(ownerAddr, _balance);
        *ownerTotalToken = ownerTotalToken.get() - _balance * changeRate.get();
        *totalToken = totalToken.get() - _balance * changeRate.get();
        DIPC_EMIT_EVENT(tokenCount, "ownerTotalToken", ownerTotalToken.get(), "totalToken", totalToken.get());
    }
    /**
     * @brief owner deposit to the contract address to get more token
     * @param _depositValue: the value num transfer to the contract address
     */
    PAYABLE void PortfolioManage::depositPool(uint64_t _depositValue){
        isOwner();
        //DipcAssert(_depositValue == dipc::callValue());
        uint64_t tokenBalance = changeU256ToUint64WithChangeRate(callValue(), changeRate.get()); 
        *ownerTotalToken = ownerTotalToken.get() + tokenBalance;
        *totalToken = totalToken.get() + tokenBalance;
        DIPC_EMIT_EVENT(tokenCount, "ownerTotalToken", ownerTotalToken.get(), "totalToken", totalToken.get());
    }
     /**
     * @brief query the total token in the contract
     * @return the total token int the contract
     */
    CONSTANT uint64_t PortfolioManage::queryTotalToken(){
        return totalToken.get();
    }

     /**
     * @brief query the token balance of the portfolio
     * @param _portfolioName : the portfolio name
     * @return the balance of the portfolio, the unit is token
     */
    CONSTANT uint64_t PortfolioManage::queryPortfolioBalance(char* _portfolioName){
        return portfolioBalance.get()[_portfolioName];
    }

    /**
     * @brief query the portfolio name  whether  used or not 
     * @return true is used, false is not used
     */
    CONSTANT bool PortfolioManage::queryPortfolioNameIfUsed(char* _portfolioName){
        if(portfolioStorge.get()[_portfolioName] != ""){
            return true;
        } 
        return false;
    }

    /**
     * @brief query the change rate between DIP and current token
     * @return the change rate between DIP and current token
     */
    CONSTANT uint64_t PortfolioManage::queryChangeRate(){
        return changeRate.get();
    }
2019-12-19_15:14:48.866436: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/tools/abi/AbiMacro.cpp:82] smatch[2].str : PortfolioManage::withdrawPool(; action : PortfolioManage::withdrawPool

2019-12-19_15:14:48.866443: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/tools/abi/AbiMacro.cpp:131] Export macrostr:EXPORT  contract:void  actions_str:withdrawPool

2019-12-19_15:14:48.866460: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/tools/abi/AbiMacro.cpp:149] get macro:PAYABLE
2019-12-19_15:14:48.866466: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/tools/abi/AbiMacro.cpp:67] file_name : /Users/konggan/workspace/chain/dipperin/github-dipc/dipc/testcontract/PortfolioManage/PortfolioManage.cpp

2019-12-19_15:14:48.866472: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/tools/abi/AbiMacro.cpp:68] Export macrostr:PAYABLE; long str :PAYABLE; longstr :PAYABLE void PortfolioManage::depositPool(uint64_t _depositValue){
        isOwner();
        //DipcAssert(_depositValue == dipc::callValue());
        uint64_t tokenBalance = changeU256ToUint64WithChangeRate(callValue(), changeRate.get()); 
        *ownerTotalToken = ownerTotalToken.get() + tokenBalance;
        *totalToken = totalToken.get() + tokenBalance;
        DIPC_EMIT_EVENT(tokenCount, "ownerTotalToken", ownerTotalToken.get(), "totalToken", totalToken.get());
    }
     /**
     * @brief query the total token in the contract
     * @return the total token int the contract
     */
    CONSTANT uint64_t PortfolioManage::queryTotalToken(){
        return totalToken.get();
    }

     /**
     * @brief query the token balance of the portfolio
     * @param _portfolioName : the portfolio name
     * @return the balance of the portfolio, the unit is token
     */
    CONSTANT uint64_t PortfolioManage::queryPortfolioBalance(char* _portfolioName){
        return portfolioBalance.get()[_portfolioName];
    }

    /**
     * @brief query the portfolio name  whether  used or not 
     * @return true is used, false is not used
     */
    CONSTANT bool PortfolioManage::queryPortfolioNameIfUsed(char* _portfolioName){
        if(portfolioStorge.get()[_portfolioName] != ""){
            return true;
        } 
        return false;
    }

    /**
     * @brief query the change rate between DIP and current token
     * @return the change rate between DIP and current token
     */
    CONSTANT uint64_t PortfolioManage::queryChangeRate(){
        return changeRate.get();
    }
2019-12-19_15:14:48.866498: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/tools/abi/AbiMacro.cpp:82] smatch[2].str : PortfolioManage::depositPool(; action : PortfolioManage::depositPool

2019-12-19_15:14:48.866505: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/tools/abi/AbiMacro.cpp:131] Export macrostr:PAYABLE  contract:void  actions_str:depositPool

2019-12-19_15:14:48.866520: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/tools/abi/AbiMacro.cpp:149] get macro:CONSTANT
2019-12-19_15:14:48.866527: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/tools/abi/AbiMacro.cpp:67] file_name : /Users/konggan/workspace/chain/dipperin/github-dipc/dipc/testcontract/PortfolioManage/PortfolioManage.cpp

2019-12-19_15:14:48.866532: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/tools/abi/AbiMacro.cpp:68] Export macrostr:CONSTANT; long str :CONSTANT; longstr :CONSTANT uint64_t PortfolioManage::queryTotalToken(){
        return totalToken.get();
    }

     /**
     * @brief query the token balance of the portfolio
     * @param _portfolioName : the portfolio name
     * @return the balance of the portfolio, the unit is token
     */
    CONSTANT uint64_t PortfolioManage::queryPortfolioBalance(char* _portfolioName){
        return portfolioBalance.get()[_portfolioName];
    }

    /**
     * @brief query the portfolio name  whether  used or not 
     * @return true is used, false is not used
     */
    CONSTANT bool PortfolioManage::queryPortfolioNameIfUsed(char* _portfolioName){
        if(portfolioStorge.get()[_portfolioName] != ""){
            return true;
        } 
        return false;
    }

    /**
     * @brief query the change rate between DIP and current token
     * @return the change rate between DIP and current token
     */
    CONSTANT uint64_t PortfolioManage::queryChangeRate(){
        return changeRate.get();
    }
2019-12-19_15:14:48.866555: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/tools/abi/AbiMacro.cpp:82] smatch[2].str : PortfolioManage::queryTotalToken(; action : PortfolioManage::queryTotalToken

2019-12-19_15:14:48.866562: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/tools/abi/AbiMacro.cpp:131] Export macrostr:CONSTANT  contract:uint64_t  actions_str:queryTotalToken

2019-12-19_15:14:48.866571: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/tools/abi/AbiMacro.cpp:149] get macro:CONSTANT
2019-12-19_15:14:48.866577: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/tools/abi/AbiMacro.cpp:67] file_name : /Users/konggan/workspace/chain/dipperin/github-dipc/dipc/testcontract/PortfolioManage/PortfolioManage.cpp

2019-12-19_15:14:48.866582: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/tools/abi/AbiMacro.cpp:68] Export macrostr:CONSTANT; long str :CONSTANT; longstr :CONSTANT uint64_t PortfolioManage::queryPortfolioBalance(char* _portfolioName){
        return portfolioBalance.get()[_portfolioName];
    }

    /**
     * @brief query the portfolio name  whether  used or not 
     * @return true is used, false is not used
     */
    CONSTANT bool PortfolioManage::queryPortfolioNameIfUsed(char* _portfolioName){
        if(portfolioStorge.get()[_portfolioName] != ""){
            return true;
        } 
        return false;
    }

    /**
     * @brief query the change rate between DIP and current token
     * @return the change rate between DIP and current token
     */
    CONSTANT uint64_t PortfolioManage::queryChangeRate(){
        return changeRate.get();
    }
2019-12-19_15:14:48.866611: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/tools/abi/AbiMacro.cpp:82] smatch[2].str : PortfolioManage::queryPortfolioBalance(; action : PortfolioManage::queryPortfolioBalance

2019-12-19_15:14:48.866618: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/tools/abi/AbiMacro.cpp:131] Export macrostr:CONSTANT  contract:uint64_t  actions_str:queryPortfolioBalance

2019-12-19_15:14:48.866627: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/tools/abi/AbiMacro.cpp:149] get macro:CONSTANT
2019-12-19_15:14:48.866633: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/tools/abi/AbiMacro.cpp:67] file_name : /Users/konggan/workspace/chain/dipperin/github-dipc/dipc/testcontract/PortfolioManage/PortfolioManage.cpp

2019-12-19_15:14:48.866638: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/tools/abi/AbiMacro.cpp:68] Export macrostr:CONSTANT; long str :CONSTANT; longstr :CONSTANT bool PortfolioManage::queryPortfolioNameIfUsed(char* _portfolioName){
        if(portfolioStorge.get()[_portfolioName] != ""){
            return true;
        } 
        return false;
    }

    /**
     * @brief query the change rate between DIP and current token
     * @return the change rate between DIP and current token
     */
    CONSTANT uint64_t PortfolioManage::queryChangeRate(){
        return changeRate.get();
    }
2019-12-19_15:14:48.866728: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/tools/abi/AbiMacro.cpp:82] smatch[2].str : PortfolioManage::queryPortfolioNameIfUsed(; action : PortfolioManage::queryPortfolioNameIfUsed

2019-12-19_15:14:48.866736: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/tools/abi/AbiMacro.cpp:131] Export macrostr:CONSTANT  contract:bool  actions_str:queryPortfolioNameIfUsed

2019-12-19_15:14:48.866748: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/tools/abi/AbiMacro.cpp:149] get macro:CONSTANT
2019-12-19_15:14:48.866754: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/tools/abi/AbiMacro.cpp:67] file_name : /Users/konggan/workspace/chain/dipperin/github-dipc/dipc/testcontract/PortfolioManage/PortfolioManage.cpp

2019-12-19_15:14:48.866759: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/tools/abi/AbiMacro.cpp:68] Export macrostr:CONSTANT; long str :CONSTANT; longstr :CONSTANT uint64_t PortfolioManage::queryChangeRate(){
        return changeRate.get();
    }
2019-12-19_15:14:48.866783: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/tools/abi/AbiMacro.cpp:82] smatch[2].str : PortfolioManage::queryChangeRate(; action : PortfolioManage::queryChangeRate

2019-12-19_15:14:48.866790: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/tools/abi/AbiMacro.cpp:131] Export macrostr:CONSTANT  contract:uint64_t  actions_str:queryChangeRate

2019-12-19_15:14:48.871984: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:1121] result:0contract fullname:[PortfolioManage]
2019-12-19_15:14:50.880002: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/tools/abi/AbiGenerator.cpp:109] contract != Token
2019-12-19_15:14:50.880027: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/tools/abi/AbiGenerator.cpp:111] decl name:[PortfolioManage] contract:[PortfolioManage]
2019-12-19_15:14:50.880041: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/tools/abi/AbiGenerator.cpp:119] funcEntire : void isOwner(){
        std::string callerStr = caller().toString();
        DipcAssert(callerStr == owner.get());
    ; funcEnd : }
    
    inline uint64_t getTotalBalance(){
        print("callValueUDIP");
        print(dipc::callValueUDIP());
        print(changeRate.get());
        //print(uint64_t(std::pow(10.0,3)));
       return dipc::callValueUDIP() * changeRate.get() / 1000;
    }
   

public:
    PAYABLE void init();
    EXPORT void setChangeRate(uint64_t _changeRate);
    EXPORT void setUserCanWithdraw(bool _canWithdraw);
    PAYABLE void createPortfolio(char* _portfolioName, char* _portfolioDesc);
    PAYABLE void depositPortfolio(char* _portfolioName);
    PAYABLE void createOrder(char* _portfolioName, char* _orderId, uint16_t _orderType, char* _stockCode, uint64_t _stockPrice, uint64_t _stockAmount, uint64_t _endTime);
    EXPORT void dealOrder(char* _portfolioName, char* _orderId);
    EXPORT void revocationOrder(char* _portfolioName, char* _orderId);
    EXPORT void withdrawPortfolio(char* _portfolioName, uint64_t _withdrawBalance);
    EXPORT void withdrawPool(uint64_t _balance);
    PAYABLE void depositPool(uint64_t _depositValue);
    CONSTANT uint64_t queryTotalToken();
    CONSTANT uint64_t queryPortfolioBalance(char* _portfolioName);
    CONSTANT bool queryPortfolioNameIfUsed(char* _portfolioName);
    CONSTANT uint64_t queryChangeRate();
};
DIPC_EVENT(initEvent, const char* ,uint64_t);
DIPC_EVENT(tokenCount, const char* ,uint64_t, const char*, uint64_t);
DIPC_EVENT(portfolioInfo, const char*, const char* ,const char* , uint64_t);
DIPC_EVENT(createOrder, const char*, const char*, const char*, const char*, const char*, uint64_t);
DIPC_EVENT(depositPortfolio, const char*, const char*, const char*, uint64_t);
DIPC_EVENT(revocationPortfolio, const char*, const char*, const char*, const char*);
DIPC_EVENT(dealPortfolio, const char*, const char*, const char*, const char*);
DIPC_EVENT(ErrEvent, const char*, const char*);
2019-12-19_15:14:50.880054: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/tools/abi/AbiGenerator.cpp:119] funcEntire : inline uint64_t getTotalBalance(){
        print("callValueUDIP");
        print(dipc::callValueUDIP());
        print(changeRate.get());
        //print(uint64_t(std::pow(10.0,3)));
       return dipc::callValueUDIP() * changeRate.get() / 1000;
    ; funcEnd : }
   

public:
    PAYABLE void init();
    EXPORT void setChangeRate(uint64_t _changeRate);
    EXPORT void setUserCanWithdraw(bool _canWithdraw);
    PAYABLE void createPortfolio(char* _portfolioName, char* _portfolioDesc);
    PAYABLE void depositPortfolio(char* _portfolioName);
    PAYABLE void createOrder(char* _portfolioName, char* _orderId, uint16_t _orderType, char* _stockCode, uint64_t _stockPrice, uint64_t _stockAmount, uint64_t _endTime);
    EXPORT void dealOrder(char* _portfolioName, char* _orderId);
    EXPORT void revocationOrder(char* _portfolioName, char* _orderId);
    EXPORT void withdrawPortfolio(char* _portfolioName, uint64_t _withdrawBalance);
    EXPORT void withdrawPool(uint64_t _balance);
    PAYABLE void depositPool(uint64_t _depositValue);
    CONSTANT uint64_t queryTotalToken();
    CONSTANT uint64_t queryPortfolioBalance(char* _portfolioName);
    CONSTANT bool queryPortfolioNameIfUsed(char* _portfolioName);
    CONSTANT uint64_t queryChangeRate();
};
DIPC_EVENT(initEvent, const char* ,uint64_t);
DIPC_EVENT(tokenCount, const char* ,uint64_t, const char*, uint64_t);
DIPC_EVENT(portfolioInfo, const char*, const char* ,const char* , uint64_t);
DIPC_EVENT(createOrder, const char*, const char*, const char*, const char*, const char*, uint64_t);
DIPC_EVENT(depositPortfolio, const char*, const char*, const char*, uint64_t);
DIPC_EVENT(revocationPortfolio, const char*, const char*, const char*, const char*);
DIPC_EVENT(dealPortfolio, const char*, const char*, const char*, const char*);
DIPC_EVENT(ErrEvent, const char*, const char*);
2019-12-19_15:14:50.880061: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/tools/abi/AbiGenerator.cpp:119] funcEntire : void init(; funcEnd : );
    EXPORT void setChangeRate(uint64_t _changeRate);
    EXPORT void setUserCanWithdraw(bool _canWithdraw);
    PAYABLE void createPortfolio(char* _portfolioName, char* _portfolioDesc);
    PAYABLE void depositPortfolio(char* _portfolioName);
    PAYABLE void createOrder(char* _portfolioName, char* _orderId, uint16_t _orderType, char* _stockCode, uint64_t _stockPrice, uint64_t _stockAmount, uint64_t _endTime);
    EXPORT void dealOrder(char* _portfolioName, char* _orderId);
    EXPORT void revocationOrder(char* _portfolioName, char* _orderId);
    EXPORT void withdrawPortfolio(char* _portfolioName, uint64_t _withdrawBalance);
    EXPORT void withdrawPool(uint64_t _balance);
    PAYABLE void depositPool(uint64_t _depositValue);
    CONSTANT uint64_t queryTotalToken();
    CONSTANT uint64_t queryPortfolioBalance(char* _portfolioName);
    CONSTANT bool queryPortfolioNameIfUsed(char* _portfolioName);
    CONSTANT uint64_t queryChangeRate();
};
DIPC_EVENT(initEvent, const char* ,uint64_t);
DIPC_EVENT(tokenCount, const char* ,uint64_t, const char*, uint64_t);
DIPC_EVENT(portfolioInfo, const char*, const char* ,const char* , uint64_t);
DIPC_EVENT(createOrder, const char*, const char*, const char*, const char*, const char*, uint64_t);
DIPC_EVENT(depositPortfolio, const char*, const char*, const char*, uint64_t);
DIPC_EVENT(revocationPortfolio, const char*, const char*, const char*, const char*);
DIPC_EVENT(dealPortfolio, const char*, const char*, const char*, const char*);
DIPC_EVENT(ErrEvent, const char*, const char*);
2019-12-19_15:14:50.880068: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/tools/abi/AbiGenerator.cpp:124] method :init
2019-12-19_15:14:50.880074: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/tools/abi/AbiGenerator.cpp:145] abi.methodName : init; abi.isConst : false; abi.isPayable :true; abi.isExport :false
2019-12-19_15:14:50.880096: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/tools/abi/AbiGenerator.cpp:47] typeName:  realTypeName:void
2019-12-19_15:14:50.880104: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/tools/abi/AbiGenerator.cpp:119] funcEntire : void setChangeRate(uint64_t _changeRate; funcEnd : );
    EXPORT void setUserCanWithdraw(bool _canWithdraw);
    PAYABLE void createPortfolio(char* _portfolioName, char* _portfolioDesc);
    PAYABLE void depositPortfolio(char* _portfolioName);
    PAYABLE void createOrder(char* _portfolioName, char* _orderId, uint16_t _orderType, char* _stockCode, uint64_t _stockPrice, uint64_t _stockAmount, uint64_t _endTime);
    EXPORT void dealOrder(char* _portfolioName, char* _orderId);
    EXPORT void revocationOrder(char* _portfolioName, char* _orderId);
    EXPORT void withdrawPortfolio(char* _portfolioName, uint64_t _withdrawBalance);
    EXPORT void withdrawPool(uint64_t _balance);
    PAYABLE void depositPool(uint64_t _depositValue);
    CONSTANT uint64_t queryTotalToken();
    CONSTANT uint64_t queryPortfolioBalance(char* _portfolioName);
    CONSTANT bool queryPortfolioNameIfUsed(char* _portfolioName);
    CONSTANT uint64_t queryChangeRate();
};
DIPC_EVENT(initEvent, const char* ,uint64_t);
DIPC_EVENT(tokenCount, const char* ,uint64_t, const char*, uint64_t);
DIPC_EVENT(portfolioInfo, const char*, const char* ,const char* , uint64_t);
DIPC_EVENT(createOrder, const char*, const char*, const char*, const char*, const char*, uint64_t);
DIPC_EVENT(depositPortfolio, const char*, const char*, const char*, uint64_t);
DIPC_EVENT(revocationPortfolio, const char*, const char*, const char*, const char*);
DIPC_EVENT(dealPortfolio, const char*, const char*, const char*, const char*);
DIPC_EVENT(ErrEvent, const char*, const char*);
2019-12-19_15:14:50.880110: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/tools/abi/AbiGenerator.cpp:124] method :setChangeRate
2019-12-19_15:14:50.880116: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/tools/abi/AbiGenerator.cpp:145] abi.methodName : setChangeRate; abi.isConst : false; abi.isPayable :false; abi.isExport :true
2019-12-19_15:14:50.880126: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/tools/abi/AbiGenerator.cpp:47] typeName:  realTypeName:void
2019-12-19_15:14:50.880132: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/tools/abi/AbiGenerator.cpp:160] parame name:_changeRate
2019-12-19_15:14:50.880138: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/tools/abi/AbiGenerator.cpp:26] xxx:uint64_t
2019-12-19_15:14:50.880144: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/tools/abi/AbiGenerator.cpp:28] set typeName
2019-12-19_15:14:50.880156: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/tools/abi/AbiGenerator.cpp:47] typeName:uint64_t  realTypeName:unsigned long long
2019-12-19_15:14:50.880184: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/tools/abi/AbiGenerator.cpp:119] funcEntire : void setUserCanWithdraw(bool _canWithdraw; funcEnd : );
    PAYABLE void createPortfolio(char* _portfolioName, char* _portfolioDesc);
    PAYABLE void depositPortfolio(char* _portfolioName);
    PAYABLE void createOrder(char* _portfolioName, char* _orderId, uint16_t _orderType, char* _stockCode, uint64_t _stockPrice, uint64_t _stockAmount, uint64_t _endTime);
    EXPORT void dealOrder(char* _portfolioName, char* _orderId);
    EXPORT void revocationOrder(char* _portfolioName, char* _orderId);
    EXPORT void withdrawPortfolio(char* _portfolioName, uint64_t _withdrawBalance);
    EXPORT void withdrawPool(uint64_t _balance);
    PAYABLE void depositPool(uint64_t _depositValue);
    CONSTANT uint64_t queryTotalToken();
    CONSTANT uint64_t queryPortfolioBalance(char* _portfolioName);
    CONSTANT bool queryPortfolioNameIfUsed(char* _portfolioName);
    CONSTANT uint64_t queryChangeRate();
};
DIPC_EVENT(initEvent, const char* ,uint64_t);
DIPC_EVENT(tokenCount, const char* ,uint64_t, const char*, uint64_t);
DIPC_EVENT(portfolioInfo, const char*, const char* ,const char* , uint64_t);
DIPC_EVENT(createOrder, const char*, const char*, const char*, const char*, const char*, uint64_t);
DIPC_EVENT(depositPortfolio, const char*, const char*, const char*, uint64_t);
DIPC_EVENT(revocationPortfolio, const char*, const char*, const char*, const char*);
DIPC_EVENT(dealPortfolio, const char*, const char*, const char*, const char*);
DIPC_EVENT(ErrEvent, const char*, const char*);
2019-12-19_15:14:50.880192: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/tools/abi/AbiGenerator.cpp:124] method :setUserCanWithdraw
2019-12-19_15:14:50.880198: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/tools/abi/AbiGenerator.cpp:145] abi.methodName : setUserCanWithdraw; abi.isConst : false; abi.isPayable :false; abi.isExport :true
2019-12-19_15:14:50.880208: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/tools/abi/AbiGenerator.cpp:47] typeName:  realTypeName:void
2019-12-19_15:14:50.880214: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/tools/abi/AbiGenerator.cpp:160] parame name:_canWithdraw
2019-12-19_15:14:50.880223: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/tools/abi/AbiGenerator.cpp:47] typeName:  realTypeName:_Bool
2019-12-19_15:14:50.880247: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/tools/abi/AbiGenerator.cpp:119] funcEntire : void createPortfolio(char* _portfolioName, char* _portfolioDesc; funcEnd : );
    PAYABLE void depositPortfolio(char* _portfolioName);
    PAYABLE void createOrder(char* _portfolioName, char* _orderId, uint16_t _orderType, char* _stockCode, uint64_t _stockPrice, uint64_t _stockAmount, uint64_t _endTime);
    EXPORT void dealOrder(char* _portfolioName, char* _orderId);
    EXPORT void revocationOrder(char* _portfolioName, char* _orderId);
    EXPORT void withdrawPortfolio(char* _portfolioName, uint64_t _withdrawBalance);
    EXPORT void withdrawPool(uint64_t _balance);
    PAYABLE void depositPool(uint64_t _depositValue);
    CONSTANT uint64_t queryTotalToken();
    CONSTANT uint64_t queryPortfolioBalance(char* _portfolioName);
    CONSTANT bool queryPortfolioNameIfUsed(char* _portfolioName);
    CONSTANT uint64_t queryChangeRate();
};
DIPC_EVENT(initEvent, const char* ,uint64_t);
DIPC_EVENT(tokenCount, const char* ,uint64_t, const char*, uint64_t);
DIPC_EVENT(portfolioInfo, const char*, const char* ,const char* , uint64_t);
DIPC_EVENT(createOrder, const char*, const char*, const char*, const char*, const char*, uint64_t);
DIPC_EVENT(depositPortfolio, const char*, const char*, const char*, uint64_t);
DIPC_EVENT(revocationPortfolio, const char*, const char*, const char*, const char*);
DIPC_EVENT(dealPortfolio, const char*, const char*, const char*, const char*);
DIPC_EVENT(ErrEvent, const char*, const char*);
2019-12-19_15:14:50.880254: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/tools/abi/AbiGenerator.cpp:124] method :createPortfolio
2019-12-19_15:14:50.880260: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/tools/abi/AbiGenerator.cpp:145] abi.methodName : createPortfolio; abi.isConst : false; abi.isPayable :true; abi.isExport :false
2019-12-19_15:14:50.880269: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/tools/abi/AbiGenerator.cpp:47] typeName:  realTypeName:void
2019-12-19_15:14:50.880275: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/tools/abi/AbiGenerator.cpp:160] parame name:_portfolioName
2019-12-19_15:14:50.880287: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/tools/abi/AbiGenerator.cpp:47] typeName:  realTypeName:char *
2019-12-19_15:14:50.880312: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/tools/abi/AbiGenerator.cpp:160] parame name:_portfolioDesc
2019-12-19_15:14:50.880323: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/tools/abi/AbiGenerator.cpp:47] typeName:  realTypeName:char *
2019-12-19_15:14:50.880352: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/tools/abi/AbiGenerator.cpp:119] funcEntire : void depositPortfolio(char* _portfolioName; funcEnd : );
    PAYABLE void createOrder(char* _portfolioName, char* _orderId, uint16_t _orderType, char* _stockCode, uint64_t _stockPrice, uint64_t _stockAmount, uint64_t _endTime);
    EXPORT void dealOrder(char* _portfolioName, char* _orderId);
    EXPORT void revocationOrder(char* _portfolioName, char* _orderId);
    EXPORT void withdrawPortfolio(char* _portfolioName, uint64_t _withdrawBalance);
    EXPORT void withdrawPool(uint64_t _balance);
    PAYABLE void depositPool(uint64_t _depositValue);
    CONSTANT uint64_t queryTotalToken();
    CONSTANT uint64_t queryPortfolioBalance(char* _portfolioName);
    CONSTANT bool queryPortfolioNameIfUsed(char* _portfolioName);
    CONSTANT uint64_t queryChangeRate();
};
DIPC_EVENT(initEvent, const char* ,uint64_t);
DIPC_EVENT(tokenCount, const char* ,uint64_t, const char*, uint64_t);
DIPC_EVENT(portfolioInfo, const char*, const char* ,const char* , uint64_t);
DIPC_EVENT(createOrder, const char*, const char*, const char*, const char*, const char*, uint64_t);
DIPC_EVENT(depositPortfolio, const char*, const char*, const char*, uint64_t);
DIPC_EVENT(revocationPortfolio, const char*, const char*, const char*, const char*);
DIPC_EVENT(dealPortfolio, const char*, const char*, const char*, const char*);
DIPC_EVENT(ErrEvent, const char*, const char*);
2019-12-19_15:14:50.880360: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/tools/abi/AbiGenerator.cpp:124] method :depositPortfolio
2019-12-19_15:14:50.880365: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/tools/abi/AbiGenerator.cpp:145] abi.methodName : depositPortfolio; abi.isConst : false; abi.isPayable :true; abi.isExport :false
2019-12-19_15:14:50.880375: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/tools/abi/AbiGenerator.cpp:47] typeName:  realTypeName:void
2019-12-19_15:14:50.880381: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/tools/abi/AbiGenerator.cpp:160] parame name:_portfolioName
2019-12-19_15:14:50.880392: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/tools/abi/AbiGenerator.cpp:47] typeName:  realTypeName:char *
2019-12-19_15:14:50.880416: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/tools/abi/AbiGenerator.cpp:119] funcEntire : void createOrder(char* _portfolioName, char* _orderId, uint16_t _orderType, char* _stockCode, uint64_t _stockPrice, uint64_t _stockAmount, uint64_t _endTime; funcEnd : );
    EXPORT void dealOrder(char* _portfolioName, char* _orderId);
    EXPORT void revocationOrder(char* _portfolioName, char* _orderId);
    EXPORT void withdrawPortfolio(char* _portfolioName, uint64_t _withdrawBalance);
    EXPORT void withdrawPool(uint64_t _balance);
    PAYABLE void depositPool(uint64_t _depositValue);
    CONSTANT uint64_t queryTotalToken();
    CONSTANT uint64_t queryPortfolioBalance(char* _portfolioName);
    CONSTANT bool queryPortfolioNameIfUsed(char* _portfolioName);
    CONSTANT uint64_t queryChangeRate();
};
DIPC_EVENT(initEvent, const char* ,uint64_t);
DIPC_EVENT(tokenCount, const char* ,uint64_t, const char*, uint64_t);
DIPC_EVENT(portfolioInfo, const char*, const char* ,const char* , uint64_t);
DIPC_EVENT(createOrder, const char*, const char*, const char*, const char*, const char*, uint64_t);
DIPC_EVENT(depositPortfolio, const char*, const char*, const char*, uint64_t);
DIPC_EVENT(revocationPortfolio, const char*, const char*, const char*, const char*);
DIPC_EVENT(dealPortfolio, const char*, const char*, const char*, const char*);
DIPC_EVENT(ErrEvent, const char*, const char*);
2019-12-19_15:14:50.880423: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/tools/abi/AbiGenerator.cpp:124] method :createOrder
2019-12-19_15:14:50.880429: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/tools/abi/AbiGenerator.cpp:145] abi.methodName : createOrder; abi.isConst : false; abi.isPayable :true; abi.isExport :false
2019-12-19_15:14:50.880439: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/tools/abi/AbiGenerator.cpp:47] typeName:  realTypeName:void
2019-12-19_15:14:50.880445: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/tools/abi/AbiGenerator.cpp:160] parame name:_portfolioName
2019-12-19_15:14:50.880455: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/tools/abi/AbiGenerator.cpp:47] typeName:  realTypeName:char *
2019-12-19_15:14:50.880479: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/tools/abi/AbiGenerator.cpp:160] parame name:_orderId
2019-12-19_15:14:50.880489: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/tools/abi/AbiGenerator.cpp:47] typeName:  realTypeName:char *
2019-12-19_15:14:50.880512: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/tools/abi/AbiGenerator.cpp:160] parame name:_orderType
2019-12-19_15:14:50.880519: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/tools/abi/AbiGenerator.cpp:26] xxx:uint16_t
2019-12-19_15:14:50.880524: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/tools/abi/AbiGenerator.cpp:28] set typeName
2019-12-19_15:14:50.880535: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/tools/abi/AbiGenerator.cpp:47] typeName:uint16_t  realTypeName:unsigned short
2019-12-19_15:14:50.880557: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/tools/abi/AbiGenerator.cpp:160] parame name:_stockCode
2019-12-19_15:14:50.880567: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/tools/abi/AbiGenerator.cpp:47] typeName:  realTypeName:char *
2019-12-19_15:14:50.880590: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/tools/abi/AbiGenerator.cpp:160] parame name:_stockPrice
2019-12-19_15:14:50.880596: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/tools/abi/AbiGenerator.cpp:26] xxx:uint64_t
2019-12-19_15:14:50.880601: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/tools/abi/AbiGenerator.cpp:28] set typeName
2019-12-19_15:14:50.880613: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/tools/abi/AbiGenerator.cpp:47] typeName:uint64_t  realTypeName:unsigned long long
2019-12-19_15:14:50.880634: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/tools/abi/AbiGenerator.cpp:160] parame name:_stockAmount
2019-12-19_15:14:50.880640: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/tools/abi/AbiGenerator.cpp:26] xxx:uint64_t
2019-12-19_15:14:50.880645: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/tools/abi/AbiGenerator.cpp:28] set typeName
2019-12-19_15:14:50.880657: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/tools/abi/AbiGenerator.cpp:47] typeName:uint64_t  realTypeName:unsigned long long
2019-12-19_15:14:50.880678: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/tools/abi/AbiGenerator.cpp:160] parame name:_endTime
2019-12-19_15:14:50.880684: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/tools/abi/AbiGenerator.cpp:26] xxx:uint64_t
2019-12-19_15:14:50.880689: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/tools/abi/AbiGenerator.cpp:28] set typeName
2019-12-19_15:14:50.880701: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/tools/abi/AbiGenerator.cpp:47] typeName:uint64_t  realTypeName:unsigned long long
2019-12-19_15:14:50.880723: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/tools/abi/AbiGenerator.cpp:119] funcEntire : void dealOrder(char* _portfolioName, char* _orderId; funcEnd : );
    EXPORT void revocationOrder(char* _portfolioName, char* _orderId);
    EXPORT void withdrawPortfolio(char* _portfolioName, uint64_t _withdrawBalance);
    EXPORT void withdrawPool(uint64_t _balance);
    PAYABLE void depositPool(uint64_t _depositValue);
    CONSTANT uint64_t queryTotalToken();
    CONSTANT uint64_t queryPortfolioBalance(char* _portfolioName);
    CONSTANT bool queryPortfolioNameIfUsed(char* _portfolioName);
    CONSTANT uint64_t queryChangeRate();
};
DIPC_EVENT(initEvent, const char* ,uint64_t);
DIPC_EVENT(tokenCount, const char* ,uint64_t, const char*, uint64_t);
DIPC_EVENT(portfolioInfo, const char*, const char* ,const char* , uint64_t);
DIPC_EVENT(createOrder, const char*, const char*, const char*, const char*, const char*, uint64_t);
DIPC_EVENT(depositPortfolio, const char*, const char*, const char*, uint64_t);
DIPC_EVENT(revocationPortfolio, const char*, const char*, const char*, const char*);
DIPC_EVENT(dealPortfolio, const char*, const char*, const char*, const char*);
DIPC_EVENT(ErrEvent, const char*, const char*);
2019-12-19_15:14:50.880730: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/tools/abi/AbiGenerator.cpp:124] method :dealOrder
2019-12-19_15:14:50.880736: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/tools/abi/AbiGenerator.cpp:145] abi.methodName : dealOrder; abi.isConst : false; abi.isPayable :false; abi.isExport :true
2019-12-19_15:14:50.880746: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/tools/abi/AbiGenerator.cpp:47] typeName:  realTypeName:void
2019-12-19_15:14:50.880752: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/tools/abi/AbiGenerator.cpp:160] parame name:_portfolioName
2019-12-19_15:14:50.880763: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/tools/abi/AbiGenerator.cpp:47] typeName:  realTypeName:char *
2019-12-19_15:14:50.880786: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/tools/abi/AbiGenerator.cpp:160] parame name:_orderId
2019-12-19_15:14:50.880797: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/tools/abi/AbiGenerator.cpp:47] typeName:  realTypeName:char *
2019-12-19_15:14:50.880821: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/tools/abi/AbiGenerator.cpp:119] funcEntire : void revocationOrder(char* _portfolioName, char* _orderId; funcEnd : );
    EXPORT void withdrawPortfolio(char* _portfolioName, uint64_t _withdrawBalance);
    EXPORT void withdrawPool(uint64_t _balance);
    PAYABLE void depositPool(uint64_t _depositValue);
    CONSTANT uint64_t queryTotalToken();
    CONSTANT uint64_t queryPortfolioBalance(char* _portfolioName);
    CONSTANT bool queryPortfolioNameIfUsed(char* _portfolioName);
    CONSTANT uint64_t queryChangeRate();
};
DIPC_EVENT(initEvent, const char* ,uint64_t);
DIPC_EVENT(tokenCount, const char* ,uint64_t, const char*, uint64_t);
DIPC_EVENT(portfolioInfo, const char*, const char* ,const char* , uint64_t);
DIPC_EVENT(createOrder, const char*, const char*, const char*, const char*, const char*, uint64_t);
DIPC_EVENT(depositPortfolio, const char*, const char*, const char*, uint64_t);
DIPC_EVENT(revocationPortfolio, const char*, const char*, const char*, const char*);
DIPC_EVENT(dealPortfolio, const char*, const char*, const char*, const char*);
DIPC_EVENT(ErrEvent, const char*, const char*);
2019-12-19_15:14:50.880827: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/tools/abi/AbiGenerator.cpp:124] method :revocationOrder
2019-12-19_15:14:50.880834: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/tools/abi/AbiGenerator.cpp:145] abi.methodName : revocationOrder; abi.isConst : false; abi.isPayable :false; abi.isExport :true
2019-12-19_15:14:50.880843: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/tools/abi/AbiGenerator.cpp:47] typeName:  realTypeName:void
2019-12-19_15:14:50.880849: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/tools/abi/AbiGenerator.cpp:160] parame name:_portfolioName
2019-12-19_15:14:50.880860: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/tools/abi/AbiGenerator.cpp:47] typeName:  realTypeName:char *
2019-12-19_15:14:50.880884: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/tools/abi/AbiGenerator.cpp:160] parame name:_orderId
2019-12-19_15:14:50.880894: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/tools/abi/AbiGenerator.cpp:47] typeName:  realTypeName:char *
2019-12-19_15:14:50.880918: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/tools/abi/AbiGenerator.cpp:119] funcEntire : void withdrawPortfolio(char* _portfolioName, uint64_t _withdrawBalance; funcEnd : );
    EXPORT void withdrawPool(uint64_t _balance);
    PAYABLE void depositPool(uint64_t _depositValue);
    CONSTANT uint64_t queryTotalToken();
    CONSTANT uint64_t queryPortfolioBalance(char* _portfolioName);
    CONSTANT bool queryPortfolioNameIfUsed(char* _portfolioName);
    CONSTANT uint64_t queryChangeRate();
};
DIPC_EVENT(initEvent, const char* ,uint64_t);
DIPC_EVENT(tokenCount, const char* ,uint64_t, const char*, uint64_t);
DIPC_EVENT(portfolioInfo, const char*, const char* ,const char* , uint64_t);
DIPC_EVENT(createOrder, const char*, const char*, const char*, const char*, const char*, uint64_t);
DIPC_EVENT(depositPortfolio, const char*, const char*, const char*, uint64_t);
DIPC_EVENT(revocationPortfolio, const char*, const char*, const char*, const char*);
DIPC_EVENT(dealPortfolio, const char*, const char*, const char*, const char*);
DIPC_EVENT(ErrEvent, const char*, const char*);
2019-12-19_15:14:50.880924: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/tools/abi/AbiGenerator.cpp:124] method :withdrawPortfolio
2019-12-19_15:14:50.880930: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/tools/abi/AbiGenerator.cpp:145] abi.methodName : withdrawPortfolio; abi.isConst : false; abi.isPayable :false; abi.isExport :true
2019-12-19_15:14:50.880940: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/tools/abi/AbiGenerator.cpp:47] typeName:  realTypeName:void
2019-12-19_15:14:50.880946: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/tools/abi/AbiGenerator.cpp:160] parame name:_portfolioName
2019-12-19_15:14:50.880956: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/tools/abi/AbiGenerator.cpp:47] typeName:  realTypeName:char *
2019-12-19_15:14:50.880979: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/tools/abi/AbiGenerator.cpp:160] parame name:_withdrawBalance
2019-12-19_15:14:50.880985: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/tools/abi/AbiGenerator.cpp:26] xxx:uint64_t
2019-12-19_15:14:50.880990: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/tools/abi/AbiGenerator.cpp:28] set typeName
2019-12-19_15:14:50.881002: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/tools/abi/AbiGenerator.cpp:47] typeName:uint64_t  realTypeName:unsigned long long
2019-12-19_15:14:50.881025: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/tools/abi/AbiGenerator.cpp:119] funcEntire : void withdrawPool(uint64_t _balance; funcEnd : );
    PAYABLE void depositPool(uint64_t _depositValue);
    CONSTANT uint64_t queryTotalToken();
    CONSTANT uint64_t queryPortfolioBalance(char* _portfolioName);
    CONSTANT bool queryPortfolioNameIfUsed(char* _portfolioName);
    CONSTANT uint64_t queryChangeRate();
};
DIPC_EVENT(initEvent, const char* ,uint64_t);
DIPC_EVENT(tokenCount, const char* ,uint64_t, const char*, uint64_t);
DIPC_EVENT(portfolioInfo, const char*, const char* ,const char* , uint64_t);
DIPC_EVENT(createOrder, const char*, const char*, const char*, const char*, const char*, uint64_t);
DIPC_EVENT(depositPortfolio, const char*, const char*, const char*, uint64_t);
DIPC_EVENT(revocationPortfolio, const char*, const char*, const char*, const char*);
DIPC_EVENT(dealPortfolio, const char*, const char*, const char*, const char*);
DIPC_EVENT(ErrEvent, const char*, const char*);
2019-12-19_15:14:50.881032: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/tools/abi/AbiGenerator.cpp:124] method :withdrawPool
2019-12-19_15:14:50.881039: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/tools/abi/AbiGenerator.cpp:145] abi.methodName : withdrawPool; abi.isConst : false; abi.isPayable :false; abi.isExport :true
2019-12-19_15:14:50.881048: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/tools/abi/AbiGenerator.cpp:47] typeName:  realTypeName:void
2019-12-19_15:14:50.881054: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/tools/abi/AbiGenerator.cpp:160] parame name:_balance
2019-12-19_15:14:50.881060: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/tools/abi/AbiGenerator.cpp:26] xxx:uint64_t
2019-12-19_15:14:50.881065: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/tools/abi/AbiGenerator.cpp:28] set typeName
2019-12-19_15:14:50.881077: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/tools/abi/AbiGenerator.cpp:47] typeName:uint64_t  realTypeName:unsigned long long
2019-12-19_15:14:50.881099: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/tools/abi/AbiGenerator.cpp:119] funcEntire : void depositPool(uint64_t _depositValue; funcEnd : );
    CONSTANT uint64_t queryTotalToken();
    CONSTANT uint64_t queryPortfolioBalance(char* _portfolioName);
    CONSTANT bool queryPortfolioNameIfUsed(char* _portfolioName);
    CONSTANT uint64_t queryChangeRate();
};
DIPC_EVENT(initEvent, const char* ,uint64_t);
DIPC_EVENT(tokenCount, const char* ,uint64_t, const char*, uint64_t);
DIPC_EVENT(portfolioInfo, const char*, const char* ,const char* , uint64_t);
DIPC_EVENT(createOrder, const char*, const char*, const char*, const char*, const char*, uint64_t);
DIPC_EVENT(depositPortfolio, const char*, const char*, const char*, uint64_t);
DIPC_EVENT(revocationPortfolio, const char*, const char*, const char*, const char*);
DIPC_EVENT(dealPortfolio, const char*, const char*, const char*, const char*);
DIPC_EVENT(ErrEvent, const char*, const char*);
2019-12-19_15:14:50.881106: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/tools/abi/AbiGenerator.cpp:124] method :depositPool
2019-12-19_15:14:50.881111: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/tools/abi/AbiGenerator.cpp:145] abi.methodName : depositPool; abi.isConst : false; abi.isPayable :true; abi.isExport :false
2019-12-19_15:14:50.881121: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/tools/abi/AbiGenerator.cpp:47] typeName:  realTypeName:void
2019-12-19_15:14:50.881126: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/tools/abi/AbiGenerator.cpp:160] parame name:_depositValue
2019-12-19_15:14:50.881132: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/tools/abi/AbiGenerator.cpp:26] xxx:uint64_t
2019-12-19_15:14:50.881137: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/tools/abi/AbiGenerator.cpp:28] set typeName
2019-12-19_15:14:50.881149: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/tools/abi/AbiGenerator.cpp:47] typeName:uint64_t  realTypeName:unsigned long long
2019-12-19_15:14:50.881171: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/tools/abi/AbiGenerator.cpp:119] funcEntire : uint64_t queryTotalToken(; funcEnd : );
    CONSTANT uint64_t queryPortfolioBalance(char* _portfolioName);
    CONSTANT bool queryPortfolioNameIfUsed(char* _portfolioName);
    CONSTANT uint64_t queryChangeRate();
};
DIPC_EVENT(initEvent, const char* ,uint64_t);
DIPC_EVENT(tokenCount, const char* ,uint64_t, const char*, uint64_t);
DIPC_EVENT(portfolioInfo, const char*, const char* ,const char* , uint64_t);
DIPC_EVENT(createOrder, const char*, const char*, const char*, const char*, const char*, uint64_t);
DIPC_EVENT(depositPortfolio, const char*, const char*, const char*, uint64_t);
DIPC_EVENT(revocationPortfolio, const char*, const char*, const char*, const char*);
DIPC_EVENT(dealPortfolio, const char*, const char*, const char*, const char*);
DIPC_EVENT(ErrEvent, const char*, const char*);
2019-12-19_15:14:50.881178: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/tools/abi/AbiGenerator.cpp:124] method :queryTotalToken
2019-12-19_15:14:50.881184: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/tools/abi/AbiGenerator.cpp:145] abi.methodName : queryTotalToken; abi.isConst : true; abi.isPayable :false; abi.isExport :false
2019-12-19_15:14:50.881190: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/tools/abi/AbiGenerator.cpp:26] xxx:uint64_t
2019-12-19_15:14:50.881195: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/tools/abi/AbiGenerator.cpp:28] set typeName
2019-12-19_15:14:50.881207: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/tools/abi/AbiGenerator.cpp:47] typeName:uint64_t  realTypeName:unsigned long long
2019-12-19_15:14:50.881214: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/tools/abi/AbiGenerator.cpp:119] funcEntire : uint64_t queryPortfolioBalance(char* _portfolioName; funcEnd : );
    CONSTANT bool queryPortfolioNameIfUsed(char* _portfolioName);
    CONSTANT uint64_t queryChangeRate();
};
DIPC_EVENT(initEvent, const char* ,uint64_t);
DIPC_EVENT(tokenCount, const char* ,uint64_t, const char*, uint64_t);
DIPC_EVENT(portfolioInfo, const char*, const char* ,const char* , uint64_t);
DIPC_EVENT(createOrder, const char*, const char*, const char*, const char*, const char*, uint64_t);
DIPC_EVENT(depositPortfolio, const char*, const char*, const char*, uint64_t);
DIPC_EVENT(revocationPortfolio, const char*, const char*, const char*, const char*);
DIPC_EVENT(dealPortfolio, const char*, const char*, const char*, const char*);
DIPC_EVENT(ErrEvent, const char*, const char*);
2019-12-19_15:14:50.881220: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/tools/abi/AbiGenerator.cpp:124] method :queryPortfolioBalance
2019-12-19_15:14:50.881226: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/tools/abi/AbiGenerator.cpp:145] abi.methodName : queryPortfolioBalance; abi.isConst : true; abi.isPayable :false; abi.isExport :false
2019-12-19_15:14:50.881232: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/tools/abi/AbiGenerator.cpp:26] xxx:uint64_t
2019-12-19_15:14:50.881237: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/tools/abi/AbiGenerator.cpp:28] set typeName
2019-12-19_15:14:50.881248: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/tools/abi/AbiGenerator.cpp:47] typeName:uint64_t  realTypeName:unsigned long long
2019-12-19_15:14:50.881254: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/tools/abi/AbiGenerator.cpp:160] parame name:_portfolioName
2019-12-19_15:14:50.881265: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/tools/abi/AbiGenerator.cpp:47] typeName:  realTypeName:char *
2019-12-19_15:14:50.881288: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/tools/abi/AbiGenerator.cpp:119] funcEntire : bool queryPortfolioNameIfUsed(char* _portfolioName; funcEnd : );
    CONSTANT uint64_t queryChangeRate();
};
DIPC_EVENT(initEvent, const char* ,uint64_t);
DIPC_EVENT(tokenCount, const char* ,uint64_t, const char*, uint64_t);
DIPC_EVENT(portfolioInfo, const char*, const char* ,const char* , uint64_t);
DIPC_EVENT(createOrder, const char*, const char*, const char*, const char*, const char*, uint64_t);
DIPC_EVENT(depositPortfolio, const char*, const char*, const char*, uint64_t);
DIPC_EVENT(revocationPortfolio, const char*, const char*, const char*, const char*);
DIPC_EVENT(dealPortfolio, const char*, const char*, const char*, const char*);
DIPC_EVENT(ErrEvent, const char*, const char*);
2019-12-19_15:14:50.881295: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/tools/abi/AbiGenerator.cpp:124] method :queryPortfolioNameIfUsed
2019-12-19_15:14:50.881302: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/tools/abi/AbiGenerator.cpp:145] abi.methodName : queryPortfolioNameIfUsed; abi.isConst : true; abi.isPayable :false; abi.isExport :false
2019-12-19_15:14:50.881313: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/tools/abi/AbiGenerator.cpp:47] typeName:  realTypeName:_Bool
2019-12-19_15:14:50.881319: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/tools/abi/AbiGenerator.cpp:160] parame name:_portfolioName
2019-12-19_15:14:50.881329: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/tools/abi/AbiGenerator.cpp:47] typeName:  realTypeName:char *
2019-12-19_15:14:50.881353: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/tools/abi/AbiGenerator.cpp:119] funcEntire : uint64_t queryChangeRate(; funcEnd : );
};
DIPC_EVENT(initEvent, const char* ,uint64_t);
DIPC_EVENT(tokenCount, const char* ,uint64_t, const char*, uint64_t);
DIPC_EVENT(portfolioInfo, const char*, const char* ,const char* , uint64_t);
DIPC_EVENT(createOrder, const char*, const char*, const char*, const char*, const char*, uint64_t);
DIPC_EVENT(depositPortfolio, const char*, const char*, const char*, uint64_t);
DIPC_EVENT(revocationPortfolio, const char*, const char*, const char*, const char*);
DIPC_EVENT(dealPortfolio, const char*, const char*, const char*, const char*);
DIPC_EVENT(ErrEvent, const char*, const char*);
2019-12-19_15:14:50.881359: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/tools/abi/AbiGenerator.cpp:124] method :queryChangeRate
2019-12-19_15:14:50.881365: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/tools/abi/AbiGenerator.cpp:145] abi.methodName : queryChangeRate; abi.isConst : true; abi.isPayable :false; abi.isExport :false
2019-12-19_15:14:50.881371: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/tools/abi/AbiGenerator.cpp:26] xxx:uint64_t
2019-12-19_15:14:50.881377: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/tools/abi/AbiGenerator.cpp:28] set typeName
2019-12-19_15:14:50.881389: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/tools/abi/AbiGenerator.cpp:47] typeName:uint64_t  realTypeName:unsigned long long
2019-12-19_15:14:50.881395: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/tools/abi/AbiGenerator.cpp:119] funcEntire : ; funcEnd : PortfolioManage : public Contract {
private:
    String<ownc> owner;
    Uint64<ownerTotalTokenc> ownerTotalToken;
    Uint64<changeRatec> changeRate;
    Bool<userCanWithdrawc> userCanWithdraw;
    Uint64<totalTokenc> totalToken; 
    //Map<portfolioMapc, char * , std::string> portfolioStorge;
    Map<portfolioMapc, std::string , std::string> portfolioStorge;
    Map<portfolioBalancec, std::string , uint64_t> portfolioBalance; 
    void isOwner(){
        std::string callerStr = caller().toString();
        DipcAssert(callerStr == owner.get());
    }
    
    inline uint64_t getTotalBalance(){
        print("callValueUDIP");
        print(dipc::callValueUDIP());
        print(changeRate.get());
        //print(uint64_t(std::pow(10.0,3)));
       return dipc::callValueUDIP() * changeRate.get() / 1000;
    }
   

public:
    PAYABLE void init();
    EXPORT void setChangeRate(uint64_t _changeRate);
    EXPORT void setUserCanWithdraw(bool _canWithdraw);
    PAYABLE void createPortfolio(char* _portfolioName, char* _portfolioDesc);
    PAYABLE void depositPortfolio(char* _portfolioName);
    PAYABLE void createOrder(char* _portfolioName, char* _orderId, uint16_t _orderType, char* _stockCode, uint64_t _stockPrice, uint64_t _stockAmount, uint64_t _endTime);
    EXPORT void dealOrder(char* _portfolioName, char* _orderId);
    EXPORT void revocationOrder(char* _portfolioName, char* _orderId);
    EXPORT void withdrawPortfolio(char* _portfolioName, uint64_t _withdrawBalance);
    EXPORT void withdrawPool(uint64_t _balance);
    PAYABLE void depositPool(uint64_t _depositValue);
    CONSTANT uint64_t queryTotalToken();
    CONSTANT uint64_t queryPortfolioBalance(char* _portfolioName);
    CONSTANT bool queryPortfolioNameIfUsed(char* _portfolioName);
    CONSTANT uint64_t queryChangeRate();
};
DIPC_EVENT(initEvent, const char* ,uint64_t);
DIPC_EVENT(tokenCount, const char* ,uint64_t, const char*, uint64_t);
DIPC_EVENT(portfolioInfo, const char*, const char* ,const char* , uint64_t);
DIPC_EVENT(createOrder, const char*, const char*, const char*, const char*, const char*, uint64_t);
DIPC_EVENT(depositPortfolio, const char*, const char*, const char*, uint64_t);
DIPC_EVENT(revocationPortfolio, const char*, const char*, const char*, const char*);
DIPC_EVENT(dealPortfolio, const char*, const char*, const char*, const char*);
DIPC_EVENT(ErrEvent, const char*, const char*);
2019-12-19_15:14:50.881403: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/tools/abi/AbiGenerator.cpp:119] funcEntire : ; funcEnd : PortfolioManage : public Contract {
private:
    String<ownc> owner;
    Uint64<ownerTotalTokenc> ownerTotalToken;
    Uint64<changeRatec> changeRate;
    Bool<userCanWithdrawc> userCanWithdraw;
    Uint64<totalTokenc> totalToken; 
    //Map<portfolioMapc, char * , std::string> portfolioStorge;
    Map<portfolioMapc, std::string , std::string> portfolioStorge;
    Map<portfolioBalancec, std::string , uint64_t> portfolioBalance; 
    void isOwner(){
        std::string callerStr = caller().toString();
        DipcAssert(callerStr == owner.get());
    }
    
    inline uint64_t getTotalBalance(){
        print("callValueUDIP");
        print(dipc::callValueUDIP());
        print(changeRate.get());
        //print(uint64_t(std::pow(10.0,3)));
       return dipc::callValueUDIP() * changeRate.get() / 1000;
    }
   

public:
    PAYABLE void init();
    EXPORT void setChangeRate(uint64_t _changeRate);
    EXPORT void setUserCanWithdraw(bool _canWithdraw);
    PAYABLE void createPortfolio(char* _portfolioName, char* _portfolioDesc);
    PAYABLE void depositPortfolio(char* _portfolioName);
    PAYABLE void createOrder(char* _portfolioName, char* _orderId, uint16_t _orderType, char* _stockCode, uint64_t _stockPrice, uint64_t _stockAmount, uint64_t _endTime);
    EXPORT void dealOrder(char* _portfolioName, char* _orderId);
    EXPORT void revocationOrder(char* _portfolioName, char* _orderId);
    EXPORT void withdrawPortfolio(char* _portfolioName, uint64_t _withdrawBalance);
    EXPORT void withdrawPool(uint64_t _balance);
    PAYABLE void depositPool(uint64_t _depositValue);
    CONSTANT uint64_t queryTotalToken();
    CONSTANT uint64_t queryPortfolioBalance(char* _portfolioName);
    CONSTANT bool queryPortfolioNameIfUsed(char* _portfolioName);
    CONSTANT uint64_t queryChangeRate();
};
DIPC_EVENT(initEvent, const char* ,uint64_t);
DIPC_EVENT(tokenCount, const char* ,uint64_t, const char*, uint64_t);
DIPC_EVENT(portfolioInfo, const char*, const char* ,const char* , uint64_t);
DIPC_EVENT(createOrder, const char*, const char*, const char*, const char*, const char*, uint64_t);
DIPC_EVENT(depositPortfolio, const char*, const char*, const char*, uint64_t);
DIPC_EVENT(revocationPortfolio, const char*, const char*, const char*, const char*);
DIPC_EVENT(dealPortfolio, const char*, const char*, const char*, const char*);
DIPC_EVENT(ErrEvent, const char*, const char*);
2019-12-19_15:14:50.881411: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/tools/abi/AbiGenerator.cpp:119] funcEntire : ; funcEnd : PortfolioManage : public Contract {
private:
    String<ownc> owner;
    Uint64<ownerTotalTokenc> ownerTotalToken;
    Uint64<changeRatec> changeRate;
    Bool<userCanWithdrawc> userCanWithdraw;
    Uint64<totalTokenc> totalToken; 
    //Map<portfolioMapc, char * , std::string> portfolioStorge;
    Map<portfolioMapc, std::string , std::string> portfolioStorge;
    Map<portfolioBalancec, std::string , uint64_t> portfolioBalance; 
    void isOwner(){
        std::string callerStr = caller().toString();
        DipcAssert(callerStr == owner.get());
    }
    
    inline uint64_t getTotalBalance(){
        print("callValueUDIP");
        print(dipc::callValueUDIP());
        print(changeRate.get());
        //print(uint64_t(std::pow(10.0,3)));
       return dipc::callValueUDIP() * changeRate.get() / 1000;
    }
   

public:
    PAYABLE void init();
    EXPORT void setChangeRate(uint64_t _changeRate);
    EXPORT void setUserCanWithdraw(bool _canWithdraw);
    PAYABLE void createPortfolio(char* _portfolioName, char* _portfolioDesc);
    PAYABLE void depositPortfolio(char* _portfolioName);
    PAYABLE void createOrder(char* _portfolioName, char* _orderId, uint16_t _orderType, char* _stockCode, uint64_t _stockPrice, uint64_t _stockAmount, uint64_t _endTime);
    EXPORT void dealOrder(char* _portfolioName, char* _orderId);
    EXPORT void revocationOrder(char* _portfolioName, char* _orderId);
    EXPORT void withdrawPortfolio(char* _portfolioName, uint64_t _withdrawBalance);
    EXPORT void withdrawPool(uint64_t _balance);
    PAYABLE void depositPool(uint64_t _depositValue);
    CONSTANT uint64_t queryTotalToken();
    CONSTANT uint64_t queryPortfolioBalance(char* _portfolioName);
    CONSTANT bool queryPortfolioNameIfUsed(char* _portfolioName);
    CONSTANT uint64_t queryChangeRate();
};
DIPC_EVENT(initEvent, const char* ,uint64_t);
DIPC_EVENT(tokenCount, const char* ,uint64_t, const char*, uint64_t);
DIPC_EVENT(portfolioInfo, const char*, const char* ,const char* , uint64_t);
DIPC_EVENT(createOrder, const char*, const char*, const char*, const char*, const char*, uint64_t);
DIPC_EVENT(depositPortfolio, const char*, const char*, const char*, uint64_t);
DIPC_EVENT(revocationPortfolio, const char*, const char*, const char*, const char*);
DIPC_EVENT(dealPortfolio, const char*, const char*, const char*, const char*);
DIPC_EVENT(ErrEvent, const char*, const char*);
2019-12-19_15:14:50.881418: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/tools/abi/AbiGenerator.cpp:119] funcEntire : ; funcEnd : PortfolioManage : public Contract {
private:
    String<ownc> owner;
    Uint64<ownerTotalTokenc> ownerTotalToken;
    Uint64<changeRatec> changeRate;
    Bool<userCanWithdrawc> userCanWithdraw;
    Uint64<totalTokenc> totalToken; 
    //Map<portfolioMapc, char * , std::string> portfolioStorge;
    Map<portfolioMapc, std::string , std::string> portfolioStorge;
    Map<portfolioBalancec, std::string , uint64_t> portfolioBalance; 
    void isOwner(){
        std::string callerStr = caller().toString();
        DipcAssert(callerStr == owner.get());
    }
    
    inline uint64_t getTotalBalance(){
        print("callValueUDIP");
        print(dipc::callValueUDIP());
        print(changeRate.get());
        //print(uint64_t(std::pow(10.0,3)));
       return dipc::callValueUDIP() * changeRate.get() / 1000;
    }
   

public:
    PAYABLE void init();
    EXPORT void setChangeRate(uint64_t _changeRate);
    EXPORT void setUserCanWithdraw(bool _canWithdraw);
    PAYABLE void createPortfolio(char* _portfolioName, char* _portfolioDesc);
    PAYABLE void depositPortfolio(char* _portfolioName);
    PAYABLE void createOrder(char* _portfolioName, char* _orderId, uint16_t _orderType, char* _stockCode, uint64_t _stockPrice, uint64_t _stockAmount, uint64_t _endTime);
    EXPORT void dealOrder(char* _portfolioName, char* _orderId);
    EXPORT void revocationOrder(char* _portfolioName, char* _orderId);
    EXPORT void withdrawPortfolio(char* _portfolioName, uint64_t _withdrawBalance);
    EXPORT void withdrawPool(uint64_t _balance);
    PAYABLE void depositPool(uint64_t _depositValue);
    CONSTANT uint64_t queryTotalToken();
    CONSTANT uint64_t queryPortfolioBalance(char* _portfolioName);
    CONSTANT bool queryPortfolioNameIfUsed(char* _portfolioName);
    CONSTANT uint64_t queryChangeRate();
};
DIPC_EVENT(initEvent, const char* ,uint64_t);
DIPC_EVENT(tokenCount, const char* ,uint64_t, const char*, uint64_t);
DIPC_EVENT(portfolioInfo, const char*, const char* ,const char* , uint64_t);
DIPC_EVENT(createOrder, const char*, const char*, const char*, const char*, const char*, uint64_t);
DIPC_EVENT(depositPortfolio, const char*, const char*, const char*, uint64_t);
DIPC_EVENT(revocationPortfolio, const char*, const char*, const char*, const char*);
DIPC_EVENT(dealPortfolio, const char*, const char*, const char*, const char*);
DIPC_EVENT(ErrEvent, const char*, const char*);
2019-12-19_15:14:50.881424: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/tools/abi/AbiGenerator.cpp:172] abis size:15
2019-12-19_15:14:53.238640: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:1152] find method successfind abi size:15
2019-12-19_15:14:53.238666: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:1157] methodName:init args:(
2019-12-19_15:14:53.238679: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:1168] )
2019-12-19_15:14:53.238685: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:1169] return typeName: realTypeName:void
2019-12-19_15:14:53.238692: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:1157] methodName:setChangeRate args:(
2019-12-19_15:14:53.238698: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:1164] name:_changeRate, typeName:uint64_t realTypeName:unsigned long long
2019-12-19_15:14:53.238704: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:1168] )
2019-12-19_15:14:53.238709: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:1169] return typeName: realTypeName:void
2019-12-19_15:14:53.238715: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:1157] methodName:setUserCanWithdraw args:(
2019-12-19_15:14:53.238720: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:1164] name:_canWithdraw, typeName: realTypeName:_Bool
2019-12-19_15:14:53.238726: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:1168] )
2019-12-19_15:14:53.238731: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:1169] return typeName: realTypeName:void
2019-12-19_15:14:53.238736: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:1157] methodName:createPortfolio args:(
2019-12-19_15:14:53.238742: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:1164] name:_portfolioName, typeName: realTypeName:char *
2019-12-19_15:14:53.238748: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:1164] name:_portfolioDesc, typeName: realTypeName:char *
2019-12-19_15:14:53.238753: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:1168] )
2019-12-19_15:14:53.238758: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:1169] return typeName: realTypeName:void
2019-12-19_15:14:53.238764: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:1157] methodName:depositPortfolio args:(
2019-12-19_15:14:53.238769: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:1164] name:_portfolioName, typeName: realTypeName:char *
2019-12-19_15:14:53.238775: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:1168] )
2019-12-19_15:14:53.238780: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:1169] return typeName: realTypeName:void
2019-12-19_15:14:53.238785: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:1157] methodName:createOrder args:(
2019-12-19_15:14:53.238790: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:1164] name:_portfolioName, typeName: realTypeName:char *
2019-12-19_15:14:53.238796: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:1164] name:_orderId, typeName: realTypeName:char *
2019-12-19_15:14:53.238801: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:1164] name:_orderType, typeName:uint16_t realTypeName:unsigned short
2019-12-19_15:14:53.238808: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:1164] name:_stockCode, typeName: realTypeName:char *
2019-12-19_15:14:53.238814: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:1164] name:_stockPrice, typeName:uint64_t realTypeName:unsigned long long
2019-12-19_15:14:53.238819: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:1164] name:_stockAmount, typeName:uint64_t realTypeName:unsigned long long
2019-12-19_15:14:53.238825: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:1164] name:_endTime, typeName:uint64_t realTypeName:unsigned long long
2019-12-19_15:14:53.238830: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:1168] )
2019-12-19_15:14:53.238835: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:1169] return typeName: realTypeName:void
2019-12-19_15:14:53.238841: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:1157] methodName:dealOrder args:(
2019-12-19_15:14:53.238846: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:1164] name:_portfolioName, typeName: realTypeName:char *
2019-12-19_15:14:53.238852: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:1164] name:_orderId, typeName: realTypeName:char *
2019-12-19_15:14:53.238857: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:1168] )
2019-12-19_15:14:53.238862: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:1169] return typeName: realTypeName:void
2019-12-19_15:14:53.238867: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:1157] methodName:revocationOrder args:(
2019-12-19_15:14:53.238873: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:1164] name:_portfolioName, typeName: realTypeName:char *
2019-12-19_15:14:53.238878: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:1164] name:_orderId, typeName: realTypeName:char *
2019-12-19_15:14:53.238884: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:1168] )
2019-12-19_15:14:53.238889: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:1169] return typeName: realTypeName:void
2019-12-19_15:14:53.238894: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:1157] methodName:withdrawPortfolio args:(
2019-12-19_15:14:53.238900: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:1164] name:_portfolioName, typeName: realTypeName:char *
2019-12-19_15:14:53.238906: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:1164] name:_withdrawBalance, typeName:uint64_t realTypeName:unsigned long long
2019-12-19_15:14:53.238911: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:1168] )
2019-12-19_15:14:53.238916: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:1169] return typeName: realTypeName:void
2019-12-19_15:14:53.238922: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:1157] methodName:withdrawPool args:(
2019-12-19_15:14:53.238927: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:1164] name:_balance, typeName:uint64_t realTypeName:unsigned long long
2019-12-19_15:14:53.238932: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:1168] )
2019-12-19_15:14:53.238938: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:1169] return typeName: realTypeName:void
2019-12-19_15:14:53.238944: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:1157] methodName:depositPool args:(
2019-12-19_15:14:53.238949: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:1164] name:_depositValue, typeName:uint64_t realTypeName:unsigned long long
2019-12-19_15:14:53.238955: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:1168] )
2019-12-19_15:14:53.238960: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:1169] return typeName: realTypeName:void
2019-12-19_15:14:53.238965: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:1157] methodName:queryTotalToken args:(
2019-12-19_15:14:53.238971: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:1168] )
2019-12-19_15:14:53.238976: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:1169] return typeName:uint64_t realTypeName:unsigned long long
2019-12-19_15:14:53.238981: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:1157] methodName:queryPortfolioBalance args:(
2019-12-19_15:14:53.238986: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:1164] name:_portfolioName, typeName: realTypeName:char *
2019-12-19_15:14:53.238992: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:1168] )
2019-12-19_15:14:53.238997: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:1169] return typeName:uint64_t realTypeName:unsigned long long
2019-12-19_15:14:53.239002: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:1157] methodName:queryPortfolioNameIfUsed args:(
2019-12-19_15:14:53.239008: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:1164] name:_portfolioName, typeName: realTypeName:char *
2019-12-19_15:14:53.239013: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:1168] )
2019-12-19_15:14:53.239018: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:1169] return typeName: realTypeName:_Bool
2019-12-19_15:14:53.239023: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:1157] methodName:queryChangeRate args:(
2019-12-19_15:14:53.239029: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:1168] )
2019-12-19_15:14:53.239034: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:1169] return typeName:uint64_t realTypeName:unsigned long long
2019-12-19_15:14:53.239039: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:1182] start create abi json
2019-12-19_15:14:53.239905: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:776] random:[/var/folders/tt/8v4bb03x685c49jk_vkvr7s80000gp/T/3e3a6heh3g58dhgeb7a2] fileName:PortfolioManage.cpp.abi.json
2019-12-19_15:14:53.239919: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:778] tmpFile:[/var/folders/tt/8v4bb03x685c49jk_vkvr7s80000gp/T/3e3a6heh3g58dhgeb7a2/PortfolioManage.cpp.abi.json]
2019-12-19_15:14:53.244091: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:789] copy ::/var/folders/tt/8v4bb03x685c49jk_vkvr7s80000gp/T/3e3a6heh3g58dhgeb7a2/PortfolioManage.cpp.abi.json to ::./PortfolioManage.cpp.abi.json
2019-12-19_15:14:53.245624: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:810] random:[/var/folders/tt/8v4bb03x685c49jk_vkvr7s80000gp/T/3e3a6heh3g58dhgeb7a2] fileName:PortfolioManage.cpp.exports
2019-12-19_15:14:53.245703: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:812] tmpFile:[/var/folders/tt/8v4bb03x685c49jk_vkvr7s80000gp/T/3e3a6heh3g58dhgeb7a2/PortfolioManage.cpp.exports]
2019-12-19_15:14:53.245980: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:827] copy ::/var/folders/tt/8v4bb03x685c49jk_vkvr7s80000gp/T/3e3a6heh3g58dhgeb7a2/PortfolioManage.cpp.exports to ::/var/folders/tt/8v4bb03x685c49jk_vkvr7s80000gp/T//PortfolioManage.cpp.exports
2019-12-19_15:14:53.246223: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:848] abidef_output  abidef_filename PortfolioManage.cpp

2019-12-19_15:14:53.246396: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:876] macrostr  =======::#include "PortfolioManage.hpp"

    /**
     * @brief init contract params
     * //@param depositValue: the value of owner transfer to the contractthe unit is WU 
     * @return void
     */
    PAYABLE void PortfolioManage::init(){
        *owner = caller().toString();
        *changeRate = 10000;
        *userCanWithdraw = false;
        uint64_t tokenBalance = getTotalBalance();
        //DipcAssert(depositValue == callValue());
        *ownerTotalToken = tokenBalance;
        *totalToken = ownerTotalToken.get();
        //print("tokenBalance");
        //print(tokenBalance);
        DIPC_EMIT_EVENT(initEvent, "ownerTotalToken" ,tokenBalance);
    }
    
     /**
     * @brief set the change rate between DIP and current token
     * @param _changeRate: the change rate between DIP and current token
     * @return void
     */
    EXPORT void PortfolioManage::setChangeRate(uint64_t _changeRate){
        isOwner();
        *changeRate = _changeRate;
    }
     /**
     * @brief set whether the user can withdraw token by himself 
     * @param _canWithdraw: true or false -- whether the user can withdraw token by himself 
     * @return void
     */
    EXPORT void PortfolioManage::setUserCanWithdraw(bool _canWithdraw){
        isOwner();
        *userCanWithdraw = _canWithdraw;
    }

    /**
     * @brief create a portfolio
     * @param _portfolioName: the name of current portfolio
     * @param _portfolioDesc: the description of current portfolio
     * @return void
     */
    PAYABLE void PortfolioManage::createPortfolio(char* _portfolioName, char* _portfolioDesc){
        if(portfolioStorge.get()[_portfolioName] != ""){
            DIPC_EMIT_EVENT(ErrEvent, "Current portfolio exist: ", _portfolioName);
            return;
        } 
        std::string callerAddr = caller().toString();
        uint64_t tokenBalance = getTotalBalance();
        // changeU256ToUint64WithChangeRate(callValue(), changeRate.get());
        PortfolioInfo info(_portfolioName, _portfolioDesc, &callerAddr[0]);
        std::string portfolioStr = info.toJson();
        //print("createPortfolio");
        //print(portfolioStr);
        //print(info.getPortfolioResult());

        (*portfolioStorge)[_portfolioName] = portfolioStr;
        DipcAssert(totalToken.get() + tokenBalance > totalToken);
        (*portfolioBalance)[_portfolioName] = tokenBalance;
        *totalToken = totalToken.get() + tokenBalance; 
        //u256 callV = callValue();
        DIPC_EMIT_EVENT(portfolioInfo, _portfolioName, &portfolioStr[0], "portfolioBalance", tokenBalance);
    }

    /**
     * @brief deposit a portfolio
     * @param _portfolioName: the name of the portfolio  want to deposit
     * @return void
     */
    PAYABLE void PortfolioManage::depositPortfolio(char* _portfolioName){
        uint64_t tokenBalance = getTotalBalance();
        //uint64_t tokenBalance = changeU256ToUint64WithChangeRate(callValue(), changeRate.get());
        uint64_t currentBalance = portfolioBalance.get()[_portfolioName];
        uint64_t finalBalance  = currentBalance + tokenBalance;
        DipcAssert(totalToken.get() + tokenBalance > totalToken);
        DipcAssert(finalBalance > currentBalance);
        (*portfolioBalance)[_portfolioName] = finalBalance;
        *totalToken = totalToken.get() + finalBalance; 
        DIPC_EMIT_EVENT(depositPortfolio, "portfolioName", _portfolioName, "portfolioBalance", finalBalance);
    }
    /**
     * @brief create a order
     * @param _portfolioName: the name of the portfolio  current order blong to   
     * @param _orderId: orderId used by application
     * @param _orderType
     * @param _stockCode
     * @param _stockPrice: unit is token
     * @param _stockAmount: uint is one share 
     * @param _endTime: nanoseconds the order expire
     * @return void
     */
    PAYABLE void PortfolioManage::createOrder(char* _portfolioName, char* _orderId, uint16_t _orderType, char* _stockCode, uint64_t _stockPrice, uint64_t _stockAmount, uint64_t _endTime){
        uint64_t tokenBalance = getTotalBalance();
        DIPC_EMIT_EVENT(createOrder, "portfolioName", _portfolioName, "OrderInfo", "ignore", "tokenBalance", tokenBalance);
        uint64_t spent = 0;
        if(_orderType == 1){
            spent = _stockPrice * _stockAmount;
            DipcAssert((portfolioBalance.get()[_portfolioName] + tokenBalance) > spent);
        }
        struct Order order{_orderId, _orderType, _stockCode, _stockPrice, _stockAmount, _endTime, 0};
        std::string pInfo = portfolioStorge.get()[_portfolioName];
        //print("identity start");
        //print(pInfo);
        //print(tokenBalance);
        if(pInfo == "") {
            DIPC_EMIT_EVENT(ErrEvent, "Current portfolio  doesn't exist: ", _portfolioName);
            return;
        }
        PortfolioInfo info;
        info.parseJson(pInfo);
        if(info.getOrder(_orderId).orderId != ""){
            DIPC_EMIT_EVENT(ErrEvent, "Current order exist: ", _orderId);
            return;
        }
        info.addOrder(order);
        pInfo = info.toJson();

        uint64_t currentBalance = portfolioBalance.get()[_portfolioName] ;
        uint64_t finalBalance = currentBalance + tokenBalance - spent;
        DipcAssert(totalToken.get() + tokenBalance > totalToken);
        //DipcAssert(finalBalance > currentBalance);
        DipcAssert(ownerTotalToken.get() < ownerTotalToken.get() + spent);
        (*portfolioStorge)[_portfolioName] = &pInfo[0];
        //print("identity ten");
        //print(pInfo);
        //print(finalBalance);
        //print(spent);


        (*portfolioBalance)[_portfolioName] = finalBalance;
        *totalToken = totalToken.get() + finalBalance; 
        *ownerTotalToken = ownerTotalToken.get() + spent;
        DIPC_EMIT_EVENT(createOrder, "portfolioName", _portfolioName, "OrderInfo", &order.toJson()[0], "portfolioBalance", finalBalance);
    }

    /**
     * @brief 
     * 
     * 
     * 
     */
    EXPORT void PortfolioManage::dealOrder(char* _portfolioName, char* _orderId){
        isOwner();
        std::string pInfo = portfolioStorge.get()[_portfolioName];
        //print("dealOrder  pInfo");
        //print(pInfo);
        PortfolioInfo info;
        info.parseJson(pInfo);
        //print("dealOrder  start");

        //print(info.toJson());
         Order ord = info.getOrder(_orderId);
         //print("dealOrder");
         //print(ord.toJson());
        if(ord.orderId != "" && ord.orderStatus == 0){
            //DipcAssert(info.getOwnerAddress() == caller().toString());
            uint64_t timenow = dipc::timestamp();
            if(ord.endTime > timenow){
                ord.orderStatus = 1;
            }else {
                ord.orderStatus = 3;
            }
        } else {
          // print("dealOrder  return ");

            return;
        }
        // print("dealOrder  one ");

        uint64_t sellValue = 0;
        if(ord.orderType == 0){
            sellValue = ord.stockAmount * ord.stockPrice;
        }
        uint64_t currentBalance =  portfolioBalance.get()[_portfolioName];
        // print("dealOrder  two");

        DipcAssert(currentBalance + sellValue >= currentBalance);
        DipcAssert((ownerTotalToken.get() - sellValue) <= ownerTotalToken.get());
        


        (*portfolioBalance)[_portfolioName] = currentBalance + sellValue;
        *ownerTotalToken = ownerTotalToken.get() - sellValue;
        (*portfolioStorge)[_portfolioName] = &info.toJson()[0];
        //print("dealOrder  three");
        //print(info.toJson());
        //print(currentBalance + sellValue);
        //print(ownerTotalToken.get());

        DIPC_EMIT_EVENT(dealPortfolio, "orderId", _orderId, "orderInfo", &ord.toJson()[0]);
    }
    /**
     * @brief 
     * 
     * 
     * 
     */
    EXPORT void PortfolioManage::revocationOrder(char* _portfolioName, char* _orderId){
        std::string pInfo = portfolioStorge.get()[_portfolioName];
        //print("pInfo");
        //print(pInfo);
        PortfolioInfo info;
        info.parseJson(pInfo);
        Order ord = info.getOrder(_orderId);
        //print("ordInfo");
        //print(ord.toJson());
        if(ord.orderId != "" && ord.orderStatus == 0){
            std::string callerStr = caller().toString();
            //print("revocationOrder start");
            //print(info.getOwnerAddress());
            //print(callerStr);
            DipcAssert(info.getOwnerAddress() == caller().toString());
            //print("revocationOrder end");

            uint64_t timenow = dipc::timestamp();
            if(ord.endTime > timenow){
                ord.orderStatus = 2;
            }else {
                ord.orderStatus = 3;
            }
        } else {
            return;
        }
        uint64_t lockToken = 0;
        if(ord.orderType == 1){
            lockToken = ord.stockPrice * ord.stockAmount;
        }
        uint64_t currentBalance =  portfolioBalance.get()[_portfolioName];
        //print("revocationOrder can see");
        //print(currentBalance);
        // print(ownerTotalToken.get());
        // print(lockToken);

        DipcAssert(currentBalance + lockToken >= currentBalance);
        DipcAssert(ownerTotalToken.get() - lockToken <= ownerTotalToken.get());

        //print("revocationOrder can see  two");
        (*portfolioBalance)[_portfolioName] = currentBalance + lockToken;
        *ownerTotalToken = ownerTotalToken.get() - lockToken;
        (*portfolioStorge)[_portfolioName] = &info.toJson()[0];
        DIPC_EMIT_EVENT(revocationPortfolio, "orderId", _orderId, "orderInfo", &ord.toJson()[0]);
    }
    /**
     * @brief 
     * @param _withdrawBalance:  the unit is token
     * 
     * 
     */
    EXPORT void PortfolioManage::withdrawPortfolio(char* _portfolioName, uint64_t _withdrawBalance){
         if(!userCanWithdraw.get()){
             return;
         }
         uint64_t currentBalance =  portfolioBalance.get()[_portfolioName];
         DipcAssert(currentBalance - _withdrawBalance < currentBalance);
         auto coinBalance = changeUint64ToU256WithChangeRate(currentBalance, changeRate.get());
         (*portfolioBalance)[_portfolioName] = currentBalance - _withdrawBalance;
         callTransfer(caller(), coinBalance);
    }
    /**
     * @brief owner deposit to the contract address to get more token
     * @param _depositValue: the value num transfer to the contract address
     */
    EXPORT void PortfolioManage::withdrawPool(uint64_t _balance){
        isOwner();
        Address ownerAddr = Address(owner.get()); 
        callTransfer(ownerAddr, _balance);
        *ownerTotalToken = ownerTotalToken.get() - _balance * changeRate.get();
        *totalToken = totalToken.get() - _balance * changeRate.get();
        DIPC_EMIT_EVENT(tokenCount, "ownerTotalToken", ownerTotalToken.get(), "totalToken", totalToken.get());
    }
    /**
     * @brief owner deposit to the contract address to get more token
     * @param _depositValue: the value num transfer to the contract address
     */
    PAYABLE void PortfolioManage::depositPool(uint64_t _depositValue){
        isOwner();
        //DipcAssert(_depositValue == dipc::callValue());
        uint64_t tokenBalance = changeU256ToUint64WithChangeRate(callValue(), changeRate.get()); 
        *ownerTotalToken = ownerTotalToken.get() + tokenBalance;
        *totalToken = totalToken.get() + tokenBalance;
        DIPC_EMIT_EVENT(tokenCount, "ownerTotalToken", ownerTotalToken.get(), "totalToken", totalToken.get());
    }
     /**
     * @brief query the total token in the contract
     * @return the total token int the contract
     */
    CONSTANT uint64_t PortfolioManage::queryTotalToken(){
        return totalToken.get();
    }

     /**
     * @brief query the token balance of the portfolio
     * @param _portfolioName : the portfolio name
     * @return the balance of the portfolio, the unit is token
     */
    CONSTANT uint64_t PortfolioManage::queryPortfolioBalance(char* _portfolioName){
        return portfolioBalance.get()[_portfolioName];
    }

    /**
     * @brief query the portfolio name  whether  used or not 
     * @return true is used, false is not used
     */
    CONSTANT bool PortfolioManage::queryPortfolioNameIfUsed(char* _portfolioName){
        if(portfolioStorge.get()[_portfolioName] != ""){
            return true;
        } 
        return false;
    }

    /**
     * @brief query the change rate between DIP and current token
     * @return the change rate between DIP and current token
     */
    CONSTANT uint64_t PortfolioManage::queryChangeRate(){
        return changeRate.get();
    }

2019-12-19_15:14:53.246417: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:877] headerStr  =======::

2019-12-19_15:14:53.246508: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:880] removedComments  =======::#include "PortfolioManage.hpp"

    
    PAYABLE void PortfolioManage::init(){
        *owner = caller().toString();
        *changeRate = 10000;
        *userCanWithdraw = false;
        uint64_t tokenBalance = getTotalBalance();
        
        *ownerTotalToken = tokenBalance;
        *totalToken = ownerTotalToken.get();
        
        
        DIPC_EMIT_EVENT(initEvent, "ownerTotalToken" ,tokenBalance);
    }
    
     
    EXPORT void PortfolioManage::setChangeRate(uint64_t _changeRate){
        isOwner();
        *changeRate = _changeRate;
    }
     
    EXPORT void PortfolioManage::setUserCanWithdraw(bool _canWithdraw){
        isOwner();
        *userCanWithdraw = _canWithdraw;
    }

    
    PAYABLE void PortfolioManage::createPortfolio(char* _portfolioName, char* _portfolioDesc){
        if(portfolioStorge.get()[_portfolioName] != ""){
            DIPC_EMIT_EVENT(ErrEvent, "Current portfolio exist: ", _portfolioName);
            return;
        } 
        std::string callerAddr = caller().toString();
        uint64_t tokenBalance = getTotalBalance();
        
        PortfolioInfo info(_portfolioName, _portfolioDesc, &callerAddr[0]);
        std::string portfolioStr = info.toJson();
        
        
        

        (*portfolioStorge)[_portfolioName] = portfolioStr;
        DipcAssert(totalToken.get() + tokenBalance > totalToken);
        (*portfolioBalance)[_portfolioName] = tokenBalance;
        *totalToken = totalToken.get() + tokenBalance; 
        
        DIPC_EMIT_EVENT(portfolioInfo, _portfolioName, &portfolioStr[0], "portfolioBalance", tokenBalance);
    }

    
    PAYABLE void PortfolioManage::depositPortfolio(char* _portfolioName){
        uint64_t tokenBalance = getTotalBalance();
        
        uint64_t currentBalance = portfolioBalance.get()[_portfolioName];
        uint64_t finalBalance  = currentBalance + tokenBalance;
        DipcAssert(totalToken.get() + tokenBalance > totalToken);
        DipcAssert(finalBalance > currentBalance);
        (*portfolioBalance)[_portfolioName] = finalBalance;
        *totalToken = totalToken.get() + finalBalance; 
        DIPC_EMIT_EVENT(depositPortfolio, "portfolioName", _portfolioName, "portfolioBalance", finalBalance);
    }
    
    PAYABLE void PortfolioManage::createOrder(char* _portfolioName, char* _orderId, uint16_t _orderType, char* _stockCode, uint64_t _stockPrice, uint64_t _stockAmount, uint64_t _endTime){
        uint64_t tokenBalance = getTotalBalance();
        DIPC_EMIT_EVENT(createOrder, "portfolioName", _portfolioName, "OrderInfo", "ignore", "tokenBalance", tokenBalance);
        uint64_t spent = 0;
        if(_orderType == 1){
            spent = _stockPrice * _stockAmount;
            DipcAssert((portfolioBalance.get()[_portfolioName] + tokenBalance) > spent);
        }
        struct Order order{_orderId, _orderType, _stockCode, _stockPrice, _stockAmount, _endTime, 0};
        std::string pInfo = portfolioStorge.get()[_portfolioName];
        
        
        
        if(pInfo == "") {
            DIPC_EMIT_EVENT(ErrEvent, "Current portfolio  doesn't exist: ", _portfolioName);
            return;
        }
        PortfolioInfo info;
        info.parseJson(pInfo);
        if(info.getOrder(_orderId).orderId != ""){
            DIPC_EMIT_EVENT(ErrEvent, "Current order exist: ", _orderId);
            return;
        }
        info.addOrder(order);
        pInfo = info.toJson();

        uint64_t currentBalance = portfolioBalance.get()[_portfolioName] ;
        uint64_t finalBalance = currentBalance + tokenBalance - spent;
        DipcAssert(totalToken.get() + tokenBalance > totalToken);
        
        DipcAssert(ownerTotalToken.get() < ownerTotalToken.get() + spent);
        (*portfolioStorge)[_portfolioName] = &pInfo[0];
        
        
        
        


        (*portfolioBalance)[_portfolioName] = finalBalance;
        *totalToken = totalToken.get() + finalBalance; 
        *ownerTotalToken = ownerTotalToken.get() + spent;
        DIPC_EMIT_EVENT(createOrder, "portfolioName", _portfolioName, "OrderInfo", &order.toJson()[0], "portfolioBalance", finalBalance);
    }

    
    EXPORT void PortfolioManage::dealOrder(char* _portfolioName, char* _orderId){
        isOwner();
        std::string pInfo = portfolioStorge.get()[_portfolioName];
        
        
        PortfolioInfo info;
        info.parseJson(pInfo);
        

        
         Order ord = info.getOrder(_orderId);
         
         
        if(ord.orderId != "" && ord.orderStatus == 0){
            
            uint64_t timenow = dipc::timestamp();
            if(ord.endTime > timenow){
                ord.orderStatus = 1;
            }else {
                ord.orderStatus = 3;
            }
        } else {
          

            return;
        }
        

        uint64_t sellValue = 0;
        if(ord.orderType == 0){
            sellValue = ord.stockAmount * ord.stockPrice;
        }
        uint64_t currentBalance =  portfolioBalance.get()[_portfolioName];
        

        DipcAssert(currentBalance + sellValue >= currentBalance);
        DipcAssert((ownerTotalToken.get() - sellValue) <= ownerTotalToken.get());
        


        (*portfolioBalance)[_portfolioName] = currentBalance + sellValue;
        *ownerTotalToken = ownerTotalToken.get() - sellValue;
        (*portfolioStorge)[_portfolioName] = &info.toJson()[0];
        
        
        
        

        DIPC_EMIT_EVENT(dealPortfolio, "orderId", _orderId, "orderInfo", &ord.toJson()[0]);
    }
    
    EXPORT void PortfolioManage::revocationOrder(char* _portfolioName, char* _orderId){
        std::string pInfo = portfolioStorge.get()[_portfolioName];
        
        
        PortfolioInfo info;
        info.parseJson(pInfo);
        Order ord = info.getOrder(_orderId);
        
        
        if(ord.orderId != "" && ord.orderStatus == 0){
            std::string callerStr = caller().toString();
            
            
            
            DipcAssert(info.getOwnerAddress() == caller().toString());
            

            uint64_t timenow = dipc::timestamp();
            if(ord.endTime > timenow){
                ord.orderStatus = 2;
            }else {
                ord.orderStatus = 3;
            }
        } else {
            return;
        }
        uint64_t lockToken = 0;
        if(ord.orderType == 1){
            lockToken = ord.stockPrice * ord.stockAmount;
        }
        uint64_t currentBalance =  portfolioBalance.get()[_portfolioName];
        
        
        
        

        DipcAssert(currentBalance + lockToken >= currentBalance);
        DipcAssert(ownerTotalToken.get() - lockToken <= ownerTotalToken.get());

        
        (*portfolioBalance)[_portfolioName] = currentBalance + lockToken;
        *ownerTotalToken = ownerTotalToken.get() - lockToken;
        (*portfolioStorge)[_portfolioName] = &info.toJson()[0];
        DIPC_EMIT_EVENT(revocationPortfolio, "orderId", _orderId, "orderInfo", &ord.toJson()[0]);
    }
    
    EXPORT void PortfolioManage::withdrawPortfolio(char* _portfolioName, uint64_t _withdrawBalance){
         if(!userCanWithdraw.get()){
             return;
         }
         uint64_t currentBalance =  portfolioBalance.get()[_portfolioName];
         DipcAssert(currentBalance - _withdrawBalance < currentBalance);
         auto coinBalance = changeUint64ToU256WithChangeRate(currentBalance, changeRate.get());
         (*portfolioBalance)[_portfolioName] = currentBalance - _withdrawBalance;
         callTransfer(caller(), coinBalance);
    }
    
    EXPORT void PortfolioManage::withdrawPool(uint64_t _balance){
        isOwner();
        Address ownerAddr = Address(owner.get()); 
        callTransfer(ownerAddr, _balance);
        *ownerTotalToken = ownerTotalToken.get() - _balance * changeRate.get();
        *totalToken = totalToken.get() - _balance * changeRate.get();
        DIPC_EMIT_EVENT(tokenCount, "ownerTotalToken", ownerTotalToken.get(), "totalToken", totalToken.get());
    }
    
    PAYABLE void PortfolioManage::depositPool(uint64_t _depositValue){
        isOwner();
        
        uint64_t tokenBalance = changeU256ToUint64WithChangeRate(callValue(), changeRate.get()); 
        *ownerTotalToken = ownerTotalToken.get() + tokenBalance;
        *totalToken = totalToken.get() + tokenBalance;
        DIPC_EMIT_EVENT(tokenCount, "ownerTotalToken", ownerTotalToken.get(), "totalToken", totalToken.get());
    }
     
    CONSTANT uint64_t PortfolioManage::queryTotalToken(){
        return totalToken.get();
    }

     
    CONSTANT uint64_t PortfolioManage::queryPortfolioBalance(char* _portfolioName){
        return portfolioBalance.get()[_portfolioName];
    }

    
    CONSTANT bool PortfolioManage::queryPortfolioNameIfUsed(char* _portfolioName){
        if(portfolioStorge.get()[_portfolioName] != ""){
            return true;
        } 
        return false;
    }

    
    CONSTANT uint64_t PortfolioManage::queryChangeRate(){
        return changeRate.get();
    }

2019-12-19_15:14:53.246542: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:401] abis.ispayable :true

2019-12-19_15:14:53.246561: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:424] finalContract  this height   codetext height #include "PortfolioManage.hpp"

    
    PAYABLE void PortfolioManage::init(){
        *owner = caller().toString();
        *changeRate = 10000;
        *userCanWithdraw = false;
        uint64_t tokenBalance = getTotalBalance();
        
        *ownerTotalToken = tokenBalance;
        *totalToken = ownerTotalToken.get();
        
        
        DIPC_EMIT_EVENT(initEvent, "ownerTotalToken" ,tokenBalance);
    }
    
     
    EXPORT void PortfolioManage::setChangeRate(uint64_t _changeRate){
        isOwner();
        *changeRate = _changeRate;
    }
     
    EXPORT void PortfolioManage::setUserCanWithdraw(bool _canWithdraw){
        isOwner();
        *userCanWithdraw = _canWithdraw;
    }

    
    PAYABLE void PortfolioManage::createPortfolio(char* _portfolioName, char* _portfolioDesc){
        if(portfolioStorge.get()[_portfolioName] != ""){
            DIPC_EMIT_EVENT(ErrEvent, "Current portfolio exist: ", _portfolioName);
            return;
        } 
        std::string callerAddr = caller().toString();
        uint64_t tokenBalance = getTotalBalance();
        
        PortfolioInfo info(_portfolioName, _portfolioDesc, &callerAddr[0]);
        std::string portfolioStr = info.toJson();
        
        
        

        (*portfolioStorge)[_portfolioName] = portfolioStr;
        DipcAssert(totalToken.get() + tokenBalance > totalToken);
        (*portfolioBalance)[_portfolioName] = tokenBalance;
        *totalToken = totalToken.get() + tokenBalance; 
        
        DIPC_EMIT_EVENT(portfolioInfo, _portfolioName, &portfolioStr[0], "portfolioBalance", tokenBalance);
    }

    
    PAYABLE void PortfolioManage::depositPortfolio(char* _portfolioName){
        uint64_t tokenBalance = getTotalBalance();
        
        uint64_t currentBalance = portfolioBalance.get()[_portfolioName];
        uint64_t finalBalance  = currentBalance + tokenBalance;
        DipcAssert(totalToken.get() + tokenBalance > totalToken);
        DipcAssert(finalBalance > currentBalance);
        (*portfolioBalance)[_portfolioName] = finalBalance;
        *totalToken = totalToken.get() + finalBalance; 
        DIPC_EMIT_EVENT(depositPortfolio, "portfolioName", _portfolioName, "portfolioBalance", finalBalance);
    }
    
    PAYABLE void PortfolioManage::createOrder(char* _portfolioName, char* _orderId, uint16_t _orderType, char* _stockCode, uint64_t _stockPrice, uint64_t _stockAmount, uint64_t _endTime){
        uint64_t tokenBalance = getTotalBalance();
        DIPC_EMIT_EVENT(createOrder, "portfolioName", _portfolioName, "OrderInfo", "ignore", "tokenBalance", tokenBalance);
        uint64_t spent = 0;
        if(_orderType == 1){
            spent = _stockPrice * _stockAmount;
            DipcAssert((portfolioBalance.get()[_portfolioName] + tokenBalance) > spent);
        }
        struct Order order{_orderId, _orderType, _stockCode, _stockPrice, _stockAmount, _endTime, 0};
        std::string pInfo = portfolioStorge.get()[_portfolioName];
        
        
        
        if(pInfo == "") {
            DIPC_EMIT_EVENT(ErrEvent, "Current portfolio  doesn't exist: ", _portfolioName);
            return;
        }
        PortfolioInfo info;
        info.parseJson(pInfo);
        if(info.getOrder(_orderId).orderId != ""){
            DIPC_EMIT_EVENT(ErrEvent, "Current order exist: ", _orderId);
            return;
        }
        info.addOrder(order);
        pInfo = info.toJson();

        uint64_t currentBalance = portfolioBalance.get()[_portfolioName] ;
        uint64_t finalBalance = currentBalance + tokenBalance - spent;
        DipcAssert(totalToken.get() + tokenBalance > totalToken);
        
        DipcAssert(ownerTotalToken.get() < ownerTotalToken.get() + spent);
        (*portfolioStorge)[_portfolioName] = &pInfo[0];
        
        
        
        


        (*portfolioBalance)[_portfolioName] = finalBalance;
        *totalToken = totalToken.get() + finalBalance; 
        *ownerTotalToken = ownerTotalToken.get() + spent;
        DIPC_EMIT_EVENT(createOrder, "portfolioName", _portfolioName, "OrderInfo", &order.toJson()[0], "portfolioBalance", finalBalance);
    }

    
    EXPORT void PortfolioManage::dealOrder(char* _portfolioName, char* _orderId){
        isOwner();
        std::string pInfo = portfolioStorge.get()[_portfolioName];
        
        
        PortfolioInfo info;
        info.parseJson(pInfo);
        

        
         Order ord = info.getOrder(_orderId);
         
         
        if(ord.orderId != "" && ord.orderStatus == 0){
            
            uint64_t timenow = dipc::timestamp();
            if(ord.endTime > timenow){
                ord.orderStatus = 1;
            }else {
                ord.orderStatus = 3;
            }
        } else {
          

            return;
        }
        

        uint64_t sellValue = 0;
        if(ord.orderType == 0){
            sellValue = ord.stockAmount * ord.stockPrice;
        }
        uint64_t currentBalance =  portfolioBalance.get()[_portfolioName];
        

        DipcAssert(currentBalance + sellValue >= currentBalance);
        DipcAssert((ownerTotalToken.get() - sellValue) <= ownerTotalToken.get());
        


        (*portfolioBalance)[_portfolioName] = currentBalance + sellValue;
        *ownerTotalToken = ownerTotalToken.get() - sellValue;
        (*portfolioStorge)[_portfolioName] = &info.toJson()[0];
        
        
        
        

        DIPC_EMIT_EVENT(dealPortfolio, "orderId", _orderId, "orderInfo", &ord.toJson()[0]);
    }
    
    EXPORT void PortfolioManage::revocationOrder(char* _portfolioName, char* _orderId){
        std::string pInfo = portfolioStorge.get()[_portfolioName];
        
        
        PortfolioInfo info;
        info.parseJson(pInfo);
        Order ord = info.getOrder(_orderId);
        
        
        if(ord.orderId != "" && ord.orderStatus == 0){
            std::string callerStr = caller().toString();
            
            
            
            DipcAssert(info.getOwnerAddress() == caller().toString());
            

            uint64_t timenow = dipc::timestamp();
            if(ord.endTime > timenow){
                ord.orderStatus = 2;
            }else {
                ord.orderStatus = 3;
            }
        } else {
            return;
        }
        uint64_t lockToken = 0;
        if(ord.orderType == 1){
            lockToken = ord.stockPrice * ord.stockAmount;
        }
        uint64_t currentBalance =  portfolioBalance.get()[_portfolioName];
        
        
        
        

        DipcAssert(currentBalance + lockToken >= currentBalance);
        DipcAssert(ownerTotalToken.get() - lockToken <= ownerTotalToken.get());

        
        (*portfolioBalance)[_portfolioName] = currentBalance + lockToken;
        *ownerTotalToken = ownerTotalToken.get() - lockToken;
        (*portfolioStorge)[_portfolioName] = &info.toJson()[0];
        DIPC_EMIT_EVENT(revocationPortfolio, "orderId", _orderId, "orderInfo", &ord.toJson()[0]);
    }
    
    EXPORT void PortfolioManage::withdrawPortfolio(char* _portfolioName, uint64_t _withdrawBalance){
         if(!userCanWithdraw.get()){
             return;
         }
         uint64_t currentBalance =  portfolioBalance.get()[_portfolioName];
         DipcAssert(currentBalance - _withdrawBalance < currentBalance);
         auto coinBalance = changeUint64ToU256WithChangeRate(currentBalance, changeRate.get());
         (*portfolioBalance)[_portfolioName] = currentBalance - _withdrawBalance;
         callTransfer(caller(), coinBalance);
    }
    
    EXPORT void PortfolioManage::withdrawPool(uint64_t _balance){
        isOwner();
        Address ownerAddr = Address(owner.get()); 
        callTransfer(ownerAddr, _balance);
        *ownerTotalToken = ownerTotalToken.get() - _balance * changeRate.get();
        *totalToken = totalToken.get() - _balance * changeRate.get();
        DIPC_EMIT_EVENT(tokenCount, "ownerTotalToken", ownerTotalToken.get(), "totalToken", totalToken.get());
    }
    
    PAYABLE void PortfolioManage::depositPool(uint64_t _depositValue){
        isOwner();
        
        uint64_t tokenBalance = changeU256ToUint64WithChangeRate(callValue(), changeRate.get()); 
        *ownerTotalToken = ownerTotalToken.get() + tokenBalance;
        *totalToken = totalToken.get() + tokenBalance;
        DIPC_EMIT_EVENT(tokenCount, "ownerTotalToken", ownerTotalToken.get(), "totalToken", totalToken.get());
    }
     
    CONSTANT uint64_t PortfolioManage::queryTotalToken(){
        return totalToken.get();
    }

     
    CONSTANT uint64_t PortfolioManage::queryPortfolioBalance(char* _portfolioName){
        return portfolioBalance.get()[_portfolioName];
    }

    
    CONSTANT bool PortfolioManage::queryPortfolioNameIfUsed(char* _portfolioName){
        if(portfolioStorge.get()[_portfolioName] != ""){
            return true;
        } 
        return false;
    }

    
    CONSTANT uint64_t PortfolioManage::queryChangeRate(){
        return changeRate.get();
    }

2019-12-19_15:14:53.246570: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:427] searchContext  #include "PortfolioManage.hpp"

    
    PAYABLE void PortfolioManage::init(){
        *owner = caller().toString();
        *changeRate = 10000;
        *userCanWithdraw = false;
        uint64_t tokenBalance = getTotalBalance();
        
        *ownerTotalToken = tokenBalance;
        *totalToken = ownerTotalToken.get();
        
        
        DIPC_EMIT_EVENT(initEvent, "ownerTotalToken" ,tokenBalance);
    }
    
     
    EXPORT void PortfolioManage::setChangeRate(uint64_t _changeRate){
        isOwner();
        *changeRate = _changeRate;
    }
     
    EXPORT void PortfolioManage::setUserCanWithdraw(bool _canWithdraw){
        isOwner();
        *userCanWithdraw = _canWithdraw;
    }

    
    PAYABLE void PortfolioManage::createPortfolio(char* _portfolioName, char* _portfolioDesc){
        if(portfolioStorge.get()[_portfolioName] != ""){
            DIPC_EMIT_EVENT(ErrEvent, "Current portfolio exist: ", _portfolioName);
            return;
        } 
        std::string callerAddr = caller().toString();
        uint64_t tokenBalance = getTotalBalance();
        
        PortfolioInfo info(_portfolioName, _portfolioDesc, &callerAddr[0]);
        std::string portfolioStr = info.toJson();
        
        
        

        (*portfolioStorge)[_portfolioName] = portfolioStr;
        DipcAssert(totalToken.get() + tokenBalance > totalToken);
        (*portfolioBalance)[_portfolioName] = tokenBalance;
        *totalToken = totalToken.get() + tokenBalance; 
        
        DIPC_EMIT_EVENT(portfolioInfo, _portfolioName, &portfolioStr[0], "portfolioBalance", tokenBalance);
    }

    
    PAYABLE void PortfolioManage::depositPortfolio(char* _portfolioName){
        uint64_t tokenBalance = getTotalBalance();
        
        uint64_t currentBalance = portfolioBalance.get()[_portfolioName];
        uint64_t finalBalance  = currentBalance + tokenBalance;
        DipcAssert(totalToken.get() + tokenBalance > totalToken);
        DipcAssert(finalBalance > currentBalance);
        (*portfolioBalance)[_portfolioName] = finalBalance;
        *totalToken = totalToken.get() + finalBalance; 
        DIPC_EMIT_EVENT(depositPortfolio, "portfolioName", _portfolioName, "portfolioBalance", finalBalance);
    }
    
    PAYABLE void PortfolioManage::createOrder(char* _portfolioName, char* _orderId, uint16_t _orderType, char* _stockCode, uint64_t _stockPrice, uint64_t _stockAmount, uint64_t _endTime){
        uint64_t tokenBalance = getTotalBalance();
        DIPC_EMIT_EVENT(createOrder, "portfolioName", _portfolioName, "OrderInfo", "ignore", "tokenBalance", tokenBalance);
        uint64_t spent = 0;
        if(_orderType == 1){
            spent = _stockPrice * _stockAmount;
            DipcAssert((portfolioBalance.get()[_portfolioName] + tokenBalance) > spent);
        }
        struct Order order{_orderId, _orderType, _stockCode, _stockPrice, _stockAmount, _endTime, 0};
        std::string pInfo = portfolioStorge.get()[_portfolioName];
        
        
        
        if(pInfo == "") {
            DIPC_EMIT_EVENT(ErrEvent, "Current portfolio  doesn't exist: ", _portfolioName);
            return;
        }
        PortfolioInfo info;
        info.parseJson(pInfo);
        if(info.getOrder(_orderId).orderId != ""){
            DIPC_EMIT_EVENT(ErrEvent, "Current order exist: ", _orderId);
            return;
        }
        info.addOrder(order);
        pInfo = info.toJson();

        uint64_t currentBalance = portfolioBalance.get()[_portfolioName] ;
        uint64_t finalBalance = currentBalance + tokenBalance - spent;
        DipcAssert(totalToken.get() + tokenBalance > totalToken);
        
        DipcAssert(ownerTotalToken.get() < ownerTotalToken.get() + spent);
        (*portfolioStorge)[_portfolioName] = &pInfo[0];
        
        
        
        


        (*portfolioBalance)[_portfolioName] = finalBalance;
        *totalToken = totalToken.get() + finalBalance; 
        *ownerTotalToken = ownerTotalToken.get() + spent;
        DIPC_EMIT_EVENT(createOrder, "portfolioName", _portfolioName, "OrderInfo", &order.toJson()[0], "portfolioBalance", finalBalance);
    }

    
    EXPORT void PortfolioManage::dealOrder(char* _portfolioName, char* _orderId){
        isOwner();
        std::string pInfo = portfolioStorge.get()[_portfolioName];
        
        
        PortfolioInfo info;
        info.parseJson(pInfo);
        

        
         Order ord = info.getOrder(_orderId);
         
         
        if(ord.orderId != "" && ord.orderStatus == 0){
            
            uint64_t timenow = dipc::timestamp();
            if(ord.endTime > timenow){
                ord.orderStatus = 1;
            }else {
                ord.orderStatus = 3;
            }
        } else {
          

            return;
        }
        

        uint64_t sellValue = 0;
        if(ord.orderType == 0){
            sellValue = ord.stockAmount * ord.stockPrice;
        }
        uint64_t currentBalance =  portfolioBalance.get()[_portfolioName];
        

        DipcAssert(currentBalance + sellValue >= currentBalance);
        DipcAssert((ownerTotalToken.get() - sellValue) <= ownerTotalToken.get());
        


        (*portfolioBalance)[_portfolioName] = currentBalance + sellValue;
        *ownerTotalToken = ownerTotalToken.get() - sellValue;
        (*portfolioStorge)[_portfolioName] = &info.toJson()[0];
        
        
        
        

        DIPC_EMIT_EVENT(dealPortfolio, "orderId", _orderId, "orderInfo", &ord.toJson()[0]);
    }
    
    EXPORT void PortfolioManage::revocationOrder(char* _portfolioName, char* _orderId){
        std::string pInfo = portfolioStorge.get()[_portfolioName];
        
        
        PortfolioInfo info;
        info.parseJson(pInfo);
        Order ord = info.getOrder(_orderId);
        
        
        if(ord.orderId != "" && ord.orderStatus == 0){
            std::string callerStr = caller().toString();
            
            
            
            DipcAssert(info.getOwnerAddress() == caller().toString());
            

            uint64_t timenow = dipc::timestamp();
            if(ord.endTime > timenow){
                ord.orderStatus = 2;
            }else {
                ord.orderStatus = 3;
            }
        } else {
            return;
        }
        uint64_t lockToken = 0;
        if(ord.orderType == 1){
            lockToken = ord.stockPrice * ord.stockAmount;
        }
        uint64_t currentBalance =  portfolioBalance.get()[_portfolioName];
        
        
        
        

        DipcAssert(currentBalance + lockToken >= currentBalance);
        DipcAssert(ownerTotalToken.get() - lockToken <= ownerTotalToken.get());

        
        (*portfolioBalance)[_portfolioName] = currentBalance + lockToken;
        *ownerTotalToken = ownerTotalToken.get() - lockToken;
        (*portfolioStorge)[_portfolioName] = &info.toJson()[0];
        DIPC_EMIT_EVENT(revocationPortfolio, "orderId", _orderId, "orderInfo", &ord.toJson()[0]);
    }
    
    EXPORT void PortfolioManage::withdrawPortfolio(char* _portfolioName, uint64_t _withdrawBalance){
         if(!userCanWithdraw.get()){
             return;
         }
         uint64_t currentBalance =  portfolioBalance.get()[_portfolioName];
         DipcAssert(currentBalance - _withdrawBalance < currentBalance);
         auto coinBalance = changeUint64ToU256WithChangeRate(currentBalance, changeRate.get());
         (*portfolioBalance)[_portfolioName] = currentBalance - _withdrawBalance;
         callTransfer(caller(), coinBalance);
    }
    
    EXPORT void PortfolioManage::withdrawPool(uint64_t _balance){
        isOwner();
        Address ownerAddr = Address(owner.get()); 
        callTransfer(ownerAddr, _balance);
        *ownerTotalToken = ownerTotalToken.get() - _balance * changeRate.get();
        *totalToken = totalToken.get() - _balance * changeRate.get();
        DIPC_EMIT_EVENT(tokenCount, "ownerTotalToken", ownerTotalToken.get(), "totalToken", totalToken.get());
    }
    
    PAYABLE void PortfolioManage::depositPool(uint64_t _depositValue){
        isOwner();
        
        uint64_t tokenBalance = changeU256ToUint64WithChangeRate(callValue(), changeRate.get()); 
        *ownerTotalToken = ownerTotalToken.get() + tokenBalance;
        *totalToken = totalToken.get() + tokenBalance;
        DIPC_EMIT_EVENT(tokenCount, "ownerTotalToken", ownerTotalToken.get(), "totalToken", totalToken.get());
    }
     
    CONSTANT uint64_t PortfolioManage::queryTotalToken(){
        return totalToken.get();
    }

     
    CONSTANT uint64_t PortfolioManage::queryPortfolioBalance(char* _portfolioName){
        return portfolioBalance.get()[_portfolioName];
    }

    
    CONSTANT bool PortfolioManage::queryPortfolioNameIfUsed(char* _portfolioName){
        if(portfolioStorge.get()[_portfolioName] != ""){
            return true;
        } 
        return false;
    }

    
    CONSTANT uint64_t PortfolioManage::queryChangeRate(){
        return changeRate.get();
    }

2019-12-19_15:14:53.247295: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:451] log out out payable : PAYABLE void PortfolioManage::depositPortfolio(char* _portfolioName){
        

2019-12-19_15:14:53.247304: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:457] name : depositPortfolio   pos1  0

2019-12-19_15:14:53.247312: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:469] pos2  1619   pos1  1619

2019-12-19_15:14:53.247320: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:500] pos2 after 2235   pos1  1619

2019-12-19_15:14:53.247326: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:509] finalContract  first #include "PortfolioManage.hpp"

    
    PAYABLE void PortfolioManage::init(){
        *owner = caller().toString();
        *changeRate = 10000;
        *userCanWithdraw = false;
        uint64_t tokenBalance = getTotalBalance();
        
        *ownerTotalToken = tokenBalance;
        *totalToken = ownerTotalToken.get();
        
        
        DIPC_EMIT_EVENT(initEvent, "ownerTotalToken" ,tokenBalance);
    }
    
     
    EXPORT void PortfolioManage::setChangeRate(uint64_t _changeRate){
        isOwner();
        *changeRate = _changeRate;
    }
     
    EXPORT void PortfolioManage::setUserCanWithdraw(bool _canWithdraw){
        isOwner();
        *userCanWithdraw = _canWithdraw;
    }

    
    PAYABLE void PortfolioManage::createPortfolio(char* _portfolioName, char* _portfolioDesc){
        if(portfolioStorge.get()[_portfolioName] != ""){
            DIPC_EMIT_EVENT(ErrEvent, "Current portfolio exist: ", _portfolioName);
            return;
        } 
        std::string callerAddr = caller().toString();
        uint64_t tokenBalance = getTotalBalance();
        
        PortfolioInfo info(_portfolioName, _portfolioDesc, &callerAddr[0]);
        std::string portfolioStr = info.toJson();
        
        
        

        (*portfolioStorge)[_portfolioName] = portfolioStr;
        DipcAssert(totalToken.get() + tokenBalance > totalToken);
        (*portfolioBalance)[_portfolioName] = tokenBalance;
        *totalToken = totalToken.get() + tokenBalance; 
        
        DIPC_EMIT_EVENT(portfolioInfo, _portfolioName, &portfolioStr[0], "portfolioBalance", tokenBalance);
    }

    
    

2019-12-19_15:14:53.247332: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:510] codetext  first #include "PortfolioManage.hpp"

    
    PAYABLE void PortfolioManage::init(){
        *owner = caller().toString();
        *changeRate = 10000;
        *userCanWithdraw = false;
        uint64_t tokenBalance = getTotalBalance();
        
        *ownerTotalToken = tokenBalance;
        *totalToken = ownerTotalToken.get();
        
        
        DIPC_EMIT_EVENT(initEvent, "ownerTotalToken" ,tokenBalance);
    }
    
     
    EXPORT void PortfolioManage::setChangeRate(uint64_t _changeRate){
        isOwner();
        *changeRate = _changeRate;
    }
     
    EXPORT void PortfolioManage::setUserCanWithdraw(bool _canWithdraw){
        isOwner();
        *userCanWithdraw = _canWithdraw;
    }

    
    PAYABLE void PortfolioManage::createPortfolio(char* _portfolioName, char* _portfolioDesc){
        if(portfolioStorge.get()[_portfolioName] != ""){
            DIPC_EMIT_EVENT(ErrEvent, "Current portfolio exist: ", _portfolioName);
            return;
        } 
        std::string callerAddr = caller().toString();
        uint64_t tokenBalance = getTotalBalance();
        
        PortfolioInfo info(_portfolioName, _portfolioDesc, &callerAddr[0]);
        std::string portfolioStr = info.toJson();
        
        
        

        (*portfolioStorge)[_portfolioName] = portfolioStr;
        DipcAssert(totalToken.get() + tokenBalance > totalToken);
        (*portfolioBalance)[_portfolioName] = tokenBalance;
        *totalToken = totalToken.get() + tokenBalance; 
        
        DIPC_EMIT_EVENT(portfolioInfo, _portfolioName, &portfolioStr[0], "portfolioBalance", tokenBalance);
    }

    
    PAYABLE void PortfolioManage::depositPortfolio(char* _portfolioName){
        uint64_t tokenBalance = getTotalBalance();
        
        uint64_t currentBalance = portfolioBalance.get()[_portfolioName];
        uint64_t finalBalance  = currentBalance + tokenBalance;
        DipcAssert(totalToken.get() + tokenBalance > totalToken);
        DipcAssert(finalBalance > currentBalance);
        (*portfolioBalance)[_portfolioName] = finalBalance;
        *totalToken = totalToken.get() + finalBalance; 
        DIPC_EMIT_EVENT(depositPortfolio, "portfolioName", _portfolioName, "portfolioBalance", finalBalance);
    }
    
    PAYABLE void PortfolioManage::createOrder(char* _portfolioName, char* _orderId, uint16_t _orderType, char* _stockCode, uint64_t _stockPrice, uint64_t _stockAmount, uint64_t _endTime){
        uint64_t tokenBalance = getTotalBalance();
        DIPC_EMIT_EVENT(createOrder, "portfolioName", _portfolioName, "OrderInfo", "ignore", "tokenBalance", tokenBalance);
        uint64_t spent = 0;
        if(_orderType == 1){
            spent = _stockPrice * _stockAmount;
            DipcAssert((portfolioBalance.get()[_portfolioName] + tokenBalance) > spent);
        }
        struct Order order{_orderId, _orderType, _stockCode, _stockPrice, _stockAmount, _endTime, 0};
        std::string pInfo = portfolioStorge.get()[_portfolioName];
        
        
        
        if(pInfo == "") {
            DIPC_EMIT_EVENT(ErrEvent, "Current portfolio  doesn't exist: ", _portfolioName);
            return;
        }
        PortfolioInfo info;
        info.parseJson(pInfo);
        if(info.getOrder(_orderId).orderId != ""){
            DIPC_EMIT_EVENT(ErrEvent, "Current order exist: ", _orderId);
            return;
        }
        info.addOrder(order);
        pInfo = info.toJson();

        uint64_t currentBalance = portfolioBalance.get()[_portfolioName] ;
        uint64_t finalBalance = currentBalance + tokenBalance - spent;
        DipcAssert(totalToken.get() + tokenBalance > totalToken);
        
        DipcAssert(ownerTotalToken.get() < ownerTotalToken.get() + spent);
        (*portfolioStorge)[_portfolioName] = &pInfo[0];
        
        
        
        


        (*portfolioBalance)[_portfolioName] = finalBalance;
        *totalToken = totalToken.get() + finalBalance; 
        *ownerTotalToken = ownerTotalToken.get() + spent;
        DIPC_EMIT_EVENT(createOrder, "portfolioName", _portfolioName, "OrderInfo", &order.toJson()[0], "portfolioBalance", finalBalance);
    }

    
    EXPORT void PortfolioManage::dealOrder(char* _portfolioName, char* _orderId){
        isOwner();
        std::string pInfo = portfolioStorge.get()[_portfolioName];
        
        
        PortfolioInfo info;
        info.parseJson(pInfo);
        

        
         Order ord = info.getOrder(_orderId);
         
         
        if(ord.orderId != "" && ord.orderStatus == 0){
            
            uint64_t timenow = dipc::timestamp();
            if(ord.endTime > timenow){
                ord.orderStatus = 1;
            }else {
                ord.orderStatus = 3;
            }
        } else {
          

            return;
        }
        

        uint64_t sellValue = 0;
        if(ord.orderType == 0){
            sellValue = ord.stockAmount * ord.stockPrice;
        }
        uint64_t currentBalance =  portfolioBalance.get()[_portfolioName];
        

        DipcAssert(currentBalance + sellValue >= currentBalance);
        DipcAssert((ownerTotalToken.get() - sellValue) <= ownerTotalToken.get());
        


        (*portfolioBalance)[_portfolioName] = currentBalance + sellValue;
        *ownerTotalToken = ownerTotalToken.get() - sellValue;
        (*portfolioStorge)[_portfolioName] = &info.toJson()[0];
        
        
        
        

        DIPC_EMIT_EVENT(dealPortfolio, "orderId", _orderId, "orderInfo", &ord.toJson()[0]);
    }
    
    EXPORT void PortfolioManage::revocationOrder(char* _portfolioName, char* _orderId){
        std::string pInfo = portfolioStorge.get()[_portfolioName];
        
        
        PortfolioInfo info;
        info.parseJson(pInfo);
        Order ord = info.getOrder(_orderId);
        
        
        if(ord.orderId != "" && ord.orderStatus == 0){
            std::string callerStr = caller().toString();
            
            
            
            DipcAssert(info.getOwnerAddress() == caller().toString());
            

            uint64_t timenow = dipc::timestamp();
            if(ord.endTime > timenow){
                ord.orderStatus = 2;
            }else {
                ord.orderStatus = 3;
            }
        } else {
            return;
        }
        uint64_t lockToken = 0;
        if(ord.orderType == 1){
            lockToken = ord.stockPrice * ord.stockAmount;
        }
        uint64_t currentBalance =  portfolioBalance.get()[_portfolioName];
        
        
        
        

        DipcAssert(currentBalance + lockToken >= currentBalance);
        DipcAssert(ownerTotalToken.get() - lockToken <= ownerTotalToken.get());

        
        (*portfolioBalance)[_portfolioName] = currentBalance + lockToken;
        *ownerTotalToken = ownerTotalToken.get() - lockToken;
        (*portfolioStorge)[_portfolioName] = &info.toJson()[0];
        DIPC_EMIT_EVENT(revocationPortfolio, "orderId", _orderId, "orderInfo", &ord.toJson()[0]);
    }
    
    EXPORT void PortfolioManage::withdrawPortfolio(char* _portfolioName, uint64_t _withdrawBalance){
         if(!userCanWithdraw.get()){
             return;
         }
         uint64_t currentBalance =  portfolioBalance.get()[_portfolioName];
         DipcAssert(currentBalance - _withdrawBalance < currentBalance);
         auto coinBalance = changeUint64ToU256WithChangeRate(currentBalance, changeRate.get());
         (*portfolioBalance)[_portfolioName] = currentBalance - _withdrawBalance;
         callTransfer(caller(), coinBalance);
    }
    
    EXPORT void PortfolioManage::withdrawPool(uint64_t _balance){
        isOwner();
        Address ownerAddr = Address(owner.get()); 
        callTransfer(ownerAddr, _balance);
        *ownerTotalToken = ownerTotalToken.get() - _balance * changeRate.get();
        *totalToken = totalToken.get() - _balance * changeRate.get();
        DIPC_EMIT_EVENT(tokenCount, "ownerTotalToken", ownerTotalToken.get(), "totalToken", totalToken.get());
    }
    
    PAYABLE void PortfolioManage::depositPool(uint64_t _depositValue){
        isOwner();
        
        uint64_t tokenBalance = changeU256ToUint64WithChangeRate(callValue(), changeRate.get()); 
        *ownerTotalToken = ownerTotalToken.get() + tokenBalance;
        *totalToken = totalToken.get() + tokenBalance;
        DIPC_EMIT_EVENT(tokenCount, "ownerTotalToken", ownerTotalToken.get(), "totalToken", totalToken.get());
    }
     
    CONSTANT uint64_t PortfolioManage::queryTotalToken(){
        return totalToken.get();
    }

     
    CONSTANT uint64_t PortfolioManage::queryPortfolioBalance(char* _portfolioName){
        return portfolioBalance.get()[_portfolioName];
    }

    
    CONSTANT bool PortfolioManage::queryPortfolioNameIfUsed(char* _portfolioName){
        if(portfolioStorge.get()[_portfolioName] != ""){
            return true;
        } 
        return false;
    }

    
    CONSTANT uint64_t PortfolioManage::queryChangeRate(){
        return changeRate.get();
    }

2019-12-19_15:14:53.247340: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:513] s  first PAYABLE void PortfolioManage::depositPortfolio(char* _portfolioName){
        uint64_t tokenBalance = getTotalBalance();
        
        uint64_t currentBalance = portfolioBalance.get()[_portfolioName];
        uint64_t finalBalance  = currentBalance + tokenBalance;
        DipcAssert(totalToken.get() + tokenBalance > totalToken);
        DipcAssert(finalBalance > currentBalance);
        (*portfolioBalance)[_portfolioName] = finalBalance;
        *totalToken = totalToken.get() + finalBalance; 
        DIPC_EMIT_EVENT(depositPortfolio, "portfolioName", _portfolioName, "portfolioBalance", finalBalance);
    }

2019-12-19_15:14:53.251772: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:599] search func : PAYABLE void PortfolioManage::depositPortfolio(char* _portfolioName){
        uint64_t tokenBalance = getTotalBalance();
        
        uint64_t currentBalance = portfolioBalance.get()[_portfolioName];
        uint64_t finalBalance  = currentBalance + tokenBalance;
        DipcAssert(totalToken.get() + tokenBalance > totalToken);
        DipcAssert(finalBalance > currentBalance);
        (*portfolioBalance)[_portfolioName] = finalBalance;
        *totalToken = totalToken.get() + finalBalance; 
        DIPC_EMIT_EVENT(depositPortfolio, "portfolioName", _portfolioName, "portfolioBalance", finalBalance);
    }
2019-12-19_15:14:53.251790: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:424] finalContract  this height  #include "PortfolioManage.hpp"

    
    PAYABLE void PortfolioManage::init(){
        *owner = caller().toString();
        *changeRate = 10000;
        *userCanWithdraw = false;
        uint64_t tokenBalance = getTotalBalance();
        
        *ownerTotalToken = tokenBalance;
        *totalToken = ownerTotalToken.get();
        
        
        DIPC_EMIT_EVENT(initEvent, "ownerTotalToken" ,tokenBalance);
    }
    
     
    EXPORT void PortfolioManage::setChangeRate(uint64_t _changeRate){
        isOwner();
        *changeRate = _changeRate;
    }
     
    EXPORT void PortfolioManage::setUserCanWithdraw(bool _canWithdraw){
        isOwner();
        *userCanWithdraw = _canWithdraw;
    }

    
    PAYABLE void PortfolioManage::createPortfolio(char* _portfolioName, char* _portfolioDesc){
        if(portfolioStorge.get()[_portfolioName] != ""){
            DIPC_EMIT_EVENT(ErrEvent, "Current portfolio exist: ", _portfolioName);
            return;
        } 
        std::string callerAddr = caller().toString();
        uint64_t tokenBalance = getTotalBalance();
        
        PortfolioInfo info(_portfolioName, _portfolioDesc, &callerAddr[0]);
        std::string portfolioStr = info.toJson();
        
        
        

        (*portfolioStorge)[_portfolioName] = portfolioStr;
        DipcAssert(totalToken.get() + tokenBalance > totalToken);
        (*portfolioBalance)[_portfolioName] = tokenBalance;
        *totalToken = totalToken.get() + tokenBalance; 
        
        DIPC_EMIT_EVENT(portfolioInfo, _portfolioName, &portfolioStr[0], "portfolioBalance", tokenBalance);
    }

    
    PAYABLE void PortfolioManage::depositPortfolio(char* _portfolioName){
        uint64_t tokenBalance = getTotalBalance();
        
        uint64_t currentBalance = portfolioBalance.get()[_portfolioName];
        uint64_t finalBalance  = currentBalance + tokenBalance;
        DipcAssert(totalToken.get() + tokenBalance > totalToken);
        DipcAssert(finalBalance > currentBalance);
        (*portfolioBalance)[_portfolioName] = finalBalance;
        *totalToken = totalToken.get() + finalBalance; 
        DIPC_EMIT_EVENT(depositPortfolio, "portfolioName", _portfolioName, "portfolioBalance", finalBalance);
    } codetext height #include "PortfolioManage.hpp"

    
    PAYABLE void PortfolioManage::init(){
        *owner = caller().toString();
        *changeRate = 10000;
        *userCanWithdraw = false;
        uint64_t tokenBalance = getTotalBalance();
        
        *ownerTotalToken = tokenBalance;
        *totalToken = ownerTotalToken.get();
        
        
        DIPC_EMIT_EVENT(initEvent, "ownerTotalToken" ,tokenBalance);
    }
    
     
    EXPORT void PortfolioManage::setChangeRate(uint64_t _changeRate){
        isOwner();
        *changeRate = _changeRate;
    }
     
    EXPORT void PortfolioManage::setUserCanWithdraw(bool _canWithdraw){
        isOwner();
        *userCanWithdraw = _canWithdraw;
    }

    
    PAYABLE void PortfolioManage::createPortfolio(char* _portfolioName, char* _portfolioDesc){
        if(portfolioStorge.get()[_portfolioName] != ""){
            DIPC_EMIT_EVENT(ErrEvent, "Current portfolio exist: ", _portfolioName);
            return;
        } 
        std::string callerAddr = caller().toString();
        uint64_t tokenBalance = getTotalBalance();
        
        PortfolioInfo info(_portfolioName, _portfolioDesc, &callerAddr[0]);
        std::string portfolioStr = info.toJson();
        
        
        

        (*portfolioStorge)[_portfolioName] = portfolioStr;
        DipcAssert(totalToken.get() + tokenBalance > totalToken);
        (*portfolioBalance)[_portfolioName] = tokenBalance;
        *totalToken = totalToken.get() + tokenBalance; 
        
        DIPC_EMIT_EVENT(portfolioInfo, _portfolioName, &portfolioStr[0], "portfolioBalance", tokenBalance);
    }

    
    PAYABLE void PortfolioManage::depositPortfolio(char* _portfolioName){
        uint64_t tokenBalance = getTotalBalance();
        
        uint64_t currentBalance = portfolioBalance.get()[_portfolioName];
        uint64_t finalBalance  = currentBalance + tokenBalance;
        DipcAssert(totalToken.get() + tokenBalance > totalToken);
        DipcAssert(finalBalance > currentBalance);
        (*portfolioBalance)[_portfolioName] = finalBalance;
        *totalToken = totalToken.get() + finalBalance; 
        DIPC_EMIT_EVENT(depositPortfolio, "portfolioName", _portfolioName, "portfolioBalance", finalBalance);
    }
    
    PAYABLE void PortfolioManage::createOrder(char* _portfolioName, char* _orderId, uint16_t _orderType, char* _stockCode, uint64_t _stockPrice, uint64_t _stockAmount, uint64_t _endTime){
        uint64_t tokenBalance = getTotalBalance();
        DIPC_EMIT_EVENT(createOrder, "portfolioName", _portfolioName, "OrderInfo", "ignore", "tokenBalance", tokenBalance);
        uint64_t spent = 0;
        if(_orderType == 1){
            spent = _stockPrice * _stockAmount;
            DipcAssert((portfolioBalance.get()[_portfolioName] + tokenBalance) > spent);
        }
        struct Order order{_orderId, _orderType, _stockCode, _stockPrice, _stockAmount, _endTime, 0};
        std::string pInfo = portfolioStorge.get()[_portfolioName];
        
        
        
        if(pInfo == "") {
            DIPC_EMIT_EVENT(ErrEvent, "Current portfolio  doesn't exist: ", _portfolioName);
            return;
        }
        PortfolioInfo info;
        info.parseJson(pInfo);
        if(info.getOrder(_orderId).orderId != ""){
            DIPC_EMIT_EVENT(ErrEvent, "Current order exist: ", _orderId);
            return;
        }
        info.addOrder(order);
        pInfo = info.toJson();

        uint64_t currentBalance = portfolioBalance.get()[_portfolioName] ;
        uint64_t finalBalance = currentBalance + tokenBalance - spent;
        DipcAssert(totalToken.get() + tokenBalance > totalToken);
        
        DipcAssert(ownerTotalToken.get() < ownerTotalToken.get() + spent);
        (*portfolioStorge)[_portfolioName] = &pInfo[0];
        
        
        
        


        (*portfolioBalance)[_portfolioName] = finalBalance;
        *totalToken = totalToken.get() + finalBalance; 
        *ownerTotalToken = ownerTotalToken.get() + spent;
        DIPC_EMIT_EVENT(createOrder, "portfolioName", _portfolioName, "OrderInfo", &order.toJson()[0], "portfolioBalance", finalBalance);
    }

    
    EXPORT void PortfolioManage::dealOrder(char* _portfolioName, char* _orderId){
        isOwner();
        std::string pInfo = portfolioStorge.get()[_portfolioName];
        
        
        PortfolioInfo info;
        info.parseJson(pInfo);
        

        
         Order ord = info.getOrder(_orderId);
         
         
        if(ord.orderId != "" && ord.orderStatus == 0){
            
            uint64_t timenow = dipc::timestamp();
            if(ord.endTime > timenow){
                ord.orderStatus = 1;
            }else {
                ord.orderStatus = 3;
            }
        } else {
          

            return;
        }
        

        uint64_t sellValue = 0;
        if(ord.orderType == 0){
            sellValue = ord.stockAmount * ord.stockPrice;
        }
        uint64_t currentBalance =  portfolioBalance.get()[_portfolioName];
        

        DipcAssert(currentBalance + sellValue >= currentBalance);
        DipcAssert((ownerTotalToken.get() - sellValue) <= ownerTotalToken.get());
        


        (*portfolioBalance)[_portfolioName] = currentBalance + sellValue;
        *ownerTotalToken = ownerTotalToken.get() - sellValue;
        (*portfolioStorge)[_portfolioName] = &info.toJson()[0];
        
        
        
        

        DIPC_EMIT_EVENT(dealPortfolio, "orderId", _orderId, "orderInfo", &ord.toJson()[0]);
    }
    
    EXPORT void PortfolioManage::revocationOrder(char* _portfolioName, char* _orderId){
        std::string pInfo = portfolioStorge.get()[_portfolioName];
        
        
        PortfolioInfo info;
        info.parseJson(pInfo);
        Order ord = info.getOrder(_orderId);
        
        
        if(ord.orderId != "" && ord.orderStatus == 0){
            std::string callerStr = caller().toString();
            
            
            
            DipcAssert(info.getOwnerAddress() == caller().toString());
            

            uint64_t timenow = dipc::timestamp();
            if(ord.endTime > timenow){
                ord.orderStatus = 2;
            }else {
                ord.orderStatus = 3;
            }
        } else {
            return;
        }
        uint64_t lockToken = 0;
        if(ord.orderType == 1){
            lockToken = ord.stockPrice * ord.stockAmount;
        }
        uint64_t currentBalance =  portfolioBalance.get()[_portfolioName];
        
        
        
        

        DipcAssert(currentBalance + lockToken >= currentBalance);
        DipcAssert(ownerTotalToken.get() - lockToken <= ownerTotalToken.get());

        
        (*portfolioBalance)[_portfolioName] = currentBalance + lockToken;
        *ownerTotalToken = ownerTotalToken.get() - lockToken;
        (*portfolioStorge)[_portfolioName] = &info.toJson()[0];
        DIPC_EMIT_EVENT(revocationPortfolio, "orderId", _orderId, "orderInfo", &ord.toJson()[0]);
    }
    
    EXPORT void PortfolioManage::withdrawPortfolio(char* _portfolioName, uint64_t _withdrawBalance){
         if(!userCanWithdraw.get()){
             return;
         }
         uint64_t currentBalance =  portfolioBalance.get()[_portfolioName];
         DipcAssert(currentBalance - _withdrawBalance < currentBalance);
         auto coinBalance = changeUint64ToU256WithChangeRate(currentBalance, changeRate.get());
         (*portfolioBalance)[_portfolioName] = currentBalance - _withdrawBalance;
         callTransfer(caller(), coinBalance);
    }
    
    EXPORT void PortfolioManage::withdrawPool(uint64_t _balance){
        isOwner();
        Address ownerAddr = Address(owner.get()); 
        callTransfer(ownerAddr, _balance);
        *ownerTotalToken = ownerTotalToken.get() - _balance * changeRate.get();
        *totalToken = totalToken.get() - _balance * changeRate.get();
        DIPC_EMIT_EVENT(tokenCount, "ownerTotalToken", ownerTotalToken.get(), "totalToken", totalToken.get());
    }
    
    PAYABLE void PortfolioManage::depositPool(uint64_t _depositValue){
        isOwner();
        
        uint64_t tokenBalance = changeU256ToUint64WithChangeRate(callValue(), changeRate.get()); 
        *ownerTotalToken = ownerTotalToken.get() + tokenBalance;
        *totalToken = totalToken.get() + tokenBalance;
        DIPC_EMIT_EVENT(tokenCount, "ownerTotalToken", ownerTotalToken.get(), "totalToken", totalToken.get());
    }
     
    CONSTANT uint64_t PortfolioManage::queryTotalToken(){
        return totalToken.get();
    }

     
    CONSTANT uint64_t PortfolioManage::queryPortfolioBalance(char* _portfolioName){
        return portfolioBalance.get()[_portfolioName];
    }

    
    CONSTANT bool PortfolioManage::queryPortfolioNameIfUsed(char* _portfolioName){
        if(portfolioStorge.get()[_portfolioName] != ""){
            return true;
        } 
        return false;
    }

    
    CONSTANT uint64_t PortfolioManage::queryChangeRate(){
        return changeRate.get();
    }

2019-12-19_15:14:53.251856: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:427] searchContext  
    
    PAYABLE void PortfolioManage::createOrder(char* _portfolioName, char* _orderId, uint16_t _orderType, char* _stockCode, uint64_t _stockPrice, uint64_t _stockAmount, uint64_t _endTime){
        uint64_t tokenBalance = getTotalBalance();
        DIPC_EMIT_EVENT(createOrder, "portfolioName", _portfolioName, "OrderInfo", "ignore", "tokenBalance", tokenBalance);
        uint64_t spent = 0;
        if(_orderType == 1){
            spent = _stockPrice * _stockAmount;
            DipcAssert((portfolioBalance.get()[_portfolioName] + tokenBalance) > spent);
        }
        struct Order order{_orderId, _orderType, _stockCode, _stockPrice, _stockAmount, _endTime, 0};
        std::string pInfo = portfolioStorge.get()[_portfolioName];
        
        
        
        if(pInfo == "") {
            DIPC_EMIT_EVENT(ErrEvent, "Current portfolio  doesn't exist: ", _portfolioName);
            return;
        }
        PortfolioInfo info;
        info.parseJson(pInfo);
        if(info.getOrder(_orderId).orderId != ""){
            DIPC_EMIT_EVENT(ErrEvent, "Current order exist: ", _orderId);
            return;
        }
        info.addOrder(order);
        pInfo = info.toJson();

        uint64_t currentBalance = portfolioBalance.get()[_portfolioName] ;
        uint64_t finalBalance = currentBalance + tokenBalance - spent;
        DipcAssert(totalToken.get() + tokenBalance > totalToken);
        
        DipcAssert(ownerTotalToken.get() < ownerTotalToken.get() + spent);
        (*portfolioStorge)[_portfolioName] = &pInfo[0];
        
        
        
        


        (*portfolioBalance)[_portfolioName] = finalBalance;
        *totalToken = totalToken.get() + finalBalance; 
        *ownerTotalToken = ownerTotalToken.get() + spent;
        DIPC_EMIT_EVENT(createOrder, "portfolioName", _portfolioName, "OrderInfo", &order.toJson()[0], "portfolioBalance", finalBalance);
    }

    
    EXPORT void PortfolioManage::dealOrder(char* _portfolioName, char* _orderId){
        isOwner();
        std::string pInfo = portfolioStorge.get()[_portfolioName];
        
        
        PortfolioInfo info;
        info.parseJson(pInfo);
        

        
         Order ord = info.getOrder(_orderId);
         
         
        if(ord.orderId != "" && ord.orderStatus == 0){
            
            uint64_t timenow = dipc::timestamp();
            if(ord.endTime > timenow){
                ord.orderStatus = 1;
            }else {
                ord.orderStatus = 3;
            }
        } else {
          

            return;
        }
        

        uint64_t sellValue = 0;
        if(ord.orderType == 0){
            sellValue = ord.stockAmount * ord.stockPrice;
        }
        uint64_t currentBalance =  portfolioBalance.get()[_portfolioName];
        

        DipcAssert(currentBalance + sellValue >= currentBalance);
        DipcAssert((ownerTotalToken.get() - sellValue) <= ownerTotalToken.get());
        


        (*portfolioBalance)[_portfolioName] = currentBalance + sellValue;
        *ownerTotalToken = ownerTotalToken.get() - sellValue;
        (*portfolioStorge)[_portfolioName] = &info.toJson()[0];
        
        
        
        

        DIPC_EMIT_EVENT(dealPortfolio, "orderId", _orderId, "orderInfo", &ord.toJson()[0]);
    }
    
    EXPORT void PortfolioManage::revocationOrder(char* _portfolioName, char* _orderId){
        std::string pInfo = portfolioStorge.get()[_portfolioName];
        
        
        PortfolioInfo info;
        info.parseJson(pInfo);
        Order ord = info.getOrder(_orderId);
        
        
        if(ord.orderId != "" && ord.orderStatus == 0){
            std::string callerStr = caller().toString();
            
            
            
            DipcAssert(info.getOwnerAddress() == caller().toString());
            

            uint64_t timenow = dipc::timestamp();
            if(ord.endTime > timenow){
                ord.orderStatus = 2;
            }else {
                ord.orderStatus = 3;
            }
        } else {
            return;
        }
        uint64_t lockToken = 0;
        if(ord.orderType == 1){
            lockToken = ord.stockPrice * ord.stockAmount;
        }
        uint64_t currentBalance =  portfolioBalance.get()[_portfolioName];
        
        
        
        

        DipcAssert(currentBalance + lockToken >= currentBalance);
        DipcAssert(ownerTotalToken.get() - lockToken <= ownerTotalToken.get());

        
        (*portfolioBalance)[_portfolioName] = currentBalance + lockToken;
        *ownerTotalToken = ownerTotalToken.get() - lockToken;
        (*portfolioStorge)[_portfolioName] = &info.toJson()[0];
        DIPC_EMIT_EVENT(revocationPortfolio, "orderId", _orderId, "orderInfo", &ord.toJson()[0]);
    }
    
    EXPORT void PortfolioManage::withdrawPortfolio(char* _portfolioName, uint64_t _withdrawBalance){
         if(!userCanWithdraw.get()){
             return;
         }
         uint64_t currentBalance =  portfolioBalance.get()[_portfolioName];
         DipcAssert(currentBalance - _withdrawBalance < currentBalance);
         auto coinBalance = changeUint64ToU256WithChangeRate(currentBalance, changeRate.get());
         (*portfolioBalance)[_portfolioName] = currentBalance - _withdrawBalance;
         callTransfer(caller(), coinBalance);
    }
    
    EXPORT void PortfolioManage::withdrawPool(uint64_t _balance){
        isOwner();
        Address ownerAddr = Address(owner.get()); 
        callTransfer(ownerAddr, _balance);
        *ownerTotalToken = ownerTotalToken.get() - _balance * changeRate.get();
        *totalToken = totalToken.get() - _balance * changeRate.get();
        DIPC_EMIT_EVENT(tokenCount, "ownerTotalToken", ownerTotalToken.get(), "totalToken", totalToken.get());
    }
    
    PAYABLE void PortfolioManage::depositPool(uint64_t _depositValue){
        isOwner();
        
        uint64_t tokenBalance = changeU256ToUint64WithChangeRate(callValue(), changeRate.get()); 
        *ownerTotalToken = ownerTotalToken.get() + tokenBalance;
        *totalToken = totalToken.get() + tokenBalance;
        DIPC_EMIT_EVENT(tokenCount, "ownerTotalToken", ownerTotalToken.get(), "totalToken", totalToken.get());
    }
     
    CONSTANT uint64_t PortfolioManage::queryTotalToken(){
        return totalToken.get();
    }

     
    CONSTANT uint64_t PortfolioManage::queryPortfolioBalance(char* _portfolioName){
        return portfolioBalance.get()[_portfolioName];
    }

    
    CONSTANT bool PortfolioManage::queryPortfolioNameIfUsed(char* _portfolioName){
        if(portfolioStorge.get()[_portfolioName] != ""){
            return true;
        } 
        return false;
    }

    
    CONSTANT uint64_t PortfolioManage::queryChangeRate(){
        return changeRate.get();
    }

2019-12-19_15:14:53.254455: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:442] finalContract  this new  #include "PortfolioManage.hpp"

    
    PAYABLE void PortfolioManage::init(){
        *owner = caller().toString();
        *changeRate = 10000;
        *userCanWithdraw = false;
        uint64_t tokenBalance = getTotalBalance();
        
        *ownerTotalToken = tokenBalance;
        *totalToken = ownerTotalToken.get();
        
        
        DIPC_EMIT_EVENT(initEvent, "ownerTotalToken" ,tokenBalance);
    }
    
     
    EXPORT void PortfolioManage::setChangeRate(uint64_t _changeRate){
        isOwner();
        *changeRate = _changeRate;
    }
     
    EXPORT void PortfolioManage::setUserCanWithdraw(bool _canWithdraw){
        isOwner();
        *userCanWithdraw = _canWithdraw;
    }

    
    PAYABLE void PortfolioManage::createPortfolio(char* _portfolioName, char* _portfolioDesc){
        if(portfolioStorge.get()[_portfolioName] != ""){
            DIPC_EMIT_EVENT(ErrEvent, "Current portfolio exist: ", _portfolioName);
            return;
        } 
        std::string callerAddr = caller().toString();
        uint64_t tokenBalance = getTotalBalance();
        
        PortfolioInfo info(_portfolioName, _portfolioDesc, &callerAddr[0]);
        std::string portfolioStr = info.toJson();
        
        
        

        (*portfolioStorge)[_portfolioName] = portfolioStr;
        DipcAssert(totalToken.get() + tokenBalance > totalToken);
        (*portfolioBalance)[_portfolioName] = tokenBalance;
        *totalToken = totalToken.get() + tokenBalance; 
        
        DIPC_EMIT_EVENT(portfolioInfo, _portfolioName, &portfolioStr[0], "portfolioBalance", tokenBalance);
    }

    
    PAYABLE void PortfolioManage::depositPortfolio(char* _portfolioName){
        uint64_t tokenBalance = getTotalBalance();
        
        uint64_t currentBalance = portfolioBalance.get()[_portfolioName];
        uint64_t finalBalance  = currentBalance + tokenBalance;
        DipcAssert(totalToken.get() + tokenBalance > totalToken);
        DipcAssert(finalBalance > currentBalance);
        (*portfolioBalance)[_portfolioName] = finalBalance;
        *totalToken = totalToken.get() + finalBalance; 
        DIPC_EMIT_EVENT(depositPortfolio, "portfolioName", _portfolioName, "portfolioBalance", finalBalance);
    } codetext new #include "PortfolioManage.hpp"

    
    PAYABLE void PortfolioManage::init(){
        *owner = caller().toString();
        *changeRate = 10000;
        *userCanWithdraw = false;
        uint64_t tokenBalance = getTotalBalance();
        
        *ownerTotalToken = tokenBalance;
        *totalToken = ownerTotalToken.get();
        
        
        DIPC_EMIT_EVENT(initEvent, "ownerTotalToken" ,tokenBalance);
    }
    
     
    EXPORT void PortfolioManage::setChangeRate(uint64_t _changeRate){
        isOwner();
        *changeRate = _changeRate;
    }
     
    EXPORT void PortfolioManage::setUserCanWithdraw(bool _canWithdraw){
        isOwner();
        *userCanWithdraw = _canWithdraw;
    }

    
    PAYABLE void PortfolioManage::createPortfolio(char* _portfolioName, char* _portfolioDesc){
        if(portfolioStorge.get()[_portfolioName] != ""){
            DIPC_EMIT_EVENT(ErrEvent, "Current portfolio exist: ", _portfolioName);
            return;
        } 
        std::string callerAddr = caller().toString();
        uint64_t tokenBalance = getTotalBalance();
        
        PortfolioInfo info(_portfolioName, _portfolioDesc, &callerAddr[0]);
        std::string portfolioStr = info.toJson();
        
        
        

        (*portfolioStorge)[_portfolioName] = portfolioStr;
        DipcAssert(totalToken.get() + tokenBalance > totalToken);
        (*portfolioBalance)[_portfolioName] = tokenBalance;
        *totalToken = totalToken.get() + tokenBalance; 
        
        DIPC_EMIT_EVENT(portfolioInfo, _portfolioName, &portfolioStr[0], "portfolioBalance", tokenBalance);
    }

    
    PAYABLE void PortfolioManage::depositPortfolio(char* _portfolioName){
        uint64_t tokenBalance = getTotalBalance();
        
        uint64_t currentBalance = portfolioBalance.get()[_portfolioName];
        uint64_t finalBalance  = currentBalance + tokenBalance;
        DipcAssert(totalToken.get() + tokenBalance > totalToken);
        DipcAssert(finalBalance > currentBalance);
        (*portfolioBalance)[_portfolioName] = finalBalance;
        *totalToken = totalToken.get() + finalBalance; 
        DIPC_EMIT_EVENT(depositPortfolio, "portfolioName", _portfolioName, "portfolioBalance", finalBalance);
    }
    
    PAYABLE void PortfolioManage::createOrder(char* _portfolioName, char* _orderId, uint16_t _orderType, char* _stockCode, uint64_t _stockPrice, uint64_t _stockAmount, uint64_t _endTime){
        uint64_t tokenBalance = getTotalBalance();
        DIPC_EMIT_EVENT(createOrder, "portfolioName", _portfolioName, "OrderInfo", "ignore", "tokenBalance", tokenBalance);
        uint64_t spent = 0;
        if(_orderType == 1){
            spent = _stockPrice * _stockAmount;
            DipcAssert((portfolioBalance.get()[_portfolioName] + tokenBalance) > spent);
        }
        struct Order order{_orderId, _orderType, _stockCode, _stockPrice, _stockAmount, _endTime, 0};
        std::string pInfo = portfolioStorge.get()[_portfolioName];
        
        
        
        if(pInfo == "") {
            DIPC_EMIT_EVENT(ErrEvent, "Current portfolio  doesn't exist: ", _portfolioName);
            return;
        }
        PortfolioInfo info;
        info.parseJson(pInfo);
        if(info.getOrder(_orderId).orderId != ""){
            DIPC_EMIT_EVENT(ErrEvent, "Current order exist: ", _orderId);
            return;
        }
        info.addOrder(order);
        pInfo = info.toJson();

        uint64_t currentBalance = portfolioBalance.get()[_portfolioName] ;
        uint64_t finalBalance = currentBalance + tokenBalance - spent;
        DipcAssert(totalToken.get() + tokenBalance > totalToken);
        
        DipcAssert(ownerTotalToken.get() < ownerTotalToken.get() + spent);
        (*portfolioStorge)[_portfolioName] = &pInfo[0];
        
        
        
        


        (*portfolioBalance)[_portfolioName] = finalBalance;
        *totalToken = totalToken.get() + finalBalance; 
        *ownerTotalToken = ownerTotalToken.get() + spent;
        DIPC_EMIT_EVENT(createOrder, "portfolioName", _portfolioName, "OrderInfo", &order.toJson()[0], "portfolioBalance", finalBalance);
    }

    
    EXPORT void PortfolioManage::dealOrder(char* _portfolioName, char* _orderId){
        isOwner();
        std::string pInfo = portfolioStorge.get()[_portfolioName];
        
        
        PortfolioInfo info;
        info.parseJson(pInfo);
        

        
         Order ord = info.getOrder(_orderId);
         
         
        if(ord.orderId != "" && ord.orderStatus == 0){
            
            uint64_t timenow = dipc::timestamp();
            if(ord.endTime > timenow){
                ord.orderStatus = 1;
            }else {
                ord.orderStatus = 3;
            }
        } else {
          

            return;
        }
        

        uint64_t sellValue = 0;
        if(ord.orderType == 0){
            sellValue = ord.stockAmount * ord.stockPrice;
        }
        uint64_t currentBalance =  portfolioBalance.get()[_portfolioName];
        

        DipcAssert(currentBalance + sellValue >= currentBalance);
        DipcAssert((ownerTotalToken.get() - sellValue) <= ownerTotalToken.get());
        


        (*portfolioBalance)[_portfolioName] = currentBalance + sellValue;
        *ownerTotalToken = ownerTotalToken.get() - sellValue;
        (*portfolioStorge)[_portfolioName] = &info.toJson()[0];
        
        
        
        

        DIPC_EMIT_EVENT(dealPortfolio, "orderId", _orderId, "orderInfo", &ord.toJson()[0]);
    }
    
    EXPORT void PortfolioManage::revocationOrder(char* _portfolioName, char* _orderId){
        std::string pInfo = portfolioStorge.get()[_portfolioName];
        
        
        PortfolioInfo info;
        info.parseJson(pInfo);
        Order ord = info.getOrder(_orderId);
        
        
        if(ord.orderId != "" && ord.orderStatus == 0){
            std::string callerStr = caller().toString();
            
            
            
            DipcAssert(info.getOwnerAddress() == caller().toString());
            

            uint64_t timenow = dipc::timestamp();
            if(ord.endTime > timenow){
                ord.orderStatus = 2;
            }else {
                ord.orderStatus = 3;
            }
        } else {
            return;
        }
        uint64_t lockToken = 0;
        if(ord.orderType == 1){
            lockToken = ord.stockPrice * ord.stockAmount;
        }
        uint64_t currentBalance =  portfolioBalance.get()[_portfolioName];
        
        
        
        

        DipcAssert(currentBalance + lockToken >= currentBalance);
        DipcAssert(ownerTotalToken.get() - lockToken <= ownerTotalToken.get());

        
        (*portfolioBalance)[_portfolioName] = currentBalance + lockToken;
        *ownerTotalToken = ownerTotalToken.get() - lockToken;
        (*portfolioStorge)[_portfolioName] = &info.toJson()[0];
        DIPC_EMIT_EVENT(revocationPortfolio, "orderId", _orderId, "orderInfo", &ord.toJson()[0]);
    }
    
    EXPORT void PortfolioManage::withdrawPortfolio(char* _portfolioName, uint64_t _withdrawBalance){
         if(!userCanWithdraw.get()){
             return;
         }
         uint64_t currentBalance =  portfolioBalance.get()[_portfolioName];
         DipcAssert(currentBalance - _withdrawBalance < currentBalance);
         auto coinBalance = changeUint64ToU256WithChangeRate(currentBalance, changeRate.get());
         (*portfolioBalance)[_portfolioName] = currentBalance - _withdrawBalance;
         callTransfer(caller(), coinBalance);
    }
    
    EXPORT void PortfolioManage::withdrawPool(uint64_t _balance){
        isOwner();
        Address ownerAddr = Address(owner.get()); 
        callTransfer(ownerAddr, _balance);
        *ownerTotalToken = ownerTotalToken.get() - _balance * changeRate.get();
        *totalToken = totalToken.get() - _balance * changeRate.get();
        DIPC_EMIT_EVENT(tokenCount, "ownerTotalToken", ownerTotalToken.get(), "totalToken", totalToken.get());
    }
    
    PAYABLE void PortfolioManage::depositPool(uint64_t _depositValue){
        isOwner();
        
        uint64_t tokenBalance = changeU256ToUint64WithChangeRate(callValue(), changeRate.get()); 
        *ownerTotalToken = ownerTotalToken.get() + tokenBalance;
        *totalToken = totalToken.get() + tokenBalance;
        DIPC_EMIT_EVENT(tokenCount, "ownerTotalToken", ownerTotalToken.get(), "totalToken", totalToken.get());
    }
     
    CONSTANT uint64_t PortfolioManage::queryTotalToken(){
        return totalToken.get();
    }

     
    CONSTANT uint64_t PortfolioManage::queryPortfolioBalance(char* _portfolioName){
        return portfolioBalance.get()[_portfolioName];
    }

    
    CONSTANT bool PortfolioManage::queryPortfolioNameIfUsed(char* _portfolioName){
        if(portfolioStorge.get()[_portfolioName] != ""){
            return true;
        } 
        return false;
    }

    
    CONSTANT uint64_t PortfolioManage::queryChangeRate(){
        return changeRate.get();
    }

2019-12-19_15:14:53.254472: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:604] finalContract  final content =======   : #include "PortfolioManage.hpp"

    
    PAYABLE void PortfolioManage::init(){
        *owner = caller().toString();
        *changeRate = 10000;
        *userCanWithdraw = false;
        uint64_t tokenBalance = getTotalBalance();
        
        *ownerTotalToken = tokenBalance;
        *totalToken = ownerTotalToken.get();
        
        
        DIPC_EMIT_EVENT(initEvent, "ownerTotalToken" ,tokenBalance);
    }
    
     
    EXPORT void PortfolioManage::setChangeRate(uint64_t _changeRate){
        isOwner();
        *changeRate = _changeRate;
    }
     
    EXPORT void PortfolioManage::setUserCanWithdraw(bool _canWithdraw){
        isOwner();
        *userCanWithdraw = _canWithdraw;
    }

    
    PAYABLE void PortfolioManage::createPortfolio(char* _portfolioName, char* _portfolioDesc){
        if(portfolioStorge.get()[_portfolioName] != ""){
            DIPC_EMIT_EVENT(ErrEvent, "Current portfolio exist: ", _portfolioName);
            return;
        } 
        std::string callerAddr = caller().toString();
        uint64_t tokenBalance = getTotalBalance();
        
        PortfolioInfo info(_portfolioName, _portfolioDesc, &callerAddr[0]);
        std::string portfolioStr = info.toJson();
        
        
        

        (*portfolioStorge)[_portfolioName] = portfolioStr;
        DipcAssert(totalToken.get() + tokenBalance > totalToken);
        (*portfolioBalance)[_portfolioName] = tokenBalance;
        *totalToken = totalToken.get() + tokenBalance; 
        
        DIPC_EMIT_EVENT(portfolioInfo, _portfolioName, &portfolioStr[0], "portfolioBalance", tokenBalance);
    }

    
    PAYABLE void PortfolioManage::depositPortfolio(char* _portfolioName){
        uint64_t tokenBalance = getTotalBalance();
        
        uint64_t currentBalance = portfolioBalance.get()[_portfolioName];
        uint64_t finalBalance  = currentBalance + tokenBalance;
        DipcAssert(totalToken.get() + tokenBalance > totalToken);
        DipcAssert(finalBalance > currentBalance);
        (*portfolioBalance)[_portfolioName] = finalBalance;
        *totalToken = totalToken.get() + finalBalance; 
        DIPC_EMIT_EVENT(depositPortfolio, "portfolioName", _portfolioName, "portfolioBalance", finalBalance);
    }
    
    PAYABLE void PortfolioManage::createOrder(char* _portfolioName, char* _orderId, uint16_t _orderType, char* _stockCode, uint64_t _stockPrice, uint64_t _stockAmount, uint64_t _endTime){
        uint64_t tokenBalance = getTotalBalance();
        DIPC_EMIT_EVENT(createOrder, "portfolioName", _portfolioName, "OrderInfo", "ignore", "tokenBalance", tokenBalance);
        uint64_t spent = 0;
        if(_orderType == 1){
            spent = _stockPrice * _stockAmount;
            DipcAssert((portfolioBalance.get()[_portfolioName] + tokenBalance) > spent);
        }
        struct Order order{_orderId, _orderType, _stockCode, _stockPrice, _stockAmount, _endTime, 0};
        std::string pInfo = portfolioStorge.get()[_portfolioName];
        
        
        
        if(pInfo == "") {
            DIPC_EMIT_EVENT(ErrEvent, "Current portfolio  doesn't exist: ", _portfolioName);
            return;
        }
        PortfolioInfo info;
        info.parseJson(pInfo);
        if(info.getOrder(_orderId).orderId != ""){
            DIPC_EMIT_EVENT(ErrEvent, "Current order exist: ", _orderId);
            return;
        }
        info.addOrder(order);
        pInfo = info.toJson();

        uint64_t currentBalance = portfolioBalance.get()[_portfolioName] ;
        uint64_t finalBalance = currentBalance + tokenBalance - spent;
        DipcAssert(totalToken.get() + tokenBalance > totalToken);
        
        DipcAssert(ownerTotalToken.get() < ownerTotalToken.get() + spent);
        (*portfolioStorge)[_portfolioName] = &pInfo[0];
        
        
        
        


        (*portfolioBalance)[_portfolioName] = finalBalance;
        *totalToken = totalToken.get() + finalBalance; 
        *ownerTotalToken = ownerTotalToken.get() + spent;
        DIPC_EMIT_EVENT(createOrder, "portfolioName", _portfolioName, "OrderInfo", &order.toJson()[0], "portfolioBalance", finalBalance);
    }

    
    EXPORT void PortfolioManage::dealOrder(char* _portfolioName, char* _orderId){
        isOwner();
        std::string pInfo = portfolioStorge.get()[_portfolioName];
        
        
        PortfolioInfo info;
        info.parseJson(pInfo);
        

        
         Order ord = info.getOrder(_orderId);
         
         
        if(ord.orderId != "" && ord.orderStatus == 0){
            
            uint64_t timenow = dipc::timestamp();
            if(ord.endTime > timenow){
                ord.orderStatus = 1;
            }else {
                ord.orderStatus = 3;
            }
        } else {
          

            return;
        }
        

        uint64_t sellValue = 0;
        if(ord.orderType == 0){
            sellValue = ord.stockAmount * ord.stockPrice;
        }
        uint64_t currentBalance =  portfolioBalance.get()[_portfolioName];
        

        DipcAssert(currentBalance + sellValue >= currentBalance);
        DipcAssert((ownerTotalToken.get() - sellValue) <= ownerTotalToken.get());
        


        (*portfolioBalance)[_portfolioName] = currentBalance + sellValue;
        *ownerTotalToken = ownerTotalToken.get() - sellValue;
        (*portfolioStorge)[_portfolioName] = &info.toJson()[0];
        
        
        
        

        DIPC_EMIT_EVENT(dealPortfolio, "orderId", _orderId, "orderInfo", &ord.toJson()[0]);
    }
    
    EXPORT void PortfolioManage::revocationOrder(char* _portfolioName, char* _orderId){
        std::string pInfo = portfolioStorge.get()[_portfolioName];
        
        
        PortfolioInfo info;
        info.parseJson(pInfo);
        Order ord = info.getOrder(_orderId);
        
        
        if(ord.orderId != "" && ord.orderStatus == 0){
            std::string callerStr = caller().toString();
            
            
            
            DipcAssert(info.getOwnerAddress() == caller().toString());
            

            uint64_t timenow = dipc::timestamp();
            if(ord.endTime > timenow){
                ord.orderStatus = 2;
            }else {
                ord.orderStatus = 3;
            }
        } else {
            return;
        }
        uint64_t lockToken = 0;
        if(ord.orderType == 1){
            lockToken = ord.stockPrice * ord.stockAmount;
        }
        uint64_t currentBalance =  portfolioBalance.get()[_portfolioName];
        
        
        
        

        DipcAssert(currentBalance + lockToken >= currentBalance);
        DipcAssert(ownerTotalToken.get() - lockToken <= ownerTotalToken.get());

        
        (*portfolioBalance)[_portfolioName] = currentBalance + lockToken;
        *ownerTotalToken = ownerTotalToken.get() - lockToken;
        (*portfolioStorge)[_portfolioName] = &info.toJson()[0];
        DIPC_EMIT_EVENT(revocationPortfolio, "orderId", _orderId, "orderInfo", &ord.toJson()[0]);
    }
    
    EXPORT void PortfolioManage::withdrawPortfolio(char* _portfolioName, uint64_t _withdrawBalance){
         if(!userCanWithdraw.get()){
             return;
         }
         uint64_t currentBalance =  portfolioBalance.get()[_portfolioName];
         DipcAssert(currentBalance - _withdrawBalance < currentBalance);
         auto coinBalance = changeUint64ToU256WithChangeRate(currentBalance, changeRate.get());
         (*portfolioBalance)[_portfolioName] = currentBalance - _withdrawBalance;
         callTransfer(caller(), coinBalance);
    }
    
    EXPORT void PortfolioManage::withdrawPool(uint64_t _balance){
        isOwner();
        Address ownerAddr = Address(owner.get()); 
        callTransfer(ownerAddr, _balance);
        *ownerTotalToken = ownerTotalToken.get() - _balance * changeRate.get();
        *totalToken = totalToken.get() - _balance * changeRate.get();
        DIPC_EMIT_EVENT(tokenCount, "ownerTotalToken", ownerTotalToken.get(), "totalToken", totalToken.get());
    }
    
    PAYABLE void PortfolioManage::depositPool(uint64_t _depositValue){
        isOwner();
        
        uint64_t tokenBalance = changeU256ToUint64WithChangeRate(callValue(), changeRate.get()); 
        *ownerTotalToken = ownerTotalToken.get() + tokenBalance;
        *totalToken = totalToken.get() + tokenBalance;
        DIPC_EMIT_EVENT(tokenCount, "ownerTotalToken", ownerTotalToken.get(), "totalToken", totalToken.get());
    }
     
    CONSTANT uint64_t PortfolioManage::queryTotalToken(){
        return totalToken.get();
    }

     
    CONSTANT uint64_t PortfolioManage::queryPortfolioBalance(char* _portfolioName){
        return portfolioBalance.get()[_portfolioName];
    }

    
    CONSTANT bool PortfolioManage::queryPortfolioNameIfUsed(char* _portfolioName){
        if(portfolioStorge.get()[_portfolioName] != ""){
            return true;
        } 
        return false;
    }

    
    CONSTANT uint64_t PortfolioManage::queryChangeRate(){
        return changeRate.get();
    }

2019-12-19_15:14:53.254481: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:401] abis.ispayable :true

2019-12-19_15:14:53.254500: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:424] finalContract  this height  #include "PortfolioManage.hpp"

    
    PAYABLE void PortfolioManage::init(){
        *owner = caller().toString();
        *changeRate = 10000;
        *userCanWithdraw = false;
        uint64_t tokenBalance = getTotalBalance();
        
        *ownerTotalToken = tokenBalance;
        *totalToken = ownerTotalToken.get();
        
        
        DIPC_EMIT_EVENT(initEvent, "ownerTotalToken" ,tokenBalance);
    }
    
     
    EXPORT void PortfolioManage::setChangeRate(uint64_t _changeRate){
        isOwner();
        *changeRate = _changeRate;
    }
     
    EXPORT void PortfolioManage::setUserCanWithdraw(bool _canWithdraw){
        isOwner();
        *userCanWithdraw = _canWithdraw;
    }

    
    PAYABLE void PortfolioManage::createPortfolio(char* _portfolioName, char* _portfolioDesc){
        if(portfolioStorge.get()[_portfolioName] != ""){
            DIPC_EMIT_EVENT(ErrEvent, "Current portfolio exist: ", _portfolioName);
            return;
        } 
        std::string callerAddr = caller().toString();
        uint64_t tokenBalance = getTotalBalance();
        
        PortfolioInfo info(_portfolioName, _portfolioDesc, &callerAddr[0]);
        std::string portfolioStr = info.toJson();
        
        
        

        (*portfolioStorge)[_portfolioName] = portfolioStr;
        DipcAssert(totalToken.get() + tokenBalance > totalToken);
        (*portfolioBalance)[_portfolioName] = tokenBalance;
        *totalToken = totalToken.get() + tokenBalance; 
        
        DIPC_EMIT_EVENT(portfolioInfo, _portfolioName, &portfolioStr[0], "portfolioBalance", tokenBalance);
    }

    
    PAYABLE void PortfolioManage::depositPortfolio(char* _portfolioName){
        uint64_t tokenBalance = getTotalBalance();
        
        uint64_t currentBalance = portfolioBalance.get()[_portfolioName];
        uint64_t finalBalance  = currentBalance + tokenBalance;
        DipcAssert(totalToken.get() + tokenBalance > totalToken);
        DipcAssert(finalBalance > currentBalance);
        (*portfolioBalance)[_portfolioName] = finalBalance;
        *totalToken = totalToken.get() + finalBalance; 
        DIPC_EMIT_EVENT(depositPortfolio, "portfolioName", _portfolioName, "portfolioBalance", finalBalance);
    }
    
    PAYABLE void PortfolioManage::createOrder(char* _portfolioName, char* _orderId, uint16_t _orderType, char* _stockCode, uint64_t _stockPrice, uint64_t _stockAmount, uint64_t _endTime){
        uint64_t tokenBalance = getTotalBalance();
        DIPC_EMIT_EVENT(createOrder, "portfolioName", _portfolioName, "OrderInfo", "ignore", "tokenBalance", tokenBalance);
        uint64_t spent = 0;
        if(_orderType == 1){
            spent = _stockPrice * _stockAmount;
            DipcAssert((portfolioBalance.get()[_portfolioName] + tokenBalance) > spent);
        }
        struct Order order{_orderId, _orderType, _stockCode, _stockPrice, _stockAmount, _endTime, 0};
        std::string pInfo = portfolioStorge.get()[_portfolioName];
        
        
        
        if(pInfo == "") {
            DIPC_EMIT_EVENT(ErrEvent, "Current portfolio  doesn't exist: ", _portfolioName);
            return;
        }
        PortfolioInfo info;
        info.parseJson(pInfo);
        if(info.getOrder(_orderId).orderId != ""){
            DIPC_EMIT_EVENT(ErrEvent, "Current order exist: ", _orderId);
            return;
        }
        info.addOrder(order);
        pInfo = info.toJson();

        uint64_t currentBalance = portfolioBalance.get()[_portfolioName] ;
        uint64_t finalBalance = currentBalance + tokenBalance - spent;
        DipcAssert(totalToken.get() + tokenBalance > totalToken);
        
        DipcAssert(ownerTotalToken.get() < ownerTotalToken.get() + spent);
        (*portfolioStorge)[_portfolioName] = &pInfo[0];
        
        
        
        


        (*portfolioBalance)[_portfolioName] = finalBalance;
        *totalToken = totalToken.get() + finalBalance; 
        *ownerTotalToken = ownerTotalToken.get() + spent;
        DIPC_EMIT_EVENT(createOrder, "portfolioName", _portfolioName, "OrderInfo", &order.toJson()[0], "portfolioBalance", finalBalance);
    }

    
    EXPORT void PortfolioManage::dealOrder(char* _portfolioName, char* _orderId){
        isOwner();
        std::string pInfo = portfolioStorge.get()[_portfolioName];
        
        
        PortfolioInfo info;
        info.parseJson(pInfo);
        

        
         Order ord = info.getOrder(_orderId);
         
         
        if(ord.orderId != "" && ord.orderStatus == 0){
            
            uint64_t timenow = dipc::timestamp();
            if(ord.endTime > timenow){
                ord.orderStatus = 1;
            }else {
                ord.orderStatus = 3;
            }
        } else {
          

            return;
        }
        

        uint64_t sellValue = 0;
        if(ord.orderType == 0){
            sellValue = ord.stockAmount * ord.stockPrice;
        }
        uint64_t currentBalance =  portfolioBalance.get()[_portfolioName];
        

        DipcAssert(currentBalance + sellValue >= currentBalance);
        DipcAssert((ownerTotalToken.get() - sellValue) <= ownerTotalToken.get());
        


        (*portfolioBalance)[_portfolioName] = currentBalance + sellValue;
        *ownerTotalToken = ownerTotalToken.get() - sellValue;
        (*portfolioStorge)[_portfolioName] = &info.toJson()[0];
        
        
        
        

        DIPC_EMIT_EVENT(dealPortfolio, "orderId", _orderId, "orderInfo", &ord.toJson()[0]);
    }
    
    EXPORT void PortfolioManage::revocationOrder(char* _portfolioName, char* _orderId){
        std::string pInfo = portfolioStorge.get()[_portfolioName];
        
        
        PortfolioInfo info;
        info.parseJson(pInfo);
        Order ord = info.getOrder(_orderId);
        
        
        if(ord.orderId != "" && ord.orderStatus == 0){
            std::string callerStr = caller().toString();
            
            
            
            DipcAssert(info.getOwnerAddress() == caller().toString());
            

            uint64_t timenow = dipc::timestamp();
            if(ord.endTime > timenow){
                ord.orderStatus = 2;
            }else {
                ord.orderStatus = 3;
            }
        } else {
            return;
        }
        uint64_t lockToken = 0;
        if(ord.orderType == 1){
            lockToken = ord.stockPrice * ord.stockAmount;
        }
        uint64_t currentBalance =  portfolioBalance.get()[_portfolioName];
        
        
        
        

        DipcAssert(currentBalance + lockToken >= currentBalance);
        DipcAssert(ownerTotalToken.get() - lockToken <= ownerTotalToken.get());

        
        (*portfolioBalance)[_portfolioName] = currentBalance + lockToken;
        *ownerTotalToken = ownerTotalToken.get() - lockToken;
        (*portfolioStorge)[_portfolioName] = &info.toJson()[0];
        DIPC_EMIT_EVENT(revocationPortfolio, "orderId", _orderId, "orderInfo", &ord.toJson()[0]);
    }
    
    EXPORT void PortfolioManage::withdrawPortfolio(char* _portfolioName, uint64_t _withdrawBalance){
         if(!userCanWithdraw.get()){
             return;
         }
         uint64_t currentBalance =  portfolioBalance.get()[_portfolioName];
         DipcAssert(currentBalance - _withdrawBalance < currentBalance);
         auto coinBalance = changeUint64ToU256WithChangeRate(currentBalance, changeRate.get());
         (*portfolioBalance)[_portfolioName] = currentBalance - _withdrawBalance;
         callTransfer(caller(), coinBalance);
    }
    
    EXPORT void PortfolioManage::withdrawPool(uint64_t _balance){
        isOwner();
        Address ownerAddr = Address(owner.get()); 
        callTransfer(ownerAddr, _balance);
        *ownerTotalToken = ownerTotalToken.get() - _balance * changeRate.get();
        *totalToken = totalToken.get() - _balance * changeRate.get();
        DIPC_EMIT_EVENT(tokenCount, "ownerTotalToken", ownerTotalToken.get(), "totalToken", totalToken.get());
    }
    
    PAYABLE void PortfolioManage::depositPool(uint64_t _depositValue){
        isOwner();
        
        uint64_t tokenBalance = changeU256ToUint64WithChangeRate(callValue(), changeRate.get()); 
        *ownerTotalToken = ownerTotalToken.get() + tokenBalance;
        *totalToken = totalToken.get() + tokenBalance;
        DIPC_EMIT_EVENT(tokenCount, "ownerTotalToken", ownerTotalToken.get(), "totalToken", totalToken.get());
    }
     
    CONSTANT uint64_t PortfolioManage::queryTotalToken(){
        return totalToken.get();
    }

     
    CONSTANT uint64_t PortfolioManage::queryPortfolioBalance(char* _portfolioName){
        return portfolioBalance.get()[_portfolioName];
    }

    
    CONSTANT bool PortfolioManage::queryPortfolioNameIfUsed(char* _portfolioName){
        if(portfolioStorge.get()[_portfolioName] != ""){
            return true;
        } 
        return false;
    }

    
    CONSTANT uint64_t PortfolioManage::queryChangeRate(){
        return changeRate.get();
    } codetext height #include "PortfolioManage.hpp"

    
    PAYABLE void PortfolioManage::init(){
        *owner = caller().toString();
        *changeRate = 10000;
        *userCanWithdraw = false;
        uint64_t tokenBalance = getTotalBalance();
        
        *ownerTotalToken = tokenBalance;
        *totalToken = ownerTotalToken.get();
        
        
        DIPC_EMIT_EVENT(initEvent, "ownerTotalToken" ,tokenBalance);
    }
    
     
    EXPORT void PortfolioManage::setChangeRate(uint64_t _changeRate){
        isOwner();
        *changeRate = _changeRate;
    }
     
    EXPORT void PortfolioManage::setUserCanWithdraw(bool _canWithdraw){
        isOwner();
        *userCanWithdraw = _canWithdraw;
    }

    
    PAYABLE void PortfolioManage::createPortfolio(char* _portfolioName, char* _portfolioDesc){
        if(portfolioStorge.get()[_portfolioName] != ""){
            DIPC_EMIT_EVENT(ErrEvent, "Current portfolio exist: ", _portfolioName);
            return;
        } 
        std::string callerAddr = caller().toString();
        uint64_t tokenBalance = getTotalBalance();
        
        PortfolioInfo info(_portfolioName, _portfolioDesc, &callerAddr[0]);
        std::string portfolioStr = info.toJson();
        
        
        

        (*portfolioStorge)[_portfolioName] = portfolioStr;
        DipcAssert(totalToken.get() + tokenBalance > totalToken);
        (*portfolioBalance)[_portfolioName] = tokenBalance;
        *totalToken = totalToken.get() + tokenBalance; 
        
        DIPC_EMIT_EVENT(portfolioInfo, _portfolioName, &portfolioStr[0], "portfolioBalance", tokenBalance);
    }

    
    PAYABLE void PortfolioManage::depositPortfolio(char* _portfolioName){
        uint64_t tokenBalance = getTotalBalance();
        
        uint64_t currentBalance = portfolioBalance.get()[_portfolioName];
        uint64_t finalBalance  = currentBalance + tokenBalance;
        DipcAssert(totalToken.get() + tokenBalance > totalToken);
        DipcAssert(finalBalance > currentBalance);
        (*portfolioBalance)[_portfolioName] = finalBalance;
        *totalToken = totalToken.get() + finalBalance; 
        DIPC_EMIT_EVENT(depositPortfolio, "portfolioName", _portfolioName, "portfolioBalance", finalBalance);
    }
    
    PAYABLE void PortfolioManage::createOrder(char* _portfolioName, char* _orderId, uint16_t _orderType, char* _stockCode, uint64_t _stockPrice, uint64_t _stockAmount, uint64_t _endTime){
        uint64_t tokenBalance = getTotalBalance();
        DIPC_EMIT_EVENT(createOrder, "portfolioName", _portfolioName, "OrderInfo", "ignore", "tokenBalance", tokenBalance);
        uint64_t spent = 0;
        if(_orderType == 1){
            spent = _stockPrice * _stockAmount;
            DipcAssert((portfolioBalance.get()[_portfolioName] + tokenBalance) > spent);
        }
        struct Order order{_orderId, _orderType, _stockCode, _stockPrice, _stockAmount, _endTime, 0};
        std::string pInfo = portfolioStorge.get()[_portfolioName];
        
        
        
        if(pInfo == "") {
            DIPC_EMIT_EVENT(ErrEvent, "Current portfolio  doesn't exist: ", _portfolioName);
            return;
        }
        PortfolioInfo info;
        info.parseJson(pInfo);
        if(info.getOrder(_orderId).orderId != ""){
            DIPC_EMIT_EVENT(ErrEvent, "Current order exist: ", _orderId);
            return;
        }
        info.addOrder(order);
        pInfo = info.toJson();

        uint64_t currentBalance = portfolioBalance.get()[_portfolioName] ;
        uint64_t finalBalance = currentBalance + tokenBalance - spent;
        DipcAssert(totalToken.get() + tokenBalance > totalToken);
        
        DipcAssert(ownerTotalToken.get() < ownerTotalToken.get() + spent);
        (*portfolioStorge)[_portfolioName] = &pInfo[0];
        
        
        
        


        (*portfolioBalance)[_portfolioName] = finalBalance;
        *totalToken = totalToken.get() + finalBalance; 
        *ownerTotalToken = ownerTotalToken.get() + spent;
        DIPC_EMIT_EVENT(createOrder, "portfolioName", _portfolioName, "OrderInfo", &order.toJson()[0], "portfolioBalance", finalBalance);
    }

    
    EXPORT void PortfolioManage::dealOrder(char* _portfolioName, char* _orderId){
        isOwner();
        std::string pInfo = portfolioStorge.get()[_portfolioName];
        
        
        PortfolioInfo info;
        info.parseJson(pInfo);
        

        
         Order ord = info.getOrder(_orderId);
         
         
        if(ord.orderId != "" && ord.orderStatus == 0){
            
            uint64_t timenow = dipc::timestamp();
            if(ord.endTime > timenow){
                ord.orderStatus = 1;
            }else {
                ord.orderStatus = 3;
            }
        } else {
          

            return;
        }
        

        uint64_t sellValue = 0;
        if(ord.orderType == 0){
            sellValue = ord.stockAmount * ord.stockPrice;
        }
        uint64_t currentBalance =  portfolioBalance.get()[_portfolioName];
        

        DipcAssert(currentBalance + sellValue >= currentBalance);
        DipcAssert((ownerTotalToken.get() - sellValue) <= ownerTotalToken.get());
        


        (*portfolioBalance)[_portfolioName] = currentBalance + sellValue;
        *ownerTotalToken = ownerTotalToken.get() - sellValue;
        (*portfolioStorge)[_portfolioName] = &info.toJson()[0];
        
        
        
        

        DIPC_EMIT_EVENT(dealPortfolio, "orderId", _orderId, "orderInfo", &ord.toJson()[0]);
    }
    
    EXPORT void PortfolioManage::revocationOrder(char* _portfolioName, char* _orderId){
        std::string pInfo = portfolioStorge.get()[_portfolioName];
        
        
        PortfolioInfo info;
        info.parseJson(pInfo);
        Order ord = info.getOrder(_orderId);
        
        
        if(ord.orderId != "" && ord.orderStatus == 0){
            std::string callerStr = caller().toString();
            
            
            
            DipcAssert(info.getOwnerAddress() == caller().toString());
            

            uint64_t timenow = dipc::timestamp();
            if(ord.endTime > timenow){
                ord.orderStatus = 2;
            }else {
                ord.orderStatus = 3;
            }
        } else {
            return;
        }
        uint64_t lockToken = 0;
        if(ord.orderType == 1){
            lockToken = ord.stockPrice * ord.stockAmount;
        }
        uint64_t currentBalance =  portfolioBalance.get()[_portfolioName];
        
        
        
        

        DipcAssert(currentBalance + lockToken >= currentBalance);
        DipcAssert(ownerTotalToken.get() - lockToken <= ownerTotalToken.get());

        
        (*portfolioBalance)[_portfolioName] = currentBalance + lockToken;
        *ownerTotalToken = ownerTotalToken.get() - lockToken;
        (*portfolioStorge)[_portfolioName] = &info.toJson()[0];
        DIPC_EMIT_EVENT(revocationPortfolio, "orderId", _orderId, "orderInfo", &ord.toJson()[0]);
    }
    
    EXPORT void PortfolioManage::withdrawPortfolio(char* _portfolioName, uint64_t _withdrawBalance){
         if(!userCanWithdraw.get()){
             return;
         }
         uint64_t currentBalance =  portfolioBalance.get()[_portfolioName];
         DipcAssert(currentBalance - _withdrawBalance < currentBalance);
         auto coinBalance = changeUint64ToU256WithChangeRate(currentBalance, changeRate.get());
         (*portfolioBalance)[_portfolioName] = currentBalance - _withdrawBalance;
         callTransfer(caller(), coinBalance);
    }
    
    EXPORT void PortfolioManage::withdrawPool(uint64_t _balance){
        isOwner();
        Address ownerAddr = Address(owner.get()); 
        callTransfer(ownerAddr, _balance);
        *ownerTotalToken = ownerTotalToken.get() - _balance * changeRate.get();
        *totalToken = totalToken.get() - _balance * changeRate.get();
        DIPC_EMIT_EVENT(tokenCount, "ownerTotalToken", ownerTotalToken.get(), "totalToken", totalToken.get());
    }
    
    PAYABLE void PortfolioManage::depositPool(uint64_t _depositValue){
        isOwner();
        
        uint64_t tokenBalance = changeU256ToUint64WithChangeRate(callValue(), changeRate.get()); 
        *ownerTotalToken = ownerTotalToken.get() + tokenBalance;
        *totalToken = totalToken.get() + tokenBalance;
        DIPC_EMIT_EVENT(tokenCount, "ownerTotalToken", ownerTotalToken.get(), "totalToken", totalToken.get());
    }
     
    CONSTANT uint64_t PortfolioManage::queryTotalToken(){
        return totalToken.get();
    }

     
    CONSTANT uint64_t PortfolioManage::queryPortfolioBalance(char* _portfolioName){
        return portfolioBalance.get()[_portfolioName];
    }

    
    CONSTANT bool PortfolioManage::queryPortfolioNameIfUsed(char* _portfolioName){
        if(portfolioStorge.get()[_portfolioName] != ""){
            return true;
        } 
        return false;
    }

    
    CONSTANT uint64_t PortfolioManage::queryChangeRate(){
        return changeRate.get();
    }

2019-12-19_15:14:53.254513: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:427] searchContext  #include "PortfolioManage.hpp"

    
    PAYABLE void PortfolioManage::init(){
        *owner = caller().toString();
        *changeRate = 10000;
        *userCanWithdraw = false;
        uint64_t tokenBalance = getTotalBalance();
        
        *ownerTotalToken = tokenBalance;
        *totalToken = ownerTotalToken.get();
        
        
        DIPC_EMIT_EVENT(initEvent, "ownerTotalToken" ,tokenBalance);
    }
    
     
    EXPORT void PortfolioManage::setChangeRate(uint64_t _changeRate){
        isOwner();
        *changeRate = _changeRate;
    }
     
    EXPORT void PortfolioManage::setUserCanWithdraw(bool _canWithdraw){
        isOwner();
        *userCanWithdraw = _canWithdraw;
    }

    
    PAYABLE void PortfolioManage::createPortfolio(char* _portfolioName, char* _portfolioDesc){
        if(portfolioStorge.get()[_portfolioName] != ""){
            DIPC_EMIT_EVENT(ErrEvent, "Current portfolio exist: ", _portfolioName);
            return;
        } 
        std::string callerAddr = caller().toString();
        uint64_t tokenBalance = getTotalBalance();
        
        PortfolioInfo info(_portfolioName, _portfolioDesc, &callerAddr[0]);
        std::string portfolioStr = info.toJson();
        
        
        

        (*portfolioStorge)[_portfolioName] = portfolioStr;
        DipcAssert(totalToken.get() + tokenBalance > totalToken);
        (*portfolioBalance)[_portfolioName] = tokenBalance;
        *totalToken = totalToken.get() + tokenBalance; 
        
        DIPC_EMIT_EVENT(portfolioInfo, _portfolioName, &portfolioStr[0], "portfolioBalance", tokenBalance);
    }

    
    PAYABLE void PortfolioManage::depositPortfolio(char* _portfolioName){
        uint64_t tokenBalance = getTotalBalance();
        
        uint64_t currentBalance = portfolioBalance.get()[_portfolioName];
        uint64_t finalBalance  = currentBalance + tokenBalance;
        DipcAssert(totalToken.get() + tokenBalance > totalToken);
        DipcAssert(finalBalance > currentBalance);
        (*portfolioBalance)[_portfolioName] = finalBalance;
        *totalToken = totalToken.get() + finalBalance; 
        DIPC_EMIT_EVENT(depositPortfolio, "portfolioName", _portfolioName, "portfolioBalance", finalBalance);
    }
    
    PAYABLE void PortfolioManage::createOrder(char* _portfolioName, char* _orderId, uint16_t _orderType, char* _stockCode, uint64_t _stockPrice, uint64_t _stockAmount, uint64_t _endTime){
        uint64_t tokenBalance = getTotalBalance();
        DIPC_EMIT_EVENT(createOrder, "portfolioName", _portfolioName, "OrderInfo", "ignore", "tokenBalance", tokenBalance);
        uint64_t spent = 0;
        if(_orderType == 1){
            spent = _stockPrice * _stockAmount;
            DipcAssert((portfolioBalance.get()[_portfolioName] + tokenBalance) > spent);
        }
        struct Order order{_orderId, _orderType, _stockCode, _stockPrice, _stockAmount, _endTime, 0};
        std::string pInfo = portfolioStorge.get()[_portfolioName];
        
        
        
        if(pInfo == "") {
            DIPC_EMIT_EVENT(ErrEvent, "Current portfolio  doesn't exist: ", _portfolioName);
            return;
        }
        PortfolioInfo info;
        info.parseJson(pInfo);
        if(info.getOrder(_orderId).orderId != ""){
            DIPC_EMIT_EVENT(ErrEvent, "Current order exist: ", _orderId);
            return;
        }
        info.addOrder(order);
        pInfo = info.toJson();

        uint64_t currentBalance = portfolioBalance.get()[_portfolioName] ;
        uint64_t finalBalance = currentBalance + tokenBalance - spent;
        DipcAssert(totalToken.get() + tokenBalance > totalToken);
        
        DipcAssert(ownerTotalToken.get() < ownerTotalToken.get() + spent);
        (*portfolioStorge)[_portfolioName] = &pInfo[0];
        
        
        
        


        (*portfolioBalance)[_portfolioName] = finalBalance;
        *totalToken = totalToken.get() + finalBalance; 
        *ownerTotalToken = ownerTotalToken.get() + spent;
        DIPC_EMIT_EVENT(createOrder, "portfolioName", _portfolioName, "OrderInfo", &order.toJson()[0], "portfolioBalance", finalBalance);
    }

    
    EXPORT void PortfolioManage::dealOrder(char* _portfolioName, char* _orderId){
        isOwner();
        std::string pInfo = portfolioStorge.get()[_portfolioName];
        
        
        PortfolioInfo info;
        info.parseJson(pInfo);
        

        
         Order ord = info.getOrder(_orderId);
         
         
        if(ord.orderId != "" && ord.orderStatus == 0){
            
            uint64_t timenow = dipc::timestamp();
            if(ord.endTime > timenow){
                ord.orderStatus = 1;
            }else {
                ord.orderStatus = 3;
            }
        } else {
          

            return;
        }
        

        uint64_t sellValue = 0;
        if(ord.orderType == 0){
            sellValue = ord.stockAmount * ord.stockPrice;
        }
        uint64_t currentBalance =  portfolioBalance.get()[_portfolioName];
        

        DipcAssert(currentBalance + sellValue >= currentBalance);
        DipcAssert((ownerTotalToken.get() - sellValue) <= ownerTotalToken.get());
        


        (*portfolioBalance)[_portfolioName] = currentBalance + sellValue;
        *ownerTotalToken = ownerTotalToken.get() - sellValue;
        (*portfolioStorge)[_portfolioName] = &info.toJson()[0];
        
        
        
        

        DIPC_EMIT_EVENT(dealPortfolio, "orderId", _orderId, "orderInfo", &ord.toJson()[0]);
    }
    
    EXPORT void PortfolioManage::revocationOrder(char* _portfolioName, char* _orderId){
        std::string pInfo = portfolioStorge.get()[_portfolioName];
        
        
        PortfolioInfo info;
        info.parseJson(pInfo);
        Order ord = info.getOrder(_orderId);
        
        
        if(ord.orderId != "" && ord.orderStatus == 0){
            std::string callerStr = caller().toString();
            
            
            
            DipcAssert(info.getOwnerAddress() == caller().toString());
            

            uint64_t timenow = dipc::timestamp();
            if(ord.endTime > timenow){
                ord.orderStatus = 2;
            }else {
                ord.orderStatus = 3;
            }
        } else {
            return;
        }
        uint64_t lockToken = 0;
        if(ord.orderType == 1){
            lockToken = ord.stockPrice * ord.stockAmount;
        }
        uint64_t currentBalance =  portfolioBalance.get()[_portfolioName];
        
        
        
        

        DipcAssert(currentBalance + lockToken >= currentBalance);
        DipcAssert(ownerTotalToken.get() - lockToken <= ownerTotalToken.get());

        
        (*portfolioBalance)[_portfolioName] = currentBalance + lockToken;
        *ownerTotalToken = ownerTotalToken.get() - lockToken;
        (*portfolioStorge)[_portfolioName] = &info.toJson()[0];
        DIPC_EMIT_EVENT(revocationPortfolio, "orderId", _orderId, "orderInfo", &ord.toJson()[0]);
    }
    
    EXPORT void PortfolioManage::withdrawPortfolio(char* _portfolioName, uint64_t _withdrawBalance){
         if(!userCanWithdraw.get()){
             return;
         }
         uint64_t currentBalance =  portfolioBalance.get()[_portfolioName];
         DipcAssert(currentBalance - _withdrawBalance < currentBalance);
         auto coinBalance = changeUint64ToU256WithChangeRate(currentBalance, changeRate.get());
         (*portfolioBalance)[_portfolioName] = currentBalance - _withdrawBalance;
         callTransfer(caller(), coinBalance);
    }
    
    EXPORT void PortfolioManage::withdrawPool(uint64_t _balance){
        isOwner();
        Address ownerAddr = Address(owner.get()); 
        callTransfer(ownerAddr, _balance);
        *ownerTotalToken = ownerTotalToken.get() - _balance * changeRate.get();
        *totalToken = totalToken.get() - _balance * changeRate.get();
        DIPC_EMIT_EVENT(tokenCount, "ownerTotalToken", ownerTotalToken.get(), "totalToken", totalToken.get());
    }
    
    PAYABLE void PortfolioManage::depositPool(uint64_t _depositValue){
        isOwner();
        
        uint64_t tokenBalance = changeU256ToUint64WithChangeRate(callValue(), changeRate.get()); 
        *ownerTotalToken = ownerTotalToken.get() + tokenBalance;
        *totalToken = totalToken.get() + tokenBalance;
        DIPC_EMIT_EVENT(tokenCount, "ownerTotalToken", ownerTotalToken.get(), "totalToken", totalToken.get());
    }
     
    CONSTANT uint64_t PortfolioManage::queryTotalToken(){
        return totalToken.get();
    }

     
    CONSTANT uint64_t PortfolioManage::queryPortfolioBalance(char* _portfolioName){
        return portfolioBalance.get()[_portfolioName];
    }

    
    CONSTANT bool PortfolioManage::queryPortfolioNameIfUsed(char* _portfolioName){
        if(portfolioStorge.get()[_portfolioName] != ""){
            return true;
        } 
        return false;
    }

    
    CONSTANT uint64_t PortfolioManage::queryChangeRate(){
        return changeRate.get();
    }

2019-12-19_15:14:53.254841: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:451] log out out payable : PAYABLE void PortfolioManage::createPortfolio(char* _portfolioName, char* _portfolioDesc){
        

2019-12-19_15:14:53.254850: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:457] name : createPortfolio   pos1  0

2019-12-19_15:14:53.254858: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:469] pos2  714   pos1  714

2019-12-19_15:14:53.254865: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:500] pos2 after 1608   pos1  714

2019-12-19_15:14:53.254872: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:509] finalContract  first #include "PortfolioManage.hpp"

    
    PAYABLE void PortfolioManage::init(){
        *owner = caller().toString();
        *changeRate = 10000;
        *userCanWithdraw = false;
        uint64_t tokenBalance = getTotalBalance();
        
        *ownerTotalToken = tokenBalance;
        *totalToken = ownerTotalToken.get();
        
        
        DIPC_EMIT_EVENT(initEvent, "ownerTotalToken" ,tokenBalance);
    }
    
     
    EXPORT void PortfolioManage::setChangeRate(uint64_t _changeRate){
        isOwner();
        *changeRate = _changeRate;
    }
     
    EXPORT void PortfolioManage::setUserCanWithdraw(bool _canWithdraw){
        isOwner();
        *userCanWithdraw = _canWithdraw;
    }

    
    

2019-12-19_15:14:53.254878: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:510] codetext  first #include "PortfolioManage.hpp"

    
    PAYABLE void PortfolioManage::init(){
        *owner = caller().toString();
        *changeRate = 10000;
        *userCanWithdraw = false;
        uint64_t tokenBalance = getTotalBalance();
        
        *ownerTotalToken = tokenBalance;
        *totalToken = ownerTotalToken.get();
        
        
        DIPC_EMIT_EVENT(initEvent, "ownerTotalToken" ,tokenBalance);
    }
    
     
    EXPORT void PortfolioManage::setChangeRate(uint64_t _changeRate){
        isOwner();
        *changeRate = _changeRate;
    }
     
    EXPORT void PortfolioManage::setUserCanWithdraw(bool _canWithdraw){
        isOwner();
        *userCanWithdraw = _canWithdraw;
    }

    
    PAYABLE void PortfolioManage::createPortfolio(char* _portfolioName, char* _portfolioDesc){
        if(portfolioStorge.get()[_portfolioName] != ""){
            DIPC_EMIT_EVENT(ErrEvent, "Current portfolio exist: ", _portfolioName);
            return;
        } 
        std::string callerAddr = caller().toString();
        uint64_t tokenBalance = getTotalBalance();
        
        PortfolioInfo info(_portfolioName, _portfolioDesc, &callerAddr[0]);
        std::string portfolioStr = info.toJson();
        
        
        

        (*portfolioStorge)[_portfolioName] = portfolioStr;
        DipcAssert(totalToken.get() + tokenBalance > totalToken);
        (*portfolioBalance)[_portfolioName] = tokenBalance;
        *totalToken = totalToken.get() + tokenBalance; 
        
        DIPC_EMIT_EVENT(portfolioInfo, _portfolioName, &portfolioStr[0], "portfolioBalance", tokenBalance);
    }

    
    PAYABLE void PortfolioManage::depositPortfolio(char* _portfolioName){
        uint64_t tokenBalance = getTotalBalance();
        
        uint64_t currentBalance = portfolioBalance.get()[_portfolioName];
        uint64_t finalBalance  = currentBalance + tokenBalance;
        DipcAssert(totalToken.get() + tokenBalance > totalToken);
        DipcAssert(finalBalance > currentBalance);
        (*portfolioBalance)[_portfolioName] = finalBalance;
        *totalToken = totalToken.get() + finalBalance; 
        DIPC_EMIT_EVENT(depositPortfolio, "portfolioName", _portfolioName, "portfolioBalance", finalBalance);
    }
    
    PAYABLE void PortfolioManage::createOrder(char* _portfolioName, char* _orderId, uint16_t _orderType, char* _stockCode, uint64_t _stockPrice, uint64_t _stockAmount, uint64_t _endTime){
        uint64_t tokenBalance = getTotalBalance();
        DIPC_EMIT_EVENT(createOrder, "portfolioName", _portfolioName, "OrderInfo", "ignore", "tokenBalance", tokenBalance);
        uint64_t spent = 0;
        if(_orderType == 1){
            spent = _stockPrice * _stockAmount;
            DipcAssert((portfolioBalance.get()[_portfolioName] + tokenBalance) > spent);
        }
        struct Order order{_orderId, _orderType, _stockCode, _stockPrice, _stockAmount, _endTime, 0};
        std::string pInfo = portfolioStorge.get()[_portfolioName];
        
        
        
        if(pInfo == "") {
            DIPC_EMIT_EVENT(ErrEvent, "Current portfolio  doesn't exist: ", _portfolioName);
            return;
        }
        PortfolioInfo info;
        info.parseJson(pInfo);
        if(info.getOrder(_orderId).orderId != ""){
            DIPC_EMIT_EVENT(ErrEvent, "Current order exist: ", _orderId);
            return;
        }
        info.addOrder(order);
        pInfo = info.toJson();

        uint64_t currentBalance = portfolioBalance.get()[_portfolioName] ;
        uint64_t finalBalance = currentBalance + tokenBalance - spent;
        DipcAssert(totalToken.get() + tokenBalance > totalToken);
        
        DipcAssert(ownerTotalToken.get() < ownerTotalToken.get() + spent);
        (*portfolioStorge)[_portfolioName] = &pInfo[0];
        
        
        
        


        (*portfolioBalance)[_portfolioName] = finalBalance;
        *totalToken = totalToken.get() + finalBalance; 
        *ownerTotalToken = ownerTotalToken.get() + spent;
        DIPC_EMIT_EVENT(createOrder, "portfolioName", _portfolioName, "OrderInfo", &order.toJson()[0], "portfolioBalance", finalBalance);
    }

    
    EXPORT void PortfolioManage::dealOrder(char* _portfolioName, char* _orderId){
        isOwner();
        std::string pInfo = portfolioStorge.get()[_portfolioName];
        
        
        PortfolioInfo info;
        info.parseJson(pInfo);
        

        
         Order ord = info.getOrder(_orderId);
         
         
        if(ord.orderId != "" && ord.orderStatus == 0){
            
            uint64_t timenow = dipc::timestamp();
            if(ord.endTime > timenow){
                ord.orderStatus = 1;
            }else {
                ord.orderStatus = 3;
            }
        } else {
          

            return;
        }
        

        uint64_t sellValue = 0;
        if(ord.orderType == 0){
            sellValue = ord.stockAmount * ord.stockPrice;
        }
        uint64_t currentBalance =  portfolioBalance.get()[_portfolioName];
        

        DipcAssert(currentBalance + sellValue >= currentBalance);
        DipcAssert((ownerTotalToken.get() - sellValue) <= ownerTotalToken.get());
        


        (*portfolioBalance)[_portfolioName] = currentBalance + sellValue;
        *ownerTotalToken = ownerTotalToken.get() - sellValue;
        (*portfolioStorge)[_portfolioName] = &info.toJson()[0];
        
        
        
        

        DIPC_EMIT_EVENT(dealPortfolio, "orderId", _orderId, "orderInfo", &ord.toJson()[0]);
    }
    
    EXPORT void PortfolioManage::revocationOrder(char* _portfolioName, char* _orderId){
        std::string pInfo = portfolioStorge.get()[_portfolioName];
        
        
        PortfolioInfo info;
        info.parseJson(pInfo);
        Order ord = info.getOrder(_orderId);
        
        
        if(ord.orderId != "" && ord.orderStatus == 0){
            std::string callerStr = caller().toString();
            
            
            
            DipcAssert(info.getOwnerAddress() == caller().toString());
            

            uint64_t timenow = dipc::timestamp();
            if(ord.endTime > timenow){
                ord.orderStatus = 2;
            }else {
                ord.orderStatus = 3;
            }
        } else {
            return;
        }
        uint64_t lockToken = 0;
        if(ord.orderType == 1){
            lockToken = ord.stockPrice * ord.stockAmount;
        }
        uint64_t currentBalance =  portfolioBalance.get()[_portfolioName];
        
        
        
        

        DipcAssert(currentBalance + lockToken >= currentBalance);
        DipcAssert(ownerTotalToken.get() - lockToken <= ownerTotalToken.get());

        
        (*portfolioBalance)[_portfolioName] = currentBalance + lockToken;
        *ownerTotalToken = ownerTotalToken.get() - lockToken;
        (*portfolioStorge)[_portfolioName] = &info.toJson()[0];
        DIPC_EMIT_EVENT(revocationPortfolio, "orderId", _orderId, "orderInfo", &ord.toJson()[0]);
    }
    
    EXPORT void PortfolioManage::withdrawPortfolio(char* _portfolioName, uint64_t _withdrawBalance){
         if(!userCanWithdraw.get()){
             return;
         }
         uint64_t currentBalance =  portfolioBalance.get()[_portfolioName];
         DipcAssert(currentBalance - _withdrawBalance < currentBalance);
         auto coinBalance = changeUint64ToU256WithChangeRate(currentBalance, changeRate.get());
         (*portfolioBalance)[_portfolioName] = currentBalance - _withdrawBalance;
         callTransfer(caller(), coinBalance);
    }
    
    EXPORT void PortfolioManage::withdrawPool(uint64_t _balance){
        isOwner();
        Address ownerAddr = Address(owner.get()); 
        callTransfer(ownerAddr, _balance);
        *ownerTotalToken = ownerTotalToken.get() - _balance * changeRate.get();
        *totalToken = totalToken.get() - _balance * changeRate.get();
        DIPC_EMIT_EVENT(tokenCount, "ownerTotalToken", ownerTotalToken.get(), "totalToken", totalToken.get());
    }
    
    PAYABLE void PortfolioManage::depositPool(uint64_t _depositValue){
        isOwner();
        
        uint64_t tokenBalance = changeU256ToUint64WithChangeRate(callValue(), changeRate.get()); 
        *ownerTotalToken = ownerTotalToken.get() + tokenBalance;
        *totalToken = totalToken.get() + tokenBalance;
        DIPC_EMIT_EVENT(tokenCount, "ownerTotalToken", ownerTotalToken.get(), "totalToken", totalToken.get());
    }
     
    CONSTANT uint64_t PortfolioManage::queryTotalToken(){
        return totalToken.get();
    }

     
    CONSTANT uint64_t PortfolioManage::queryPortfolioBalance(char* _portfolioName){
        return portfolioBalance.get()[_portfolioName];
    }

    
    CONSTANT bool PortfolioManage::queryPortfolioNameIfUsed(char* _portfolioName){
        if(portfolioStorge.get()[_portfolioName] != ""){
            return true;
        } 
        return false;
    }

    
    CONSTANT uint64_t PortfolioManage::queryChangeRate(){
        return changeRate.get();
    }

2019-12-19_15:14:53.254936: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:513] s  first PAYABLE void PortfolioManage::createPortfolio(char* _portfolioName, char* _portfolioDesc){
        if(portfolioStorge.get()[_portfolioName] != ""){
            DIPC_EMIT_EVENT(ErrEvent, "Current portfolio exist: ", _portfolioName);
            return;
        } 
        std::string callerAddr = caller().toString();
        uint64_t tokenBalance = getTotalBalance();
        
        PortfolioInfo info(_portfolioName, _portfolioDesc, &callerAddr[0]);
        std::string portfolioStr = info.toJson();
        
        
        

        (*portfolioStorge)[_portfolioName] = portfolioStr;
        DipcAssert(totalToken.get() + tokenBalance > totalToken);
        (*portfolioBalance)[_portfolioName] = tokenBalance;
        *totalToken = totalToken.get() + tokenBalance; 
        
        DIPC_EMIT_EVENT(portfolioInfo, _portfolioName, &portfolioStr[0], "portfolioBalance", tokenBalance);
    }

2019-12-19_15:14:53.262673: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:599] search func : PAYABLE void PortfolioManage::createPortfolio(char* _portfolioName, char* _portfolioDesc){
        if(portfolioStorge.get()[_portfolioName] != ""){
            DIPC_EMIT_EVENT(ErrEvent, "Current portfolio exist: ", _portfolioName);
            return;
        } 
        std::string callerAddr = caller().toString();
        uint64_t tokenBalance = getTotalBalance();
        
        PortfolioInfo info(_portfolioName, _portfolioDesc, &callerAddr[0]);
        std::string portfolioStr = info.toJson();
        
        
        

        (*portfolioStorge)[_portfolioName] = portfolioStr;
        DipcAssert(totalToken.get() + tokenBalance > totalToken);
        (*portfolioBalance)[_portfolioName] = tokenBalance;
        *totalToken = totalToken.get() + tokenBalance; 
        
        DIPC_EMIT_EVENT(portfolioInfo, _portfolioName, &portfolioStr[0], "portfolioBalance", tokenBalance);
    }
2019-12-19_15:14:53.262688: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:424] finalContract  this height  #include "PortfolioManage.hpp"

    
    PAYABLE void PortfolioManage::init(){
        *owner = caller().toString();
        *changeRate = 10000;
        *userCanWithdraw = false;
        uint64_t tokenBalance = getTotalBalance();
        
        *ownerTotalToken = tokenBalance;
        *totalToken = ownerTotalToken.get();
        
        
        DIPC_EMIT_EVENT(initEvent, "ownerTotalToken" ,tokenBalance);
    }
    
     
    EXPORT void PortfolioManage::setChangeRate(uint64_t _changeRate){
        isOwner();
        *changeRate = _changeRate;
    }
     
    EXPORT void PortfolioManage::setUserCanWithdraw(bool _canWithdraw){
        isOwner();
        *userCanWithdraw = _canWithdraw;
    }

    
    PAYABLE void PortfolioManage::createPortfolio(char* _portfolioName, char* _portfolioDesc){
        if(portfolioStorge.get()[_portfolioName] != ""){
            DIPC_EMIT_EVENT(ErrEvent, "Current portfolio exist: ", _portfolioName);
            return;
        } 
        std::string callerAddr = caller().toString();
        uint64_t tokenBalance = getTotalBalance();
        
        PortfolioInfo info(_portfolioName, _portfolioDesc, &callerAddr[0]);
        std::string portfolioStr = info.toJson();
        
        
        

        (*portfolioStorge)[_portfolioName] = portfolioStr;
        DipcAssert(totalToken.get() + tokenBalance > totalToken);
        (*portfolioBalance)[_portfolioName] = tokenBalance;
        *totalToken = totalToken.get() + tokenBalance; 
        
        DIPC_EMIT_EVENT(portfolioInfo, _portfolioName, &portfolioStr[0], "portfolioBalance", tokenBalance);
    } codetext height #include "PortfolioManage.hpp"

    
    PAYABLE void PortfolioManage::init(){
        *owner = caller().toString();
        *changeRate = 10000;
        *userCanWithdraw = false;
        uint64_t tokenBalance = getTotalBalance();
        
        *ownerTotalToken = tokenBalance;
        *totalToken = ownerTotalToken.get();
        
        
        DIPC_EMIT_EVENT(initEvent, "ownerTotalToken" ,tokenBalance);
    }
    
     
    EXPORT void PortfolioManage::setChangeRate(uint64_t _changeRate){
        isOwner();
        *changeRate = _changeRate;
    }
     
    EXPORT void PortfolioManage::setUserCanWithdraw(bool _canWithdraw){
        isOwner();
        *userCanWithdraw = _canWithdraw;
    }

    
    PAYABLE void PortfolioManage::createPortfolio(char* _portfolioName, char* _portfolioDesc){
        if(portfolioStorge.get()[_portfolioName] != ""){
            DIPC_EMIT_EVENT(ErrEvent, "Current portfolio exist: ", _portfolioName);
            return;
        } 
        std::string callerAddr = caller().toString();
        uint64_t tokenBalance = getTotalBalance();
        
        PortfolioInfo info(_portfolioName, _portfolioDesc, &callerAddr[0]);
        std::string portfolioStr = info.toJson();
        
        
        

        (*portfolioStorge)[_portfolioName] = portfolioStr;
        DipcAssert(totalToken.get() + tokenBalance > totalToken);
        (*portfolioBalance)[_portfolioName] = tokenBalance;
        *totalToken = totalToken.get() + tokenBalance; 
        
        DIPC_EMIT_EVENT(portfolioInfo, _portfolioName, &portfolioStr[0], "portfolioBalance", tokenBalance);
    }

    
    PAYABLE void PortfolioManage::depositPortfolio(char* _portfolioName){
        uint64_t tokenBalance = getTotalBalance();
        
        uint64_t currentBalance = portfolioBalance.get()[_portfolioName];
        uint64_t finalBalance  = currentBalance + tokenBalance;
        DipcAssert(totalToken.get() + tokenBalance > totalToken);
        DipcAssert(finalBalance > currentBalance);
        (*portfolioBalance)[_portfolioName] = finalBalance;
        *totalToken = totalToken.get() + finalBalance; 
        DIPC_EMIT_EVENT(depositPortfolio, "portfolioName", _portfolioName, "portfolioBalance", finalBalance);
    }
    
    PAYABLE void PortfolioManage::createOrder(char* _portfolioName, char* _orderId, uint16_t _orderType, char* _stockCode, uint64_t _stockPrice, uint64_t _stockAmount, uint64_t _endTime){
        uint64_t tokenBalance = getTotalBalance();
        DIPC_EMIT_EVENT(createOrder, "portfolioName", _portfolioName, "OrderInfo", "ignore", "tokenBalance", tokenBalance);
        uint64_t spent = 0;
        if(_orderType == 1){
            spent = _stockPrice * _stockAmount;
            DipcAssert((portfolioBalance.get()[_portfolioName] + tokenBalance) > spent);
        }
        struct Order order{_orderId, _orderType, _stockCode, _stockPrice, _stockAmount, _endTime, 0};
        std::string pInfo = portfolioStorge.get()[_portfolioName];
        
        
        
        if(pInfo == "") {
            DIPC_EMIT_EVENT(ErrEvent, "Current portfolio  doesn't exist: ", _portfolioName);
            return;
        }
        PortfolioInfo info;
        info.parseJson(pInfo);
        if(info.getOrder(_orderId).orderId != ""){
            DIPC_EMIT_EVENT(ErrEvent, "Current order exist: ", _orderId);
            return;
        }
        info.addOrder(order);
        pInfo = info.toJson();

        uint64_t currentBalance = portfolioBalance.get()[_portfolioName] ;
        uint64_t finalBalance = currentBalance + tokenBalance - spent;
        DipcAssert(totalToken.get() + tokenBalance > totalToken);
        
        DipcAssert(ownerTotalToken.get() < ownerTotalToken.get() + spent);
        (*portfolioStorge)[_portfolioName] = &pInfo[0];
        
        
        
        


        (*portfolioBalance)[_portfolioName] = finalBalance;
        *totalToken = totalToken.get() + finalBalance; 
        *ownerTotalToken = ownerTotalToken.get() + spent;
        DIPC_EMIT_EVENT(createOrder, "portfolioName", _portfolioName, "OrderInfo", &order.toJson()[0], "portfolioBalance", finalBalance);
    }

    
    EXPORT void PortfolioManage::dealOrder(char* _portfolioName, char* _orderId){
        isOwner();
        std::string pInfo = portfolioStorge.get()[_portfolioName];
        
        
        PortfolioInfo info;
        info.parseJson(pInfo);
        

        
         Order ord = info.getOrder(_orderId);
         
         
        if(ord.orderId != "" && ord.orderStatus == 0){
            
            uint64_t timenow = dipc::timestamp();
            if(ord.endTime > timenow){
                ord.orderStatus = 1;
            }else {
                ord.orderStatus = 3;
            }
        } else {
          

            return;
        }
        

        uint64_t sellValue = 0;
        if(ord.orderType == 0){
            sellValue = ord.stockAmount * ord.stockPrice;
        }
        uint64_t currentBalance =  portfolioBalance.get()[_portfolioName];
        

        DipcAssert(currentBalance + sellValue >= currentBalance);
        DipcAssert((ownerTotalToken.get() - sellValue) <= ownerTotalToken.get());
        


        (*portfolioBalance)[_portfolioName] = currentBalance + sellValue;
        *ownerTotalToken = ownerTotalToken.get() - sellValue;
        (*portfolioStorge)[_portfolioName] = &info.toJson()[0];
        
        
        
        

        DIPC_EMIT_EVENT(dealPortfolio, "orderId", _orderId, "orderInfo", &ord.toJson()[0]);
    }
    
    EXPORT void PortfolioManage::revocationOrder(char* _portfolioName, char* _orderId){
        std::string pInfo = portfolioStorge.get()[_portfolioName];
        
        
        PortfolioInfo info;
        info.parseJson(pInfo);
        Order ord = info.getOrder(_orderId);
        
        
        if(ord.orderId != "" && ord.orderStatus == 0){
            std::string callerStr = caller().toString();
            
            
            
            DipcAssert(info.getOwnerAddress() == caller().toString());
            

            uint64_t timenow = dipc::timestamp();
            if(ord.endTime > timenow){
                ord.orderStatus = 2;
            }else {
                ord.orderStatus = 3;
            }
        } else {
            return;
        }
        uint64_t lockToken = 0;
        if(ord.orderType == 1){
            lockToken = ord.stockPrice * ord.stockAmount;
        }
        uint64_t currentBalance =  portfolioBalance.get()[_portfolioName];
        
        
        
        

        DipcAssert(currentBalance + lockToken >= currentBalance);
        DipcAssert(ownerTotalToken.get() - lockToken <= ownerTotalToken.get());

        
        (*portfolioBalance)[_portfolioName] = currentBalance + lockToken;
        *ownerTotalToken = ownerTotalToken.get() - lockToken;
        (*portfolioStorge)[_portfolioName] = &info.toJson()[0];
        DIPC_EMIT_EVENT(revocationPortfolio, "orderId", _orderId, "orderInfo", &ord.toJson()[0]);
    }
    
    EXPORT void PortfolioManage::withdrawPortfolio(char* _portfolioName, uint64_t _withdrawBalance){
         if(!userCanWithdraw.get()){
             return;
         }
         uint64_t currentBalance =  portfolioBalance.get()[_portfolioName];
         DipcAssert(currentBalance - _withdrawBalance < currentBalance);
         auto coinBalance = changeUint64ToU256WithChangeRate(currentBalance, changeRate.get());
         (*portfolioBalance)[_portfolioName] = currentBalance - _withdrawBalance;
         callTransfer(caller(), coinBalance);
    }
    
    EXPORT void PortfolioManage::withdrawPool(uint64_t _balance){
        isOwner();
        Address ownerAddr = Address(owner.get()); 
        callTransfer(ownerAddr, _balance);
        *ownerTotalToken = ownerTotalToken.get() - _balance * changeRate.get();
        *totalToken = totalToken.get() - _balance * changeRate.get();
        DIPC_EMIT_EVENT(tokenCount, "ownerTotalToken", ownerTotalToken.get(), "totalToken", totalToken.get());
    }
    
    PAYABLE void PortfolioManage::depositPool(uint64_t _depositValue){
        isOwner();
        
        uint64_t tokenBalance = changeU256ToUint64WithChangeRate(callValue(), changeRate.get()); 
        *ownerTotalToken = ownerTotalToken.get() + tokenBalance;
        *totalToken = totalToken.get() + tokenBalance;
        DIPC_EMIT_EVENT(tokenCount, "ownerTotalToken", ownerTotalToken.get(), "totalToken", totalToken.get());
    }
     
    CONSTANT uint64_t PortfolioManage::queryTotalToken(){
        return totalToken.get();
    }

     
    CONSTANT uint64_t PortfolioManage::queryPortfolioBalance(char* _portfolioName){
        return portfolioBalance.get()[_portfolioName];
    }

    
    CONSTANT bool PortfolioManage::queryPortfolioNameIfUsed(char* _portfolioName){
        if(portfolioStorge.get()[_portfolioName] != ""){
            return true;
        } 
        return false;
    }

    
    CONSTANT uint64_t PortfolioManage::queryChangeRate(){
        return changeRate.get();
    }

2019-12-19_15:14:53.262699: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:427] searchContext  

    
    PAYABLE void PortfolioManage::depositPortfolio(char* _portfolioName){
        uint64_t tokenBalance = getTotalBalance();
        
        uint64_t currentBalance = portfolioBalance.get()[_portfolioName];
        uint64_t finalBalance  = currentBalance + tokenBalance;
        DipcAssert(totalToken.get() + tokenBalance > totalToken);
        DipcAssert(finalBalance > currentBalance);
        (*portfolioBalance)[_portfolioName] = finalBalance;
        *totalToken = totalToken.get() + finalBalance; 
        DIPC_EMIT_EVENT(depositPortfolio, "portfolioName", _portfolioName, "portfolioBalance", finalBalance);
    }
    
    PAYABLE void PortfolioManage::createOrder(char* _portfolioName, char* _orderId, uint16_t _orderType, char* _stockCode, uint64_t _stockPrice, uint64_t _stockAmount, uint64_t _endTime){
        uint64_t tokenBalance = getTotalBalance();
        DIPC_EMIT_EVENT(createOrder, "portfolioName", _portfolioName, "OrderInfo", "ignore", "tokenBalance", tokenBalance);
        uint64_t spent = 0;
        if(_orderType == 1){
            spent = _stockPrice * _stockAmount;
            DipcAssert((portfolioBalance.get()[_portfolioName] + tokenBalance) > spent);
        }
        struct Order order{_orderId, _orderType, _stockCode, _stockPrice, _stockAmount, _endTime, 0};
        std::string pInfo = portfolioStorge.get()[_portfolioName];
        
        
        
        if(pInfo == "") {
            DIPC_EMIT_EVENT(ErrEvent, "Current portfolio  doesn't exist: ", _portfolioName);
            return;
        }
        PortfolioInfo info;
        info.parseJson(pInfo);
        if(info.getOrder(_orderId).orderId != ""){
            DIPC_EMIT_EVENT(ErrEvent, "Current order exist: ", _orderId);
            return;
        }
        info.addOrder(order);
        pInfo = info.toJson();

        uint64_t currentBalance = portfolioBalance.get()[_portfolioName] ;
        uint64_t finalBalance = currentBalance + tokenBalance - spent;
        DipcAssert(totalToken.get() + tokenBalance > totalToken);
        
        DipcAssert(ownerTotalToken.get() < ownerTotalToken.get() + spent);
        (*portfolioStorge)[_portfolioName] = &pInfo[0];
        
        
        
        


        (*portfolioBalance)[_portfolioName] = finalBalance;
        *totalToken = totalToken.get() + finalBalance; 
        *ownerTotalToken = ownerTotalToken.get() + spent;
        DIPC_EMIT_EVENT(createOrder, "portfolioName", _portfolioName, "OrderInfo", &order.toJson()[0], "portfolioBalance", finalBalance);
    }

    
    EXPORT void PortfolioManage::dealOrder(char* _portfolioName, char* _orderId){
        isOwner();
        std::string pInfo = portfolioStorge.get()[_portfolioName];
        
        
        PortfolioInfo info;
        info.parseJson(pInfo);
        

        
         Order ord = info.getOrder(_orderId);
         
         
        if(ord.orderId != "" && ord.orderStatus == 0){
            
            uint64_t timenow = dipc::timestamp();
            if(ord.endTime > timenow){
                ord.orderStatus = 1;
            }else {
                ord.orderStatus = 3;
            }
        } else {
          

            return;
        }
        

        uint64_t sellValue = 0;
        if(ord.orderType == 0){
            sellValue = ord.stockAmount * ord.stockPrice;
        }
        uint64_t currentBalance =  portfolioBalance.get()[_portfolioName];
        

        DipcAssert(currentBalance + sellValue >= currentBalance);
        DipcAssert((ownerTotalToken.get() - sellValue) <= ownerTotalToken.get());
        


        (*portfolioBalance)[_portfolioName] = currentBalance + sellValue;
        *ownerTotalToken = ownerTotalToken.get() - sellValue;
        (*portfolioStorge)[_portfolioName] = &info.toJson()[0];
        
        
        
        

        DIPC_EMIT_EVENT(dealPortfolio, "orderId", _orderId, "orderInfo", &ord.toJson()[0]);
    }
    
    EXPORT void PortfolioManage::revocationOrder(char* _portfolioName, char* _orderId){
        std::string pInfo = portfolioStorge.get()[_portfolioName];
        
        
        PortfolioInfo info;
        info.parseJson(pInfo);
        Order ord = info.getOrder(_orderId);
        
        
        if(ord.orderId != "" && ord.orderStatus == 0){
            std::string callerStr = caller().toString();
            
            
            
            DipcAssert(info.getOwnerAddress() == caller().toString());
            

            uint64_t timenow = dipc::timestamp();
            if(ord.endTime > timenow){
                ord.orderStatus = 2;
            }else {
                ord.orderStatus = 3;
            }
        } else {
            return;
        }
        uint64_t lockToken = 0;
        if(ord.orderType == 1){
            lockToken = ord.stockPrice * ord.stockAmount;
        }
        uint64_t currentBalance =  portfolioBalance.get()[_portfolioName];
        
        
        
        

        DipcAssert(currentBalance + lockToken >= currentBalance);
        DipcAssert(ownerTotalToken.get() - lockToken <= ownerTotalToken.get());

        
        (*portfolioBalance)[_portfolioName] = currentBalance + lockToken;
        *ownerTotalToken = ownerTotalToken.get() - lockToken;
        (*portfolioStorge)[_portfolioName] = &info.toJson()[0];
        DIPC_EMIT_EVENT(revocationPortfolio, "orderId", _orderId, "orderInfo", &ord.toJson()[0]);
    }
    
    EXPORT void PortfolioManage::withdrawPortfolio(char* _portfolioName, uint64_t _withdrawBalance){
         if(!userCanWithdraw.get()){
             return;
         }
         uint64_t currentBalance =  portfolioBalance.get()[_portfolioName];
         DipcAssert(currentBalance - _withdrawBalance < currentBalance);
         auto coinBalance = changeUint64ToU256WithChangeRate(currentBalance, changeRate.get());
         (*portfolioBalance)[_portfolioName] = currentBalance - _withdrawBalance;
         callTransfer(caller(), coinBalance);
    }
    
    EXPORT void PortfolioManage::withdrawPool(uint64_t _balance){
        isOwner();
        Address ownerAddr = Address(owner.get()); 
        callTransfer(ownerAddr, _balance);
        *ownerTotalToken = ownerTotalToken.get() - _balance * changeRate.get();
        *totalToken = totalToken.get() - _balance * changeRate.get();
        DIPC_EMIT_EVENT(tokenCount, "ownerTotalToken", ownerTotalToken.get(), "totalToken", totalToken.get());
    }
    
    PAYABLE void PortfolioManage::depositPool(uint64_t _depositValue){
        isOwner();
        
        uint64_t tokenBalance = changeU256ToUint64WithChangeRate(callValue(), changeRate.get()); 
        *ownerTotalToken = ownerTotalToken.get() + tokenBalance;
        *totalToken = totalToken.get() + tokenBalance;
        DIPC_EMIT_EVENT(tokenCount, "ownerTotalToken", ownerTotalToken.get(), "totalToken", totalToken.get());
    }
     
    CONSTANT uint64_t PortfolioManage::queryTotalToken(){
        return totalToken.get();
    }

     
    CONSTANT uint64_t PortfolioManage::queryPortfolioBalance(char* _portfolioName){
        return portfolioBalance.get()[_portfolioName];
    }

    
    CONSTANT bool PortfolioManage::queryPortfolioNameIfUsed(char* _portfolioName){
        if(portfolioStorge.get()[_portfolioName] != ""){
            return true;
        } 
        return false;
    }

    
    CONSTANT uint64_t PortfolioManage::queryChangeRate(){
        return changeRate.get();
    }

2019-12-19_15:14:53.265660: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:442] finalContract  this new  #include "PortfolioManage.hpp"

    
    PAYABLE void PortfolioManage::init(){
        *owner = caller().toString();
        *changeRate = 10000;
        *userCanWithdraw = false;
        uint64_t tokenBalance = getTotalBalance();
        
        *ownerTotalToken = tokenBalance;
        *totalToken = ownerTotalToken.get();
        
        
        DIPC_EMIT_EVENT(initEvent, "ownerTotalToken" ,tokenBalance);
    }
    
     
    EXPORT void PortfolioManage::setChangeRate(uint64_t _changeRate){
        isOwner();
        *changeRate = _changeRate;
    }
     
    EXPORT void PortfolioManage::setUserCanWithdraw(bool _canWithdraw){
        isOwner();
        *userCanWithdraw = _canWithdraw;
    }

    
    PAYABLE void PortfolioManage::createPortfolio(char* _portfolioName, char* _portfolioDesc){
        if(portfolioStorge.get()[_portfolioName] != ""){
            DIPC_EMIT_EVENT(ErrEvent, "Current portfolio exist: ", _portfolioName);
            return;
        } 
        std::string callerAddr = caller().toString();
        uint64_t tokenBalance = getTotalBalance();
        
        PortfolioInfo info(_portfolioName, _portfolioDesc, &callerAddr[0]);
        std::string portfolioStr = info.toJson();
        
        
        

        (*portfolioStorge)[_portfolioName] = portfolioStr;
        DipcAssert(totalToken.get() + tokenBalance > totalToken);
        (*portfolioBalance)[_portfolioName] = tokenBalance;
        *totalToken = totalToken.get() + tokenBalance; 
        
        DIPC_EMIT_EVENT(portfolioInfo, _portfolioName, &portfolioStr[0], "portfolioBalance", tokenBalance);
    } codetext new #include "PortfolioManage.hpp"

    
    PAYABLE void PortfolioManage::init(){
        *owner = caller().toString();
        *changeRate = 10000;
        *userCanWithdraw = false;
        uint64_t tokenBalance = getTotalBalance();
        
        *ownerTotalToken = tokenBalance;
        *totalToken = ownerTotalToken.get();
        
        
        DIPC_EMIT_EVENT(initEvent, "ownerTotalToken" ,tokenBalance);
    }
    
     
    EXPORT void PortfolioManage::setChangeRate(uint64_t _changeRate){
        isOwner();
        *changeRate = _changeRate;
    }
     
    EXPORT void PortfolioManage::setUserCanWithdraw(bool _canWithdraw){
        isOwner();
        *userCanWithdraw = _canWithdraw;
    }

    
    PAYABLE void PortfolioManage::createPortfolio(char* _portfolioName, char* _portfolioDesc){
        if(portfolioStorge.get()[_portfolioName] != ""){
            DIPC_EMIT_EVENT(ErrEvent, "Current portfolio exist: ", _portfolioName);
            return;
        } 
        std::string callerAddr = caller().toString();
        uint64_t tokenBalance = getTotalBalance();
        
        PortfolioInfo info(_portfolioName, _portfolioDesc, &callerAddr[0]);
        std::string portfolioStr = info.toJson();
        
        
        

        (*portfolioStorge)[_portfolioName] = portfolioStr;
        DipcAssert(totalToken.get() + tokenBalance > totalToken);
        (*portfolioBalance)[_portfolioName] = tokenBalance;
        *totalToken = totalToken.get() + tokenBalance; 
        
        DIPC_EMIT_EVENT(portfolioInfo, _portfolioName, &portfolioStr[0], "portfolioBalance", tokenBalance);
    }

    
    PAYABLE void PortfolioManage::depositPortfolio(char* _portfolioName){
        uint64_t tokenBalance = getTotalBalance();
        
        uint64_t currentBalance = portfolioBalance.get()[_portfolioName];
        uint64_t finalBalance  = currentBalance + tokenBalance;
        DipcAssert(totalToken.get() + tokenBalance > totalToken);
        DipcAssert(finalBalance > currentBalance);
        (*portfolioBalance)[_portfolioName] = finalBalance;
        *totalToken = totalToken.get() + finalBalance; 
        DIPC_EMIT_EVENT(depositPortfolio, "portfolioName", _portfolioName, "portfolioBalance", finalBalance);
    }
    
    PAYABLE void PortfolioManage::createOrder(char* _portfolioName, char* _orderId, uint16_t _orderType, char* _stockCode, uint64_t _stockPrice, uint64_t _stockAmount, uint64_t _endTime){
        uint64_t tokenBalance = getTotalBalance();
        DIPC_EMIT_EVENT(createOrder, "portfolioName", _portfolioName, "OrderInfo", "ignore", "tokenBalance", tokenBalance);
        uint64_t spent = 0;
        if(_orderType == 1){
            spent = _stockPrice * _stockAmount;
            DipcAssert((portfolioBalance.get()[_portfolioName] + tokenBalance) > spent);
        }
        struct Order order{_orderId, _orderType, _stockCode, _stockPrice, _stockAmount, _endTime, 0};
        std::string pInfo = portfolioStorge.get()[_portfolioName];
        
        
        
        if(pInfo == "") {
            DIPC_EMIT_EVENT(ErrEvent, "Current portfolio  doesn't exist: ", _portfolioName);
            return;
        }
        PortfolioInfo info;
        info.parseJson(pInfo);
        if(info.getOrder(_orderId).orderId != ""){
            DIPC_EMIT_EVENT(ErrEvent, "Current order exist: ", _orderId);
            return;
        }
        info.addOrder(order);
        pInfo = info.toJson();

        uint64_t currentBalance = portfolioBalance.get()[_portfolioName] ;
        uint64_t finalBalance = currentBalance + tokenBalance - spent;
        DipcAssert(totalToken.get() + tokenBalance > totalToken);
        
        DipcAssert(ownerTotalToken.get() < ownerTotalToken.get() + spent);
        (*portfolioStorge)[_portfolioName] = &pInfo[0];
        
        
        
        


        (*portfolioBalance)[_portfolioName] = finalBalance;
        *totalToken = totalToken.get() + finalBalance; 
        *ownerTotalToken = ownerTotalToken.get() + spent;
        DIPC_EMIT_EVENT(createOrder, "portfolioName", _portfolioName, "OrderInfo", &order.toJson()[0], "portfolioBalance", finalBalance);
    }

    
    EXPORT void PortfolioManage::dealOrder(char* _portfolioName, char* _orderId){
        isOwner();
        std::string pInfo = portfolioStorge.get()[_portfolioName];
        
        
        PortfolioInfo info;
        info.parseJson(pInfo);
        

        
         Order ord = info.getOrder(_orderId);
         
         
        if(ord.orderId != "" && ord.orderStatus == 0){
            
            uint64_t timenow = dipc::timestamp();
            if(ord.endTime > timenow){
                ord.orderStatus = 1;
            }else {
                ord.orderStatus = 3;
            }
        } else {
          

            return;
        }
        

        uint64_t sellValue = 0;
        if(ord.orderType == 0){
            sellValue = ord.stockAmount * ord.stockPrice;
        }
        uint64_t currentBalance =  portfolioBalance.get()[_portfolioName];
        

        DipcAssert(currentBalance + sellValue >= currentBalance);
        DipcAssert((ownerTotalToken.get() - sellValue) <= ownerTotalToken.get());
        


        (*portfolioBalance)[_portfolioName] = currentBalance + sellValue;
        *ownerTotalToken = ownerTotalToken.get() - sellValue;
        (*portfolioStorge)[_portfolioName] = &info.toJson()[0];
        
        
        
        

        DIPC_EMIT_EVENT(dealPortfolio, "orderId", _orderId, "orderInfo", &ord.toJson()[0]);
    }
    
    EXPORT void PortfolioManage::revocationOrder(char* _portfolioName, char* _orderId){
        std::string pInfo = portfolioStorge.get()[_portfolioName];
        
        
        PortfolioInfo info;
        info.parseJson(pInfo);
        Order ord = info.getOrder(_orderId);
        
        
        if(ord.orderId != "" && ord.orderStatus == 0){
            std::string callerStr = caller().toString();
            
            
            
            DipcAssert(info.getOwnerAddress() == caller().toString());
            

            uint64_t timenow = dipc::timestamp();
            if(ord.endTime > timenow){
                ord.orderStatus = 2;
            }else {
                ord.orderStatus = 3;
            }
        } else {
            return;
        }
        uint64_t lockToken = 0;
        if(ord.orderType == 1){
            lockToken = ord.stockPrice * ord.stockAmount;
        }
        uint64_t currentBalance =  portfolioBalance.get()[_portfolioName];
        
        
        
        

        DipcAssert(currentBalance + lockToken >= currentBalance);
        DipcAssert(ownerTotalToken.get() - lockToken <= ownerTotalToken.get());

        
        (*portfolioBalance)[_portfolioName] = currentBalance + lockToken;
        *ownerTotalToken = ownerTotalToken.get() - lockToken;
        (*portfolioStorge)[_portfolioName] = &info.toJson()[0];
        DIPC_EMIT_EVENT(revocationPortfolio, "orderId", _orderId, "orderInfo", &ord.toJson()[0]);
    }
    
    EXPORT void PortfolioManage::withdrawPortfolio(char* _portfolioName, uint64_t _withdrawBalance){
         if(!userCanWithdraw.get()){
             return;
         }
         uint64_t currentBalance =  portfolioBalance.get()[_portfolioName];
         DipcAssert(currentBalance - _withdrawBalance < currentBalance);
         auto coinBalance = changeUint64ToU256WithChangeRate(currentBalance, changeRate.get());
         (*portfolioBalance)[_portfolioName] = currentBalance - _withdrawBalance;
         callTransfer(caller(), coinBalance);
    }
    
    EXPORT void PortfolioManage::withdrawPool(uint64_t _balance){
        isOwner();
        Address ownerAddr = Address(owner.get()); 
        callTransfer(ownerAddr, _balance);
        *ownerTotalToken = ownerTotalToken.get() - _balance * changeRate.get();
        *totalToken = totalToken.get() - _balance * changeRate.get();
        DIPC_EMIT_EVENT(tokenCount, "ownerTotalToken", ownerTotalToken.get(), "totalToken", totalToken.get());
    }
    
    PAYABLE void PortfolioManage::depositPool(uint64_t _depositValue){
        isOwner();
        
        uint64_t tokenBalance = changeU256ToUint64WithChangeRate(callValue(), changeRate.get()); 
        *ownerTotalToken = ownerTotalToken.get() + tokenBalance;
        *totalToken = totalToken.get() + tokenBalance;
        DIPC_EMIT_EVENT(tokenCount, "ownerTotalToken", ownerTotalToken.get(), "totalToken", totalToken.get());
    }
     
    CONSTANT uint64_t PortfolioManage::queryTotalToken(){
        return totalToken.get();
    }

     
    CONSTANT uint64_t PortfolioManage::queryPortfolioBalance(char* _portfolioName){
        return portfolioBalance.get()[_portfolioName];
    }

    
    CONSTANT bool PortfolioManage::queryPortfolioNameIfUsed(char* _portfolioName){
        if(portfolioStorge.get()[_portfolioName] != ""){
            return true;
        } 
        return false;
    }

    
    CONSTANT uint64_t PortfolioManage::queryChangeRate(){
        return changeRate.get();
    }

2019-12-19_15:14:53.265683: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:604] finalContract  final content =======   : #include "PortfolioManage.hpp"

    
    PAYABLE void PortfolioManage::init(){
        *owner = caller().toString();
        *changeRate = 10000;
        *userCanWithdraw = false;
        uint64_t tokenBalance = getTotalBalance();
        
        *ownerTotalToken = tokenBalance;
        *totalToken = ownerTotalToken.get();
        
        
        DIPC_EMIT_EVENT(initEvent, "ownerTotalToken" ,tokenBalance);
    }
    
     
    EXPORT void PortfolioManage::setChangeRate(uint64_t _changeRate){
        isOwner();
        *changeRate = _changeRate;
    }
     
    EXPORT void PortfolioManage::setUserCanWithdraw(bool _canWithdraw){
        isOwner();
        *userCanWithdraw = _canWithdraw;
    }

    
    PAYABLE void PortfolioManage::createPortfolio(char* _portfolioName, char* _portfolioDesc){
        if(portfolioStorge.get()[_portfolioName] != ""){
            DIPC_EMIT_EVENT(ErrEvent, "Current portfolio exist: ", _portfolioName);
            return;
        } 
        std::string callerAddr = caller().toString();
        uint64_t tokenBalance = getTotalBalance();
        
        PortfolioInfo info(_portfolioName, _portfolioDesc, &callerAddr[0]);
        std::string portfolioStr = info.toJson();
        
        
        

        (*portfolioStorge)[_portfolioName] = portfolioStr;
        DipcAssert(totalToken.get() + tokenBalance > totalToken);
        (*portfolioBalance)[_portfolioName] = tokenBalance;
        *totalToken = totalToken.get() + tokenBalance; 
        
        DIPC_EMIT_EVENT(portfolioInfo, _portfolioName, &portfolioStr[0], "portfolioBalance", tokenBalance);
    }

    
    PAYABLE void PortfolioManage::depositPortfolio(char* _portfolioName){
        uint64_t tokenBalance = getTotalBalance();
        
        uint64_t currentBalance = portfolioBalance.get()[_portfolioName];
        uint64_t finalBalance  = currentBalance + tokenBalance;
        DipcAssert(totalToken.get() + tokenBalance > totalToken);
        DipcAssert(finalBalance > currentBalance);
        (*portfolioBalance)[_portfolioName] = finalBalance;
        *totalToken = totalToken.get() + finalBalance; 
        DIPC_EMIT_EVENT(depositPortfolio, "portfolioName", _portfolioName, "portfolioBalance", finalBalance);
    }
    
    PAYABLE void PortfolioManage::createOrder(char* _portfolioName, char* _orderId, uint16_t _orderType, char* _stockCode, uint64_t _stockPrice, uint64_t _stockAmount, uint64_t _endTime){
        uint64_t tokenBalance = getTotalBalance();
        DIPC_EMIT_EVENT(createOrder, "portfolioName", _portfolioName, "OrderInfo", "ignore", "tokenBalance", tokenBalance);
        uint64_t spent = 0;
        if(_orderType == 1){
            spent = _stockPrice * _stockAmount;
            DipcAssert((portfolioBalance.get()[_portfolioName] + tokenBalance) > spent);
        }
        struct Order order{_orderId, _orderType, _stockCode, _stockPrice, _stockAmount, _endTime, 0};
        std::string pInfo = portfolioStorge.get()[_portfolioName];
        
        
        
        if(pInfo == "") {
            DIPC_EMIT_EVENT(ErrEvent, "Current portfolio  doesn't exist: ", _portfolioName);
            return;
        }
        PortfolioInfo info;
        info.parseJson(pInfo);
        if(info.getOrder(_orderId).orderId != ""){
            DIPC_EMIT_EVENT(ErrEvent, "Current order exist: ", _orderId);
            return;
        }
        info.addOrder(order);
        pInfo = info.toJson();

        uint64_t currentBalance = portfolioBalance.get()[_portfolioName] ;
        uint64_t finalBalance = currentBalance + tokenBalance - spent;
        DipcAssert(totalToken.get() + tokenBalance > totalToken);
        
        DipcAssert(ownerTotalToken.get() < ownerTotalToken.get() + spent);
        (*portfolioStorge)[_portfolioName] = &pInfo[0];
        
        
        
        


        (*portfolioBalance)[_portfolioName] = finalBalance;
        *totalToken = totalToken.get() + finalBalance; 
        *ownerTotalToken = ownerTotalToken.get() + spent;
        DIPC_EMIT_EVENT(createOrder, "portfolioName", _portfolioName, "OrderInfo", &order.toJson()[0], "portfolioBalance", finalBalance);
    }

    
    EXPORT void PortfolioManage::dealOrder(char* _portfolioName, char* _orderId){
        isOwner();
        std::string pInfo = portfolioStorge.get()[_portfolioName];
        
        
        PortfolioInfo info;
        info.parseJson(pInfo);
        

        
         Order ord = info.getOrder(_orderId);
         
         
        if(ord.orderId != "" && ord.orderStatus == 0){
            
            uint64_t timenow = dipc::timestamp();
            if(ord.endTime > timenow){
                ord.orderStatus = 1;
            }else {
                ord.orderStatus = 3;
            }
        } else {
          

            return;
        }
        

        uint64_t sellValue = 0;
        if(ord.orderType == 0){
            sellValue = ord.stockAmount * ord.stockPrice;
        }
        uint64_t currentBalance =  portfolioBalance.get()[_portfolioName];
        

        DipcAssert(currentBalance + sellValue >= currentBalance);
        DipcAssert((ownerTotalToken.get() - sellValue) <= ownerTotalToken.get());
        


        (*portfolioBalance)[_portfolioName] = currentBalance + sellValue;
        *ownerTotalToken = ownerTotalToken.get() - sellValue;
        (*portfolioStorge)[_portfolioName] = &info.toJson()[0];
        
        
        
        

        DIPC_EMIT_EVENT(dealPortfolio, "orderId", _orderId, "orderInfo", &ord.toJson()[0]);
    }
    
    EXPORT void PortfolioManage::revocationOrder(char* _portfolioName, char* _orderId){
        std::string pInfo = portfolioStorge.get()[_portfolioName];
        
        
        PortfolioInfo info;
        info.parseJson(pInfo);
        Order ord = info.getOrder(_orderId);
        
        
        if(ord.orderId != "" && ord.orderStatus == 0){
            std::string callerStr = caller().toString();
            
            
            
            DipcAssert(info.getOwnerAddress() == caller().toString());
            

            uint64_t timenow = dipc::timestamp();
            if(ord.endTime > timenow){
                ord.orderStatus = 2;
            }else {
                ord.orderStatus = 3;
            }
        } else {
            return;
        }
        uint64_t lockToken = 0;
        if(ord.orderType == 1){
            lockToken = ord.stockPrice * ord.stockAmount;
        }
        uint64_t currentBalance =  portfolioBalance.get()[_portfolioName];
        
        
        
        

        DipcAssert(currentBalance + lockToken >= currentBalance);
        DipcAssert(ownerTotalToken.get() - lockToken <= ownerTotalToken.get());

        
        (*portfolioBalance)[_portfolioName] = currentBalance + lockToken;
        *ownerTotalToken = ownerTotalToken.get() - lockToken;
        (*portfolioStorge)[_portfolioName] = &info.toJson()[0];
        DIPC_EMIT_EVENT(revocationPortfolio, "orderId", _orderId, "orderInfo", &ord.toJson()[0]);
    }
    
    EXPORT void PortfolioManage::withdrawPortfolio(char* _portfolioName, uint64_t _withdrawBalance){
         if(!userCanWithdraw.get()){
             return;
         }
         uint64_t currentBalance =  portfolioBalance.get()[_portfolioName];
         DipcAssert(currentBalance - _withdrawBalance < currentBalance);
         auto coinBalance = changeUint64ToU256WithChangeRate(currentBalance, changeRate.get());
         (*portfolioBalance)[_portfolioName] = currentBalance - _withdrawBalance;
         callTransfer(caller(), coinBalance);
    }
    
    EXPORT void PortfolioManage::withdrawPool(uint64_t _balance){
        isOwner();
        Address ownerAddr = Address(owner.get()); 
        callTransfer(ownerAddr, _balance);
        *ownerTotalToken = ownerTotalToken.get() - _balance * changeRate.get();
        *totalToken = totalToken.get() - _balance * changeRate.get();
        DIPC_EMIT_EVENT(tokenCount, "ownerTotalToken", ownerTotalToken.get(), "totalToken", totalToken.get());
    }
    
    PAYABLE void PortfolioManage::depositPool(uint64_t _depositValue){
        isOwner();
        
        uint64_t tokenBalance = changeU256ToUint64WithChangeRate(callValue(), changeRate.get()); 
        *ownerTotalToken = ownerTotalToken.get() + tokenBalance;
        *totalToken = totalToken.get() + tokenBalance;
        DIPC_EMIT_EVENT(tokenCount, "ownerTotalToken", ownerTotalToken.get(), "totalToken", totalToken.get());
    }
     
    CONSTANT uint64_t PortfolioManage::queryTotalToken(){
        return totalToken.get();
    }

     
    CONSTANT uint64_t PortfolioManage::queryPortfolioBalance(char* _portfolioName){
        return portfolioBalance.get()[_portfolioName];
    }

    
    CONSTANT bool PortfolioManage::queryPortfolioNameIfUsed(char* _portfolioName){
        if(portfolioStorge.get()[_portfolioName] != ""){
            return true;
        } 
        return false;
    }

    
    CONSTANT uint64_t PortfolioManage::queryChangeRate(){
        return changeRate.get();
    }

2019-12-19_15:14:53.265694: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:401] abis.ispayable :true

2019-12-19_15:14:53.265712: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:424] finalContract  this height  #include "PortfolioManage.hpp"

    
    PAYABLE void PortfolioManage::init(){
        *owner = caller().toString();
        *changeRate = 10000;
        *userCanWithdraw = false;
        uint64_t tokenBalance = getTotalBalance();
        
        *ownerTotalToken = tokenBalance;
        *totalToken = ownerTotalToken.get();
        
        
        DIPC_EMIT_EVENT(initEvent, "ownerTotalToken" ,tokenBalance);
    }
    
     
    EXPORT void PortfolioManage::setChangeRate(uint64_t _changeRate){
        isOwner();
        *changeRate = _changeRate;
    }
     
    EXPORT void PortfolioManage::setUserCanWithdraw(bool _canWithdraw){
        isOwner();
        *userCanWithdraw = _canWithdraw;
    }

    
    PAYABLE void PortfolioManage::createPortfolio(char* _portfolioName, char* _portfolioDesc){
        if(portfolioStorge.get()[_portfolioName] != ""){
            DIPC_EMIT_EVENT(ErrEvent, "Current portfolio exist: ", _portfolioName);
            return;
        } 
        std::string callerAddr = caller().toString();
        uint64_t tokenBalance = getTotalBalance();
        
        PortfolioInfo info(_portfolioName, _portfolioDesc, &callerAddr[0]);
        std::string portfolioStr = info.toJson();
        
        
        

        (*portfolioStorge)[_portfolioName] = portfolioStr;
        DipcAssert(totalToken.get() + tokenBalance > totalToken);
        (*portfolioBalance)[_portfolioName] = tokenBalance;
        *totalToken = totalToken.get() + tokenBalance; 
        
        DIPC_EMIT_EVENT(portfolioInfo, _portfolioName, &portfolioStr[0], "portfolioBalance", tokenBalance);
    }

    
    PAYABLE void PortfolioManage::depositPortfolio(char* _portfolioName){
        uint64_t tokenBalance = getTotalBalance();
        
        uint64_t currentBalance = portfolioBalance.get()[_portfolioName];
        uint64_t finalBalance  = currentBalance + tokenBalance;
        DipcAssert(totalToken.get() + tokenBalance > totalToken);
        DipcAssert(finalBalance > currentBalance);
        (*portfolioBalance)[_portfolioName] = finalBalance;
        *totalToken = totalToken.get() + finalBalance; 
        DIPC_EMIT_EVENT(depositPortfolio, "portfolioName", _portfolioName, "portfolioBalance", finalBalance);
    }
    
    PAYABLE void PortfolioManage::createOrder(char* _portfolioName, char* _orderId, uint16_t _orderType, char* _stockCode, uint64_t _stockPrice, uint64_t _stockAmount, uint64_t _endTime){
        uint64_t tokenBalance = getTotalBalance();
        DIPC_EMIT_EVENT(createOrder, "portfolioName", _portfolioName, "OrderInfo", "ignore", "tokenBalance", tokenBalance);
        uint64_t spent = 0;
        if(_orderType == 1){
            spent = _stockPrice * _stockAmount;
            DipcAssert((portfolioBalance.get()[_portfolioName] + tokenBalance) > spent);
        }
        struct Order order{_orderId, _orderType, _stockCode, _stockPrice, _stockAmount, _endTime, 0};
        std::string pInfo = portfolioStorge.get()[_portfolioName];
        
        
        
        if(pInfo == "") {
            DIPC_EMIT_EVENT(ErrEvent, "Current portfolio  doesn't exist: ", _portfolioName);
            return;
        }
        PortfolioInfo info;
        info.parseJson(pInfo);
        if(info.getOrder(_orderId).orderId != ""){
            DIPC_EMIT_EVENT(ErrEvent, "Current order exist: ", _orderId);
            return;
        }
        info.addOrder(order);
        pInfo = info.toJson();

        uint64_t currentBalance = portfolioBalance.get()[_portfolioName] ;
        uint64_t finalBalance = currentBalance + tokenBalance - spent;
        DipcAssert(totalToken.get() + tokenBalance > totalToken);
        
        DipcAssert(ownerTotalToken.get() < ownerTotalToken.get() + spent);
        (*portfolioStorge)[_portfolioName] = &pInfo[0];
        
        
        
        


        (*portfolioBalance)[_portfolioName] = finalBalance;
        *totalToken = totalToken.get() + finalBalance; 
        *ownerTotalToken = ownerTotalToken.get() + spent;
        DIPC_EMIT_EVENT(createOrder, "portfolioName", _portfolioName, "OrderInfo", &order.toJson()[0], "portfolioBalance", finalBalance);
    }

    
    EXPORT void PortfolioManage::dealOrder(char* _portfolioName, char* _orderId){
        isOwner();
        std::string pInfo = portfolioStorge.get()[_portfolioName];
        
        
        PortfolioInfo info;
        info.parseJson(pInfo);
        

        
         Order ord = info.getOrder(_orderId);
         
         
        if(ord.orderId != "" && ord.orderStatus == 0){
            
            uint64_t timenow = dipc::timestamp();
            if(ord.endTime > timenow){
                ord.orderStatus = 1;
            }else {
                ord.orderStatus = 3;
            }
        } else {
          

            return;
        }
        

        uint64_t sellValue = 0;
        if(ord.orderType == 0){
            sellValue = ord.stockAmount * ord.stockPrice;
        }
        uint64_t currentBalance =  portfolioBalance.get()[_portfolioName];
        

        DipcAssert(currentBalance + sellValue >= currentBalance);
        DipcAssert((ownerTotalToken.get() - sellValue) <= ownerTotalToken.get());
        


        (*portfolioBalance)[_portfolioName] = currentBalance + sellValue;
        *ownerTotalToken = ownerTotalToken.get() - sellValue;
        (*portfolioStorge)[_portfolioName] = &info.toJson()[0];
        
        
        
        

        DIPC_EMIT_EVENT(dealPortfolio, "orderId", _orderId, "orderInfo", &ord.toJson()[0]);
    }
    
    EXPORT void PortfolioManage::revocationOrder(char* _portfolioName, char* _orderId){
        std::string pInfo = portfolioStorge.get()[_portfolioName];
        
        
        PortfolioInfo info;
        info.parseJson(pInfo);
        Order ord = info.getOrder(_orderId);
        
        
        if(ord.orderId != "" && ord.orderStatus == 0){
            std::string callerStr = caller().toString();
            
            
            
            DipcAssert(info.getOwnerAddress() == caller().toString());
            

            uint64_t timenow = dipc::timestamp();
            if(ord.endTime > timenow){
                ord.orderStatus = 2;
            }else {
                ord.orderStatus = 3;
            }
        } else {
            return;
        }
        uint64_t lockToken = 0;
        if(ord.orderType == 1){
            lockToken = ord.stockPrice * ord.stockAmount;
        }
        uint64_t currentBalance =  portfolioBalance.get()[_portfolioName];
        
        
        
        

        DipcAssert(currentBalance + lockToken >= currentBalance);
        DipcAssert(ownerTotalToken.get() - lockToken <= ownerTotalToken.get());

        
        (*portfolioBalance)[_portfolioName] = currentBalance + lockToken;
        *ownerTotalToken = ownerTotalToken.get() - lockToken;
        (*portfolioStorge)[_portfolioName] = &info.toJson()[0];
        DIPC_EMIT_EVENT(revocationPortfolio, "orderId", _orderId, "orderInfo", &ord.toJson()[0]);
    }
    
    EXPORT void PortfolioManage::withdrawPortfolio(char* _portfolioName, uint64_t _withdrawBalance){
         if(!userCanWithdraw.get()){
             return;
         }
         uint64_t currentBalance =  portfolioBalance.get()[_portfolioName];
         DipcAssert(currentBalance - _withdrawBalance < currentBalance);
         auto coinBalance = changeUint64ToU256WithChangeRate(currentBalance, changeRate.get());
         (*portfolioBalance)[_portfolioName] = currentBalance - _withdrawBalance;
         callTransfer(caller(), coinBalance);
    }
    
    EXPORT void PortfolioManage::withdrawPool(uint64_t _balance){
        isOwner();
        Address ownerAddr = Address(owner.get()); 
        callTransfer(ownerAddr, _balance);
        *ownerTotalToken = ownerTotalToken.get() - _balance * changeRate.get();
        *totalToken = totalToken.get() - _balance * changeRate.get();
        DIPC_EMIT_EVENT(tokenCount, "ownerTotalToken", ownerTotalToken.get(), "totalToken", totalToken.get());
    }
    
    PAYABLE void PortfolioManage::depositPool(uint64_t _depositValue){
        isOwner();
        
        uint64_t tokenBalance = changeU256ToUint64WithChangeRate(callValue(), changeRate.get()); 
        *ownerTotalToken = ownerTotalToken.get() + tokenBalance;
        *totalToken = totalToken.get() + tokenBalance;
        DIPC_EMIT_EVENT(tokenCount, "ownerTotalToken", ownerTotalToken.get(), "totalToken", totalToken.get());
    }
     
    CONSTANT uint64_t PortfolioManage::queryTotalToken(){
        return totalToken.get();
    }

     
    CONSTANT uint64_t PortfolioManage::queryPortfolioBalance(char* _portfolioName){
        return portfolioBalance.get()[_portfolioName];
    }

    
    CONSTANT bool PortfolioManage::queryPortfolioNameIfUsed(char* _portfolioName){
        if(portfolioStorge.get()[_portfolioName] != ""){
            return true;
        } 
        return false;
    }

    
    CONSTANT uint64_t PortfolioManage::queryChangeRate(){
        return changeRate.get();
    } codetext height #include "PortfolioManage.hpp"

    
    PAYABLE void PortfolioManage::init(){
        *owner = caller().toString();
        *changeRate = 10000;
        *userCanWithdraw = false;
        uint64_t tokenBalance = getTotalBalance();
        
        *ownerTotalToken = tokenBalance;
        *totalToken = ownerTotalToken.get();
        
        
        DIPC_EMIT_EVENT(initEvent, "ownerTotalToken" ,tokenBalance);
    }
    
     
    EXPORT void PortfolioManage::setChangeRate(uint64_t _changeRate){
        isOwner();
        *changeRate = _changeRate;
    }
     
    EXPORT void PortfolioManage::setUserCanWithdraw(bool _canWithdraw){
        isOwner();
        *userCanWithdraw = _canWithdraw;
    }

    
    PAYABLE void PortfolioManage::createPortfolio(char* _portfolioName, char* _portfolioDesc){
        if(portfolioStorge.get()[_portfolioName] != ""){
            DIPC_EMIT_EVENT(ErrEvent, "Current portfolio exist: ", _portfolioName);
            return;
        } 
        std::string callerAddr = caller().toString();
        uint64_t tokenBalance = getTotalBalance();
        
        PortfolioInfo info(_portfolioName, _portfolioDesc, &callerAddr[0]);
        std::string portfolioStr = info.toJson();
        
        
        

        (*portfolioStorge)[_portfolioName] = portfolioStr;
        DipcAssert(totalToken.get() + tokenBalance > totalToken);
        (*portfolioBalance)[_portfolioName] = tokenBalance;
        *totalToken = totalToken.get() + tokenBalance; 
        
        DIPC_EMIT_EVENT(portfolioInfo, _portfolioName, &portfolioStr[0], "portfolioBalance", tokenBalance);
    }

    
    PAYABLE void PortfolioManage::depositPortfolio(char* _portfolioName){
        uint64_t tokenBalance = getTotalBalance();
        
        uint64_t currentBalance = portfolioBalance.get()[_portfolioName];
        uint64_t finalBalance  = currentBalance + tokenBalance;
        DipcAssert(totalToken.get() + tokenBalance > totalToken);
        DipcAssert(finalBalance > currentBalance);
        (*portfolioBalance)[_portfolioName] = finalBalance;
        *totalToken = totalToken.get() + finalBalance; 
        DIPC_EMIT_EVENT(depositPortfolio, "portfolioName", _portfolioName, "portfolioBalance", finalBalance);
    }
    
    PAYABLE void PortfolioManage::createOrder(char* _portfolioName, char* _orderId, uint16_t _orderType, char* _stockCode, uint64_t _stockPrice, uint64_t _stockAmount, uint64_t _endTime){
        uint64_t tokenBalance = getTotalBalance();
        DIPC_EMIT_EVENT(createOrder, "portfolioName", _portfolioName, "OrderInfo", "ignore", "tokenBalance", tokenBalance);
        uint64_t spent = 0;
        if(_orderType == 1){
            spent = _stockPrice * _stockAmount;
            DipcAssert((portfolioBalance.get()[_portfolioName] + tokenBalance) > spent);
        }
        struct Order order{_orderId, _orderType, _stockCode, _stockPrice, _stockAmount, _endTime, 0};
        std::string pInfo = portfolioStorge.get()[_portfolioName];
        
        
        
        if(pInfo == "") {
            DIPC_EMIT_EVENT(ErrEvent, "Current portfolio  doesn't exist: ", _portfolioName);
            return;
        }
        PortfolioInfo info;
        info.parseJson(pInfo);
        if(info.getOrder(_orderId).orderId != ""){
            DIPC_EMIT_EVENT(ErrEvent, "Current order exist: ", _orderId);
            return;
        }
        info.addOrder(order);
        pInfo = info.toJson();

        uint64_t currentBalance = portfolioBalance.get()[_portfolioName] ;
        uint64_t finalBalance = currentBalance + tokenBalance - spent;
        DipcAssert(totalToken.get() + tokenBalance > totalToken);
        
        DipcAssert(ownerTotalToken.get() < ownerTotalToken.get() + spent);
        (*portfolioStorge)[_portfolioName] = &pInfo[0];
        
        
        
        


        (*portfolioBalance)[_portfolioName] = finalBalance;
        *totalToken = totalToken.get() + finalBalance; 
        *ownerTotalToken = ownerTotalToken.get() + spent;
        DIPC_EMIT_EVENT(createOrder, "portfolioName", _portfolioName, "OrderInfo", &order.toJson()[0], "portfolioBalance", finalBalance);
    }

    
    EXPORT void PortfolioManage::dealOrder(char* _portfolioName, char* _orderId){
        isOwner();
        std::string pInfo = portfolioStorge.get()[_portfolioName];
        
        
        PortfolioInfo info;
        info.parseJson(pInfo);
        

        
         Order ord = info.getOrder(_orderId);
         
         
        if(ord.orderId != "" && ord.orderStatus == 0){
            
            uint64_t timenow = dipc::timestamp();
            if(ord.endTime > timenow){
                ord.orderStatus = 1;
            }else {
                ord.orderStatus = 3;
            }
        } else {
          

            return;
        }
        

        uint64_t sellValue = 0;
        if(ord.orderType == 0){
            sellValue = ord.stockAmount * ord.stockPrice;
        }
        uint64_t currentBalance =  portfolioBalance.get()[_portfolioName];
        

        DipcAssert(currentBalance + sellValue >= currentBalance);
        DipcAssert((ownerTotalToken.get() - sellValue) <= ownerTotalToken.get());
        


        (*portfolioBalance)[_portfolioName] = currentBalance + sellValue;
        *ownerTotalToken = ownerTotalToken.get() - sellValue;
        (*portfolioStorge)[_portfolioName] = &info.toJson()[0];
        
        
        
        

        DIPC_EMIT_EVENT(dealPortfolio, "orderId", _orderId, "orderInfo", &ord.toJson()[0]);
    }
    
    EXPORT void PortfolioManage::revocationOrder(char* _portfolioName, char* _orderId){
        std::string pInfo = portfolioStorge.get()[_portfolioName];
        
        
        PortfolioInfo info;
        info.parseJson(pInfo);
        Order ord = info.getOrder(_orderId);
        
        
        if(ord.orderId != "" && ord.orderStatus == 0){
            std::string callerStr = caller().toString();
            
            
            
            DipcAssert(info.getOwnerAddress() == caller().toString());
            

            uint64_t timenow = dipc::timestamp();
            if(ord.endTime > timenow){
                ord.orderStatus = 2;
            }else {
                ord.orderStatus = 3;
            }
        } else {
            return;
        }
        uint64_t lockToken = 0;
        if(ord.orderType == 1){
            lockToken = ord.stockPrice * ord.stockAmount;
        }
        uint64_t currentBalance =  portfolioBalance.get()[_portfolioName];
        
        
        
        

        DipcAssert(currentBalance + lockToken >= currentBalance);
        DipcAssert(ownerTotalToken.get() - lockToken <= ownerTotalToken.get());

        
        (*portfolioBalance)[_portfolioName] = currentBalance + lockToken;
        *ownerTotalToken = ownerTotalToken.get() - lockToken;
        (*portfolioStorge)[_portfolioName] = &info.toJson()[0];
        DIPC_EMIT_EVENT(revocationPortfolio, "orderId", _orderId, "orderInfo", &ord.toJson()[0]);
    }
    
    EXPORT void PortfolioManage::withdrawPortfolio(char* _portfolioName, uint64_t _withdrawBalance){
         if(!userCanWithdraw.get()){
             return;
         }
         uint64_t currentBalance =  portfolioBalance.get()[_portfolioName];
         DipcAssert(currentBalance - _withdrawBalance < currentBalance);
         auto coinBalance = changeUint64ToU256WithChangeRate(currentBalance, changeRate.get());
         (*portfolioBalance)[_portfolioName] = currentBalance - _withdrawBalance;
         callTransfer(caller(), coinBalance);
    }
    
    EXPORT void PortfolioManage::withdrawPool(uint64_t _balance){
        isOwner();
        Address ownerAddr = Address(owner.get()); 
        callTransfer(ownerAddr, _balance);
        *ownerTotalToken = ownerTotalToken.get() - _balance * changeRate.get();
        *totalToken = totalToken.get() - _balance * changeRate.get();
        DIPC_EMIT_EVENT(tokenCount, "ownerTotalToken", ownerTotalToken.get(), "totalToken", totalToken.get());
    }
    
    PAYABLE void PortfolioManage::depositPool(uint64_t _depositValue){
        isOwner();
        
        uint64_t tokenBalance = changeU256ToUint64WithChangeRate(callValue(), changeRate.get()); 
        *ownerTotalToken = ownerTotalToken.get() + tokenBalance;
        *totalToken = totalToken.get() + tokenBalance;
        DIPC_EMIT_EVENT(tokenCount, "ownerTotalToken", ownerTotalToken.get(), "totalToken", totalToken.get());
    }
     
    CONSTANT uint64_t PortfolioManage::queryTotalToken(){
        return totalToken.get();
    }

     
    CONSTANT uint64_t PortfolioManage::queryPortfolioBalance(char* _portfolioName){
        return portfolioBalance.get()[_portfolioName];
    }

    
    CONSTANT bool PortfolioManage::queryPortfolioNameIfUsed(char* _portfolioName){
        if(portfolioStorge.get()[_portfolioName] != ""){
            return true;
        } 
        return false;
    }

    
    CONSTANT uint64_t PortfolioManage::queryChangeRate(){
        return changeRate.get();
    }

2019-12-19_15:14:53.265723: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:427] searchContext  #include "PortfolioManage.hpp"

    
    PAYABLE void PortfolioManage::init(){
        *owner = caller().toString();
        *changeRate = 10000;
        *userCanWithdraw = false;
        uint64_t tokenBalance = getTotalBalance();
        
        *ownerTotalToken = tokenBalance;
        *totalToken = ownerTotalToken.get();
        
        
        DIPC_EMIT_EVENT(initEvent, "ownerTotalToken" ,tokenBalance);
    }
    
     
    EXPORT void PortfolioManage::setChangeRate(uint64_t _changeRate){
        isOwner();
        *changeRate = _changeRate;
    }
     
    EXPORT void PortfolioManage::setUserCanWithdraw(bool _canWithdraw){
        isOwner();
        *userCanWithdraw = _canWithdraw;
    }

    
    PAYABLE void PortfolioManage::createPortfolio(char* _portfolioName, char* _portfolioDesc){
        if(portfolioStorge.get()[_portfolioName] != ""){
            DIPC_EMIT_EVENT(ErrEvent, "Current portfolio exist: ", _portfolioName);
            return;
        } 
        std::string callerAddr = caller().toString();
        uint64_t tokenBalance = getTotalBalance();
        
        PortfolioInfo info(_portfolioName, _portfolioDesc, &callerAddr[0]);
        std::string portfolioStr = info.toJson();
        
        
        

        (*portfolioStorge)[_portfolioName] = portfolioStr;
        DipcAssert(totalToken.get() + tokenBalance > totalToken);
        (*portfolioBalance)[_portfolioName] = tokenBalance;
        *totalToken = totalToken.get() + tokenBalance; 
        
        DIPC_EMIT_EVENT(portfolioInfo, _portfolioName, &portfolioStr[0], "portfolioBalance", tokenBalance);
    }

    
    PAYABLE void PortfolioManage::depositPortfolio(char* _portfolioName){
        uint64_t tokenBalance = getTotalBalance();
        
        uint64_t currentBalance = portfolioBalance.get()[_portfolioName];
        uint64_t finalBalance  = currentBalance + tokenBalance;
        DipcAssert(totalToken.get() + tokenBalance > totalToken);
        DipcAssert(finalBalance > currentBalance);
        (*portfolioBalance)[_portfolioName] = finalBalance;
        *totalToken = totalToken.get() + finalBalance; 
        DIPC_EMIT_EVENT(depositPortfolio, "portfolioName", _portfolioName, "portfolioBalance", finalBalance);
    }
    
    PAYABLE void PortfolioManage::createOrder(char* _portfolioName, char* _orderId, uint16_t _orderType, char* _stockCode, uint64_t _stockPrice, uint64_t _stockAmount, uint64_t _endTime){
        uint64_t tokenBalance = getTotalBalance();
        DIPC_EMIT_EVENT(createOrder, "portfolioName", _portfolioName, "OrderInfo", "ignore", "tokenBalance", tokenBalance);
        uint64_t spent = 0;
        if(_orderType == 1){
            spent = _stockPrice * _stockAmount;
            DipcAssert((portfolioBalance.get()[_portfolioName] + tokenBalance) > spent);
        }
        struct Order order{_orderId, _orderType, _stockCode, _stockPrice, _stockAmount, _endTime, 0};
        std::string pInfo = portfolioStorge.get()[_portfolioName];
        
        
        
        if(pInfo == "") {
            DIPC_EMIT_EVENT(ErrEvent, "Current portfolio  doesn't exist: ", _portfolioName);
            return;
        }
        PortfolioInfo info;
        info.parseJson(pInfo);
        if(info.getOrder(_orderId).orderId != ""){
            DIPC_EMIT_EVENT(ErrEvent, "Current order exist: ", _orderId);
            return;
        }
        info.addOrder(order);
        pInfo = info.toJson();

        uint64_t currentBalance = portfolioBalance.get()[_portfolioName] ;
        uint64_t finalBalance = currentBalance + tokenBalance - spent;
        DipcAssert(totalToken.get() + tokenBalance > totalToken);
        
        DipcAssert(ownerTotalToken.get() < ownerTotalToken.get() + spent);
        (*portfolioStorge)[_portfolioName] = &pInfo[0];
        
        
        
        


        (*portfolioBalance)[_portfolioName] = finalBalance;
        *totalToken = totalToken.get() + finalBalance; 
        *ownerTotalToken = ownerTotalToken.get() + spent;
        DIPC_EMIT_EVENT(createOrder, "portfolioName", _portfolioName, "OrderInfo", &order.toJson()[0], "portfolioBalance", finalBalance);
    }

    
    EXPORT void PortfolioManage::dealOrder(char* _portfolioName, char* _orderId){
        isOwner();
        std::string pInfo = portfolioStorge.get()[_portfolioName];
        
        
        PortfolioInfo info;
        info.parseJson(pInfo);
        

        
         Order ord = info.getOrder(_orderId);
         
         
        if(ord.orderId != "" && ord.orderStatus == 0){
            
            uint64_t timenow = dipc::timestamp();
            if(ord.endTime > timenow){
                ord.orderStatus = 1;
            }else {
                ord.orderStatus = 3;
            }
        } else {
          

            return;
        }
        

        uint64_t sellValue = 0;
        if(ord.orderType == 0){
            sellValue = ord.stockAmount * ord.stockPrice;
        }
        uint64_t currentBalance =  portfolioBalance.get()[_portfolioName];
        

        DipcAssert(currentBalance + sellValue >= currentBalance);
        DipcAssert((ownerTotalToken.get() - sellValue) <= ownerTotalToken.get());
        


        (*portfolioBalance)[_portfolioName] = currentBalance + sellValue;
        *ownerTotalToken = ownerTotalToken.get() - sellValue;
        (*portfolioStorge)[_portfolioName] = &info.toJson()[0];
        
        
        
        

        DIPC_EMIT_EVENT(dealPortfolio, "orderId", _orderId, "orderInfo", &ord.toJson()[0]);
    }
    
    EXPORT void PortfolioManage::revocationOrder(char* _portfolioName, char* _orderId){
        std::string pInfo = portfolioStorge.get()[_portfolioName];
        
        
        PortfolioInfo info;
        info.parseJson(pInfo);
        Order ord = info.getOrder(_orderId);
        
        
        if(ord.orderId != "" && ord.orderStatus == 0){
            std::string callerStr = caller().toString();
            
            
            
            DipcAssert(info.getOwnerAddress() == caller().toString());
            

            uint64_t timenow = dipc::timestamp();
            if(ord.endTime > timenow){
                ord.orderStatus = 2;
            }else {
                ord.orderStatus = 3;
            }
        } else {
            return;
        }
        uint64_t lockToken = 0;
        if(ord.orderType == 1){
            lockToken = ord.stockPrice * ord.stockAmount;
        }
        uint64_t currentBalance =  portfolioBalance.get()[_portfolioName];
        
        
        
        

        DipcAssert(currentBalance + lockToken >= currentBalance);
        DipcAssert(ownerTotalToken.get() - lockToken <= ownerTotalToken.get());

        
        (*portfolioBalance)[_portfolioName] = currentBalance + lockToken;
        *ownerTotalToken = ownerTotalToken.get() - lockToken;
        (*portfolioStorge)[_portfolioName] = &info.toJson()[0];
        DIPC_EMIT_EVENT(revocationPortfolio, "orderId", _orderId, "orderInfo", &ord.toJson()[0]);
    }
    
    EXPORT void PortfolioManage::withdrawPortfolio(char* _portfolioName, uint64_t _withdrawBalance){
         if(!userCanWithdraw.get()){
             return;
         }
         uint64_t currentBalance =  portfolioBalance.get()[_portfolioName];
         DipcAssert(currentBalance - _withdrawBalance < currentBalance);
         auto coinBalance = changeUint64ToU256WithChangeRate(currentBalance, changeRate.get());
         (*portfolioBalance)[_portfolioName] = currentBalance - _withdrawBalance;
         callTransfer(caller(), coinBalance);
    }
    
    EXPORT void PortfolioManage::withdrawPool(uint64_t _balance){
        isOwner();
        Address ownerAddr = Address(owner.get()); 
        callTransfer(ownerAddr, _balance);
        *ownerTotalToken = ownerTotalToken.get() - _balance * changeRate.get();
        *totalToken = totalToken.get() - _balance * changeRate.get();
        DIPC_EMIT_EVENT(tokenCount, "ownerTotalToken", ownerTotalToken.get(), "totalToken", totalToken.get());
    }
    
    PAYABLE void PortfolioManage::depositPool(uint64_t _depositValue){
        isOwner();
        
        uint64_t tokenBalance = changeU256ToUint64WithChangeRate(callValue(), changeRate.get()); 
        *ownerTotalToken = ownerTotalToken.get() + tokenBalance;
        *totalToken = totalToken.get() + tokenBalance;
        DIPC_EMIT_EVENT(tokenCount, "ownerTotalToken", ownerTotalToken.get(), "totalToken", totalToken.get());
    }
     
    CONSTANT uint64_t PortfolioManage::queryTotalToken(){
        return totalToken.get();
    }

     
    CONSTANT uint64_t PortfolioManage::queryPortfolioBalance(char* _portfolioName){
        return portfolioBalance.get()[_portfolioName];
    }

    
    CONSTANT bool PortfolioManage::queryPortfolioNameIfUsed(char* _portfolioName){
        if(portfolioStorge.get()[_portfolioName] != ""){
            return true;
        } 
        return false;
    }

    
    CONSTANT uint64_t PortfolioManage::queryChangeRate(){
        return changeRate.get();
    }

2019-12-19_15:14:53.266859: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:451] log out out payable : PAYABLE void PortfolioManage::createOrder(char* _portfolioName, char* _orderId, uint16_t _orderType, char* _stockCode, uint64_t _stockPrice, uint64_t _stockAmount, uint64_t _endTime){
        

2019-12-19_15:14:53.266872: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:457] name : createOrder   pos1  0

2019-12-19_15:14:53.266881: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:469] pos2  2245   pos1  2245

2019-12-19_15:14:53.266889: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:500] pos2 after 4136   pos1  2245

2019-12-19_15:14:53.266896: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:509] finalContract  first #include "PortfolioManage.hpp"

    
    PAYABLE void PortfolioManage::init(){
        *owner = caller().toString();
        *changeRate = 10000;
        *userCanWithdraw = false;
        uint64_t tokenBalance = getTotalBalance();
        
        *ownerTotalToken = tokenBalance;
        *totalToken = ownerTotalToken.get();
        
        
        DIPC_EMIT_EVENT(initEvent, "ownerTotalToken" ,tokenBalance);
    }
    
     
    EXPORT void PortfolioManage::setChangeRate(uint64_t _changeRate){
        isOwner();
        *changeRate = _changeRate;
    }
     
    EXPORT void PortfolioManage::setUserCanWithdraw(bool _canWithdraw){
        isOwner();
        *userCanWithdraw = _canWithdraw;
    }

    
    PAYABLE void PortfolioManage::createPortfolio(char* _portfolioName, char* _portfolioDesc){
        if(portfolioStorge.get()[_portfolioName] != ""){
            DIPC_EMIT_EVENT(ErrEvent, "Current portfolio exist: ", _portfolioName);
            return;
        } 
        std::string callerAddr = caller().toString();
        uint64_t tokenBalance = getTotalBalance();
        
        PortfolioInfo info(_portfolioName, _portfolioDesc, &callerAddr[0]);
        std::string portfolioStr = info.toJson();
        
        
        

        (*portfolioStorge)[_portfolioName] = portfolioStr;
        DipcAssert(totalToken.get() + tokenBalance > totalToken);
        (*portfolioBalance)[_portfolioName] = tokenBalance;
        *totalToken = totalToken.get() + tokenBalance; 
        
        DIPC_EMIT_EVENT(portfolioInfo, _portfolioName, &portfolioStr[0], "portfolioBalance", tokenBalance);
    }

    
    PAYABLE void PortfolioManage::depositPortfolio(char* _portfolioName){
        uint64_t tokenBalance = getTotalBalance();
        
        uint64_t currentBalance = portfolioBalance.get()[_portfolioName];
        uint64_t finalBalance  = currentBalance + tokenBalance;
        DipcAssert(totalToken.get() + tokenBalance > totalToken);
        DipcAssert(finalBalance > currentBalance);
        (*portfolioBalance)[_portfolioName] = finalBalance;
        *totalToken = totalToken.get() + finalBalance; 
        DIPC_EMIT_EVENT(depositPortfolio, "portfolioName", _portfolioName, "portfolioBalance", finalBalance);
    }
    
    

2019-12-19_15:14:53.266903: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:510] codetext  first #include "PortfolioManage.hpp"

    
    PAYABLE void PortfolioManage::init(){
        *owner = caller().toString();
        *changeRate = 10000;
        *userCanWithdraw = false;
        uint64_t tokenBalance = getTotalBalance();
        
        *ownerTotalToken = tokenBalance;
        *totalToken = ownerTotalToken.get();
        
        
        DIPC_EMIT_EVENT(initEvent, "ownerTotalToken" ,tokenBalance);
    }
    
     
    EXPORT void PortfolioManage::setChangeRate(uint64_t _changeRate){
        isOwner();
        *changeRate = _changeRate;
    }
     
    EXPORT void PortfolioManage::setUserCanWithdraw(bool _canWithdraw){
        isOwner();
        *userCanWithdraw = _canWithdraw;
    }

    
    PAYABLE void PortfolioManage::createPortfolio(char* _portfolioName, char* _portfolioDesc){
        if(portfolioStorge.get()[_portfolioName] != ""){
            DIPC_EMIT_EVENT(ErrEvent, "Current portfolio exist: ", _portfolioName);
            return;
        } 
        std::string callerAddr = caller().toString();
        uint64_t tokenBalance = getTotalBalance();
        
        PortfolioInfo info(_portfolioName, _portfolioDesc, &callerAddr[0]);
        std::string portfolioStr = info.toJson();
        
        
        

        (*portfolioStorge)[_portfolioName] = portfolioStr;
        DipcAssert(totalToken.get() + tokenBalance > totalToken);
        (*portfolioBalance)[_portfolioName] = tokenBalance;
        *totalToken = totalToken.get() + tokenBalance; 
        
        DIPC_EMIT_EVENT(portfolioInfo, _portfolioName, &portfolioStr[0], "portfolioBalance", tokenBalance);
    }

    
    PAYABLE void PortfolioManage::depositPortfolio(char* _portfolioName){
        uint64_t tokenBalance = getTotalBalance();
        
        uint64_t currentBalance = portfolioBalance.get()[_portfolioName];
        uint64_t finalBalance  = currentBalance + tokenBalance;
        DipcAssert(totalToken.get() + tokenBalance > totalToken);
        DipcAssert(finalBalance > currentBalance);
        (*portfolioBalance)[_portfolioName] = finalBalance;
        *totalToken = totalToken.get() + finalBalance; 
        DIPC_EMIT_EVENT(depositPortfolio, "portfolioName", _portfolioName, "portfolioBalance", finalBalance);
    }
    
    PAYABLE void PortfolioManage::createOrder(char* _portfolioName, char* _orderId, uint16_t _orderType, char* _stockCode, uint64_t _stockPrice, uint64_t _stockAmount, uint64_t _endTime){
        uint64_t tokenBalance = getTotalBalance();
        DIPC_EMIT_EVENT(createOrder, "portfolioName", _portfolioName, "OrderInfo", "ignore", "tokenBalance", tokenBalance);
        uint64_t spent = 0;
        if(_orderType == 1){
            spent = _stockPrice * _stockAmount;
            DipcAssert((portfolioBalance.get()[_portfolioName] + tokenBalance) > spent);
        }
        struct Order order{_orderId, _orderType, _stockCode, _stockPrice, _stockAmount, _endTime, 0};
        std::string pInfo = portfolioStorge.get()[_portfolioName];
        
        
        
        if(pInfo == "") {
            DIPC_EMIT_EVENT(ErrEvent, "Current portfolio  doesn't exist: ", _portfolioName);
            return;
        }
        PortfolioInfo info;
        info.parseJson(pInfo);
        if(info.getOrder(_orderId).orderId != ""){
            DIPC_EMIT_EVENT(ErrEvent, "Current order exist: ", _orderId);
            return;
        }
        info.addOrder(order);
        pInfo = info.toJson();

        uint64_t currentBalance = portfolioBalance.get()[_portfolioName] ;
        uint64_t finalBalance = currentBalance + tokenBalance - spent;
        DipcAssert(totalToken.get() + tokenBalance > totalToken);
        
        DipcAssert(ownerTotalToken.get() < ownerTotalToken.get() + spent);
        (*portfolioStorge)[_portfolioName] = &pInfo[0];
        
        
        
        


        (*portfolioBalance)[_portfolioName] = finalBalance;
        *totalToken = totalToken.get() + finalBalance; 
        *ownerTotalToken = ownerTotalToken.get() + spent;
        DIPC_EMIT_EVENT(createOrder, "portfolioName", _portfolioName, "OrderInfo", &order.toJson()[0], "portfolioBalance", finalBalance);
    }

    
    EXPORT void PortfolioManage::dealOrder(char* _portfolioName, char* _orderId){
        isOwner();
        std::string pInfo = portfolioStorge.get()[_portfolioName];
        
        
        PortfolioInfo info;
        info.parseJson(pInfo);
        

        
         Order ord = info.getOrder(_orderId);
         
         
        if(ord.orderId != "" && ord.orderStatus == 0){
            
            uint64_t timenow = dipc::timestamp();
            if(ord.endTime > timenow){
                ord.orderStatus = 1;
            }else {
                ord.orderStatus = 3;
            }
        } else {
          

            return;
        }
        

        uint64_t sellValue = 0;
        if(ord.orderType == 0){
            sellValue = ord.stockAmount * ord.stockPrice;
        }
        uint64_t currentBalance =  portfolioBalance.get()[_portfolioName];
        

        DipcAssert(currentBalance + sellValue >= currentBalance);
        DipcAssert((ownerTotalToken.get() - sellValue) <= ownerTotalToken.get());
        


        (*portfolioBalance)[_portfolioName] = currentBalance + sellValue;
        *ownerTotalToken = ownerTotalToken.get() - sellValue;
        (*portfolioStorge)[_portfolioName] = &info.toJson()[0];
        
        
        
        

        DIPC_EMIT_EVENT(dealPortfolio, "orderId", _orderId, "orderInfo", &ord.toJson()[0]);
    }
    
    EXPORT void PortfolioManage::revocationOrder(char* _portfolioName, char* _orderId){
        std::string pInfo = portfolioStorge.get()[_portfolioName];
        
        
        PortfolioInfo info;
        info.parseJson(pInfo);
        Order ord = info.getOrder(_orderId);
        
        
        if(ord.orderId != "" && ord.orderStatus == 0){
            std::string callerStr = caller().toString();
            
            
            
            DipcAssert(info.getOwnerAddress() == caller().toString());
            

            uint64_t timenow = dipc::timestamp();
            if(ord.endTime > timenow){
                ord.orderStatus = 2;
            }else {
                ord.orderStatus = 3;
            }
        } else {
            return;
        }
        uint64_t lockToken = 0;
        if(ord.orderType == 1){
            lockToken = ord.stockPrice * ord.stockAmount;
        }
        uint64_t currentBalance =  portfolioBalance.get()[_portfolioName];
        
        
        
        

        DipcAssert(currentBalance + lockToken >= currentBalance);
        DipcAssert(ownerTotalToken.get() - lockToken <= ownerTotalToken.get());

        
        (*portfolioBalance)[_portfolioName] = currentBalance + lockToken;
        *ownerTotalToken = ownerTotalToken.get() - lockToken;
        (*portfolioStorge)[_portfolioName] = &info.toJson()[0];
        DIPC_EMIT_EVENT(revocationPortfolio, "orderId", _orderId, "orderInfo", &ord.toJson()[0]);
    }
    
    EXPORT void PortfolioManage::withdrawPortfolio(char* _portfolioName, uint64_t _withdrawBalance){
         if(!userCanWithdraw.get()){
             return;
         }
         uint64_t currentBalance =  portfolioBalance.get()[_portfolioName];
         DipcAssert(currentBalance - _withdrawBalance < currentBalance);
         auto coinBalance = changeUint64ToU256WithChangeRate(currentBalance, changeRate.get());
         (*portfolioBalance)[_portfolioName] = currentBalance - _withdrawBalance;
         callTransfer(caller(), coinBalance);
    }
    
    EXPORT void PortfolioManage::withdrawPool(uint64_t _balance){
        isOwner();
        Address ownerAddr = Address(owner.get()); 
        callTransfer(ownerAddr, _balance);
        *ownerTotalToken = ownerTotalToken.get() - _balance * changeRate.get();
        *totalToken = totalToken.get() - _balance * changeRate.get();
        DIPC_EMIT_EVENT(tokenCount, "ownerTotalToken", ownerTotalToken.get(), "totalToken", totalToken.get());
    }
    
    PAYABLE void PortfolioManage::depositPool(uint64_t _depositValue){
        isOwner();
        
        uint64_t tokenBalance = changeU256ToUint64WithChangeRate(callValue(), changeRate.get()); 
        *ownerTotalToken = ownerTotalToken.get() + tokenBalance;
        *totalToken = totalToken.get() + tokenBalance;
        DIPC_EMIT_EVENT(tokenCount, "ownerTotalToken", ownerTotalToken.get(), "totalToken", totalToken.get());
    }
     
    CONSTANT uint64_t PortfolioManage::queryTotalToken(){
        return totalToken.get();
    }

     
    CONSTANT uint64_t PortfolioManage::queryPortfolioBalance(char* _portfolioName){
        return portfolioBalance.get()[_portfolioName];
    }

    
    CONSTANT bool PortfolioManage::queryPortfolioNameIfUsed(char* _portfolioName){
        if(portfolioStorge.get()[_portfolioName] != ""){
            return true;
        } 
        return false;
    }

    
    CONSTANT uint64_t PortfolioManage::queryChangeRate(){
        return changeRate.get();
    }

2019-12-19_15:14:53.266911: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:513] s  first PAYABLE void PortfolioManage::createOrder(char* _portfolioName, char* _orderId, uint16_t _orderType, char* _stockCode, uint64_t _stockPrice, uint64_t _stockAmount, uint64_t _endTime){
        uint64_t tokenBalance = getTotalBalance();
        DIPC_EMIT_EVENT(createOrder, "portfolioName", _portfolioName, "OrderInfo", "ignore", "tokenBalance", tokenBalance);
        uint64_t spent = 0;
        if(_orderType == 1){
            spent = _stockPrice * _stockAmount;
            DipcAssert((portfolioBalance.get()[_portfolioName] + tokenBalance) > spent);
        }
        struct Order order{_orderId, _orderType, _stockCode, _stockPrice, _stockAmount, _endTime, 0};
        std::string pInfo = portfolioStorge.get()[_portfolioName];
        
        
        
        if(pInfo == "") {
            DIPC_EMIT_EVENT(ErrEvent, "Current portfolio  doesn't exist: ", _portfolioName);
            return;
        }
        PortfolioInfo info;
        info.parseJson(pInfo);
        if(info.getOrder(_orderId).orderId != ""){
            DIPC_EMIT_EVENT(ErrEvent, "Current order exist: ", _orderId);
            return;
        }
        info.addOrder(order);
        pInfo = info.toJson();

        uint64_t currentBalance = portfolioBalance.get()[_portfolioName] ;
        uint64_t finalBalance = currentBalance + tokenBalance - spent;
        DipcAssert(totalToken.get() + tokenBalance > totalToken);
        
        DipcAssert(ownerTotalToken.get() < ownerTotalToken.get() + spent);
        (*portfolioStorge)[_portfolioName] = &pInfo[0];
        
        
        
        


        (*portfolioBalance)[_portfolioName] = finalBalance;
        *totalToken = totalToken.get() + finalBalance; 
        *ownerTotalToken = ownerTotalToken.get() + spent;
        DIPC_EMIT_EVENT(createOrder, "portfolioName", _portfolioName, "OrderInfo", &order.toJson()[0], "portfolioBalance", finalBalance);
    }

2019-12-19_15:14:53.286064: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:599] search func : PAYABLE void PortfolioManage::createOrder(char* _portfolioName, char* _orderId, uint16_t _orderType, char* _stockCode, uint64_t _stockPrice, uint64_t _stockAmount, uint64_t _endTime){
        uint64_t tokenBalance = getTotalBalance();
        DIPC_EMIT_EVENT(createOrder, "portfolioName", _portfolioName, "OrderInfo", "ignore", "tokenBalance", tokenBalance);
        uint64_t spent = 0;
        if(_orderType == 1){
            spent = _stockPrice * _stockAmount;
            DipcAssert((portfolioBalance.get()[_portfolioName] + tokenBalance) > spent);
        }
        struct Order order{_orderId, _orderType, _stockCode, _stockPrice, _stockAmount, _endTime, 0};
        std::string pInfo = portfolioStorge.get()[_portfolioName];
        
        
        
        if(pInfo == "") {
            DIPC_EMIT_EVENT(ErrEvent, "Current portfolio  doesn't exist: ", _portfolioName);
            return;
        }
        PortfolioInfo info;
        info.parseJson(pInfo);
        if(info.getOrder(_orderId).orderId != ""){
            DIPC_EMIT_EVENT(ErrEvent, "Current order exist: ", _orderId);
            return;
        }
        info.addOrder(order);
        pInfo = info.toJson();

        uint64_t currentBalance = portfolioBalance.get()[_portfolioName] ;
        uint64_t finalBalance = currentBalance + tokenBalance - spent;
        DipcAssert(totalToken.get() + tokenBalance > totalToken);
        
        DipcAssert(ownerTotalToken.get() < ownerTotalToken.get() + spent);
        (*portfolioStorge)[_portfolioName] = &pInfo[0];
        
        
        
        


        (*portfolioBalance)[_portfolioName] = finalBalance;
        *totalToken = totalToken.get() + finalBalance; 
        *ownerTotalToken = ownerTotalToken.get() + spent;
        DIPC_EMIT_EVENT(createOrder, "portfolioName", _portfolioName, "OrderInfo", &order.toJson()[0], "portfolioBalance", finalBalance);
    }
2019-12-19_15:14:53.286084: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:424] finalContract  this height  #include "PortfolioManage.hpp"

    
    PAYABLE void PortfolioManage::init(){
        *owner = caller().toString();
        *changeRate = 10000;
        *userCanWithdraw = false;
        uint64_t tokenBalance = getTotalBalance();
        
        *ownerTotalToken = tokenBalance;
        *totalToken = ownerTotalToken.get();
        
        
        DIPC_EMIT_EVENT(initEvent, "ownerTotalToken" ,tokenBalance);
    }
    
     
    EXPORT void PortfolioManage::setChangeRate(uint64_t _changeRate){
        isOwner();
        *changeRate = _changeRate;
    }
     
    EXPORT void PortfolioManage::setUserCanWithdraw(bool _canWithdraw){
        isOwner();
        *userCanWithdraw = _canWithdraw;
    }

    
    PAYABLE void PortfolioManage::createPortfolio(char* _portfolioName, char* _portfolioDesc){
        if(portfolioStorge.get()[_portfolioName] != ""){
            DIPC_EMIT_EVENT(ErrEvent, "Current portfolio exist: ", _portfolioName);
            return;
        } 
        std::string callerAddr = caller().toString();
        uint64_t tokenBalance = getTotalBalance();
        
        PortfolioInfo info(_portfolioName, _portfolioDesc, &callerAddr[0]);
        std::string portfolioStr = info.toJson();
        
        
        

        (*portfolioStorge)[_portfolioName] = portfolioStr;
        DipcAssert(totalToken.get() + tokenBalance > totalToken);
        (*portfolioBalance)[_portfolioName] = tokenBalance;
        *totalToken = totalToken.get() + tokenBalance; 
        
        DIPC_EMIT_EVENT(portfolioInfo, _portfolioName, &portfolioStr[0], "portfolioBalance", tokenBalance);
    }

    
    PAYABLE void PortfolioManage::depositPortfolio(char* _portfolioName){
        uint64_t tokenBalance = getTotalBalance();
        
        uint64_t currentBalance = portfolioBalance.get()[_portfolioName];
        uint64_t finalBalance  = currentBalance + tokenBalance;
        DipcAssert(totalToken.get() + tokenBalance > totalToken);
        DipcAssert(finalBalance > currentBalance);
        (*portfolioBalance)[_portfolioName] = finalBalance;
        *totalToken = totalToken.get() + finalBalance; 
        DIPC_EMIT_EVENT(depositPortfolio, "portfolioName", _portfolioName, "portfolioBalance", finalBalance);
    }
    
    PAYABLE void PortfolioManage::createOrder(char* _portfolioName, char* _orderId, uint16_t _orderType, char* _stockCode, uint64_t _stockPrice, uint64_t _stockAmount, uint64_t _endTime){
        uint64_t tokenBalance = getTotalBalance();
        DIPC_EMIT_EVENT(createOrder, "portfolioName", _portfolioName, "OrderInfo", "ignore", "tokenBalance", tokenBalance);
        uint64_t spent = 0;
        if(_orderType == 1){
            spent = _stockPrice * _stockAmount;
            DipcAssert((portfolioBalance.get()[_portfolioName] + tokenBalance) > spent);
        }
        struct Order order{_orderId, _orderType, _stockCode, _stockPrice, _stockAmount, _endTime, 0};
        std::string pInfo = portfolioStorge.get()[_portfolioName];
        
        
        
        if(pInfo == "") {
            DIPC_EMIT_EVENT(ErrEvent, "Current portfolio  doesn't exist: ", _portfolioName);
            return;
        }
        PortfolioInfo info;
        info.parseJson(pInfo);
        if(info.getOrder(_orderId).orderId != ""){
            DIPC_EMIT_EVENT(ErrEvent, "Current order exist: ", _orderId);
            return;
        }
        info.addOrder(order);
        pInfo = info.toJson();

        uint64_t currentBalance = portfolioBalance.get()[_portfolioName] ;
        uint64_t finalBalance = currentBalance + tokenBalance - spent;
        DipcAssert(totalToken.get() + tokenBalance > totalToken);
        
        DipcAssert(ownerTotalToken.get() < ownerTotalToken.get() + spent);
        (*portfolioStorge)[_portfolioName] = &pInfo[0];
        
        
        
        


        (*portfolioBalance)[_portfolioName] = finalBalance;
        *totalToken = totalToken.get() + finalBalance; 
        *ownerTotalToken = ownerTotalToken.get() + spent;
        DIPC_EMIT_EVENT(createOrder, "portfolioName", _portfolioName, "OrderInfo", &order.toJson()[0], "portfolioBalance", finalBalance);
    } codetext height #include "PortfolioManage.hpp"

    
    PAYABLE void PortfolioManage::init(){
        *owner = caller().toString();
        *changeRate = 10000;
        *userCanWithdraw = false;
        uint64_t tokenBalance = getTotalBalance();
        
        *ownerTotalToken = tokenBalance;
        *totalToken = ownerTotalToken.get();
        
        
        DIPC_EMIT_EVENT(initEvent, "ownerTotalToken" ,tokenBalance);
    }
    
     
    EXPORT void PortfolioManage::setChangeRate(uint64_t _changeRate){
        isOwner();
        *changeRate = _changeRate;
    }
     
    EXPORT void PortfolioManage::setUserCanWithdraw(bool _canWithdraw){
        isOwner();
        *userCanWithdraw = _canWithdraw;
    }

    
    PAYABLE void PortfolioManage::createPortfolio(char* _portfolioName, char* _portfolioDesc){
        if(portfolioStorge.get()[_portfolioName] != ""){
            DIPC_EMIT_EVENT(ErrEvent, "Current portfolio exist: ", _portfolioName);
            return;
        } 
        std::string callerAddr = caller().toString();
        uint64_t tokenBalance = getTotalBalance();
        
        PortfolioInfo info(_portfolioName, _portfolioDesc, &callerAddr[0]);
        std::string portfolioStr = info.toJson();
        
        
        

        (*portfolioStorge)[_portfolioName] = portfolioStr;
        DipcAssert(totalToken.get() + tokenBalance > totalToken);
        (*portfolioBalance)[_portfolioName] = tokenBalance;
        *totalToken = totalToken.get() + tokenBalance; 
        
        DIPC_EMIT_EVENT(portfolioInfo, _portfolioName, &portfolioStr[0], "portfolioBalance", tokenBalance);
    }

    
    PAYABLE void PortfolioManage::depositPortfolio(char* _portfolioName){
        uint64_t tokenBalance = getTotalBalance();
        
        uint64_t currentBalance = portfolioBalance.get()[_portfolioName];
        uint64_t finalBalance  = currentBalance + tokenBalance;
        DipcAssert(totalToken.get() + tokenBalance > totalToken);
        DipcAssert(finalBalance > currentBalance);
        (*portfolioBalance)[_portfolioName] = finalBalance;
        *totalToken = totalToken.get() + finalBalance; 
        DIPC_EMIT_EVENT(depositPortfolio, "portfolioName", _portfolioName, "portfolioBalance", finalBalance);
    }
    
    PAYABLE void PortfolioManage::createOrder(char* _portfolioName, char* _orderId, uint16_t _orderType, char* _stockCode, uint64_t _stockPrice, uint64_t _stockAmount, uint64_t _endTime){
        uint64_t tokenBalance = getTotalBalance();
        DIPC_EMIT_EVENT(createOrder, "portfolioName", _portfolioName, "OrderInfo", "ignore", "tokenBalance", tokenBalance);
        uint64_t spent = 0;
        if(_orderType == 1){
            spent = _stockPrice * _stockAmount;
            DipcAssert((portfolioBalance.get()[_portfolioName] + tokenBalance) > spent);
        }
        struct Order order{_orderId, _orderType, _stockCode, _stockPrice, _stockAmount, _endTime, 0};
        std::string pInfo = portfolioStorge.get()[_portfolioName];
        
        
        
        if(pInfo == "") {
            DIPC_EMIT_EVENT(ErrEvent, "Current portfolio  doesn't exist: ", _portfolioName);
            return;
        }
        PortfolioInfo info;
        info.parseJson(pInfo);
        if(info.getOrder(_orderId).orderId != ""){
            DIPC_EMIT_EVENT(ErrEvent, "Current order exist: ", _orderId);
            return;
        }
        info.addOrder(order);
        pInfo = info.toJson();

        uint64_t currentBalance = portfolioBalance.get()[_portfolioName] ;
        uint64_t finalBalance = currentBalance + tokenBalance - spent;
        DipcAssert(totalToken.get() + tokenBalance > totalToken);
        
        DipcAssert(ownerTotalToken.get() < ownerTotalToken.get() + spent);
        (*portfolioStorge)[_portfolioName] = &pInfo[0];
        
        
        
        


        (*portfolioBalance)[_portfolioName] = finalBalance;
        *totalToken = totalToken.get() + finalBalance; 
        *ownerTotalToken = ownerTotalToken.get() + spent;
        DIPC_EMIT_EVENT(createOrder, "portfolioName", _portfolioName, "OrderInfo", &order.toJson()[0], "portfolioBalance", finalBalance);
    }

    
    EXPORT void PortfolioManage::dealOrder(char* _portfolioName, char* _orderId){
        isOwner();
        std::string pInfo = portfolioStorge.get()[_portfolioName];
        
        
        PortfolioInfo info;
        info.parseJson(pInfo);
        

        
         Order ord = info.getOrder(_orderId);
         
         
        if(ord.orderId != "" && ord.orderStatus == 0){
            
            uint64_t timenow = dipc::timestamp();
            if(ord.endTime > timenow){
                ord.orderStatus = 1;
            }else {
                ord.orderStatus = 3;
            }
        } else {
          

            return;
        }
        

        uint64_t sellValue = 0;
        if(ord.orderType == 0){
            sellValue = ord.stockAmount * ord.stockPrice;
        }
        uint64_t currentBalance =  portfolioBalance.get()[_portfolioName];
        

        DipcAssert(currentBalance + sellValue >= currentBalance);
        DipcAssert((ownerTotalToken.get() - sellValue) <= ownerTotalToken.get());
        


        (*portfolioBalance)[_portfolioName] = currentBalance + sellValue;
        *ownerTotalToken = ownerTotalToken.get() - sellValue;
        (*portfolioStorge)[_portfolioName] = &info.toJson()[0];
        
        
        
        

        DIPC_EMIT_EVENT(dealPortfolio, "orderId", _orderId, "orderInfo", &ord.toJson()[0]);
    }
    
    EXPORT void PortfolioManage::revocationOrder(char* _portfolioName, char* _orderId){
        std::string pInfo = portfolioStorge.get()[_portfolioName];
        
        
        PortfolioInfo info;
        info.parseJson(pInfo);
        Order ord = info.getOrder(_orderId);
        
        
        if(ord.orderId != "" && ord.orderStatus == 0){
            std::string callerStr = caller().toString();
            
            
            
            DipcAssert(info.getOwnerAddress() == caller().toString());
            

            uint64_t timenow = dipc::timestamp();
            if(ord.endTime > timenow){
                ord.orderStatus = 2;
            }else {
                ord.orderStatus = 3;
            }
        } else {
            return;
        }
        uint64_t lockToken = 0;
        if(ord.orderType == 1){
            lockToken = ord.stockPrice * ord.stockAmount;
        }
        uint64_t currentBalance =  portfolioBalance.get()[_portfolioName];
        
        
        
        

        DipcAssert(currentBalance + lockToken >= currentBalance);
        DipcAssert(ownerTotalToken.get() - lockToken <= ownerTotalToken.get());

        
        (*portfolioBalance)[_portfolioName] = currentBalance + lockToken;
        *ownerTotalToken = ownerTotalToken.get() - lockToken;
        (*portfolioStorge)[_portfolioName] = &info.toJson()[0];
        DIPC_EMIT_EVENT(revocationPortfolio, "orderId", _orderId, "orderInfo", &ord.toJson()[0]);
    }
    
    EXPORT void PortfolioManage::withdrawPortfolio(char* _portfolioName, uint64_t _withdrawBalance){
         if(!userCanWithdraw.get()){
             return;
         }
         uint64_t currentBalance =  portfolioBalance.get()[_portfolioName];
         DipcAssert(currentBalance - _withdrawBalance < currentBalance);
         auto coinBalance = changeUint64ToU256WithChangeRate(currentBalance, changeRate.get());
         (*portfolioBalance)[_portfolioName] = currentBalance - _withdrawBalance;
         callTransfer(caller(), coinBalance);
    }
    
    EXPORT void PortfolioManage::withdrawPool(uint64_t _balance){
        isOwner();
        Address ownerAddr = Address(owner.get()); 
        callTransfer(ownerAddr, _balance);
        *ownerTotalToken = ownerTotalToken.get() - _balance * changeRate.get();
        *totalToken = totalToken.get() - _balance * changeRate.get();
        DIPC_EMIT_EVENT(tokenCount, "ownerTotalToken", ownerTotalToken.get(), "totalToken", totalToken.get());
    }
    
    PAYABLE void PortfolioManage::depositPool(uint64_t _depositValue){
        isOwner();
        
        uint64_t tokenBalance = changeU256ToUint64WithChangeRate(callValue(), changeRate.get()); 
        *ownerTotalToken = ownerTotalToken.get() + tokenBalance;
        *totalToken = totalToken.get() + tokenBalance;
        DIPC_EMIT_EVENT(tokenCount, "ownerTotalToken", ownerTotalToken.get(), "totalToken", totalToken.get());
    }
     
    CONSTANT uint64_t PortfolioManage::queryTotalToken(){
        return totalToken.get();
    }

     
    CONSTANT uint64_t PortfolioManage::queryPortfolioBalance(char* _portfolioName){
        return portfolioBalance.get()[_portfolioName];
    }

    
    CONSTANT bool PortfolioManage::queryPortfolioNameIfUsed(char* _portfolioName){
        if(portfolioStorge.get()[_portfolioName] != ""){
            return true;
        } 
        return false;
    }

    
    CONSTANT uint64_t PortfolioManage::queryChangeRate(){
        return changeRate.get();
    }

2019-12-19_15:14:53.286097: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:427] searchContext  

    
    EXPORT void PortfolioManage::dealOrder(char* _portfolioName, char* _orderId){
        isOwner();
        std::string pInfo = portfolioStorge.get()[_portfolioName];
        
        
        PortfolioInfo info;
        info.parseJson(pInfo);
        

        
         Order ord = info.getOrder(_orderId);
         
         
        if(ord.orderId != "" && ord.orderStatus == 0){
            
            uint64_t timenow = dipc::timestamp();
            if(ord.endTime > timenow){
                ord.orderStatus = 1;
            }else {
                ord.orderStatus = 3;
            }
        } else {
          

            return;
        }
        

        uint64_t sellValue = 0;
        if(ord.orderType == 0){
            sellValue = ord.stockAmount * ord.stockPrice;
        }
        uint64_t currentBalance =  portfolioBalance.get()[_portfolioName];
        

        DipcAssert(currentBalance + sellValue >= currentBalance);
        DipcAssert((ownerTotalToken.get() - sellValue) <= ownerTotalToken.get());
        


        (*portfolioBalance)[_portfolioName] = currentBalance + sellValue;
        *ownerTotalToken = ownerTotalToken.get() - sellValue;
        (*portfolioStorge)[_portfolioName] = &info.toJson()[0];
        
        
        
        

        DIPC_EMIT_EVENT(dealPortfolio, "orderId", _orderId, "orderInfo", &ord.toJson()[0]);
    }
    
    EXPORT void PortfolioManage::revocationOrder(char* _portfolioName, char* _orderId){
        std::string pInfo = portfolioStorge.get()[_portfolioName];
        
        
        PortfolioInfo info;
        info.parseJson(pInfo);
        Order ord = info.getOrder(_orderId);
        
        
        if(ord.orderId != "" && ord.orderStatus == 0){
            std::string callerStr = caller().toString();
            
            
            
            DipcAssert(info.getOwnerAddress() == caller().toString());
            

            uint64_t timenow = dipc::timestamp();
            if(ord.endTime > timenow){
                ord.orderStatus = 2;
            }else {
                ord.orderStatus = 3;
            }
        } else {
            return;
        }
        uint64_t lockToken = 0;
        if(ord.orderType == 1){
            lockToken = ord.stockPrice * ord.stockAmount;
        }
        uint64_t currentBalance =  portfolioBalance.get()[_portfolioName];
        
        
        
        

        DipcAssert(currentBalance + lockToken >= currentBalance);
        DipcAssert(ownerTotalToken.get() - lockToken <= ownerTotalToken.get());

        
        (*portfolioBalance)[_portfolioName] = currentBalance + lockToken;
        *ownerTotalToken = ownerTotalToken.get() - lockToken;
        (*portfolioStorge)[_portfolioName] = &info.toJson()[0];
        DIPC_EMIT_EVENT(revocationPortfolio, "orderId", _orderId, "orderInfo", &ord.toJson()[0]);
    }
    
    EXPORT void PortfolioManage::withdrawPortfolio(char* _portfolioName, uint64_t _withdrawBalance){
         if(!userCanWithdraw.get()){
             return;
         }
         uint64_t currentBalance =  portfolioBalance.get()[_portfolioName];
         DipcAssert(currentBalance - _withdrawBalance < currentBalance);
         auto coinBalance = changeUint64ToU256WithChangeRate(currentBalance, changeRate.get());
         (*portfolioBalance)[_portfolioName] = currentBalance - _withdrawBalance;
         callTransfer(caller(), coinBalance);
    }
    
    EXPORT void PortfolioManage::withdrawPool(uint64_t _balance){
        isOwner();
        Address ownerAddr = Address(owner.get()); 
        callTransfer(ownerAddr, _balance);
        *ownerTotalToken = ownerTotalToken.get() - _balance * changeRate.get();
        *totalToken = totalToken.get() - _balance * changeRate.get();
        DIPC_EMIT_EVENT(tokenCount, "ownerTotalToken", ownerTotalToken.get(), "totalToken", totalToken.get());
    }
    
    PAYABLE void PortfolioManage::depositPool(uint64_t _depositValue){
        isOwner();
        
        uint64_t tokenBalance = changeU256ToUint64WithChangeRate(callValue(), changeRate.get()); 
        *ownerTotalToken = ownerTotalToken.get() + tokenBalance;
        *totalToken = totalToken.get() + tokenBalance;
        DIPC_EMIT_EVENT(tokenCount, "ownerTotalToken", ownerTotalToken.get(), "totalToken", totalToken.get());
    }
     
    CONSTANT uint64_t PortfolioManage::queryTotalToken(){
        return totalToken.get();
    }

     
    CONSTANT uint64_t PortfolioManage::queryPortfolioBalance(char* _portfolioName){
        return portfolioBalance.get()[_portfolioName];
    }

    
    CONSTANT bool PortfolioManage::queryPortfolioNameIfUsed(char* _portfolioName){
        if(portfolioStorge.get()[_portfolioName] != ""){
            return true;
        } 
        return false;
    }

    
    CONSTANT uint64_t PortfolioManage::queryChangeRate(){
        return changeRate.get();
    }

2019-12-19_15:14:53.287871: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:442] finalContract  this new  #include "PortfolioManage.hpp"

    
    PAYABLE void PortfolioManage::init(){
        *owner = caller().toString();
        *changeRate = 10000;
        *userCanWithdraw = false;
        uint64_t tokenBalance = getTotalBalance();
        
        *ownerTotalToken = tokenBalance;
        *totalToken = ownerTotalToken.get();
        
        
        DIPC_EMIT_EVENT(initEvent, "ownerTotalToken" ,tokenBalance);
    }
    
     
    EXPORT void PortfolioManage::setChangeRate(uint64_t _changeRate){
        isOwner();
        *changeRate = _changeRate;
    }
     
    EXPORT void PortfolioManage::setUserCanWithdraw(bool _canWithdraw){
        isOwner();
        *userCanWithdraw = _canWithdraw;
    }

    
    PAYABLE void PortfolioManage::createPortfolio(char* _portfolioName, char* _portfolioDesc){
        if(portfolioStorge.get()[_portfolioName] != ""){
            DIPC_EMIT_EVENT(ErrEvent, "Current portfolio exist: ", _portfolioName);
            return;
        } 
        std::string callerAddr = caller().toString();
        uint64_t tokenBalance = getTotalBalance();
        
        PortfolioInfo info(_portfolioName, _portfolioDesc, &callerAddr[0]);
        std::string portfolioStr = info.toJson();
        
        
        

        (*portfolioStorge)[_portfolioName] = portfolioStr;
        DipcAssert(totalToken.get() + tokenBalance > totalToken);
        (*portfolioBalance)[_portfolioName] = tokenBalance;
        *totalToken = totalToken.get() + tokenBalance; 
        
        DIPC_EMIT_EVENT(portfolioInfo, _portfolioName, &portfolioStr[0], "portfolioBalance", tokenBalance);
    }

    
    PAYABLE void PortfolioManage::depositPortfolio(char* _portfolioName){
        uint64_t tokenBalance = getTotalBalance();
        
        uint64_t currentBalance = portfolioBalance.get()[_portfolioName];
        uint64_t finalBalance  = currentBalance + tokenBalance;
        DipcAssert(totalToken.get() + tokenBalance > totalToken);
        DipcAssert(finalBalance > currentBalance);
        (*portfolioBalance)[_portfolioName] = finalBalance;
        *totalToken = totalToken.get() + finalBalance; 
        DIPC_EMIT_EVENT(depositPortfolio, "portfolioName", _portfolioName, "portfolioBalance", finalBalance);
    }
    
    PAYABLE void PortfolioManage::createOrder(char* _portfolioName, char* _orderId, uint16_t _orderType, char* _stockCode, uint64_t _stockPrice, uint64_t _stockAmount, uint64_t _endTime){
        uint64_t tokenBalance = getTotalBalance();
        DIPC_EMIT_EVENT(createOrder, "portfolioName", _portfolioName, "OrderInfo", "ignore", "tokenBalance", tokenBalance);
        uint64_t spent = 0;
        if(_orderType == 1){
            spent = _stockPrice * _stockAmount;
            DipcAssert((portfolioBalance.get()[_portfolioName] + tokenBalance) > spent);
        }
        struct Order order{_orderId, _orderType, _stockCode, _stockPrice, _stockAmount, _endTime, 0};
        std::string pInfo = portfolioStorge.get()[_portfolioName];
        
        
        
        if(pInfo == "") {
            DIPC_EMIT_EVENT(ErrEvent, "Current portfolio  doesn't exist: ", _portfolioName);
            return;
        }
        PortfolioInfo info;
        info.parseJson(pInfo);
        if(info.getOrder(_orderId).orderId != ""){
            DIPC_EMIT_EVENT(ErrEvent, "Current order exist: ", _orderId);
            return;
        }
        info.addOrder(order);
        pInfo = info.toJson();

        uint64_t currentBalance = portfolioBalance.get()[_portfolioName] ;
        uint64_t finalBalance = currentBalance + tokenBalance - spent;
        DipcAssert(totalToken.get() + tokenBalance > totalToken);
        
        DipcAssert(ownerTotalToken.get() < ownerTotalToken.get() + spent);
        (*portfolioStorge)[_portfolioName] = &pInfo[0];
        
        
        
        


        (*portfolioBalance)[_portfolioName] = finalBalance;
        *totalToken = totalToken.get() + finalBalance; 
        *ownerTotalToken = ownerTotalToken.get() + spent;
        DIPC_EMIT_EVENT(createOrder, "portfolioName", _portfolioName, "OrderInfo", &order.toJson()[0], "portfolioBalance", finalBalance);
    } codetext new #include "PortfolioManage.hpp"

    
    PAYABLE void PortfolioManage::init(){
        *owner = caller().toString();
        *changeRate = 10000;
        *userCanWithdraw = false;
        uint64_t tokenBalance = getTotalBalance();
        
        *ownerTotalToken = tokenBalance;
        *totalToken = ownerTotalToken.get();
        
        
        DIPC_EMIT_EVENT(initEvent, "ownerTotalToken" ,tokenBalance);
    }
    
     
    EXPORT void PortfolioManage::setChangeRate(uint64_t _changeRate){
        isOwner();
        *changeRate = _changeRate;
    }
     
    EXPORT void PortfolioManage::setUserCanWithdraw(bool _canWithdraw){
        isOwner();
        *userCanWithdraw = _canWithdraw;
    }

    
    PAYABLE void PortfolioManage::createPortfolio(char* _portfolioName, char* _portfolioDesc){
        if(portfolioStorge.get()[_portfolioName] != ""){
            DIPC_EMIT_EVENT(ErrEvent, "Current portfolio exist: ", _portfolioName);
            return;
        } 
        std::string callerAddr = caller().toString();
        uint64_t tokenBalance = getTotalBalance();
        
        PortfolioInfo info(_portfolioName, _portfolioDesc, &callerAddr[0]);
        std::string portfolioStr = info.toJson();
        
        
        

        (*portfolioStorge)[_portfolioName] = portfolioStr;
        DipcAssert(totalToken.get() + tokenBalance > totalToken);
        (*portfolioBalance)[_portfolioName] = tokenBalance;
        *totalToken = totalToken.get() + tokenBalance; 
        
        DIPC_EMIT_EVENT(portfolioInfo, _portfolioName, &portfolioStr[0], "portfolioBalance", tokenBalance);
    }

    
    PAYABLE void PortfolioManage::depositPortfolio(char* _portfolioName){
        uint64_t tokenBalance = getTotalBalance();
        
        uint64_t currentBalance = portfolioBalance.get()[_portfolioName];
        uint64_t finalBalance  = currentBalance + tokenBalance;
        DipcAssert(totalToken.get() + tokenBalance > totalToken);
        DipcAssert(finalBalance > currentBalance);
        (*portfolioBalance)[_portfolioName] = finalBalance;
        *totalToken = totalToken.get() + finalBalance; 
        DIPC_EMIT_EVENT(depositPortfolio, "portfolioName", _portfolioName, "portfolioBalance", finalBalance);
    }
    
    PAYABLE void PortfolioManage::createOrder(char* _portfolioName, char* _orderId, uint16_t _orderType, char* _stockCode, uint64_t _stockPrice, uint64_t _stockAmount, uint64_t _endTime){
        uint64_t tokenBalance = getTotalBalance();
        DIPC_EMIT_EVENT(createOrder, "portfolioName", _portfolioName, "OrderInfo", "ignore", "tokenBalance", tokenBalance);
        uint64_t spent = 0;
        if(_orderType == 1){
            spent = _stockPrice * _stockAmount;
            DipcAssert((portfolioBalance.get()[_portfolioName] + tokenBalance) > spent);
        }
        struct Order order{_orderId, _orderType, _stockCode, _stockPrice, _stockAmount, _endTime, 0};
        std::string pInfo = portfolioStorge.get()[_portfolioName];
        
        
        
        if(pInfo == "") {
            DIPC_EMIT_EVENT(ErrEvent, "Current portfolio  doesn't exist: ", _portfolioName);
            return;
        }
        PortfolioInfo info;
        info.parseJson(pInfo);
        if(info.getOrder(_orderId).orderId != ""){
            DIPC_EMIT_EVENT(ErrEvent, "Current order exist: ", _orderId);
            return;
        }
        info.addOrder(order);
        pInfo = info.toJson();

        uint64_t currentBalance = portfolioBalance.get()[_portfolioName] ;
        uint64_t finalBalance = currentBalance + tokenBalance - spent;
        DipcAssert(totalToken.get() + tokenBalance > totalToken);
        
        DipcAssert(ownerTotalToken.get() < ownerTotalToken.get() + spent);
        (*portfolioStorge)[_portfolioName] = &pInfo[0];
        
        
        
        


        (*portfolioBalance)[_portfolioName] = finalBalance;
        *totalToken = totalToken.get() + finalBalance; 
        *ownerTotalToken = ownerTotalToken.get() + spent;
        DIPC_EMIT_EVENT(createOrder, "portfolioName", _portfolioName, "OrderInfo", &order.toJson()[0], "portfolioBalance", finalBalance);
    }

    
    EXPORT void PortfolioManage::dealOrder(char* _portfolioName, char* _orderId){
        isOwner();
        std::string pInfo = portfolioStorge.get()[_portfolioName];
        
        
        PortfolioInfo info;
        info.parseJson(pInfo);
        

        
         Order ord = info.getOrder(_orderId);
         
         
        if(ord.orderId != "" && ord.orderStatus == 0){
            
            uint64_t timenow = dipc::timestamp();
            if(ord.endTime > timenow){
                ord.orderStatus = 1;
            }else {
                ord.orderStatus = 3;
            }
        } else {
          

            return;
        }
        

        uint64_t sellValue = 0;
        if(ord.orderType == 0){
            sellValue = ord.stockAmount * ord.stockPrice;
        }
        uint64_t currentBalance =  portfolioBalance.get()[_portfolioName];
        

        DipcAssert(currentBalance + sellValue >= currentBalance);
        DipcAssert((ownerTotalToken.get() - sellValue) <= ownerTotalToken.get());
        


        (*portfolioBalance)[_portfolioName] = currentBalance + sellValue;
        *ownerTotalToken = ownerTotalToken.get() - sellValue;
        (*portfolioStorge)[_portfolioName] = &info.toJson()[0];
        
        
        
        

        DIPC_EMIT_EVENT(dealPortfolio, "orderId", _orderId, "orderInfo", &ord.toJson()[0]);
    }
    
    EXPORT void PortfolioManage::revocationOrder(char* _portfolioName, char* _orderId){
        std::string pInfo = portfolioStorge.get()[_portfolioName];
        
        
        PortfolioInfo info;
        info.parseJson(pInfo);
        Order ord = info.getOrder(_orderId);
        
        
        if(ord.orderId != "" && ord.orderStatus == 0){
            std::string callerStr = caller().toString();
            
            
            
            DipcAssert(info.getOwnerAddress() == caller().toString());
            

            uint64_t timenow = dipc::timestamp();
            if(ord.endTime > timenow){
                ord.orderStatus = 2;
            }else {
                ord.orderStatus = 3;
            }
        } else {
            return;
        }
        uint64_t lockToken = 0;
        if(ord.orderType == 1){
            lockToken = ord.stockPrice * ord.stockAmount;
        }
        uint64_t currentBalance =  portfolioBalance.get()[_portfolioName];
        
        
        
        

        DipcAssert(currentBalance + lockToken >= currentBalance);
        DipcAssert(ownerTotalToken.get() - lockToken <= ownerTotalToken.get());

        
        (*portfolioBalance)[_portfolioName] = currentBalance + lockToken;
        *ownerTotalToken = ownerTotalToken.get() - lockToken;
        (*portfolioStorge)[_portfolioName] = &info.toJson()[0];
        DIPC_EMIT_EVENT(revocationPortfolio, "orderId", _orderId, "orderInfo", &ord.toJson()[0]);
    }
    
    EXPORT void PortfolioManage::withdrawPortfolio(char* _portfolioName, uint64_t _withdrawBalance){
         if(!userCanWithdraw.get()){
             return;
         }
         uint64_t currentBalance =  portfolioBalance.get()[_portfolioName];
         DipcAssert(currentBalance - _withdrawBalance < currentBalance);
         auto coinBalance = changeUint64ToU256WithChangeRate(currentBalance, changeRate.get());
         (*portfolioBalance)[_portfolioName] = currentBalance - _withdrawBalance;
         callTransfer(caller(), coinBalance);
    }
    
    EXPORT void PortfolioManage::withdrawPool(uint64_t _balance){
        isOwner();
        Address ownerAddr = Address(owner.get()); 
        callTransfer(ownerAddr, _balance);
        *ownerTotalToken = ownerTotalToken.get() - _balance * changeRate.get();
        *totalToken = totalToken.get() - _balance * changeRate.get();
        DIPC_EMIT_EVENT(tokenCount, "ownerTotalToken", ownerTotalToken.get(), "totalToken", totalToken.get());
    }
    
    PAYABLE void PortfolioManage::depositPool(uint64_t _depositValue){
        isOwner();
        
        uint64_t tokenBalance = changeU256ToUint64WithChangeRate(callValue(), changeRate.get()); 
        *ownerTotalToken = ownerTotalToken.get() + tokenBalance;
        *totalToken = totalToken.get() + tokenBalance;
        DIPC_EMIT_EVENT(tokenCount, "ownerTotalToken", ownerTotalToken.get(), "totalToken", totalToken.get());
    }
     
    CONSTANT uint64_t PortfolioManage::queryTotalToken(){
        return totalToken.get();
    }

     
    CONSTANT uint64_t PortfolioManage::queryPortfolioBalance(char* _portfolioName){
        return portfolioBalance.get()[_portfolioName];
    }

    
    CONSTANT bool PortfolioManage::queryPortfolioNameIfUsed(char* _portfolioName){
        if(portfolioStorge.get()[_portfolioName] != ""){
            return true;
        } 
        return false;
    }

    
    CONSTANT uint64_t PortfolioManage::queryChangeRate(){
        return changeRate.get();
    }

2019-12-19_15:14:53.287887: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:604] finalContract  final content =======   : #include "PortfolioManage.hpp"

    
    PAYABLE void PortfolioManage::init(){
        *owner = caller().toString();
        *changeRate = 10000;
        *userCanWithdraw = false;
        uint64_t tokenBalance = getTotalBalance();
        
        *ownerTotalToken = tokenBalance;
        *totalToken = ownerTotalToken.get();
        
        
        DIPC_EMIT_EVENT(initEvent, "ownerTotalToken" ,tokenBalance);
    }
    
     
    EXPORT void PortfolioManage::setChangeRate(uint64_t _changeRate){
        isOwner();
        *changeRate = _changeRate;
    }
     
    EXPORT void PortfolioManage::setUserCanWithdraw(bool _canWithdraw){
        isOwner();
        *userCanWithdraw = _canWithdraw;
    }

    
    PAYABLE void PortfolioManage::createPortfolio(char* _portfolioName, char* _portfolioDesc){
        if(portfolioStorge.get()[_portfolioName] != ""){
            DIPC_EMIT_EVENT(ErrEvent, "Current portfolio exist: ", _portfolioName);
            return;
        } 
        std::string callerAddr = caller().toString();
        uint64_t tokenBalance = getTotalBalance();
        
        PortfolioInfo info(_portfolioName, _portfolioDesc, &callerAddr[0]);
        std::string portfolioStr = info.toJson();
        
        
        

        (*portfolioStorge)[_portfolioName] = portfolioStr;
        DipcAssert(totalToken.get() + tokenBalance > totalToken);
        (*portfolioBalance)[_portfolioName] = tokenBalance;
        *totalToken = totalToken.get() + tokenBalance; 
        
        DIPC_EMIT_EVENT(portfolioInfo, _portfolioName, &portfolioStr[0], "portfolioBalance", tokenBalance);
    }

    
    PAYABLE void PortfolioManage::depositPortfolio(char* _portfolioName){
        uint64_t tokenBalance = getTotalBalance();
        
        uint64_t currentBalance = portfolioBalance.get()[_portfolioName];
        uint64_t finalBalance  = currentBalance + tokenBalance;
        DipcAssert(totalToken.get() + tokenBalance > totalToken);
        DipcAssert(finalBalance > currentBalance);
        (*portfolioBalance)[_portfolioName] = finalBalance;
        *totalToken = totalToken.get() + finalBalance; 
        DIPC_EMIT_EVENT(depositPortfolio, "portfolioName", _portfolioName, "portfolioBalance", finalBalance);
    }
    
    PAYABLE void PortfolioManage::createOrder(char* _portfolioName, char* _orderId, uint16_t _orderType, char* _stockCode, uint64_t _stockPrice, uint64_t _stockAmount, uint64_t _endTime){
        uint64_t tokenBalance = getTotalBalance();
        DIPC_EMIT_EVENT(createOrder, "portfolioName", _portfolioName, "OrderInfo", "ignore", "tokenBalance", tokenBalance);
        uint64_t spent = 0;
        if(_orderType == 1){
            spent = _stockPrice * _stockAmount;
            DipcAssert((portfolioBalance.get()[_portfolioName] + tokenBalance) > spent);
        }
        struct Order order{_orderId, _orderType, _stockCode, _stockPrice, _stockAmount, _endTime, 0};
        std::string pInfo = portfolioStorge.get()[_portfolioName];
        
        
        
        if(pInfo == "") {
            DIPC_EMIT_EVENT(ErrEvent, "Current portfolio  doesn't exist: ", _portfolioName);
            return;
        }
        PortfolioInfo info;
        info.parseJson(pInfo);
        if(info.getOrder(_orderId).orderId != ""){
            DIPC_EMIT_EVENT(ErrEvent, "Current order exist: ", _orderId);
            return;
        }
        info.addOrder(order);
        pInfo = info.toJson();

        uint64_t currentBalance = portfolioBalance.get()[_portfolioName] ;
        uint64_t finalBalance = currentBalance + tokenBalance - spent;
        DipcAssert(totalToken.get() + tokenBalance > totalToken);
        
        DipcAssert(ownerTotalToken.get() < ownerTotalToken.get() + spent);
        (*portfolioStorge)[_portfolioName] = &pInfo[0];
        
        
        
        


        (*portfolioBalance)[_portfolioName] = finalBalance;
        *totalToken = totalToken.get() + finalBalance; 
        *ownerTotalToken = ownerTotalToken.get() + spent;
        DIPC_EMIT_EVENT(createOrder, "portfolioName", _portfolioName, "OrderInfo", &order.toJson()[0], "portfolioBalance", finalBalance);
    }

    
    EXPORT void PortfolioManage::dealOrder(char* _portfolioName, char* _orderId){
        isOwner();
        std::string pInfo = portfolioStorge.get()[_portfolioName];
        
        
        PortfolioInfo info;
        info.parseJson(pInfo);
        

        
         Order ord = info.getOrder(_orderId);
         
         
        if(ord.orderId != "" && ord.orderStatus == 0){
            
            uint64_t timenow = dipc::timestamp();
            if(ord.endTime > timenow){
                ord.orderStatus = 1;
            }else {
                ord.orderStatus = 3;
            }
        } else {
          

            return;
        }
        

        uint64_t sellValue = 0;
        if(ord.orderType == 0){
            sellValue = ord.stockAmount * ord.stockPrice;
        }
        uint64_t currentBalance =  portfolioBalance.get()[_portfolioName];
        

        DipcAssert(currentBalance + sellValue >= currentBalance);
        DipcAssert((ownerTotalToken.get() - sellValue) <= ownerTotalToken.get());
        


        (*portfolioBalance)[_portfolioName] = currentBalance + sellValue;
        *ownerTotalToken = ownerTotalToken.get() - sellValue;
        (*portfolioStorge)[_portfolioName] = &info.toJson()[0];
        
        
        
        

        DIPC_EMIT_EVENT(dealPortfolio, "orderId", _orderId, "orderInfo", &ord.toJson()[0]);
    }
    
    EXPORT void PortfolioManage::revocationOrder(char* _portfolioName, char* _orderId){
        std::string pInfo = portfolioStorge.get()[_portfolioName];
        
        
        PortfolioInfo info;
        info.parseJson(pInfo);
        Order ord = info.getOrder(_orderId);
        
        
        if(ord.orderId != "" && ord.orderStatus == 0){
            std::string callerStr = caller().toString();
            
            
            
            DipcAssert(info.getOwnerAddress() == caller().toString());
            

            uint64_t timenow = dipc::timestamp();
            if(ord.endTime > timenow){
                ord.orderStatus = 2;
            }else {
                ord.orderStatus = 3;
            }
        } else {
            return;
        }
        uint64_t lockToken = 0;
        if(ord.orderType == 1){
            lockToken = ord.stockPrice * ord.stockAmount;
        }
        uint64_t currentBalance =  portfolioBalance.get()[_portfolioName];
        
        
        
        

        DipcAssert(currentBalance + lockToken >= currentBalance);
        DipcAssert(ownerTotalToken.get() - lockToken <= ownerTotalToken.get());

        
        (*portfolioBalance)[_portfolioName] = currentBalance + lockToken;
        *ownerTotalToken = ownerTotalToken.get() - lockToken;
        (*portfolioStorge)[_portfolioName] = &info.toJson()[0];
        DIPC_EMIT_EVENT(revocationPortfolio, "orderId", _orderId, "orderInfo", &ord.toJson()[0]);
    }
    
    EXPORT void PortfolioManage::withdrawPortfolio(char* _portfolioName, uint64_t _withdrawBalance){
         if(!userCanWithdraw.get()){
             return;
         }
         uint64_t currentBalance =  portfolioBalance.get()[_portfolioName];
         DipcAssert(currentBalance - _withdrawBalance < currentBalance);
         auto coinBalance = changeUint64ToU256WithChangeRate(currentBalance, changeRate.get());
         (*portfolioBalance)[_portfolioName] = currentBalance - _withdrawBalance;
         callTransfer(caller(), coinBalance);
    }
    
    EXPORT void PortfolioManage::withdrawPool(uint64_t _balance){
        isOwner();
        Address ownerAddr = Address(owner.get()); 
        callTransfer(ownerAddr, _balance);
        *ownerTotalToken = ownerTotalToken.get() - _balance * changeRate.get();
        *totalToken = totalToken.get() - _balance * changeRate.get();
        DIPC_EMIT_EVENT(tokenCount, "ownerTotalToken", ownerTotalToken.get(), "totalToken", totalToken.get());
    }
    
    PAYABLE void PortfolioManage::depositPool(uint64_t _depositValue){
        isOwner();
        
        uint64_t tokenBalance = changeU256ToUint64WithChangeRate(callValue(), changeRate.get()); 
        *ownerTotalToken = ownerTotalToken.get() + tokenBalance;
        *totalToken = totalToken.get() + tokenBalance;
        DIPC_EMIT_EVENT(tokenCount, "ownerTotalToken", ownerTotalToken.get(), "totalToken", totalToken.get());
    }
     
    CONSTANT uint64_t PortfolioManage::queryTotalToken(){
        return totalToken.get();
    }

     
    CONSTANT uint64_t PortfolioManage::queryPortfolioBalance(char* _portfolioName){
        return portfolioBalance.get()[_portfolioName];
    }

    
    CONSTANT bool PortfolioManage::queryPortfolioNameIfUsed(char* _portfolioName){
        if(portfolioStorge.get()[_portfolioName] != ""){
            return true;
        } 
        return false;
    }

    
    CONSTANT uint64_t PortfolioManage::queryChangeRate(){
        return changeRate.get();
    }

2019-12-19_15:14:53.287897: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:401] abis.ispayable :true

2019-12-19_15:14:53.287915: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:424] finalContract  this height  #include "PortfolioManage.hpp"

    
    PAYABLE void PortfolioManage::init(){
        *owner = caller().toString();
        *changeRate = 10000;
        *userCanWithdraw = false;
        uint64_t tokenBalance = getTotalBalance();
        
        *ownerTotalToken = tokenBalance;
        *totalToken = ownerTotalToken.get();
        
        
        DIPC_EMIT_EVENT(initEvent, "ownerTotalToken" ,tokenBalance);
    }
    
     
    EXPORT void PortfolioManage::setChangeRate(uint64_t _changeRate){
        isOwner();
        *changeRate = _changeRate;
    }
     
    EXPORT void PortfolioManage::setUserCanWithdraw(bool _canWithdraw){
        isOwner();
        *userCanWithdraw = _canWithdraw;
    }

    
    PAYABLE void PortfolioManage::createPortfolio(char* _portfolioName, char* _portfolioDesc){
        if(portfolioStorge.get()[_portfolioName] != ""){
            DIPC_EMIT_EVENT(ErrEvent, "Current portfolio exist: ", _portfolioName);
            return;
        } 
        std::string callerAddr = caller().toString();
        uint64_t tokenBalance = getTotalBalance();
        
        PortfolioInfo info(_portfolioName, _portfolioDesc, &callerAddr[0]);
        std::string portfolioStr = info.toJson();
        
        
        

        (*portfolioStorge)[_portfolioName] = portfolioStr;
        DipcAssert(totalToken.get() + tokenBalance > totalToken);
        (*portfolioBalance)[_portfolioName] = tokenBalance;
        *totalToken = totalToken.get() + tokenBalance; 
        
        DIPC_EMIT_EVENT(portfolioInfo, _portfolioName, &portfolioStr[0], "portfolioBalance", tokenBalance);
    }

    
    PAYABLE void PortfolioManage::depositPortfolio(char* _portfolioName){
        uint64_t tokenBalance = getTotalBalance();
        
        uint64_t currentBalance = portfolioBalance.get()[_portfolioName];
        uint64_t finalBalance  = currentBalance + tokenBalance;
        DipcAssert(totalToken.get() + tokenBalance > totalToken);
        DipcAssert(finalBalance > currentBalance);
        (*portfolioBalance)[_portfolioName] = finalBalance;
        *totalToken = totalToken.get() + finalBalance; 
        DIPC_EMIT_EVENT(depositPortfolio, "portfolioName", _portfolioName, "portfolioBalance", finalBalance);
    }
    
    PAYABLE void PortfolioManage::createOrder(char* _portfolioName, char* _orderId, uint16_t _orderType, char* _stockCode, uint64_t _stockPrice, uint64_t _stockAmount, uint64_t _endTime){
        uint64_t tokenBalance = getTotalBalance();
        DIPC_EMIT_EVENT(createOrder, "portfolioName", _portfolioName, "OrderInfo", "ignore", "tokenBalance", tokenBalance);
        uint64_t spent = 0;
        if(_orderType == 1){
            spent = _stockPrice * _stockAmount;
            DipcAssert((portfolioBalance.get()[_portfolioName] + tokenBalance) > spent);
        }
        struct Order order{_orderId, _orderType, _stockCode, _stockPrice, _stockAmount, _endTime, 0};
        std::string pInfo = portfolioStorge.get()[_portfolioName];
        
        
        
        if(pInfo == "") {
            DIPC_EMIT_EVENT(ErrEvent, "Current portfolio  doesn't exist: ", _portfolioName);
            return;
        }
        PortfolioInfo info;
        info.parseJson(pInfo);
        if(info.getOrder(_orderId).orderId != ""){
            DIPC_EMIT_EVENT(ErrEvent, "Current order exist: ", _orderId);
            return;
        }
        info.addOrder(order);
        pInfo = info.toJson();

        uint64_t currentBalance = portfolioBalance.get()[_portfolioName] ;
        uint64_t finalBalance = currentBalance + tokenBalance - spent;
        DipcAssert(totalToken.get() + tokenBalance > totalToken);
        
        DipcAssert(ownerTotalToken.get() < ownerTotalToken.get() + spent);
        (*portfolioStorge)[_portfolioName] = &pInfo[0];
        
        
        
        


        (*portfolioBalance)[_portfolioName] = finalBalance;
        *totalToken = totalToken.get() + finalBalance; 
        *ownerTotalToken = ownerTotalToken.get() + spent;
        DIPC_EMIT_EVENT(createOrder, "portfolioName", _portfolioName, "OrderInfo", &order.toJson()[0], "portfolioBalance", finalBalance);
    }

    
    EXPORT void PortfolioManage::dealOrder(char* _portfolioName, char* _orderId){
        isOwner();
        std::string pInfo = portfolioStorge.get()[_portfolioName];
        
        
        PortfolioInfo info;
        info.parseJson(pInfo);
        

        
         Order ord = info.getOrder(_orderId);
         
         
        if(ord.orderId != "" && ord.orderStatus == 0){
            
            uint64_t timenow = dipc::timestamp();
            if(ord.endTime > timenow){
                ord.orderStatus = 1;
            }else {
                ord.orderStatus = 3;
            }
        } else {
          

            return;
        }
        

        uint64_t sellValue = 0;
        if(ord.orderType == 0){
            sellValue = ord.stockAmount * ord.stockPrice;
        }
        uint64_t currentBalance =  portfolioBalance.get()[_portfolioName];
        

        DipcAssert(currentBalance + sellValue >= currentBalance);
        DipcAssert((ownerTotalToken.get() - sellValue) <= ownerTotalToken.get());
        


        (*portfolioBalance)[_portfolioName] = currentBalance + sellValue;
        *ownerTotalToken = ownerTotalToken.get() - sellValue;
        (*portfolioStorge)[_portfolioName] = &info.toJson()[0];
        
        
        
        

        DIPC_EMIT_EVENT(dealPortfolio, "orderId", _orderId, "orderInfo", &ord.toJson()[0]);
    }
    
    EXPORT void PortfolioManage::revocationOrder(char* _portfolioName, char* _orderId){
        std::string pInfo = portfolioStorge.get()[_portfolioName];
        
        
        PortfolioInfo info;
        info.parseJson(pInfo);
        Order ord = info.getOrder(_orderId);
        
        
        if(ord.orderId != "" && ord.orderStatus == 0){
            std::string callerStr = caller().toString();
            
            
            
            DipcAssert(info.getOwnerAddress() == caller().toString());
            

            uint64_t timenow = dipc::timestamp();
            if(ord.endTime > timenow){
                ord.orderStatus = 2;
            }else {
                ord.orderStatus = 3;
            }
        } else {
            return;
        }
        uint64_t lockToken = 0;
        if(ord.orderType == 1){
            lockToken = ord.stockPrice * ord.stockAmount;
        }
        uint64_t currentBalance =  portfolioBalance.get()[_portfolioName];
        
        
        
        

        DipcAssert(currentBalance + lockToken >= currentBalance);
        DipcAssert(ownerTotalToken.get() - lockToken <= ownerTotalToken.get());

        
        (*portfolioBalance)[_portfolioName] = currentBalance + lockToken;
        *ownerTotalToken = ownerTotalToken.get() - lockToken;
        (*portfolioStorge)[_portfolioName] = &info.toJson()[0];
        DIPC_EMIT_EVENT(revocationPortfolio, "orderId", _orderId, "orderInfo", &ord.toJson()[0]);
    }
    
    EXPORT void PortfolioManage::withdrawPortfolio(char* _portfolioName, uint64_t _withdrawBalance){
         if(!userCanWithdraw.get()){
             return;
         }
         uint64_t currentBalance =  portfolioBalance.get()[_portfolioName];
         DipcAssert(currentBalance - _withdrawBalance < currentBalance);
         auto coinBalance = changeUint64ToU256WithChangeRate(currentBalance, changeRate.get());
         (*portfolioBalance)[_portfolioName] = currentBalance - _withdrawBalance;
         callTransfer(caller(), coinBalance);
    }
    
    EXPORT void PortfolioManage::withdrawPool(uint64_t _balance){
        isOwner();
        Address ownerAddr = Address(owner.get()); 
        callTransfer(ownerAddr, _balance);
        *ownerTotalToken = ownerTotalToken.get() - _balance * changeRate.get();
        *totalToken = totalToken.get() - _balance * changeRate.get();
        DIPC_EMIT_EVENT(tokenCount, "ownerTotalToken", ownerTotalToken.get(), "totalToken", totalToken.get());
    }
    
    PAYABLE void PortfolioManage::depositPool(uint64_t _depositValue){
        isOwner();
        
        uint64_t tokenBalance = changeU256ToUint64WithChangeRate(callValue(), changeRate.get()); 
        *ownerTotalToken = ownerTotalToken.get() + tokenBalance;
        *totalToken = totalToken.get() + tokenBalance;
        DIPC_EMIT_EVENT(tokenCount, "ownerTotalToken", ownerTotalToken.get(), "totalToken", totalToken.get());
    }
     
    CONSTANT uint64_t PortfolioManage::queryTotalToken(){
        return totalToken.get();
    }

     
    CONSTANT uint64_t PortfolioManage::queryPortfolioBalance(char* _portfolioName){
        return portfolioBalance.get()[_portfolioName];
    }

    
    CONSTANT bool PortfolioManage::queryPortfolioNameIfUsed(char* _portfolioName){
        if(portfolioStorge.get()[_portfolioName] != ""){
            return true;
        } 
        return false;
    }

    
    CONSTANT uint64_t PortfolioManage::queryChangeRate(){
        return changeRate.get();
    } codetext height #include "PortfolioManage.hpp"

    
    PAYABLE void PortfolioManage::init(){
        *owner = caller().toString();
        *changeRate = 10000;
        *userCanWithdraw = false;
        uint64_t tokenBalance = getTotalBalance();
        
        *ownerTotalToken = tokenBalance;
        *totalToken = ownerTotalToken.get();
        
        
        DIPC_EMIT_EVENT(initEvent, "ownerTotalToken" ,tokenBalance);
    }
    
     
    EXPORT void PortfolioManage::setChangeRate(uint64_t _changeRate){
        isOwner();
        *changeRate = _changeRate;
    }
     
    EXPORT void PortfolioManage::setUserCanWithdraw(bool _canWithdraw){
        isOwner();
        *userCanWithdraw = _canWithdraw;
    }

    
    PAYABLE void PortfolioManage::createPortfolio(char* _portfolioName, char* _portfolioDesc){
        if(portfolioStorge.get()[_portfolioName] != ""){
            DIPC_EMIT_EVENT(ErrEvent, "Current portfolio exist: ", _portfolioName);
            return;
        } 
        std::string callerAddr = caller().toString();
        uint64_t tokenBalance = getTotalBalance();
        
        PortfolioInfo info(_portfolioName, _portfolioDesc, &callerAddr[0]);
        std::string portfolioStr = info.toJson();
        
        
        

        (*portfolioStorge)[_portfolioName] = portfolioStr;
        DipcAssert(totalToken.get() + tokenBalance > totalToken);
        (*portfolioBalance)[_portfolioName] = tokenBalance;
        *totalToken = totalToken.get() + tokenBalance; 
        
        DIPC_EMIT_EVENT(portfolioInfo, _portfolioName, &portfolioStr[0], "portfolioBalance", tokenBalance);
    }

    
    PAYABLE void PortfolioManage::depositPortfolio(char* _portfolioName){
        uint64_t tokenBalance = getTotalBalance();
        
        uint64_t currentBalance = portfolioBalance.get()[_portfolioName];
        uint64_t finalBalance  = currentBalance + tokenBalance;
        DipcAssert(totalToken.get() + tokenBalance > totalToken);
        DipcAssert(finalBalance > currentBalance);
        (*portfolioBalance)[_portfolioName] = finalBalance;
        *totalToken = totalToken.get() + finalBalance; 
        DIPC_EMIT_EVENT(depositPortfolio, "portfolioName", _portfolioName, "portfolioBalance", finalBalance);
    }
    
    PAYABLE void PortfolioManage::createOrder(char* _portfolioName, char* _orderId, uint16_t _orderType, char* _stockCode, uint64_t _stockPrice, uint64_t _stockAmount, uint64_t _endTime){
        uint64_t tokenBalance = getTotalBalance();
        DIPC_EMIT_EVENT(createOrder, "portfolioName", _portfolioName, "OrderInfo", "ignore", "tokenBalance", tokenBalance);
        uint64_t spent = 0;
        if(_orderType == 1){
            spent = _stockPrice * _stockAmount;
            DipcAssert((portfolioBalance.get()[_portfolioName] + tokenBalance) > spent);
        }
        struct Order order{_orderId, _orderType, _stockCode, _stockPrice, _stockAmount, _endTime, 0};
        std::string pInfo = portfolioStorge.get()[_portfolioName];
        
        
        
        if(pInfo == "") {
            DIPC_EMIT_EVENT(ErrEvent, "Current portfolio  doesn't exist: ", _portfolioName);
            return;
        }
        PortfolioInfo info;
        info.parseJson(pInfo);
        if(info.getOrder(_orderId).orderId != ""){
            DIPC_EMIT_EVENT(ErrEvent, "Current order exist: ", _orderId);
            return;
        }
        info.addOrder(order);
        pInfo = info.toJson();

        uint64_t currentBalance = portfolioBalance.get()[_portfolioName] ;
        uint64_t finalBalance = currentBalance + tokenBalance - spent;
        DipcAssert(totalToken.get() + tokenBalance > totalToken);
        
        DipcAssert(ownerTotalToken.get() < ownerTotalToken.get() + spent);
        (*portfolioStorge)[_portfolioName] = &pInfo[0];
        
        
        
        


        (*portfolioBalance)[_portfolioName] = finalBalance;
        *totalToken = totalToken.get() + finalBalance; 
        *ownerTotalToken = ownerTotalToken.get() + spent;
        DIPC_EMIT_EVENT(createOrder, "portfolioName", _portfolioName, "OrderInfo", &order.toJson()[0], "portfolioBalance", finalBalance);
    }

    
    EXPORT void PortfolioManage::dealOrder(char* _portfolioName, char* _orderId){
        isOwner();
        std::string pInfo = portfolioStorge.get()[_portfolioName];
        
        
        PortfolioInfo info;
        info.parseJson(pInfo);
        

        
         Order ord = info.getOrder(_orderId);
         
         
        if(ord.orderId != "" && ord.orderStatus == 0){
            
            uint64_t timenow = dipc::timestamp();
            if(ord.endTime > timenow){
                ord.orderStatus = 1;
            }else {
                ord.orderStatus = 3;
            }
        } else {
          

            return;
        }
        

        uint64_t sellValue = 0;
        if(ord.orderType == 0){
            sellValue = ord.stockAmount * ord.stockPrice;
        }
        uint64_t currentBalance =  portfolioBalance.get()[_portfolioName];
        

        DipcAssert(currentBalance + sellValue >= currentBalance);
        DipcAssert((ownerTotalToken.get() - sellValue) <= ownerTotalToken.get());
        


        (*portfolioBalance)[_portfolioName] = currentBalance + sellValue;
        *ownerTotalToken = ownerTotalToken.get() - sellValue;
        (*portfolioStorge)[_portfolioName] = &info.toJson()[0];
        
        
        
        

        DIPC_EMIT_EVENT(dealPortfolio, "orderId", _orderId, "orderInfo", &ord.toJson()[0]);
    }
    
    EXPORT void PortfolioManage::revocationOrder(char* _portfolioName, char* _orderId){
        std::string pInfo = portfolioStorge.get()[_portfolioName];
        
        
        PortfolioInfo info;
        info.parseJson(pInfo);
        Order ord = info.getOrder(_orderId);
        
        
        if(ord.orderId != "" && ord.orderStatus == 0){
            std::string callerStr = caller().toString();
            
            
            
            DipcAssert(info.getOwnerAddress() == caller().toString());
            

            uint64_t timenow = dipc::timestamp();
            if(ord.endTime > timenow){
                ord.orderStatus = 2;
            }else {
                ord.orderStatus = 3;
            }
        } else {
            return;
        }
        uint64_t lockToken = 0;
        if(ord.orderType == 1){
            lockToken = ord.stockPrice * ord.stockAmount;
        }
        uint64_t currentBalance =  portfolioBalance.get()[_portfolioName];
        
        
        
        

        DipcAssert(currentBalance + lockToken >= currentBalance);
        DipcAssert(ownerTotalToken.get() - lockToken <= ownerTotalToken.get());

        
        (*portfolioBalance)[_portfolioName] = currentBalance + lockToken;
        *ownerTotalToken = ownerTotalToken.get() - lockToken;
        (*portfolioStorge)[_portfolioName] = &info.toJson()[0];
        DIPC_EMIT_EVENT(revocationPortfolio, "orderId", _orderId, "orderInfo", &ord.toJson()[0]);
    }
    
    EXPORT void PortfolioManage::withdrawPortfolio(char* _portfolioName, uint64_t _withdrawBalance){
         if(!userCanWithdraw.get()){
             return;
         }
         uint64_t currentBalance =  portfolioBalance.get()[_portfolioName];
         DipcAssert(currentBalance - _withdrawBalance < currentBalance);
         auto coinBalance = changeUint64ToU256WithChangeRate(currentBalance, changeRate.get());
         (*portfolioBalance)[_portfolioName] = currentBalance - _withdrawBalance;
         callTransfer(caller(), coinBalance);
    }
    
    EXPORT void PortfolioManage::withdrawPool(uint64_t _balance){
        isOwner();
        Address ownerAddr = Address(owner.get()); 
        callTransfer(ownerAddr, _balance);
        *ownerTotalToken = ownerTotalToken.get() - _balance * changeRate.get();
        *totalToken = totalToken.get() - _balance * changeRate.get();
        DIPC_EMIT_EVENT(tokenCount, "ownerTotalToken", ownerTotalToken.get(), "totalToken", totalToken.get());
    }
    
    PAYABLE void PortfolioManage::depositPool(uint64_t _depositValue){
        isOwner();
        
        uint64_t tokenBalance = changeU256ToUint64WithChangeRate(callValue(), changeRate.get()); 
        *ownerTotalToken = ownerTotalToken.get() + tokenBalance;
        *totalToken = totalToken.get() + tokenBalance;
        DIPC_EMIT_EVENT(tokenCount, "ownerTotalToken", ownerTotalToken.get(), "totalToken", totalToken.get());
    }
     
    CONSTANT uint64_t PortfolioManage::queryTotalToken(){
        return totalToken.get();
    }

     
    CONSTANT uint64_t PortfolioManage::queryPortfolioBalance(char* _portfolioName){
        return portfolioBalance.get()[_portfolioName];
    }

    
    CONSTANT bool PortfolioManage::queryPortfolioNameIfUsed(char* _portfolioName){
        if(portfolioStorge.get()[_portfolioName] != ""){
            return true;
        } 
        return false;
    }

    
    CONSTANT uint64_t PortfolioManage::queryChangeRate(){
        return changeRate.get();
    }

2019-12-19_15:14:53.288037: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:427] searchContext  #include "PortfolioManage.hpp"

    
    PAYABLE void PortfolioManage::init(){
        *owner = caller().toString();
        *changeRate = 10000;
        *userCanWithdraw = false;
        uint64_t tokenBalance = getTotalBalance();
        
        *ownerTotalToken = tokenBalance;
        *totalToken = ownerTotalToken.get();
        
        
        DIPC_EMIT_EVENT(initEvent, "ownerTotalToken" ,tokenBalance);
    }
    
     
    EXPORT void PortfolioManage::setChangeRate(uint64_t _changeRate){
        isOwner();
        *changeRate = _changeRate;
    }
     
    EXPORT void PortfolioManage::setUserCanWithdraw(bool _canWithdraw){
        isOwner();
        *userCanWithdraw = _canWithdraw;
    }

    
    PAYABLE void PortfolioManage::createPortfolio(char* _portfolioName, char* _portfolioDesc){
        if(portfolioStorge.get()[_portfolioName] != ""){
            DIPC_EMIT_EVENT(ErrEvent, "Current portfolio exist: ", _portfolioName);
            return;
        } 
        std::string callerAddr = caller().toString();
        uint64_t tokenBalance = getTotalBalance();
        
        PortfolioInfo info(_portfolioName, _portfolioDesc, &callerAddr[0]);
        std::string portfolioStr = info.toJson();
        
        
        

        (*portfolioStorge)[_portfolioName] = portfolioStr;
        DipcAssert(totalToken.get() + tokenBalance > totalToken);
        (*portfolioBalance)[_portfolioName] = tokenBalance;
        *totalToken = totalToken.get() + tokenBalance; 
        
        DIPC_EMIT_EVENT(portfolioInfo, _portfolioName, &portfolioStr[0], "portfolioBalance", tokenBalance);
    }

    
    PAYABLE void PortfolioManage::depositPortfolio(char* _portfolioName){
        uint64_t tokenBalance = getTotalBalance();
        
        uint64_t currentBalance = portfolioBalance.get()[_portfolioName];
        uint64_t finalBalance  = currentBalance + tokenBalance;
        DipcAssert(totalToken.get() + tokenBalance > totalToken);
        DipcAssert(finalBalance > currentBalance);
        (*portfolioBalance)[_portfolioName] = finalBalance;
        *totalToken = totalToken.get() + finalBalance; 
        DIPC_EMIT_EVENT(depositPortfolio, "portfolioName", _portfolioName, "portfolioBalance", finalBalance);
    }
    
    PAYABLE void PortfolioManage::createOrder(char* _portfolioName, char* _orderId, uint16_t _orderType, char* _stockCode, uint64_t _stockPrice, uint64_t _stockAmount, uint64_t _endTime){
        uint64_t tokenBalance = getTotalBalance();
        DIPC_EMIT_EVENT(createOrder, "portfolioName", _portfolioName, "OrderInfo", "ignore", "tokenBalance", tokenBalance);
        uint64_t spent = 0;
        if(_orderType == 1){
            spent = _stockPrice * _stockAmount;
            DipcAssert((portfolioBalance.get()[_portfolioName] + tokenBalance) > spent);
        }
        struct Order order{_orderId, _orderType, _stockCode, _stockPrice, _stockAmount, _endTime, 0};
        std::string pInfo = portfolioStorge.get()[_portfolioName];
        
        
        
        if(pInfo == "") {
            DIPC_EMIT_EVENT(ErrEvent, "Current portfolio  doesn't exist: ", _portfolioName);
            return;
        }
        PortfolioInfo info;
        info.parseJson(pInfo);
        if(info.getOrder(_orderId).orderId != ""){
            DIPC_EMIT_EVENT(ErrEvent, "Current order exist: ", _orderId);
            return;
        }
        info.addOrder(order);
        pInfo = info.toJson();

        uint64_t currentBalance = portfolioBalance.get()[_portfolioName] ;
        uint64_t finalBalance = currentBalance + tokenBalance - spent;
        DipcAssert(totalToken.get() + tokenBalance > totalToken);
        
        DipcAssert(ownerTotalToken.get() < ownerTotalToken.get() + spent);
        (*portfolioStorge)[_portfolioName] = &pInfo[0];
        
        
        
        


        (*portfolioBalance)[_portfolioName] = finalBalance;
        *totalToken = totalToken.get() + finalBalance; 
        *ownerTotalToken = ownerTotalToken.get() + spent;
        DIPC_EMIT_EVENT(createOrder, "portfolioName", _portfolioName, "OrderInfo", &order.toJson()[0], "portfolioBalance", finalBalance);
    }

    
    EXPORT void PortfolioManage::dealOrder(char* _portfolioName, char* _orderId){
        isOwner();
        std::string pInfo = portfolioStorge.get()[_portfolioName];
        
        
        PortfolioInfo info;
        info.parseJson(pInfo);
        

        
         Order ord = info.getOrder(_orderId);
         
         
        if(ord.orderId != "" && ord.orderStatus == 0){
            
            uint64_t timenow = dipc::timestamp();
            if(ord.endTime > timenow){
                ord.orderStatus = 1;
            }else {
                ord.orderStatus = 3;
            }
        } else {
          

            return;
        }
        

        uint64_t sellValue = 0;
        if(ord.orderType == 0){
            sellValue = ord.stockAmount * ord.stockPrice;
        }
        uint64_t currentBalance =  portfolioBalance.get()[_portfolioName];
        

        DipcAssert(currentBalance + sellValue >= currentBalance);
        DipcAssert((ownerTotalToken.get() - sellValue) <= ownerTotalToken.get());
        


        (*portfolioBalance)[_portfolioName] = currentBalance + sellValue;
        *ownerTotalToken = ownerTotalToken.get() - sellValue;
        (*portfolioStorge)[_portfolioName] = &info.toJson()[0];
        
        
        
        

        DIPC_EMIT_EVENT(dealPortfolio, "orderId", _orderId, "orderInfo", &ord.toJson()[0]);
    }
    
    EXPORT void PortfolioManage::revocationOrder(char* _portfolioName, char* _orderId){
        std::string pInfo = portfolioStorge.get()[_portfolioName];
        
        
        PortfolioInfo info;
        info.parseJson(pInfo);
        Order ord = info.getOrder(_orderId);
        
        
        if(ord.orderId != "" && ord.orderStatus == 0){
            std::string callerStr = caller().toString();
            
            
            
            DipcAssert(info.getOwnerAddress() == caller().toString());
            

            uint64_t timenow = dipc::timestamp();
            if(ord.endTime > timenow){
                ord.orderStatus = 2;
            }else {
                ord.orderStatus = 3;
            }
        } else {
            return;
        }
        uint64_t lockToken = 0;
        if(ord.orderType == 1){
            lockToken = ord.stockPrice * ord.stockAmount;
        }
        uint64_t currentBalance =  portfolioBalance.get()[_portfolioName];
        
        
        
        

        DipcAssert(currentBalance + lockToken >= currentBalance);
        DipcAssert(ownerTotalToken.get() - lockToken <= ownerTotalToken.get());

        
        (*portfolioBalance)[_portfolioName] = currentBalance + lockToken;
        *ownerTotalToken = ownerTotalToken.get() - lockToken;
        (*portfolioStorge)[_portfolioName] = &info.toJson()[0];
        DIPC_EMIT_EVENT(revocationPortfolio, "orderId", _orderId, "orderInfo", &ord.toJson()[0]);
    }
    
    EXPORT void PortfolioManage::withdrawPortfolio(char* _portfolioName, uint64_t _withdrawBalance){
         if(!userCanWithdraw.get()){
             return;
         }
         uint64_t currentBalance =  portfolioBalance.get()[_portfolioName];
         DipcAssert(currentBalance - _withdrawBalance < currentBalance);
         auto coinBalance = changeUint64ToU256WithChangeRate(currentBalance, changeRate.get());
         (*portfolioBalance)[_portfolioName] = currentBalance - _withdrawBalance;
         callTransfer(caller(), coinBalance);
    }
    
    EXPORT void PortfolioManage::withdrawPool(uint64_t _balance){
        isOwner();
        Address ownerAddr = Address(owner.get()); 
        callTransfer(ownerAddr, _balance);
        *ownerTotalToken = ownerTotalToken.get() - _balance * changeRate.get();
        *totalToken = totalToken.get() - _balance * changeRate.get();
        DIPC_EMIT_EVENT(tokenCount, "ownerTotalToken", ownerTotalToken.get(), "totalToken", totalToken.get());
    }
    
    PAYABLE void PortfolioManage::depositPool(uint64_t _depositValue){
        isOwner();
        
        uint64_t tokenBalance = changeU256ToUint64WithChangeRate(callValue(), changeRate.get()); 
        *ownerTotalToken = ownerTotalToken.get() + tokenBalance;
        *totalToken = totalToken.get() + tokenBalance;
        DIPC_EMIT_EVENT(tokenCount, "ownerTotalToken", ownerTotalToken.get(), "totalToken", totalToken.get());
    }
     
    CONSTANT uint64_t PortfolioManage::queryTotalToken(){
        return totalToken.get();
    }

     
    CONSTANT uint64_t PortfolioManage::queryPortfolioBalance(char* _portfolioName){
        return portfolioBalance.get()[_portfolioName];
    }

    
    CONSTANT bool PortfolioManage::queryPortfolioNameIfUsed(char* _portfolioName){
        if(portfolioStorge.get()[_portfolioName] != ""){
            return true;
        } 
        return false;
    }

    
    CONSTANT uint64_t PortfolioManage::queryChangeRate(){
        return changeRate.get();
    }

2019-12-19_15:14:53.291274: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:451] log out out payable : PAYABLE void PortfolioManage::depositPool(uint64_t _depositValue){
        

2019-12-19_15:14:53.291283: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:457] name : depositPool   pos1  0

2019-12-19_15:14:53.291293: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:469] pos2  8016   pos1  8016

2019-12-19_15:14:53.291300: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:500] pos2 after 8445   pos1  8016

2019-12-19_15:14:53.291307: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:509] finalContract  first #include "PortfolioManage.hpp"

    
    PAYABLE void PortfolioManage::init(){
        *owner = caller().toString();
        *changeRate = 10000;
        *userCanWithdraw = false;
        uint64_t tokenBalance = getTotalBalance();
        
        *ownerTotalToken = tokenBalance;
        *totalToken = ownerTotalToken.get();
        
        
        DIPC_EMIT_EVENT(initEvent, "ownerTotalToken" ,tokenBalance);
    }
    
     
    EXPORT void PortfolioManage::setChangeRate(uint64_t _changeRate){
        isOwner();
        *changeRate = _changeRate;
    }
     
    EXPORT void PortfolioManage::setUserCanWithdraw(bool _canWithdraw){
        isOwner();
        *userCanWithdraw = _canWithdraw;
    }

    
    PAYABLE void PortfolioManage::createPortfolio(char* _portfolioName, char* _portfolioDesc){
        if(portfolioStorge.get()[_portfolioName] != ""){
            DIPC_EMIT_EVENT(ErrEvent, "Current portfolio exist: ", _portfolioName);
            return;
        } 
        std::string callerAddr = caller().toString();
        uint64_t tokenBalance = getTotalBalance();
        
        PortfolioInfo info(_portfolioName, _portfolioDesc, &callerAddr[0]);
        std::string portfolioStr = info.toJson();
        
        
        

        (*portfolioStorge)[_portfolioName] = portfolioStr;
        DipcAssert(totalToken.get() + tokenBalance > totalToken);
        (*portfolioBalance)[_portfolioName] = tokenBalance;
        *totalToken = totalToken.get() + tokenBalance; 
        
        DIPC_EMIT_EVENT(portfolioInfo, _portfolioName, &portfolioStr[0], "portfolioBalance", tokenBalance);
    }

    
    PAYABLE void PortfolioManage::depositPortfolio(char* _portfolioName){
        uint64_t tokenBalance = getTotalBalance();
        
        uint64_t currentBalance = portfolioBalance.get()[_portfolioName];
        uint64_t finalBalance  = currentBalance + tokenBalance;
        DipcAssert(totalToken.get() + tokenBalance > totalToken);
        DipcAssert(finalBalance > currentBalance);
        (*portfolioBalance)[_portfolioName] = finalBalance;
        *totalToken = totalToken.get() + finalBalance; 
        DIPC_EMIT_EVENT(depositPortfolio, "portfolioName", _portfolioName, "portfolioBalance", finalBalance);
    }
    
    PAYABLE void PortfolioManage::createOrder(char* _portfolioName, char* _orderId, uint16_t _orderType, char* _stockCode, uint64_t _stockPrice, uint64_t _stockAmount, uint64_t _endTime){
        uint64_t tokenBalance = getTotalBalance();
        DIPC_EMIT_EVENT(createOrder, "portfolioName", _portfolioName, "OrderInfo", "ignore", "tokenBalance", tokenBalance);
        uint64_t spent = 0;
        if(_orderType == 1){
            spent = _stockPrice * _stockAmount;
            DipcAssert((portfolioBalance.get()[_portfolioName] + tokenBalance) > spent);
        }
        struct Order order{_orderId, _orderType, _stockCode, _stockPrice, _stockAmount, _endTime, 0};
        std::string pInfo = portfolioStorge.get()[_portfolioName];
        
        
        
        if(pInfo == "") {
            DIPC_EMIT_EVENT(ErrEvent, "Current portfolio  doesn't exist: ", _portfolioName);
            return;
        }
        PortfolioInfo info;
        info.parseJson(pInfo);
        if(info.getOrder(_orderId).orderId != ""){
            DIPC_EMIT_EVENT(ErrEvent, "Current order exist: ", _orderId);
            return;
        }
        info.addOrder(order);
        pInfo = info.toJson();

        uint64_t currentBalance = portfolioBalance.get()[_portfolioName] ;
        uint64_t finalBalance = currentBalance + tokenBalance - spent;
        DipcAssert(totalToken.get() + tokenBalance > totalToken);
        
        DipcAssert(ownerTotalToken.get() < ownerTotalToken.get() + spent);
        (*portfolioStorge)[_portfolioName] = &pInfo[0];
        
        
        
        


        (*portfolioBalance)[_portfolioName] = finalBalance;
        *totalToken = totalToken.get() + finalBalance; 
        *ownerTotalToken = ownerTotalToken.get() + spent;
        DIPC_EMIT_EVENT(createOrder, "portfolioName", _portfolioName, "OrderInfo", &order.toJson()[0], "portfolioBalance", finalBalance);
    }

    
    EXPORT void PortfolioManage::dealOrder(char* _portfolioName, char* _orderId){
        isOwner();
        std::string pInfo = portfolioStorge.get()[_portfolioName];
        
        
        PortfolioInfo info;
        info.parseJson(pInfo);
        

        
         Order ord = info.getOrder(_orderId);
         
         
        if(ord.orderId != "" && ord.orderStatus == 0){
            
            uint64_t timenow = dipc::timestamp();
            if(ord.endTime > timenow){
                ord.orderStatus = 1;
            }else {
                ord.orderStatus = 3;
            }
        } else {
          

            return;
        }
        

        uint64_t sellValue = 0;
        if(ord.orderType == 0){
            sellValue = ord.stockAmount * ord.stockPrice;
        }
        uint64_t currentBalance =  portfolioBalance.get()[_portfolioName];
        

        DipcAssert(currentBalance + sellValue >= currentBalance);
        DipcAssert((ownerTotalToken.get() - sellValue) <= ownerTotalToken.get());
        


        (*portfolioBalance)[_portfolioName] = currentBalance + sellValue;
        *ownerTotalToken = ownerTotalToken.get() - sellValue;
        (*portfolioStorge)[_portfolioName] = &info.toJson()[0];
        
        
        
        

        DIPC_EMIT_EVENT(dealPortfolio, "orderId", _orderId, "orderInfo", &ord.toJson()[0]);
    }
    
    EXPORT void PortfolioManage::revocationOrder(char* _portfolioName, char* _orderId){
        std::string pInfo = portfolioStorge.get()[_portfolioName];
        
        
        PortfolioInfo info;
        info.parseJson(pInfo);
        Order ord = info.getOrder(_orderId);
        
        
        if(ord.orderId != "" && ord.orderStatus == 0){
            std::string callerStr = caller().toString();
            
            
            
            DipcAssert(info.getOwnerAddress() == caller().toString());
            

            uint64_t timenow = dipc::timestamp();
            if(ord.endTime > timenow){
                ord.orderStatus = 2;
            }else {
                ord.orderStatus = 3;
            }
        } else {
            return;
        }
        uint64_t lockToken = 0;
        if(ord.orderType == 1){
            lockToken = ord.stockPrice * ord.stockAmount;
        }
        uint64_t currentBalance =  portfolioBalance.get()[_portfolioName];
        
        
        
        

        DipcAssert(currentBalance + lockToken >= currentBalance);
        DipcAssert(ownerTotalToken.get() - lockToken <= ownerTotalToken.get());

        
        (*portfolioBalance)[_portfolioName] = currentBalance + lockToken;
        *ownerTotalToken = ownerTotalToken.get() - lockToken;
        (*portfolioStorge)[_portfolioName] = &info.toJson()[0];
        DIPC_EMIT_EVENT(revocationPortfolio, "orderId", _orderId, "orderInfo", &ord.toJson()[0]);
    }
    
    EXPORT void PortfolioManage::withdrawPortfolio(char* _portfolioName, uint64_t _withdrawBalance){
         if(!userCanWithdraw.get()){
             return;
         }
         uint64_t currentBalance =  portfolioBalance.get()[_portfolioName];
         DipcAssert(currentBalance - _withdrawBalance < currentBalance);
         auto coinBalance = changeUint64ToU256WithChangeRate(currentBalance, changeRate.get());
         (*portfolioBalance)[_portfolioName] = currentBalance - _withdrawBalance;
         callTransfer(caller(), coinBalance);
    }
    
    EXPORT void PortfolioManage::withdrawPool(uint64_t _balance){
        isOwner();
        Address ownerAddr = Address(owner.get()); 
        callTransfer(ownerAddr, _balance);
        *ownerTotalToken = ownerTotalToken.get() - _balance * changeRate.get();
        *totalToken = totalToken.get() - _balance * changeRate.get();
        DIPC_EMIT_EVENT(tokenCount, "ownerTotalToken", ownerTotalToken.get(), "totalToken", totalToken.get());
    }
    
    

2019-12-19_15:14:53.291314: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:510] codetext  first #include "PortfolioManage.hpp"

    
    PAYABLE void PortfolioManage::init(){
        *owner = caller().toString();
        *changeRate = 10000;
        *userCanWithdraw = false;
        uint64_t tokenBalance = getTotalBalance();
        
        *ownerTotalToken = tokenBalance;
        *totalToken = ownerTotalToken.get();
        
        
        DIPC_EMIT_EVENT(initEvent, "ownerTotalToken" ,tokenBalance);
    }
    
     
    EXPORT void PortfolioManage::setChangeRate(uint64_t _changeRate){
        isOwner();
        *changeRate = _changeRate;
    }
     
    EXPORT void PortfolioManage::setUserCanWithdraw(bool _canWithdraw){
        isOwner();
        *userCanWithdraw = _canWithdraw;
    }

    
    PAYABLE void PortfolioManage::createPortfolio(char* _portfolioName, char* _portfolioDesc){
        if(portfolioStorge.get()[_portfolioName] != ""){
            DIPC_EMIT_EVENT(ErrEvent, "Current portfolio exist: ", _portfolioName);
            return;
        } 
        std::string callerAddr = caller().toString();
        uint64_t tokenBalance = getTotalBalance();
        
        PortfolioInfo info(_portfolioName, _portfolioDesc, &callerAddr[0]);
        std::string portfolioStr = info.toJson();
        
        
        

        (*portfolioStorge)[_portfolioName] = portfolioStr;
        DipcAssert(totalToken.get() + tokenBalance > totalToken);
        (*portfolioBalance)[_portfolioName] = tokenBalance;
        *totalToken = totalToken.get() + tokenBalance; 
        
        DIPC_EMIT_EVENT(portfolioInfo, _portfolioName, &portfolioStr[0], "portfolioBalance", tokenBalance);
    }

    
    PAYABLE void PortfolioManage::depositPortfolio(char* _portfolioName){
        uint64_t tokenBalance = getTotalBalance();
        
        uint64_t currentBalance = portfolioBalance.get()[_portfolioName];
        uint64_t finalBalance  = currentBalance + tokenBalance;
        DipcAssert(totalToken.get() + tokenBalance > totalToken);
        DipcAssert(finalBalance > currentBalance);
        (*portfolioBalance)[_portfolioName] = finalBalance;
        *totalToken = totalToken.get() + finalBalance; 
        DIPC_EMIT_EVENT(depositPortfolio, "portfolioName", _portfolioName, "portfolioBalance", finalBalance);
    }
    
    PAYABLE void PortfolioManage::createOrder(char* _portfolioName, char* _orderId, uint16_t _orderType, char* _stockCode, uint64_t _stockPrice, uint64_t _stockAmount, uint64_t _endTime){
        uint64_t tokenBalance = getTotalBalance();
        DIPC_EMIT_EVENT(createOrder, "portfolioName", _portfolioName, "OrderInfo", "ignore", "tokenBalance", tokenBalance);
        uint64_t spent = 0;
        if(_orderType == 1){
            spent = _stockPrice * _stockAmount;
            DipcAssert((portfolioBalance.get()[_portfolioName] + tokenBalance) > spent);
        }
        struct Order order{_orderId, _orderType, _stockCode, _stockPrice, _stockAmount, _endTime, 0};
        std::string pInfo = portfolioStorge.get()[_portfolioName];
        
        
        
        if(pInfo == "") {
            DIPC_EMIT_EVENT(ErrEvent, "Current portfolio  doesn't exist: ", _portfolioName);
            return;
        }
        PortfolioInfo info;
        info.parseJson(pInfo);
        if(info.getOrder(_orderId).orderId != ""){
            DIPC_EMIT_EVENT(ErrEvent, "Current order exist: ", _orderId);
            return;
        }
        info.addOrder(order);
        pInfo = info.toJson();

        uint64_t currentBalance = portfolioBalance.get()[_portfolioName] ;
        uint64_t finalBalance = currentBalance + tokenBalance - spent;
        DipcAssert(totalToken.get() + tokenBalance > totalToken);
        
        DipcAssert(ownerTotalToken.get() < ownerTotalToken.get() + spent);
        (*portfolioStorge)[_portfolioName] = &pInfo[0];
        
        
        
        


        (*portfolioBalance)[_portfolioName] = finalBalance;
        *totalToken = totalToken.get() + finalBalance; 
        *ownerTotalToken = ownerTotalToken.get() + spent;
        DIPC_EMIT_EVENT(createOrder, "portfolioName", _portfolioName, "OrderInfo", &order.toJson()[0], "portfolioBalance", finalBalance);
    }

    
    EXPORT void PortfolioManage::dealOrder(char* _portfolioName, char* _orderId){
        isOwner();
        std::string pInfo = portfolioStorge.get()[_portfolioName];
        
        
        PortfolioInfo info;
        info.parseJson(pInfo);
        

        
         Order ord = info.getOrder(_orderId);
         
         
        if(ord.orderId != "" && ord.orderStatus == 0){
            
            uint64_t timenow = dipc::timestamp();
            if(ord.endTime > timenow){
                ord.orderStatus = 1;
            }else {
                ord.orderStatus = 3;
            }
        } else {
          

            return;
        }
        

        uint64_t sellValue = 0;
        if(ord.orderType == 0){
            sellValue = ord.stockAmount * ord.stockPrice;
        }
        uint64_t currentBalance =  portfolioBalance.get()[_portfolioName];
        

        DipcAssert(currentBalance + sellValue >= currentBalance);
        DipcAssert((ownerTotalToken.get() - sellValue) <= ownerTotalToken.get());
        


        (*portfolioBalance)[_portfolioName] = currentBalance + sellValue;
        *ownerTotalToken = ownerTotalToken.get() - sellValue;
        (*portfolioStorge)[_portfolioName] = &info.toJson()[0];
        
        
        
        

        DIPC_EMIT_EVENT(dealPortfolio, "orderId", _orderId, "orderInfo", &ord.toJson()[0]);
    }
    
    EXPORT void PortfolioManage::revocationOrder(char* _portfolioName, char* _orderId){
        std::string pInfo = portfolioStorge.get()[_portfolioName];
        
        
        PortfolioInfo info;
        info.parseJson(pInfo);
        Order ord = info.getOrder(_orderId);
        
        
        if(ord.orderId != "" && ord.orderStatus == 0){
            std::string callerStr = caller().toString();
            
            
            
            DipcAssert(info.getOwnerAddress() == caller().toString());
            

            uint64_t timenow = dipc::timestamp();
            if(ord.endTime > timenow){
                ord.orderStatus = 2;
            }else {
                ord.orderStatus = 3;
            }
        } else {
            return;
        }
        uint64_t lockToken = 0;
        if(ord.orderType == 1){
            lockToken = ord.stockPrice * ord.stockAmount;
        }
        uint64_t currentBalance =  portfolioBalance.get()[_portfolioName];
        
        
        
        

        DipcAssert(currentBalance + lockToken >= currentBalance);
        DipcAssert(ownerTotalToken.get() - lockToken <= ownerTotalToken.get());

        
        (*portfolioBalance)[_portfolioName] = currentBalance + lockToken;
        *ownerTotalToken = ownerTotalToken.get() - lockToken;
        (*portfolioStorge)[_portfolioName] = &info.toJson()[0];
        DIPC_EMIT_EVENT(revocationPortfolio, "orderId", _orderId, "orderInfo", &ord.toJson()[0]);
    }
    
    EXPORT void PortfolioManage::withdrawPortfolio(char* _portfolioName, uint64_t _withdrawBalance){
         if(!userCanWithdraw.get()){
             return;
         }
         uint64_t currentBalance =  portfolioBalance.get()[_portfolioName];
         DipcAssert(currentBalance - _withdrawBalance < currentBalance);
         auto coinBalance = changeUint64ToU256WithChangeRate(currentBalance, changeRate.get());
         (*portfolioBalance)[_portfolioName] = currentBalance - _withdrawBalance;
         callTransfer(caller(), coinBalance);
    }
    
    EXPORT void PortfolioManage::withdrawPool(uint64_t _balance){
        isOwner();
        Address ownerAddr = Address(owner.get()); 
        callTransfer(ownerAddr, _balance);
        *ownerTotalToken = ownerTotalToken.get() - _balance * changeRate.get();
        *totalToken = totalToken.get() - _balance * changeRate.get();
        DIPC_EMIT_EVENT(tokenCount, "ownerTotalToken", ownerTotalToken.get(), "totalToken", totalToken.get());
    }
    
    PAYABLE void PortfolioManage::depositPool(uint64_t _depositValue){
        isOwner();
        
        uint64_t tokenBalance = changeU256ToUint64WithChangeRate(callValue(), changeRate.get()); 
        *ownerTotalToken = ownerTotalToken.get() + tokenBalance;
        *totalToken = totalToken.get() + tokenBalance;
        DIPC_EMIT_EVENT(tokenCount, "ownerTotalToken", ownerTotalToken.get(), "totalToken", totalToken.get());
    }
     
    CONSTANT uint64_t PortfolioManage::queryTotalToken(){
        return totalToken.get();
    }

     
    CONSTANT uint64_t PortfolioManage::queryPortfolioBalance(char* _portfolioName){
        return portfolioBalance.get()[_portfolioName];
    }

    
    CONSTANT bool PortfolioManage::queryPortfolioNameIfUsed(char* _portfolioName){
        if(portfolioStorge.get()[_portfolioName] != ""){
            return true;
        } 
        return false;
    }

    
    CONSTANT uint64_t PortfolioManage::queryChangeRate(){
        return changeRate.get();
    }

2019-12-19_15:14:53.291322: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:513] s  first PAYABLE void PortfolioManage::depositPool(uint64_t _depositValue){
        isOwner();
        
        uint64_t tokenBalance = changeU256ToUint64WithChangeRate(callValue(), changeRate.get()); 
        *ownerTotalToken = ownerTotalToken.get() + tokenBalance;
        *totalToken = totalToken.get() + tokenBalance;
        DIPC_EMIT_EVENT(tokenCount, "ownerTotalToken", ownerTotalToken.get(), "totalToken", totalToken.get());
    }

2019-12-19_15:14:53.294278: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:599] search func : PAYABLE void PortfolioManage::depositPool(uint64_t _depositValue){
        isOwner();
        
        uint64_t tokenBalance = changeU256ToUint64WithChangeRate(callValue(), changeRate.get()); 
        *ownerTotalToken = ownerTotalToken.get() + tokenBalance;
        *totalToken = totalToken.get() + tokenBalance;
        DIPC_EMIT_EVENT(tokenCount, "ownerTotalToken", ownerTotalToken.get(), "totalToken", totalToken.get());
    }
2019-12-19_15:14:53.294288: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:424] finalContract  this height  #include "PortfolioManage.hpp"

    
    PAYABLE void PortfolioManage::init(){
        *owner = caller().toString();
        *changeRate = 10000;
        *userCanWithdraw = false;
        uint64_t tokenBalance = getTotalBalance();
        
        *ownerTotalToken = tokenBalance;
        *totalToken = ownerTotalToken.get();
        
        
        DIPC_EMIT_EVENT(initEvent, "ownerTotalToken" ,tokenBalance);
    }
    
     
    EXPORT void PortfolioManage::setChangeRate(uint64_t _changeRate){
        isOwner();
        *changeRate = _changeRate;
    }
     
    EXPORT void PortfolioManage::setUserCanWithdraw(bool _canWithdraw){
        isOwner();
        *userCanWithdraw = _canWithdraw;
    }

    
    PAYABLE void PortfolioManage::createPortfolio(char* _portfolioName, char* _portfolioDesc){
        if(portfolioStorge.get()[_portfolioName] != ""){
            DIPC_EMIT_EVENT(ErrEvent, "Current portfolio exist: ", _portfolioName);
            return;
        } 
        std::string callerAddr = caller().toString();
        uint64_t tokenBalance = getTotalBalance();
        
        PortfolioInfo info(_portfolioName, _portfolioDesc, &callerAddr[0]);
        std::string portfolioStr = info.toJson();
        
        
        

        (*portfolioStorge)[_portfolioName] = portfolioStr;
        DipcAssert(totalToken.get() + tokenBalance > totalToken);
        (*portfolioBalance)[_portfolioName] = tokenBalance;
        *totalToken = totalToken.get() + tokenBalance; 
        
        DIPC_EMIT_EVENT(portfolioInfo, _portfolioName, &portfolioStr[0], "portfolioBalance", tokenBalance);
    }

    
    PAYABLE void PortfolioManage::depositPortfolio(char* _portfolioName){
        uint64_t tokenBalance = getTotalBalance();
        
        uint64_t currentBalance = portfolioBalance.get()[_portfolioName];
        uint64_t finalBalance  = currentBalance + tokenBalance;
        DipcAssert(totalToken.get() + tokenBalance > totalToken);
        DipcAssert(finalBalance > currentBalance);
        (*portfolioBalance)[_portfolioName] = finalBalance;
        *totalToken = totalToken.get() + finalBalance; 
        DIPC_EMIT_EVENT(depositPortfolio, "portfolioName", _portfolioName, "portfolioBalance", finalBalance);
    }
    
    PAYABLE void PortfolioManage::createOrder(char* _portfolioName, char* _orderId, uint16_t _orderType, char* _stockCode, uint64_t _stockPrice, uint64_t _stockAmount, uint64_t _endTime){
        uint64_t tokenBalance = getTotalBalance();
        DIPC_EMIT_EVENT(createOrder, "portfolioName", _portfolioName, "OrderInfo", "ignore", "tokenBalance", tokenBalance);
        uint64_t spent = 0;
        if(_orderType == 1){
            spent = _stockPrice * _stockAmount;
            DipcAssert((portfolioBalance.get()[_portfolioName] + tokenBalance) > spent);
        }
        struct Order order{_orderId, _orderType, _stockCode, _stockPrice, _stockAmount, _endTime, 0};
        std::string pInfo = portfolioStorge.get()[_portfolioName];
        
        
        
        if(pInfo == "") {
            DIPC_EMIT_EVENT(ErrEvent, "Current portfolio  doesn't exist: ", _portfolioName);
            return;
        }
        PortfolioInfo info;
        info.parseJson(pInfo);
        if(info.getOrder(_orderId).orderId != ""){
            DIPC_EMIT_EVENT(ErrEvent, "Current order exist: ", _orderId);
            return;
        }
        info.addOrder(order);
        pInfo = info.toJson();

        uint64_t currentBalance = portfolioBalance.get()[_portfolioName] ;
        uint64_t finalBalance = currentBalance + tokenBalance - spent;
        DipcAssert(totalToken.get() + tokenBalance > totalToken);
        
        DipcAssert(ownerTotalToken.get() < ownerTotalToken.get() + spent);
        (*portfolioStorge)[_portfolioName] = &pInfo[0];
        
        
        
        


        (*portfolioBalance)[_portfolioName] = finalBalance;
        *totalToken = totalToken.get() + finalBalance; 
        *ownerTotalToken = ownerTotalToken.get() + spent;
        DIPC_EMIT_EVENT(createOrder, "portfolioName", _portfolioName, "OrderInfo", &order.toJson()[0], "portfolioBalance", finalBalance);
    }

    
    EXPORT void PortfolioManage::dealOrder(char* _portfolioName, char* _orderId){
        isOwner();
        std::string pInfo = portfolioStorge.get()[_portfolioName];
        
        
        PortfolioInfo info;
        info.parseJson(pInfo);
        

        
         Order ord = info.getOrder(_orderId);
         
         
        if(ord.orderId != "" && ord.orderStatus == 0){
            
            uint64_t timenow = dipc::timestamp();
            if(ord.endTime > timenow){
                ord.orderStatus = 1;
            }else {
                ord.orderStatus = 3;
            }
        } else {
          

            return;
        }
        

        uint64_t sellValue = 0;
        if(ord.orderType == 0){
            sellValue = ord.stockAmount * ord.stockPrice;
        }
        uint64_t currentBalance =  portfolioBalance.get()[_portfolioName];
        

        DipcAssert(currentBalance + sellValue >= currentBalance);
        DipcAssert((ownerTotalToken.get() - sellValue) <= ownerTotalToken.get());
        


        (*portfolioBalance)[_portfolioName] = currentBalance + sellValue;
        *ownerTotalToken = ownerTotalToken.get() - sellValue;
        (*portfolioStorge)[_portfolioName] = &info.toJson()[0];
        
        
        
        

        DIPC_EMIT_EVENT(dealPortfolio, "orderId", _orderId, "orderInfo", &ord.toJson()[0]);
    }
    
    EXPORT void PortfolioManage::revocationOrder(char* _portfolioName, char* _orderId){
        std::string pInfo = portfolioStorge.get()[_portfolioName];
        
        
        PortfolioInfo info;
        info.parseJson(pInfo);
        Order ord = info.getOrder(_orderId);
        
        
        if(ord.orderId != "" && ord.orderStatus == 0){
            std::string callerStr = caller().toString();
            
            
            
            DipcAssert(info.getOwnerAddress() == caller().toString());
            

            uint64_t timenow = dipc::timestamp();
            if(ord.endTime > timenow){
                ord.orderStatus = 2;
            }else {
                ord.orderStatus = 3;
            }
        } else {
            return;
        }
        uint64_t lockToken = 0;
        if(ord.orderType == 1){
            lockToken = ord.stockPrice * ord.stockAmount;
        }
        uint64_t currentBalance =  portfolioBalance.get()[_portfolioName];
        
        
        
        

        DipcAssert(currentBalance + lockToken >= currentBalance);
        DipcAssert(ownerTotalToken.get() - lockToken <= ownerTotalToken.get());

        
        (*portfolioBalance)[_portfolioName] = currentBalance + lockToken;
        *ownerTotalToken = ownerTotalToken.get() - lockToken;
        (*portfolioStorge)[_portfolioName] = &info.toJson()[0];
        DIPC_EMIT_EVENT(revocationPortfolio, "orderId", _orderId, "orderInfo", &ord.toJson()[0]);
    }
    
    EXPORT void PortfolioManage::withdrawPortfolio(char* _portfolioName, uint64_t _withdrawBalance){
         if(!userCanWithdraw.get()){
             return;
         }
         uint64_t currentBalance =  portfolioBalance.get()[_portfolioName];
         DipcAssert(currentBalance - _withdrawBalance < currentBalance);
         auto coinBalance = changeUint64ToU256WithChangeRate(currentBalance, changeRate.get());
         (*portfolioBalance)[_portfolioName] = currentBalance - _withdrawBalance;
         callTransfer(caller(), coinBalance);
    }
    
    EXPORT void PortfolioManage::withdrawPool(uint64_t _balance){
        isOwner();
        Address ownerAddr = Address(owner.get()); 
        callTransfer(ownerAddr, _balance);
        *ownerTotalToken = ownerTotalToken.get() - _balance * changeRate.get();
        *totalToken = totalToken.get() - _balance * changeRate.get();
        DIPC_EMIT_EVENT(tokenCount, "ownerTotalToken", ownerTotalToken.get(), "totalToken", totalToken.get());
    }
    
    PAYABLE void PortfolioManage::depositPool(uint64_t _depositValue){
        isOwner();
        
        uint64_t tokenBalance = changeU256ToUint64WithChangeRate(callValue(), changeRate.get()); 
        *ownerTotalToken = ownerTotalToken.get() + tokenBalance;
        *totalToken = totalToken.get() + tokenBalance;
        DIPC_EMIT_EVENT(tokenCount, "ownerTotalToken", ownerTotalToken.get(), "totalToken", totalToken.get());
    } codetext height #include "PortfolioManage.hpp"

    
    PAYABLE void PortfolioManage::init(){
        *owner = caller().toString();
        *changeRate = 10000;
        *userCanWithdraw = false;
        uint64_t tokenBalance = getTotalBalance();
        
        *ownerTotalToken = tokenBalance;
        *totalToken = ownerTotalToken.get();
        
        
        DIPC_EMIT_EVENT(initEvent, "ownerTotalToken" ,tokenBalance);
    }
    
     
    EXPORT void PortfolioManage::setChangeRate(uint64_t _changeRate){
        isOwner();
        *changeRate = _changeRate;
    }
     
    EXPORT void PortfolioManage::setUserCanWithdraw(bool _canWithdraw){
        isOwner();
        *userCanWithdraw = _canWithdraw;
    }

    
    PAYABLE void PortfolioManage::createPortfolio(char* _portfolioName, char* _portfolioDesc){
        if(portfolioStorge.get()[_portfolioName] != ""){
            DIPC_EMIT_EVENT(ErrEvent, "Current portfolio exist: ", _portfolioName);
            return;
        } 
        std::string callerAddr = caller().toString();
        uint64_t tokenBalance = getTotalBalance();
        
        PortfolioInfo info(_portfolioName, _portfolioDesc, &callerAddr[0]);
        std::string portfolioStr = info.toJson();
        
        
        

        (*portfolioStorge)[_portfolioName] = portfolioStr;
        DipcAssert(totalToken.get() + tokenBalance > totalToken);
        (*portfolioBalance)[_portfolioName] = tokenBalance;
        *totalToken = totalToken.get() + tokenBalance; 
        
        DIPC_EMIT_EVENT(portfolioInfo, _portfolioName, &portfolioStr[0], "portfolioBalance", tokenBalance);
    }

    
    PAYABLE void PortfolioManage::depositPortfolio(char* _portfolioName){
        uint64_t tokenBalance = getTotalBalance();
        
        uint64_t currentBalance = portfolioBalance.get()[_portfolioName];
        uint64_t finalBalance  = currentBalance + tokenBalance;
        DipcAssert(totalToken.get() + tokenBalance > totalToken);
        DipcAssert(finalBalance > currentBalance);
        (*portfolioBalance)[_portfolioName] = finalBalance;
        *totalToken = totalToken.get() + finalBalance; 
        DIPC_EMIT_EVENT(depositPortfolio, "portfolioName", _portfolioName, "portfolioBalance", finalBalance);
    }
    
    PAYABLE void PortfolioManage::createOrder(char* _portfolioName, char* _orderId, uint16_t _orderType, char* _stockCode, uint64_t _stockPrice, uint64_t _stockAmount, uint64_t _endTime){
        uint64_t tokenBalance = getTotalBalance();
        DIPC_EMIT_EVENT(createOrder, "portfolioName", _portfolioName, "OrderInfo", "ignore", "tokenBalance", tokenBalance);
        uint64_t spent = 0;
        if(_orderType == 1){
            spent = _stockPrice * _stockAmount;
            DipcAssert((portfolioBalance.get()[_portfolioName] + tokenBalance) > spent);
        }
        struct Order order{_orderId, _orderType, _stockCode, _stockPrice, _stockAmount, _endTime, 0};
        std::string pInfo = portfolioStorge.get()[_portfolioName];
        
        
        
        if(pInfo == "") {
            DIPC_EMIT_EVENT(ErrEvent, "Current portfolio  doesn't exist: ", _portfolioName);
            return;
        }
        PortfolioInfo info;
        info.parseJson(pInfo);
        if(info.getOrder(_orderId).orderId != ""){
            DIPC_EMIT_EVENT(ErrEvent, "Current order exist: ", _orderId);
            return;
        }
        info.addOrder(order);
        pInfo = info.toJson();

        uint64_t currentBalance = portfolioBalance.get()[_portfolioName] ;
        uint64_t finalBalance = currentBalance + tokenBalance - spent;
        DipcAssert(totalToken.get() + tokenBalance > totalToken);
        
        DipcAssert(ownerTotalToken.get() < ownerTotalToken.get() + spent);
        (*portfolioStorge)[_portfolioName] = &pInfo[0];
        
        
        
        


        (*portfolioBalance)[_portfolioName] = finalBalance;
        *totalToken = totalToken.get() + finalBalance; 
        *ownerTotalToken = ownerTotalToken.get() + spent;
        DIPC_EMIT_EVENT(createOrder, "portfolioName", _portfolioName, "OrderInfo", &order.toJson()[0], "portfolioBalance", finalBalance);
    }

    
    EXPORT void PortfolioManage::dealOrder(char* _portfolioName, char* _orderId){
        isOwner();
        std::string pInfo = portfolioStorge.get()[_portfolioName];
        
        
        PortfolioInfo info;
        info.parseJson(pInfo);
        

        
         Order ord = info.getOrder(_orderId);
         
         
        if(ord.orderId != "" && ord.orderStatus == 0){
            
            uint64_t timenow = dipc::timestamp();
            if(ord.endTime > timenow){
                ord.orderStatus = 1;
            }else {
                ord.orderStatus = 3;
            }
        } else {
          

            return;
        }
        

        uint64_t sellValue = 0;
        if(ord.orderType == 0){
            sellValue = ord.stockAmount * ord.stockPrice;
        }
        uint64_t currentBalance =  portfolioBalance.get()[_portfolioName];
        

        DipcAssert(currentBalance + sellValue >= currentBalance);
        DipcAssert((ownerTotalToken.get() - sellValue) <= ownerTotalToken.get());
        


        (*portfolioBalance)[_portfolioName] = currentBalance + sellValue;
        *ownerTotalToken = ownerTotalToken.get() - sellValue;
        (*portfolioStorge)[_portfolioName] = &info.toJson()[0];
        
        
        
        

        DIPC_EMIT_EVENT(dealPortfolio, "orderId", _orderId, "orderInfo", &ord.toJson()[0]);
    }
    
    EXPORT void PortfolioManage::revocationOrder(char* _portfolioName, char* _orderId){
        std::string pInfo = portfolioStorge.get()[_portfolioName];
        
        
        PortfolioInfo info;
        info.parseJson(pInfo);
        Order ord = info.getOrder(_orderId);
        
        
        if(ord.orderId != "" && ord.orderStatus == 0){
            std::string callerStr = caller().toString();
            
            
            
            DipcAssert(info.getOwnerAddress() == caller().toString());
            

            uint64_t timenow = dipc::timestamp();
            if(ord.endTime > timenow){
                ord.orderStatus = 2;
            }else {
                ord.orderStatus = 3;
            }
        } else {
            return;
        }
        uint64_t lockToken = 0;
        if(ord.orderType == 1){
            lockToken = ord.stockPrice * ord.stockAmount;
        }
        uint64_t currentBalance =  portfolioBalance.get()[_portfolioName];
        
        
        
        

        DipcAssert(currentBalance + lockToken >= currentBalance);
        DipcAssert(ownerTotalToken.get() - lockToken <= ownerTotalToken.get());

        
        (*portfolioBalance)[_portfolioName] = currentBalance + lockToken;
        *ownerTotalToken = ownerTotalToken.get() - lockToken;
        (*portfolioStorge)[_portfolioName] = &info.toJson()[0];
        DIPC_EMIT_EVENT(revocationPortfolio, "orderId", _orderId, "orderInfo", &ord.toJson()[0]);
    }
    
    EXPORT void PortfolioManage::withdrawPortfolio(char* _portfolioName, uint64_t _withdrawBalance){
         if(!userCanWithdraw.get()){
             return;
         }
         uint64_t currentBalance =  portfolioBalance.get()[_portfolioName];
         DipcAssert(currentBalance - _withdrawBalance < currentBalance);
         auto coinBalance = changeUint64ToU256WithChangeRate(currentBalance, changeRate.get());
         (*portfolioBalance)[_portfolioName] = currentBalance - _withdrawBalance;
         callTransfer(caller(), coinBalance);
    }
    
    EXPORT void PortfolioManage::withdrawPool(uint64_t _balance){
        isOwner();
        Address ownerAddr = Address(owner.get()); 
        callTransfer(ownerAddr, _balance);
        *ownerTotalToken = ownerTotalToken.get() - _balance * changeRate.get();
        *totalToken = totalToken.get() - _balance * changeRate.get();
        DIPC_EMIT_EVENT(tokenCount, "ownerTotalToken", ownerTotalToken.get(), "totalToken", totalToken.get());
    }
    
    PAYABLE void PortfolioManage::depositPool(uint64_t _depositValue){
        isOwner();
        
        uint64_t tokenBalance = changeU256ToUint64WithChangeRate(callValue(), changeRate.get()); 
        *ownerTotalToken = ownerTotalToken.get() + tokenBalance;
        *totalToken = totalToken.get() + tokenBalance;
        DIPC_EMIT_EVENT(tokenCount, "ownerTotalToken", ownerTotalToken.get(), "totalToken", totalToken.get());
    }
     
    CONSTANT uint64_t PortfolioManage::queryTotalToken(){
        return totalToken.get();
    }

     
    CONSTANT uint64_t PortfolioManage::queryPortfolioBalance(char* _portfolioName){
        return portfolioBalance.get()[_portfolioName];
    }

    
    CONSTANT bool PortfolioManage::queryPortfolioNameIfUsed(char* _portfolioName){
        if(portfolioStorge.get()[_portfolioName] != ""){
            return true;
        } 
        return false;
    }

    
    CONSTANT uint64_t PortfolioManage::queryChangeRate(){
        return changeRate.get();
    }

2019-12-19_15:14:53.294299: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:427] searchContext  
     
    CONSTANT uint64_t PortfolioManage::queryTotalToken(){
        return totalToken.get();
    }

     
    CONSTANT uint64_t PortfolioManage::queryPortfolioBalance(char* _portfolioName){
        return portfolioBalance.get()[_portfolioName];
    }

    
    CONSTANT bool PortfolioManage::queryPortfolioNameIfUsed(char* _portfolioName){
        if(portfolioStorge.get()[_portfolioName] != ""){
            return true;
        } 
        return false;
    }

    
    CONSTANT uint64_t PortfolioManage::queryChangeRate(){
        return changeRate.get();
    }

2019-12-19_15:14:53.294502: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:442] finalContract  this new  #include "PortfolioManage.hpp"

    
    PAYABLE void PortfolioManage::init(){
        *owner = caller().toString();
        *changeRate = 10000;
        *userCanWithdraw = false;
        uint64_t tokenBalance = getTotalBalance();
        
        *ownerTotalToken = tokenBalance;
        *totalToken = ownerTotalToken.get();
        
        
        DIPC_EMIT_EVENT(initEvent, "ownerTotalToken" ,tokenBalance);
    }
    
     
    EXPORT void PortfolioManage::setChangeRate(uint64_t _changeRate){
        isOwner();
        *changeRate = _changeRate;
    }
     
    EXPORT void PortfolioManage::setUserCanWithdraw(bool _canWithdraw){
        isOwner();
        *userCanWithdraw = _canWithdraw;
    }

    
    PAYABLE void PortfolioManage::createPortfolio(char* _portfolioName, char* _portfolioDesc){
        if(portfolioStorge.get()[_portfolioName] != ""){
            DIPC_EMIT_EVENT(ErrEvent, "Current portfolio exist: ", _portfolioName);
            return;
        } 
        std::string callerAddr = caller().toString();
        uint64_t tokenBalance = getTotalBalance();
        
        PortfolioInfo info(_portfolioName, _portfolioDesc, &callerAddr[0]);
        std::string portfolioStr = info.toJson();
        
        
        

        (*portfolioStorge)[_portfolioName] = portfolioStr;
        DipcAssert(totalToken.get() + tokenBalance > totalToken);
        (*portfolioBalance)[_portfolioName] = tokenBalance;
        *totalToken = totalToken.get() + tokenBalance; 
        
        DIPC_EMIT_EVENT(portfolioInfo, _portfolioName, &portfolioStr[0], "portfolioBalance", tokenBalance);
    }

    
    PAYABLE void PortfolioManage::depositPortfolio(char* _portfolioName){
        uint64_t tokenBalance = getTotalBalance();
        
        uint64_t currentBalance = portfolioBalance.get()[_portfolioName];
        uint64_t finalBalance  = currentBalance + tokenBalance;
        DipcAssert(totalToken.get() + tokenBalance > totalToken);
        DipcAssert(finalBalance > currentBalance);
        (*portfolioBalance)[_portfolioName] = finalBalance;
        *totalToken = totalToken.get() + finalBalance; 
        DIPC_EMIT_EVENT(depositPortfolio, "portfolioName", _portfolioName, "portfolioBalance", finalBalance);
    }
    
    PAYABLE void PortfolioManage::createOrder(char* _portfolioName, char* _orderId, uint16_t _orderType, char* _stockCode, uint64_t _stockPrice, uint64_t _stockAmount, uint64_t _endTime){
        uint64_t tokenBalance = getTotalBalance();
        DIPC_EMIT_EVENT(createOrder, "portfolioName", _portfolioName, "OrderInfo", "ignore", "tokenBalance", tokenBalance);
        uint64_t spent = 0;
        if(_orderType == 1){
            spent = _stockPrice * _stockAmount;
            DipcAssert((portfolioBalance.get()[_portfolioName] + tokenBalance) > spent);
        }
        struct Order order{_orderId, _orderType, _stockCode, _stockPrice, _stockAmount, _endTime, 0};
        std::string pInfo = portfolioStorge.get()[_portfolioName];
        
        
        
        if(pInfo == "") {
            DIPC_EMIT_EVENT(ErrEvent, "Current portfolio  doesn't exist: ", _portfolioName);
            return;
        }
        PortfolioInfo info;
        info.parseJson(pInfo);
        if(info.getOrder(_orderId).orderId != ""){
            DIPC_EMIT_EVENT(ErrEvent, "Current order exist: ", _orderId);
            return;
        }
        info.addOrder(order);
        pInfo = info.toJson();

        uint64_t currentBalance = portfolioBalance.get()[_portfolioName] ;
        uint64_t finalBalance = currentBalance + tokenBalance - spent;
        DipcAssert(totalToken.get() + tokenBalance > totalToken);
        
        DipcAssert(ownerTotalToken.get() < ownerTotalToken.get() + spent);
        (*portfolioStorge)[_portfolioName] = &pInfo[0];
        
        
        
        


        (*portfolioBalance)[_portfolioName] = finalBalance;
        *totalToken = totalToken.get() + finalBalance; 
        *ownerTotalToken = ownerTotalToken.get() + spent;
        DIPC_EMIT_EVENT(createOrder, "portfolioName", _portfolioName, "OrderInfo", &order.toJson()[0], "portfolioBalance", finalBalance);
    }

    
    EXPORT void PortfolioManage::dealOrder(char* _portfolioName, char* _orderId){
        isOwner();
        std::string pInfo = portfolioStorge.get()[_portfolioName];
        
        
        PortfolioInfo info;
        info.parseJson(pInfo);
        

        
         Order ord = info.getOrder(_orderId);
         
         
        if(ord.orderId != "" && ord.orderStatus == 0){
            
            uint64_t timenow = dipc::timestamp();
            if(ord.endTime > timenow){
                ord.orderStatus = 1;
            }else {
                ord.orderStatus = 3;
            }
        } else {
          

            return;
        }
        

        uint64_t sellValue = 0;
        if(ord.orderType == 0){
            sellValue = ord.stockAmount * ord.stockPrice;
        }
        uint64_t currentBalance =  portfolioBalance.get()[_portfolioName];
        

        DipcAssert(currentBalance + sellValue >= currentBalance);
        DipcAssert((ownerTotalToken.get() - sellValue) <= ownerTotalToken.get());
        


        (*portfolioBalance)[_portfolioName] = currentBalance + sellValue;
        *ownerTotalToken = ownerTotalToken.get() - sellValue;
        (*portfolioStorge)[_portfolioName] = &info.toJson()[0];
        
        
        
        

        DIPC_EMIT_EVENT(dealPortfolio, "orderId", _orderId, "orderInfo", &ord.toJson()[0]);
    }
    
    EXPORT void PortfolioManage::revocationOrder(char* _portfolioName, char* _orderId){
        std::string pInfo = portfolioStorge.get()[_portfolioName];
        
        
        PortfolioInfo info;
        info.parseJson(pInfo);
        Order ord = info.getOrder(_orderId);
        
        
        if(ord.orderId != "" && ord.orderStatus == 0){
            std::string callerStr = caller().toString();
            
            
            
            DipcAssert(info.getOwnerAddress() == caller().toString());
            

            uint64_t timenow = dipc::timestamp();
            if(ord.endTime > timenow){
                ord.orderStatus = 2;
            }else {
                ord.orderStatus = 3;
            }
        } else {
            return;
        }
        uint64_t lockToken = 0;
        if(ord.orderType == 1){
            lockToken = ord.stockPrice * ord.stockAmount;
        }
        uint64_t currentBalance =  portfolioBalance.get()[_portfolioName];
        
        
        
        

        DipcAssert(currentBalance + lockToken >= currentBalance);
        DipcAssert(ownerTotalToken.get() - lockToken <= ownerTotalToken.get());

        
        (*portfolioBalance)[_portfolioName] = currentBalance + lockToken;
        *ownerTotalToken = ownerTotalToken.get() - lockToken;
        (*portfolioStorge)[_portfolioName] = &info.toJson()[0];
        DIPC_EMIT_EVENT(revocationPortfolio, "orderId", _orderId, "orderInfo", &ord.toJson()[0]);
    }
    
    EXPORT void PortfolioManage::withdrawPortfolio(char* _portfolioName, uint64_t _withdrawBalance){
         if(!userCanWithdraw.get()){
             return;
         }
         uint64_t currentBalance =  portfolioBalance.get()[_portfolioName];
         DipcAssert(currentBalance - _withdrawBalance < currentBalance);
         auto coinBalance = changeUint64ToU256WithChangeRate(currentBalance, changeRate.get());
         (*portfolioBalance)[_portfolioName] = currentBalance - _withdrawBalance;
         callTransfer(caller(), coinBalance);
    }
    
    EXPORT void PortfolioManage::withdrawPool(uint64_t _balance){
        isOwner();
        Address ownerAddr = Address(owner.get()); 
        callTransfer(ownerAddr, _balance);
        *ownerTotalToken = ownerTotalToken.get() - _balance * changeRate.get();
        *totalToken = totalToken.get() - _balance * changeRate.get();
        DIPC_EMIT_EVENT(tokenCount, "ownerTotalToken", ownerTotalToken.get(), "totalToken", totalToken.get());
    }
    
    PAYABLE void PortfolioManage::depositPool(uint64_t _depositValue){
        isOwner();
        
        uint64_t tokenBalance = changeU256ToUint64WithChangeRate(callValue(), changeRate.get()); 
        *ownerTotalToken = ownerTotalToken.get() + tokenBalance;
        *totalToken = totalToken.get() + tokenBalance;
        DIPC_EMIT_EVENT(tokenCount, "ownerTotalToken", ownerTotalToken.get(), "totalToken", totalToken.get());
    } codetext new #include "PortfolioManage.hpp"

    
    PAYABLE void PortfolioManage::init(){
        *owner = caller().toString();
        *changeRate = 10000;
        *userCanWithdraw = false;
        uint64_t tokenBalance = getTotalBalance();
        
        *ownerTotalToken = tokenBalance;
        *totalToken = ownerTotalToken.get();
        
        
        DIPC_EMIT_EVENT(initEvent, "ownerTotalToken" ,tokenBalance);
    }
    
     
    EXPORT void PortfolioManage::setChangeRate(uint64_t _changeRate){
        isOwner();
        *changeRate = _changeRate;
    }
     
    EXPORT void PortfolioManage::setUserCanWithdraw(bool _canWithdraw){
        isOwner();
        *userCanWithdraw = _canWithdraw;
    }

    
    PAYABLE void PortfolioManage::createPortfolio(char* _portfolioName, char* _portfolioDesc){
        if(portfolioStorge.get()[_portfolioName] != ""){
            DIPC_EMIT_EVENT(ErrEvent, "Current portfolio exist: ", _portfolioName);
            return;
        } 
        std::string callerAddr = caller().toString();
        uint64_t tokenBalance = getTotalBalance();
        
        PortfolioInfo info(_portfolioName, _portfolioDesc, &callerAddr[0]);
        std::string portfolioStr = info.toJson();
        
        
        

        (*portfolioStorge)[_portfolioName] = portfolioStr;
        DipcAssert(totalToken.get() + tokenBalance > totalToken);
        (*portfolioBalance)[_portfolioName] = tokenBalance;
        *totalToken = totalToken.get() + tokenBalance; 
        
        DIPC_EMIT_EVENT(portfolioInfo, _portfolioName, &portfolioStr[0], "portfolioBalance", tokenBalance);
    }

    
    PAYABLE void PortfolioManage::depositPortfolio(char* _portfolioName){
        uint64_t tokenBalance = getTotalBalance();
        
        uint64_t currentBalance = portfolioBalance.get()[_portfolioName];
        uint64_t finalBalance  = currentBalance + tokenBalance;
        DipcAssert(totalToken.get() + tokenBalance > totalToken);
        DipcAssert(finalBalance > currentBalance);
        (*portfolioBalance)[_portfolioName] = finalBalance;
        *totalToken = totalToken.get() + finalBalance; 
        DIPC_EMIT_EVENT(depositPortfolio, "portfolioName", _portfolioName, "portfolioBalance", finalBalance);
    }
    
    PAYABLE void PortfolioManage::createOrder(char* _portfolioName, char* _orderId, uint16_t _orderType, char* _stockCode, uint64_t _stockPrice, uint64_t _stockAmount, uint64_t _endTime){
        uint64_t tokenBalance = getTotalBalance();
        DIPC_EMIT_EVENT(createOrder, "portfolioName", _portfolioName, "OrderInfo", "ignore", "tokenBalance", tokenBalance);
        uint64_t spent = 0;
        if(_orderType == 1){
            spent = _stockPrice * _stockAmount;
            DipcAssert((portfolioBalance.get()[_portfolioName] + tokenBalance) > spent);
        }
        struct Order order{_orderId, _orderType, _stockCode, _stockPrice, _stockAmount, _endTime, 0};
        std::string pInfo = portfolioStorge.get()[_portfolioName];
        
        
        
        if(pInfo == "") {
            DIPC_EMIT_EVENT(ErrEvent, "Current portfolio  doesn't exist: ", _portfolioName);
            return;
        }
        PortfolioInfo info;
        info.parseJson(pInfo);
        if(info.getOrder(_orderId).orderId != ""){
            DIPC_EMIT_EVENT(ErrEvent, "Current order exist: ", _orderId);
            return;
        }
        info.addOrder(order);
        pInfo = info.toJson();

        uint64_t currentBalance = portfolioBalance.get()[_portfolioName] ;
        uint64_t finalBalance = currentBalance + tokenBalance - spent;
        DipcAssert(totalToken.get() + tokenBalance > totalToken);
        
        DipcAssert(ownerTotalToken.get() < ownerTotalToken.get() + spent);
        (*portfolioStorge)[_portfolioName] = &pInfo[0];
        
        
        
        


        (*portfolioBalance)[_portfolioName] = finalBalance;
        *totalToken = totalToken.get() + finalBalance; 
        *ownerTotalToken = ownerTotalToken.get() + spent;
        DIPC_EMIT_EVENT(createOrder, "portfolioName", _portfolioName, "OrderInfo", &order.toJson()[0], "portfolioBalance", finalBalance);
    }

    
    EXPORT void PortfolioManage::dealOrder(char* _portfolioName, char* _orderId){
        isOwner();
        std::string pInfo = portfolioStorge.get()[_portfolioName];
        
        
        PortfolioInfo info;
        info.parseJson(pInfo);
        

        
         Order ord = info.getOrder(_orderId);
         
         
        if(ord.orderId != "" && ord.orderStatus == 0){
            
            uint64_t timenow = dipc::timestamp();
            if(ord.endTime > timenow){
                ord.orderStatus = 1;
            }else {
                ord.orderStatus = 3;
            }
        } else {
          

            return;
        }
        

        uint64_t sellValue = 0;
        if(ord.orderType == 0){
            sellValue = ord.stockAmount * ord.stockPrice;
        }
        uint64_t currentBalance =  portfolioBalance.get()[_portfolioName];
        

        DipcAssert(currentBalance + sellValue >= currentBalance);
        DipcAssert((ownerTotalToken.get() - sellValue) <= ownerTotalToken.get());
        


        (*portfolioBalance)[_portfolioName] = currentBalance + sellValue;
        *ownerTotalToken = ownerTotalToken.get() - sellValue;
        (*portfolioStorge)[_portfolioName] = &info.toJson()[0];
        
        
        
        

        DIPC_EMIT_EVENT(dealPortfolio, "orderId", _orderId, "orderInfo", &ord.toJson()[0]);
    }
    
    EXPORT void PortfolioManage::revocationOrder(char* _portfolioName, char* _orderId){
        std::string pInfo = portfolioStorge.get()[_portfolioName];
        
        
        PortfolioInfo info;
        info.parseJson(pInfo);
        Order ord = info.getOrder(_orderId);
        
        
        if(ord.orderId != "" && ord.orderStatus == 0){
            std::string callerStr = caller().toString();
            
            
            
            DipcAssert(info.getOwnerAddress() == caller().toString());
            

            uint64_t timenow = dipc::timestamp();
            if(ord.endTime > timenow){
                ord.orderStatus = 2;
            }else {
                ord.orderStatus = 3;
            }
        } else {
            return;
        }
        uint64_t lockToken = 0;
        if(ord.orderType == 1){
            lockToken = ord.stockPrice * ord.stockAmount;
        }
        uint64_t currentBalance =  portfolioBalance.get()[_portfolioName];
        
        
        
        

        DipcAssert(currentBalance + lockToken >= currentBalance);
        DipcAssert(ownerTotalToken.get() - lockToken <= ownerTotalToken.get());

        
        (*portfolioBalance)[_portfolioName] = currentBalance + lockToken;
        *ownerTotalToken = ownerTotalToken.get() - lockToken;
        (*portfolioStorge)[_portfolioName] = &info.toJson()[0];
        DIPC_EMIT_EVENT(revocationPortfolio, "orderId", _orderId, "orderInfo", &ord.toJson()[0]);
    }
    
    EXPORT void PortfolioManage::withdrawPortfolio(char* _portfolioName, uint64_t _withdrawBalance){
         if(!userCanWithdraw.get()){
             return;
         }
         uint64_t currentBalance =  portfolioBalance.get()[_portfolioName];
         DipcAssert(currentBalance - _withdrawBalance < currentBalance);
         auto coinBalance = changeUint64ToU256WithChangeRate(currentBalance, changeRate.get());
         (*portfolioBalance)[_portfolioName] = currentBalance - _withdrawBalance;
         callTransfer(caller(), coinBalance);
    }
    
    EXPORT void PortfolioManage::withdrawPool(uint64_t _balance){
        isOwner();
        Address ownerAddr = Address(owner.get()); 
        callTransfer(ownerAddr, _balance);
        *ownerTotalToken = ownerTotalToken.get() - _balance * changeRate.get();
        *totalToken = totalToken.get() - _balance * changeRate.get();
        DIPC_EMIT_EVENT(tokenCount, "ownerTotalToken", ownerTotalToken.get(), "totalToken", totalToken.get());
    }
    
    PAYABLE void PortfolioManage::depositPool(uint64_t _depositValue){
        isOwner();
        
        uint64_t tokenBalance = changeU256ToUint64WithChangeRate(callValue(), changeRate.get()); 
        *ownerTotalToken = ownerTotalToken.get() + tokenBalance;
        *totalToken = totalToken.get() + tokenBalance;
        DIPC_EMIT_EVENT(tokenCount, "ownerTotalToken", ownerTotalToken.get(), "totalToken", totalToken.get());
    }
     
    CONSTANT uint64_t PortfolioManage::queryTotalToken(){
        return totalToken.get();
    }

     
    CONSTANT uint64_t PortfolioManage::queryPortfolioBalance(char* _portfolioName){
        return portfolioBalance.get()[_portfolioName];
    }

    
    CONSTANT bool PortfolioManage::queryPortfolioNameIfUsed(char* _portfolioName){
        if(portfolioStorge.get()[_portfolioName] != ""){
            return true;
        } 
        return false;
    }

    
    CONSTANT uint64_t PortfolioManage::queryChangeRate(){
        return changeRate.get();
    }

2019-12-19_15:14:53.294569: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:604] finalContract  final content =======   : #include "PortfolioManage.hpp"

    
    PAYABLE void PortfolioManage::init(){
        *owner = caller().toString();
        *changeRate = 10000;
        *userCanWithdraw = false;
        uint64_t tokenBalance = getTotalBalance();
        
        *ownerTotalToken = tokenBalance;
        *totalToken = ownerTotalToken.get();
        
        
        DIPC_EMIT_EVENT(initEvent, "ownerTotalToken" ,tokenBalance);
    }
    
     
    EXPORT void PortfolioManage::setChangeRate(uint64_t _changeRate){
        isOwner();
        *changeRate = _changeRate;
    }
     
    EXPORT void PortfolioManage::setUserCanWithdraw(bool _canWithdraw){
        isOwner();
        *userCanWithdraw = _canWithdraw;
    }

    
    PAYABLE void PortfolioManage::createPortfolio(char* _portfolioName, char* _portfolioDesc){
        if(portfolioStorge.get()[_portfolioName] != ""){
            DIPC_EMIT_EVENT(ErrEvent, "Current portfolio exist: ", _portfolioName);
            return;
        } 
        std::string callerAddr = caller().toString();
        uint64_t tokenBalance = getTotalBalance();
        
        PortfolioInfo info(_portfolioName, _portfolioDesc, &callerAddr[0]);
        std::string portfolioStr = info.toJson();
        
        
        

        (*portfolioStorge)[_portfolioName] = portfolioStr;
        DipcAssert(totalToken.get() + tokenBalance > totalToken);
        (*portfolioBalance)[_portfolioName] = tokenBalance;
        *totalToken = totalToken.get() + tokenBalance; 
        
        DIPC_EMIT_EVENT(portfolioInfo, _portfolioName, &portfolioStr[0], "portfolioBalance", tokenBalance);
    }

    
    PAYABLE void PortfolioManage::depositPortfolio(char* _portfolioName){
        uint64_t tokenBalance = getTotalBalance();
        
        uint64_t currentBalance = portfolioBalance.get()[_portfolioName];
        uint64_t finalBalance  = currentBalance + tokenBalance;
        DipcAssert(totalToken.get() + tokenBalance > totalToken);
        DipcAssert(finalBalance > currentBalance);
        (*portfolioBalance)[_portfolioName] = finalBalance;
        *totalToken = totalToken.get() + finalBalance; 
        DIPC_EMIT_EVENT(depositPortfolio, "portfolioName", _portfolioName, "portfolioBalance", finalBalance);
    }
    
    PAYABLE void PortfolioManage::createOrder(char* _portfolioName, char* _orderId, uint16_t _orderType, char* _stockCode, uint64_t _stockPrice, uint64_t _stockAmount, uint64_t _endTime){
        uint64_t tokenBalance = getTotalBalance();
        DIPC_EMIT_EVENT(createOrder, "portfolioName", _portfolioName, "OrderInfo", "ignore", "tokenBalance", tokenBalance);
        uint64_t spent = 0;
        if(_orderType == 1){
            spent = _stockPrice * _stockAmount;
            DipcAssert((portfolioBalance.get()[_portfolioName] + tokenBalance) > spent);
        }
        struct Order order{_orderId, _orderType, _stockCode, _stockPrice, _stockAmount, _endTime, 0};
        std::string pInfo = portfolioStorge.get()[_portfolioName];
        
        
        
        if(pInfo == "") {
            DIPC_EMIT_EVENT(ErrEvent, "Current portfolio  doesn't exist: ", _portfolioName);
            return;
        }
        PortfolioInfo info;
        info.parseJson(pInfo);
        if(info.getOrder(_orderId).orderId != ""){
            DIPC_EMIT_EVENT(ErrEvent, "Current order exist: ", _orderId);
            return;
        }
        info.addOrder(order);
        pInfo = info.toJson();

        uint64_t currentBalance = portfolioBalance.get()[_portfolioName] ;
        uint64_t finalBalance = currentBalance + tokenBalance - spent;
        DipcAssert(totalToken.get() + tokenBalance > totalToken);
        
        DipcAssert(ownerTotalToken.get() < ownerTotalToken.get() + spent);
        (*portfolioStorge)[_portfolioName] = &pInfo[0];
        
        
        
        


        (*portfolioBalance)[_portfolioName] = finalBalance;
        *totalToken = totalToken.get() + finalBalance; 
        *ownerTotalToken = ownerTotalToken.get() + spent;
        DIPC_EMIT_EVENT(createOrder, "portfolioName", _portfolioName, "OrderInfo", &order.toJson()[0], "portfolioBalance", finalBalance);
    }

    
    EXPORT void PortfolioManage::dealOrder(char* _portfolioName, char* _orderId){
        isOwner();
        std::string pInfo = portfolioStorge.get()[_portfolioName];
        
        
        PortfolioInfo info;
        info.parseJson(pInfo);
        

        
         Order ord = info.getOrder(_orderId);
         
         
        if(ord.orderId != "" && ord.orderStatus == 0){
            
            uint64_t timenow = dipc::timestamp();
            if(ord.endTime > timenow){
                ord.orderStatus = 1;
            }else {
                ord.orderStatus = 3;
            }
        } else {
          

            return;
        }
        

        uint64_t sellValue = 0;
        if(ord.orderType == 0){
            sellValue = ord.stockAmount * ord.stockPrice;
        }
        uint64_t currentBalance =  portfolioBalance.get()[_portfolioName];
        

        DipcAssert(currentBalance + sellValue >= currentBalance);
        DipcAssert((ownerTotalToken.get() - sellValue) <= ownerTotalToken.get());
        


        (*portfolioBalance)[_portfolioName] = currentBalance + sellValue;
        *ownerTotalToken = ownerTotalToken.get() - sellValue;
        (*portfolioStorge)[_portfolioName] = &info.toJson()[0];
        
        
        
        

        DIPC_EMIT_EVENT(dealPortfolio, "orderId", _orderId, "orderInfo", &ord.toJson()[0]);
    }
    
    EXPORT void PortfolioManage::revocationOrder(char* _portfolioName, char* _orderId){
        std::string pInfo = portfolioStorge.get()[_portfolioName];
        
        
        PortfolioInfo info;
        info.parseJson(pInfo);
        Order ord = info.getOrder(_orderId);
        
        
        if(ord.orderId != "" && ord.orderStatus == 0){
            std::string callerStr = caller().toString();
            
            
            
            DipcAssert(info.getOwnerAddress() == caller().toString());
            

            uint64_t timenow = dipc::timestamp();
            if(ord.endTime > timenow){
                ord.orderStatus = 2;
            }else {
                ord.orderStatus = 3;
            }
        } else {
            return;
        }
        uint64_t lockToken = 0;
        if(ord.orderType == 1){
            lockToken = ord.stockPrice * ord.stockAmount;
        }
        uint64_t currentBalance =  portfolioBalance.get()[_portfolioName];
        
        
        
        

        DipcAssert(currentBalance + lockToken >= currentBalance);
        DipcAssert(ownerTotalToken.get() - lockToken <= ownerTotalToken.get());

        
        (*portfolioBalance)[_portfolioName] = currentBalance + lockToken;
        *ownerTotalToken = ownerTotalToken.get() - lockToken;
        (*portfolioStorge)[_portfolioName] = &info.toJson()[0];
        DIPC_EMIT_EVENT(revocationPortfolio, "orderId", _orderId, "orderInfo", &ord.toJson()[0]);
    }
    
    EXPORT void PortfolioManage::withdrawPortfolio(char* _portfolioName, uint64_t _withdrawBalance){
         if(!userCanWithdraw.get()){
             return;
         }
         uint64_t currentBalance =  portfolioBalance.get()[_portfolioName];
         DipcAssert(currentBalance - _withdrawBalance < currentBalance);
         auto coinBalance = changeUint64ToU256WithChangeRate(currentBalance, changeRate.get());
         (*portfolioBalance)[_portfolioName] = currentBalance - _withdrawBalance;
         callTransfer(caller(), coinBalance);
    }
    
    EXPORT void PortfolioManage::withdrawPool(uint64_t _balance){
        isOwner();
        Address ownerAddr = Address(owner.get()); 
        callTransfer(ownerAddr, _balance);
        *ownerTotalToken = ownerTotalToken.get() - _balance * changeRate.get();
        *totalToken = totalToken.get() - _balance * changeRate.get();
        DIPC_EMIT_EVENT(tokenCount, "ownerTotalToken", ownerTotalToken.get(), "totalToken", totalToken.get());
    }
    
    PAYABLE void PortfolioManage::depositPool(uint64_t _depositValue){
        isOwner();
        
        uint64_t tokenBalance = changeU256ToUint64WithChangeRate(callValue(), changeRate.get()); 
        *ownerTotalToken = ownerTotalToken.get() + tokenBalance;
        *totalToken = totalToken.get() + tokenBalance;
        DIPC_EMIT_EVENT(tokenCount, "ownerTotalToken", ownerTotalToken.get(), "totalToken", totalToken.get());
    }
     
    CONSTANT uint64_t PortfolioManage::queryTotalToken(){
        return totalToken.get();
    }

     
    CONSTANT uint64_t PortfolioManage::queryPortfolioBalance(char* _portfolioName){
        return portfolioBalance.get()[_portfolioName];
    }

    
    CONSTANT bool PortfolioManage::queryPortfolioNameIfUsed(char* _portfolioName){
        if(portfolioStorge.get()[_portfolioName] != ""){
            return true;
        } 
        return false;
    }

    
    CONSTANT uint64_t PortfolioManage::queryChangeRate(){
        return changeRate.get();
    }

2019-12-19_15:14:53.294578: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:401] abis.ispayable :true

2019-12-19_15:14:53.294595: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:424] finalContract  this height  #include "PortfolioManage.hpp"

    
    PAYABLE void PortfolioManage::init(){
        *owner = caller().toString();
        *changeRate = 10000;
        *userCanWithdraw = false;
        uint64_t tokenBalance = getTotalBalance();
        
        *ownerTotalToken = tokenBalance;
        *totalToken = ownerTotalToken.get();
        
        
        DIPC_EMIT_EVENT(initEvent, "ownerTotalToken" ,tokenBalance);
    }
    
     
    EXPORT void PortfolioManage::setChangeRate(uint64_t _changeRate){
        isOwner();
        *changeRate = _changeRate;
    }
     
    EXPORT void PortfolioManage::setUserCanWithdraw(bool _canWithdraw){
        isOwner();
        *userCanWithdraw = _canWithdraw;
    }

    
    PAYABLE void PortfolioManage::createPortfolio(char* _portfolioName, char* _portfolioDesc){
        if(portfolioStorge.get()[_portfolioName] != ""){
            DIPC_EMIT_EVENT(ErrEvent, "Current portfolio exist: ", _portfolioName);
            return;
        } 
        std::string callerAddr = caller().toString();
        uint64_t tokenBalance = getTotalBalance();
        
        PortfolioInfo info(_portfolioName, _portfolioDesc, &callerAddr[0]);
        std::string portfolioStr = info.toJson();
        
        
        

        (*portfolioStorge)[_portfolioName] = portfolioStr;
        DipcAssert(totalToken.get() + tokenBalance > totalToken);
        (*portfolioBalance)[_portfolioName] = tokenBalance;
        *totalToken = totalToken.get() + tokenBalance; 
        
        DIPC_EMIT_EVENT(portfolioInfo, _portfolioName, &portfolioStr[0], "portfolioBalance", tokenBalance);
    }

    
    PAYABLE void PortfolioManage::depositPortfolio(char* _portfolioName){
        uint64_t tokenBalance = getTotalBalance();
        
        uint64_t currentBalance = portfolioBalance.get()[_portfolioName];
        uint64_t finalBalance  = currentBalance + tokenBalance;
        DipcAssert(totalToken.get() + tokenBalance > totalToken);
        DipcAssert(finalBalance > currentBalance);
        (*portfolioBalance)[_portfolioName] = finalBalance;
        *totalToken = totalToken.get() + finalBalance; 
        DIPC_EMIT_EVENT(depositPortfolio, "portfolioName", _portfolioName, "portfolioBalance", finalBalance);
    }
    
    PAYABLE void PortfolioManage::createOrder(char* _portfolioName, char* _orderId, uint16_t _orderType, char* _stockCode, uint64_t _stockPrice, uint64_t _stockAmount, uint64_t _endTime){
        uint64_t tokenBalance = getTotalBalance();
        DIPC_EMIT_EVENT(createOrder, "portfolioName", _portfolioName, "OrderInfo", "ignore", "tokenBalance", tokenBalance);
        uint64_t spent = 0;
        if(_orderType == 1){
            spent = _stockPrice * _stockAmount;
            DipcAssert((portfolioBalance.get()[_portfolioName] + tokenBalance) > spent);
        }
        struct Order order{_orderId, _orderType, _stockCode, _stockPrice, _stockAmount, _endTime, 0};
        std::string pInfo = portfolioStorge.get()[_portfolioName];
        
        
        
        if(pInfo == "") {
            DIPC_EMIT_EVENT(ErrEvent, "Current portfolio  doesn't exist: ", _portfolioName);
            return;
        }
        PortfolioInfo info;
        info.parseJson(pInfo);
        if(info.getOrder(_orderId).orderId != ""){
            DIPC_EMIT_EVENT(ErrEvent, "Current order exist: ", _orderId);
            return;
        }
        info.addOrder(order);
        pInfo = info.toJson();

        uint64_t currentBalance = portfolioBalance.get()[_portfolioName] ;
        uint64_t finalBalance = currentBalance + tokenBalance - spent;
        DipcAssert(totalToken.get() + tokenBalance > totalToken);
        
        DipcAssert(ownerTotalToken.get() < ownerTotalToken.get() + spent);
        (*portfolioStorge)[_portfolioName] = &pInfo[0];
        
        
        
        


        (*portfolioBalance)[_portfolioName] = finalBalance;
        *totalToken = totalToken.get() + finalBalance; 
        *ownerTotalToken = ownerTotalToken.get() + spent;
        DIPC_EMIT_EVENT(createOrder, "portfolioName", _portfolioName, "OrderInfo", &order.toJson()[0], "portfolioBalance", finalBalance);
    }

    
    EXPORT void PortfolioManage::dealOrder(char* _portfolioName, char* _orderId){
        isOwner();
        std::string pInfo = portfolioStorge.get()[_portfolioName];
        
        
        PortfolioInfo info;
        info.parseJson(pInfo);
        

        
         Order ord = info.getOrder(_orderId);
         
         
        if(ord.orderId != "" && ord.orderStatus == 0){
            
            uint64_t timenow = dipc::timestamp();
            if(ord.endTime > timenow){
                ord.orderStatus = 1;
            }else {
                ord.orderStatus = 3;
            }
        } else {
          

            return;
        }
        

        uint64_t sellValue = 0;
        if(ord.orderType == 0){
            sellValue = ord.stockAmount * ord.stockPrice;
        }
        uint64_t currentBalance =  portfolioBalance.get()[_portfolioName];
        

        DipcAssert(currentBalance + sellValue >= currentBalance);
        DipcAssert((ownerTotalToken.get() - sellValue) <= ownerTotalToken.get());
        


        (*portfolioBalance)[_portfolioName] = currentBalance + sellValue;
        *ownerTotalToken = ownerTotalToken.get() - sellValue;
        (*portfolioStorge)[_portfolioName] = &info.toJson()[0];
        
        
        
        

        DIPC_EMIT_EVENT(dealPortfolio, "orderId", _orderId, "orderInfo", &ord.toJson()[0]);
    }
    
    EXPORT void PortfolioManage::revocationOrder(char* _portfolioName, char* _orderId){
        std::string pInfo = portfolioStorge.get()[_portfolioName];
        
        
        PortfolioInfo info;
        info.parseJson(pInfo);
        Order ord = info.getOrder(_orderId);
        
        
        if(ord.orderId != "" && ord.orderStatus == 0){
            std::string callerStr = caller().toString();
            
            
            
            DipcAssert(info.getOwnerAddress() == caller().toString());
            

            uint64_t timenow = dipc::timestamp();
            if(ord.endTime > timenow){
                ord.orderStatus = 2;
            }else {
                ord.orderStatus = 3;
            }
        } else {
            return;
        }
        uint64_t lockToken = 0;
        if(ord.orderType == 1){
            lockToken = ord.stockPrice * ord.stockAmount;
        }
        uint64_t currentBalance =  portfolioBalance.get()[_portfolioName];
        
        
        
        

        DipcAssert(currentBalance + lockToken >= currentBalance);
        DipcAssert(ownerTotalToken.get() - lockToken <= ownerTotalToken.get());

        
        (*portfolioBalance)[_portfolioName] = currentBalance + lockToken;
        *ownerTotalToken = ownerTotalToken.get() - lockToken;
        (*portfolioStorge)[_portfolioName] = &info.toJson()[0];
        DIPC_EMIT_EVENT(revocationPortfolio, "orderId", _orderId, "orderInfo", &ord.toJson()[0]);
    }
    
    EXPORT void PortfolioManage::withdrawPortfolio(char* _portfolioName, uint64_t _withdrawBalance){
         if(!userCanWithdraw.get()){
             return;
         }
         uint64_t currentBalance =  portfolioBalance.get()[_portfolioName];
         DipcAssert(currentBalance - _withdrawBalance < currentBalance);
         auto coinBalance = changeUint64ToU256WithChangeRate(currentBalance, changeRate.get());
         (*portfolioBalance)[_portfolioName] = currentBalance - _withdrawBalance;
         callTransfer(caller(), coinBalance);
    }
    
    EXPORT void PortfolioManage::withdrawPool(uint64_t _balance){
        isOwner();
        Address ownerAddr = Address(owner.get()); 
        callTransfer(ownerAddr, _balance);
        *ownerTotalToken = ownerTotalToken.get() - _balance * changeRate.get();
        *totalToken = totalToken.get() - _balance * changeRate.get();
        DIPC_EMIT_EVENT(tokenCount, "ownerTotalToken", ownerTotalToken.get(), "totalToken", totalToken.get());
    }
    
    PAYABLE void PortfolioManage::depositPool(uint64_t _depositValue){
        isOwner();
        
        uint64_t tokenBalance = changeU256ToUint64WithChangeRate(callValue(), changeRate.get()); 
        *ownerTotalToken = ownerTotalToken.get() + tokenBalance;
        *totalToken = totalToken.get() + tokenBalance;
        DIPC_EMIT_EVENT(tokenCount, "ownerTotalToken", ownerTotalToken.get(), "totalToken", totalToken.get());
    }
     
    CONSTANT uint64_t PortfolioManage::queryTotalToken(){
        return totalToken.get();
    }

     
    CONSTANT uint64_t PortfolioManage::queryPortfolioBalance(char* _portfolioName){
        return portfolioBalance.get()[_portfolioName];
    }

    
    CONSTANT bool PortfolioManage::queryPortfolioNameIfUsed(char* _portfolioName){
        if(portfolioStorge.get()[_portfolioName] != ""){
            return true;
        } 
        return false;
    }

    
    CONSTANT uint64_t PortfolioManage::queryChangeRate(){
        return changeRate.get();
    } codetext height #include "PortfolioManage.hpp"

    
    PAYABLE void PortfolioManage::init(){
        *owner = caller().toString();
        *changeRate = 10000;
        *userCanWithdraw = false;
        uint64_t tokenBalance = getTotalBalance();
        
        *ownerTotalToken = tokenBalance;
        *totalToken = ownerTotalToken.get();
        
        
        DIPC_EMIT_EVENT(initEvent, "ownerTotalToken" ,tokenBalance);
    }
    
     
    EXPORT void PortfolioManage::setChangeRate(uint64_t _changeRate){
        isOwner();
        *changeRate = _changeRate;
    }
     
    EXPORT void PortfolioManage::setUserCanWithdraw(bool _canWithdraw){
        isOwner();
        *userCanWithdraw = _canWithdraw;
    }

    
    PAYABLE void PortfolioManage::createPortfolio(char* _portfolioName, char* _portfolioDesc){
        if(portfolioStorge.get()[_portfolioName] != ""){
            DIPC_EMIT_EVENT(ErrEvent, "Current portfolio exist: ", _portfolioName);
            return;
        } 
        std::string callerAddr = caller().toString();
        uint64_t tokenBalance = getTotalBalance();
        
        PortfolioInfo info(_portfolioName, _portfolioDesc, &callerAddr[0]);
        std::string portfolioStr = info.toJson();
        
        
        

        (*portfolioStorge)[_portfolioName] = portfolioStr;
        DipcAssert(totalToken.get() + tokenBalance > totalToken);
        (*portfolioBalance)[_portfolioName] = tokenBalance;
        *totalToken = totalToken.get() + tokenBalance; 
        
        DIPC_EMIT_EVENT(portfolioInfo, _portfolioName, &portfolioStr[0], "portfolioBalance", tokenBalance);
    }

    
    PAYABLE void PortfolioManage::depositPortfolio(char* _portfolioName){
        uint64_t tokenBalance = getTotalBalance();
        
        uint64_t currentBalance = portfolioBalance.get()[_portfolioName];
        uint64_t finalBalance  = currentBalance + tokenBalance;
        DipcAssert(totalToken.get() + tokenBalance > totalToken);
        DipcAssert(finalBalance > currentBalance);
        (*portfolioBalance)[_portfolioName] = finalBalance;
        *totalToken = totalToken.get() + finalBalance; 
        DIPC_EMIT_EVENT(depositPortfolio, "portfolioName", _portfolioName, "portfolioBalance", finalBalance);
    }
    
    PAYABLE void PortfolioManage::createOrder(char* _portfolioName, char* _orderId, uint16_t _orderType, char* _stockCode, uint64_t _stockPrice, uint64_t _stockAmount, uint64_t _endTime){
        uint64_t tokenBalance = getTotalBalance();
        DIPC_EMIT_EVENT(createOrder, "portfolioName", _portfolioName, "OrderInfo", "ignore", "tokenBalance", tokenBalance);
        uint64_t spent = 0;
        if(_orderType == 1){
            spent = _stockPrice * _stockAmount;
            DipcAssert((portfolioBalance.get()[_portfolioName] + tokenBalance) > spent);
        }
        struct Order order{_orderId, _orderType, _stockCode, _stockPrice, _stockAmount, _endTime, 0};
        std::string pInfo = portfolioStorge.get()[_portfolioName];
        
        
        
        if(pInfo == "") {
            DIPC_EMIT_EVENT(ErrEvent, "Current portfolio  doesn't exist: ", _portfolioName);
            return;
        }
        PortfolioInfo info;
        info.parseJson(pInfo);
        if(info.getOrder(_orderId).orderId != ""){
            DIPC_EMIT_EVENT(ErrEvent, "Current order exist: ", _orderId);
            return;
        }
        info.addOrder(order);
        pInfo = info.toJson();

        uint64_t currentBalance = portfolioBalance.get()[_portfolioName] ;
        uint64_t finalBalance = currentBalance + tokenBalance - spent;
        DipcAssert(totalToken.get() + tokenBalance > totalToken);
        
        DipcAssert(ownerTotalToken.get() < ownerTotalToken.get() + spent);
        (*portfolioStorge)[_portfolioName] = &pInfo[0];
        
        
        
        


        (*portfolioBalance)[_portfolioName] = finalBalance;
        *totalToken = totalToken.get() + finalBalance; 
        *ownerTotalToken = ownerTotalToken.get() + spent;
        DIPC_EMIT_EVENT(createOrder, "portfolioName", _portfolioName, "OrderInfo", &order.toJson()[0], "portfolioBalance", finalBalance);
    }

    
    EXPORT void PortfolioManage::dealOrder(char* _portfolioName, char* _orderId){
        isOwner();
        std::string pInfo = portfolioStorge.get()[_portfolioName];
        
        
        PortfolioInfo info;
        info.parseJson(pInfo);
        

        
         Order ord = info.getOrder(_orderId);
         
         
        if(ord.orderId != "" && ord.orderStatus == 0){
            
            uint64_t timenow = dipc::timestamp();
            if(ord.endTime > timenow){
                ord.orderStatus = 1;
            }else {
                ord.orderStatus = 3;
            }
        } else {
          

            return;
        }
        

        uint64_t sellValue = 0;
        if(ord.orderType == 0){
            sellValue = ord.stockAmount * ord.stockPrice;
        }
        uint64_t currentBalance =  portfolioBalance.get()[_portfolioName];
        

        DipcAssert(currentBalance + sellValue >= currentBalance);
        DipcAssert((ownerTotalToken.get() - sellValue) <= ownerTotalToken.get());
        


        (*portfolioBalance)[_portfolioName] = currentBalance + sellValue;
        *ownerTotalToken = ownerTotalToken.get() - sellValue;
        (*portfolioStorge)[_portfolioName] = &info.toJson()[0];
        
        
        
        

        DIPC_EMIT_EVENT(dealPortfolio, "orderId", _orderId, "orderInfo", &ord.toJson()[0]);
    }
    
    EXPORT void PortfolioManage::revocationOrder(char* _portfolioName, char* _orderId){
        std::string pInfo = portfolioStorge.get()[_portfolioName];
        
        
        PortfolioInfo info;
        info.parseJson(pInfo);
        Order ord = info.getOrder(_orderId);
        
        
        if(ord.orderId != "" && ord.orderStatus == 0){
            std::string callerStr = caller().toString();
            
            
            
            DipcAssert(info.getOwnerAddress() == caller().toString());
            

            uint64_t timenow = dipc::timestamp();
            if(ord.endTime > timenow){
                ord.orderStatus = 2;
            }else {
                ord.orderStatus = 3;
            }
        } else {
            return;
        }
        uint64_t lockToken = 0;
        if(ord.orderType == 1){
            lockToken = ord.stockPrice * ord.stockAmount;
        }
        uint64_t currentBalance =  portfolioBalance.get()[_portfolioName];
        
        
        
        

        DipcAssert(currentBalance + lockToken >= currentBalance);
        DipcAssert(ownerTotalToken.get() - lockToken <= ownerTotalToken.get());

        
        (*portfolioBalance)[_portfolioName] = currentBalance + lockToken;
        *ownerTotalToken = ownerTotalToken.get() - lockToken;
        (*portfolioStorge)[_portfolioName] = &info.toJson()[0];
        DIPC_EMIT_EVENT(revocationPortfolio, "orderId", _orderId, "orderInfo", &ord.toJson()[0]);
    }
    
    EXPORT void PortfolioManage::withdrawPortfolio(char* _portfolioName, uint64_t _withdrawBalance){
         if(!userCanWithdraw.get()){
             return;
         }
         uint64_t currentBalance =  portfolioBalance.get()[_portfolioName];
         DipcAssert(currentBalance - _withdrawBalance < currentBalance);
         auto coinBalance = changeUint64ToU256WithChangeRate(currentBalance, changeRate.get());
         (*portfolioBalance)[_portfolioName] = currentBalance - _withdrawBalance;
         callTransfer(caller(), coinBalance);
    }
    
    EXPORT void PortfolioManage::withdrawPool(uint64_t _balance){
        isOwner();
        Address ownerAddr = Address(owner.get()); 
        callTransfer(ownerAddr, _balance);
        *ownerTotalToken = ownerTotalToken.get() - _balance * changeRate.get();
        *totalToken = totalToken.get() - _balance * changeRate.get();
        DIPC_EMIT_EVENT(tokenCount, "ownerTotalToken", ownerTotalToken.get(), "totalToken", totalToken.get());
    }
    
    PAYABLE void PortfolioManage::depositPool(uint64_t _depositValue){
        isOwner();
        
        uint64_t tokenBalance = changeU256ToUint64WithChangeRate(callValue(), changeRate.get()); 
        *ownerTotalToken = ownerTotalToken.get() + tokenBalance;
        *totalToken = totalToken.get() + tokenBalance;
        DIPC_EMIT_EVENT(tokenCount, "ownerTotalToken", ownerTotalToken.get(), "totalToken", totalToken.get());
    }
     
    CONSTANT uint64_t PortfolioManage::queryTotalToken(){
        return totalToken.get();
    }

     
    CONSTANT uint64_t PortfolioManage::queryPortfolioBalance(char* _portfolioName){
        return portfolioBalance.get()[_portfolioName];
    }

    
    CONSTANT bool PortfolioManage::queryPortfolioNameIfUsed(char* _portfolioName){
        if(portfolioStorge.get()[_portfolioName] != ""){
            return true;
        } 
        return false;
    }

    
    CONSTANT uint64_t PortfolioManage::queryChangeRate(){
        return changeRate.get();
    }

2019-12-19_15:14:53.294605: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:427] searchContext  #include "PortfolioManage.hpp"

    
    PAYABLE void PortfolioManage::init(){
        *owner = caller().toString();
        *changeRate = 10000;
        *userCanWithdraw = false;
        uint64_t tokenBalance = getTotalBalance();
        
        *ownerTotalToken = tokenBalance;
        *totalToken = ownerTotalToken.get();
        
        
        DIPC_EMIT_EVENT(initEvent, "ownerTotalToken" ,tokenBalance);
    }
    
     
    EXPORT void PortfolioManage::setChangeRate(uint64_t _changeRate){
        isOwner();
        *changeRate = _changeRate;
    }
     
    EXPORT void PortfolioManage::setUserCanWithdraw(bool _canWithdraw){
        isOwner();
        *userCanWithdraw = _canWithdraw;
    }

    
    PAYABLE void PortfolioManage::createPortfolio(char* _portfolioName, char* _portfolioDesc){
        if(portfolioStorge.get()[_portfolioName] != ""){
            DIPC_EMIT_EVENT(ErrEvent, "Current portfolio exist: ", _portfolioName);
            return;
        } 
        std::string callerAddr = caller().toString();
        uint64_t tokenBalance = getTotalBalance();
        
        PortfolioInfo info(_portfolioName, _portfolioDesc, &callerAddr[0]);
        std::string portfolioStr = info.toJson();
        
        
        

        (*portfolioStorge)[_portfolioName] = portfolioStr;
        DipcAssert(totalToken.get() + tokenBalance > totalToken);
        (*portfolioBalance)[_portfolioName] = tokenBalance;
        *totalToken = totalToken.get() + tokenBalance; 
        
        DIPC_EMIT_EVENT(portfolioInfo, _portfolioName, &portfolioStr[0], "portfolioBalance", tokenBalance);
    }

    
    PAYABLE void PortfolioManage::depositPortfolio(char* _portfolioName){
        uint64_t tokenBalance = getTotalBalance();
        
        uint64_t currentBalance = portfolioBalance.get()[_portfolioName];
        uint64_t finalBalance  = currentBalance + tokenBalance;
        DipcAssert(totalToken.get() + tokenBalance > totalToken);
        DipcAssert(finalBalance > currentBalance);
        (*portfolioBalance)[_portfolioName] = finalBalance;
        *totalToken = totalToken.get() + finalBalance; 
        DIPC_EMIT_EVENT(depositPortfolio, "portfolioName", _portfolioName, "portfolioBalance", finalBalance);
    }
    
    PAYABLE void PortfolioManage::createOrder(char* _portfolioName, char* _orderId, uint16_t _orderType, char* _stockCode, uint64_t _stockPrice, uint64_t _stockAmount, uint64_t _endTime){
        uint64_t tokenBalance = getTotalBalance();
        DIPC_EMIT_EVENT(createOrder, "portfolioName", _portfolioName, "OrderInfo", "ignore", "tokenBalance", tokenBalance);
        uint64_t spent = 0;
        if(_orderType == 1){
            spent = _stockPrice * _stockAmount;
            DipcAssert((portfolioBalance.get()[_portfolioName] + tokenBalance) > spent);
        }
        struct Order order{_orderId, _orderType, _stockCode, _stockPrice, _stockAmount, _endTime, 0};
        std::string pInfo = portfolioStorge.get()[_portfolioName];
        
        
        
        if(pInfo == "") {
            DIPC_EMIT_EVENT(ErrEvent, "Current portfolio  doesn't exist: ", _portfolioName);
            return;
        }
        PortfolioInfo info;
        info.parseJson(pInfo);
        if(info.getOrder(_orderId).orderId != ""){
            DIPC_EMIT_EVENT(ErrEvent, "Current order exist: ", _orderId);
            return;
        }
        info.addOrder(order);
        pInfo = info.toJson();

        uint64_t currentBalance = portfolioBalance.get()[_portfolioName] ;
        uint64_t finalBalance = currentBalance + tokenBalance - spent;
        DipcAssert(totalToken.get() + tokenBalance > totalToken);
        
        DipcAssert(ownerTotalToken.get() < ownerTotalToken.get() + spent);
        (*portfolioStorge)[_portfolioName] = &pInfo[0];
        
        
        
        


        (*portfolioBalance)[_portfolioName] = finalBalance;
        *totalToken = totalToken.get() + finalBalance; 
        *ownerTotalToken = ownerTotalToken.get() + spent;
        DIPC_EMIT_EVENT(createOrder, "portfolioName", _portfolioName, "OrderInfo", &order.toJson()[0], "portfolioBalance", finalBalance);
    }

    
    EXPORT void PortfolioManage::dealOrder(char* _portfolioName, char* _orderId){
        isOwner();
        std::string pInfo = portfolioStorge.get()[_portfolioName];
        
        
        PortfolioInfo info;
        info.parseJson(pInfo);
        

        
         Order ord = info.getOrder(_orderId);
         
         
        if(ord.orderId != "" && ord.orderStatus == 0){
            
            uint64_t timenow = dipc::timestamp();
            if(ord.endTime > timenow){
                ord.orderStatus = 1;
            }else {
                ord.orderStatus = 3;
            }
        } else {
          

            return;
        }
        

        uint64_t sellValue = 0;
        if(ord.orderType == 0){
            sellValue = ord.stockAmount * ord.stockPrice;
        }
        uint64_t currentBalance =  portfolioBalance.get()[_portfolioName];
        

        DipcAssert(currentBalance + sellValue >= currentBalance);
        DipcAssert((ownerTotalToken.get() - sellValue) <= ownerTotalToken.get());
        


        (*portfolioBalance)[_portfolioName] = currentBalance + sellValue;
        *ownerTotalToken = ownerTotalToken.get() - sellValue;
        (*portfolioStorge)[_portfolioName] = &info.toJson()[0];
        
        
        
        

        DIPC_EMIT_EVENT(dealPortfolio, "orderId", _orderId, "orderInfo", &ord.toJson()[0]);
    }
    
    EXPORT void PortfolioManage::revocationOrder(char* _portfolioName, char* _orderId){
        std::string pInfo = portfolioStorge.get()[_portfolioName];
        
        
        PortfolioInfo info;
        info.parseJson(pInfo);
        Order ord = info.getOrder(_orderId);
        
        
        if(ord.orderId != "" && ord.orderStatus == 0){
            std::string callerStr = caller().toString();
            
            
            
            DipcAssert(info.getOwnerAddress() == caller().toString());
            

            uint64_t timenow = dipc::timestamp();
            if(ord.endTime > timenow){
                ord.orderStatus = 2;
            }else {
                ord.orderStatus = 3;
            }
        } else {
            return;
        }
        uint64_t lockToken = 0;
        if(ord.orderType == 1){
            lockToken = ord.stockPrice * ord.stockAmount;
        }
        uint64_t currentBalance =  portfolioBalance.get()[_portfolioName];
        
        
        
        

        DipcAssert(currentBalance + lockToken >= currentBalance);
        DipcAssert(ownerTotalToken.get() - lockToken <= ownerTotalToken.get());

        
        (*portfolioBalance)[_portfolioName] = currentBalance + lockToken;
        *ownerTotalToken = ownerTotalToken.get() - lockToken;
        (*portfolioStorge)[_portfolioName] = &info.toJson()[0];
        DIPC_EMIT_EVENT(revocationPortfolio, "orderId", _orderId, "orderInfo", &ord.toJson()[0]);
    }
    
    EXPORT void PortfolioManage::withdrawPortfolio(char* _portfolioName, uint64_t _withdrawBalance){
         if(!userCanWithdraw.get()){
             return;
         }
         uint64_t currentBalance =  portfolioBalance.get()[_portfolioName];
         DipcAssert(currentBalance - _withdrawBalance < currentBalance);
         auto coinBalance = changeUint64ToU256WithChangeRate(currentBalance, changeRate.get());
         (*portfolioBalance)[_portfolioName] = currentBalance - _withdrawBalance;
         callTransfer(caller(), coinBalance);
    }
    
    EXPORT void PortfolioManage::withdrawPool(uint64_t _balance){
        isOwner();
        Address ownerAddr = Address(owner.get()); 
        callTransfer(ownerAddr, _balance);
        *ownerTotalToken = ownerTotalToken.get() - _balance * changeRate.get();
        *totalToken = totalToken.get() - _balance * changeRate.get();
        DIPC_EMIT_EVENT(tokenCount, "ownerTotalToken", ownerTotalToken.get(), "totalToken", totalToken.get());
    }
    
    PAYABLE void PortfolioManage::depositPool(uint64_t _depositValue){
        isOwner();
        
        uint64_t tokenBalance = changeU256ToUint64WithChangeRate(callValue(), changeRate.get()); 
        *ownerTotalToken = ownerTotalToken.get() + tokenBalance;
        *totalToken = totalToken.get() + tokenBalance;
        DIPC_EMIT_EVENT(tokenCount, "ownerTotalToken", ownerTotalToken.get(), "totalToken", totalToken.get());
    }
     
    CONSTANT uint64_t PortfolioManage::queryTotalToken(){
        return totalToken.get();
    }

     
    CONSTANT uint64_t PortfolioManage::queryPortfolioBalance(char* _portfolioName){
        return portfolioBalance.get()[_portfolioName];
    }

    
    CONSTANT bool PortfolioManage::queryPortfolioNameIfUsed(char* _portfolioName){
        if(portfolioStorge.get()[_portfolioName] != ""){
            return true;
        } 
        return false;
    }

    
    CONSTANT uint64_t PortfolioManage::queryChangeRate(){
        return changeRate.get();
    }

2019-12-19_15:14:53.294647: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:451] log out out payable : PAYABLE void PortfolioManage::init(){
        

2019-12-19_15:14:53.294655: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:457] name : init   pos1  0

2019-12-19_15:14:53.294661: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:469] pos2  41   pos1  41

2019-12-19_15:14:53.294667: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:500] pos2 after 418   pos1  41

2019-12-19_15:14:53.294674: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:509] finalContract  first #include "PortfolioManage.hpp"

    
    

2019-12-19_15:14:53.294680: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:510] codetext  first #include "PortfolioManage.hpp"

    
    PAYABLE void PortfolioManage::init(){
        *owner = caller().toString();
        *changeRate = 10000;
        *userCanWithdraw = false;
        uint64_t tokenBalance = getTotalBalance();
        
        *ownerTotalToken = tokenBalance;
        *totalToken = ownerTotalToken.get();
        
        
        DIPC_EMIT_EVENT(initEvent, "ownerTotalToken" ,tokenBalance);
    }
    
     
    EXPORT void PortfolioManage::setChangeRate(uint64_t _changeRate){
        isOwner();
        *changeRate = _changeRate;
    }
     
    EXPORT void PortfolioManage::setUserCanWithdraw(bool _canWithdraw){
        isOwner();
        *userCanWithdraw = _canWithdraw;
    }

    
    PAYABLE void PortfolioManage::createPortfolio(char* _portfolioName, char* _portfolioDesc){
        if(portfolioStorge.get()[_portfolioName] != ""){
            DIPC_EMIT_EVENT(ErrEvent, "Current portfolio exist: ", _portfolioName);
            return;
        } 
        std::string callerAddr = caller().toString();
        uint64_t tokenBalance = getTotalBalance();
        
        PortfolioInfo info(_portfolioName, _portfolioDesc, &callerAddr[0]);
        std::string portfolioStr = info.toJson();
        
        
        

        (*portfolioStorge)[_portfolioName] = portfolioStr;
        DipcAssert(totalToken.get() + tokenBalance > totalToken);
        (*portfolioBalance)[_portfolioName] = tokenBalance;
        *totalToken = totalToken.get() + tokenBalance; 
        
        DIPC_EMIT_EVENT(portfolioInfo, _portfolioName, &portfolioStr[0], "portfolioBalance", tokenBalance);
    }

    
    PAYABLE void PortfolioManage::depositPortfolio(char* _portfolioName){
        uint64_t tokenBalance = getTotalBalance();
        
        uint64_t currentBalance = portfolioBalance.get()[_portfolioName];
        uint64_t finalBalance  = currentBalance + tokenBalance;
        DipcAssert(totalToken.get() + tokenBalance > totalToken);
        DipcAssert(finalBalance > currentBalance);
        (*portfolioBalance)[_portfolioName] = finalBalance;
        *totalToken = totalToken.get() + finalBalance; 
        DIPC_EMIT_EVENT(depositPortfolio, "portfolioName", _portfolioName, "portfolioBalance", finalBalance);
    }
    
    PAYABLE void PortfolioManage::createOrder(char* _portfolioName, char* _orderId, uint16_t _orderType, char* _stockCode, uint64_t _stockPrice, uint64_t _stockAmount, uint64_t _endTime){
        uint64_t tokenBalance = getTotalBalance();
        DIPC_EMIT_EVENT(createOrder, "portfolioName", _portfolioName, "OrderInfo", "ignore", "tokenBalance", tokenBalance);
        uint64_t spent = 0;
        if(_orderType == 1){
            spent = _stockPrice * _stockAmount;
            DipcAssert((portfolioBalance.get()[_portfolioName] + tokenBalance) > spent);
        }
        struct Order order{_orderId, _orderType, _stockCode, _stockPrice, _stockAmount, _endTime, 0};
        std::string pInfo = portfolioStorge.get()[_portfolioName];
        
        
        
        if(pInfo == "") {
            DIPC_EMIT_EVENT(ErrEvent, "Current portfolio  doesn't exist: ", _portfolioName);
            return;
        }
        PortfolioInfo info;
        info.parseJson(pInfo);
        if(info.getOrder(_orderId).orderId != ""){
            DIPC_EMIT_EVENT(ErrEvent, "Current order exist: ", _orderId);
            return;
        }
        info.addOrder(order);
        pInfo = info.toJson();

        uint64_t currentBalance = portfolioBalance.get()[_portfolioName] ;
        uint64_t finalBalance = currentBalance + tokenBalance - spent;
        DipcAssert(totalToken.get() + tokenBalance > totalToken);
        
        DipcAssert(ownerTotalToken.get() < ownerTotalToken.get() + spent);
        (*portfolioStorge)[_portfolioName] = &pInfo[0];
        
        
        
        


        (*portfolioBalance)[_portfolioName] = finalBalance;
        *totalToken = totalToken.get() + finalBalance; 
        *ownerTotalToken = ownerTotalToken.get() + spent;
        DIPC_EMIT_EVENT(createOrder, "portfolioName", _portfolioName, "OrderInfo", &order.toJson()[0], "portfolioBalance", finalBalance);
    }

    
    EXPORT void PortfolioManage::dealOrder(char* _portfolioName, char* _orderId){
        isOwner();
        std::string pInfo = portfolioStorge.get()[_portfolioName];
        
        
        PortfolioInfo info;
        info.parseJson(pInfo);
        

        
         Order ord = info.getOrder(_orderId);
         
         
        if(ord.orderId != "" && ord.orderStatus == 0){
            
            uint64_t timenow = dipc::timestamp();
            if(ord.endTime > timenow){
                ord.orderStatus = 1;
            }else {
                ord.orderStatus = 3;
            }
        } else {
          

            return;
        }
        

        uint64_t sellValue = 0;
        if(ord.orderType == 0){
            sellValue = ord.stockAmount * ord.stockPrice;
        }
        uint64_t currentBalance =  portfolioBalance.get()[_portfolioName];
        

        DipcAssert(currentBalance + sellValue >= currentBalance);
        DipcAssert((ownerTotalToken.get() - sellValue) <= ownerTotalToken.get());
        


        (*portfolioBalance)[_portfolioName] = currentBalance + sellValue;
        *ownerTotalToken = ownerTotalToken.get() - sellValue;
        (*portfolioStorge)[_portfolioName] = &info.toJson()[0];
        
        
        
        

        DIPC_EMIT_EVENT(dealPortfolio, "orderId", _orderId, "orderInfo", &ord.toJson()[0]);
    }
    
    EXPORT void PortfolioManage::revocationOrder(char* _portfolioName, char* _orderId){
        std::string pInfo = portfolioStorge.get()[_portfolioName];
        
        
        PortfolioInfo info;
        info.parseJson(pInfo);
        Order ord = info.getOrder(_orderId);
        
        
        if(ord.orderId != "" && ord.orderStatus == 0){
            std::string callerStr = caller().toString();
            
            
            
            DipcAssert(info.getOwnerAddress() == caller().toString());
            

            uint64_t timenow = dipc::timestamp();
            if(ord.endTime > timenow){
                ord.orderStatus = 2;
            }else {
                ord.orderStatus = 3;
            }
        } else {
            return;
        }
        uint64_t lockToken = 0;
        if(ord.orderType == 1){
            lockToken = ord.stockPrice * ord.stockAmount;
        }
        uint64_t currentBalance =  portfolioBalance.get()[_portfolioName];
        
        
        
        

        DipcAssert(currentBalance + lockToken >= currentBalance);
        DipcAssert(ownerTotalToken.get() - lockToken <= ownerTotalToken.get());

        
        (*portfolioBalance)[_portfolioName] = currentBalance + lockToken;
        *ownerTotalToken = ownerTotalToken.get() - lockToken;
        (*portfolioStorge)[_portfolioName] = &info.toJson()[0];
        DIPC_EMIT_EVENT(revocationPortfolio, "orderId", _orderId, "orderInfo", &ord.toJson()[0]);
    }
    
    EXPORT void PortfolioManage::withdrawPortfolio(char* _portfolioName, uint64_t _withdrawBalance){
         if(!userCanWithdraw.get()){
             return;
         }
         uint64_t currentBalance =  portfolioBalance.get()[_portfolioName];
         DipcAssert(currentBalance - _withdrawBalance < currentBalance);
         auto coinBalance = changeUint64ToU256WithChangeRate(currentBalance, changeRate.get());
         (*portfolioBalance)[_portfolioName] = currentBalance - _withdrawBalance;
         callTransfer(caller(), coinBalance);
    }
    
    EXPORT void PortfolioManage::withdrawPool(uint64_t _balance){
        isOwner();
        Address ownerAddr = Address(owner.get()); 
        callTransfer(ownerAddr, _balance);
        *ownerTotalToken = ownerTotalToken.get() - _balance * changeRate.get();
        *totalToken = totalToken.get() - _balance * changeRate.get();
        DIPC_EMIT_EVENT(tokenCount, "ownerTotalToken", ownerTotalToken.get(), "totalToken", totalToken.get());
    }
    
    PAYABLE void PortfolioManage::depositPool(uint64_t _depositValue){
        isOwner();
        
        uint64_t tokenBalance = changeU256ToUint64WithChangeRate(callValue(), changeRate.get()); 
        *ownerTotalToken = ownerTotalToken.get() + tokenBalance;
        *totalToken = totalToken.get() + tokenBalance;
        DIPC_EMIT_EVENT(tokenCount, "ownerTotalToken", ownerTotalToken.get(), "totalToken", totalToken.get());
    }
     
    CONSTANT uint64_t PortfolioManage::queryTotalToken(){
        return totalToken.get();
    }

     
    CONSTANT uint64_t PortfolioManage::queryPortfolioBalance(char* _portfolioName){
        return portfolioBalance.get()[_portfolioName];
    }

    
    CONSTANT bool PortfolioManage::queryPortfolioNameIfUsed(char* _portfolioName){
        if(portfolioStorge.get()[_portfolioName] != ""){
            return true;
        } 
        return false;
    }

    
    CONSTANT uint64_t PortfolioManage::queryChangeRate(){
        return changeRate.get();
    }

2019-12-19_15:14:53.294688: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:513] s  first PAYABLE void PortfolioManage::init(){
        *owner = caller().toString();
        *changeRate = 10000;
        *userCanWithdraw = false;
        uint64_t tokenBalance = getTotalBalance();
        
        *ownerTotalToken = tokenBalance;
        *totalToken = ownerTotalToken.get();
        
        
        DIPC_EMIT_EVENT(initEvent, "ownerTotalToken" ,tokenBalance);
    }

2019-12-19_15:14:53.298223: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:599] search func : PAYABLE void PortfolioManage::init(){
        *owner = caller().toString();
        *changeRate = 10000;
        *userCanWithdraw = false;
        uint64_t tokenBalance = getTotalBalance();
        
        *ownerTotalToken = tokenBalance;
        *totalToken = ownerTotalToken.get();
        
        
        DIPC_EMIT_EVENT(initEvent, "ownerTotalToken" ,tokenBalance);
    }
2019-12-19_15:14:53.298232: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:424] finalContract  this height  #include "PortfolioManage.hpp"

    
    PAYABLE void PortfolioManage::init(){
        *owner = caller().toString();
        *changeRate = 10000;
        *userCanWithdraw = false;
        uint64_t tokenBalance = getTotalBalance();
        
        *ownerTotalToken = tokenBalance;
        *totalToken = ownerTotalToken.get();
        
        
        DIPC_EMIT_EVENT(initEvent, "ownerTotalToken" ,tokenBalance);
    } codetext height #include "PortfolioManage.hpp"

    
    PAYABLE void PortfolioManage::init(){
        *owner = caller().toString();
        *changeRate = 10000;
        *userCanWithdraw = false;
        uint64_t tokenBalance = getTotalBalance();
        
        *ownerTotalToken = tokenBalance;
        *totalToken = ownerTotalToken.get();
        
        
        DIPC_EMIT_EVENT(initEvent, "ownerTotalToken" ,tokenBalance);
    }
    
     
    EXPORT void PortfolioManage::setChangeRate(uint64_t _changeRate){
        isOwner();
        *changeRate = _changeRate;
    }
     
    EXPORT void PortfolioManage::setUserCanWithdraw(bool _canWithdraw){
        isOwner();
        *userCanWithdraw = _canWithdraw;
    }

    
    PAYABLE void PortfolioManage::createPortfolio(char* _portfolioName, char* _portfolioDesc){
        if(portfolioStorge.get()[_portfolioName] != ""){
            DIPC_EMIT_EVENT(ErrEvent, "Current portfolio exist: ", _portfolioName);
            return;
        } 
        std::string callerAddr = caller().toString();
        uint64_t tokenBalance = getTotalBalance();
        
        PortfolioInfo info(_portfolioName, _portfolioDesc, &callerAddr[0]);
        std::string portfolioStr = info.toJson();
        
        
        

        (*portfolioStorge)[_portfolioName] = portfolioStr;
        DipcAssert(totalToken.get() + tokenBalance > totalToken);
        (*portfolioBalance)[_portfolioName] = tokenBalance;
        *totalToken = totalToken.get() + tokenBalance; 
        
        DIPC_EMIT_EVENT(portfolioInfo, _portfolioName, &portfolioStr[0], "portfolioBalance", tokenBalance);
    }

    
    PAYABLE void PortfolioManage::depositPortfolio(char* _portfolioName){
        uint64_t tokenBalance = getTotalBalance();
        
        uint64_t currentBalance = portfolioBalance.get()[_portfolioName];
        uint64_t finalBalance  = currentBalance + tokenBalance;
        DipcAssert(totalToken.get() + tokenBalance > totalToken);
        DipcAssert(finalBalance > currentBalance);
        (*portfolioBalance)[_portfolioName] = finalBalance;
        *totalToken = totalToken.get() + finalBalance; 
        DIPC_EMIT_EVENT(depositPortfolio, "portfolioName", _portfolioName, "portfolioBalance", finalBalance);
    }
    
    PAYABLE void PortfolioManage::createOrder(char* _portfolioName, char* _orderId, uint16_t _orderType, char* _stockCode, uint64_t _stockPrice, uint64_t _stockAmount, uint64_t _endTime){
        uint64_t tokenBalance = getTotalBalance();
        DIPC_EMIT_EVENT(createOrder, "portfolioName", _portfolioName, "OrderInfo", "ignore", "tokenBalance", tokenBalance);
        uint64_t spent = 0;
        if(_orderType == 1){
            spent = _stockPrice * _stockAmount;
            DipcAssert((portfolioBalance.get()[_portfolioName] + tokenBalance) > spent);
        }
        struct Order order{_orderId, _orderType, _stockCode, _stockPrice, _stockAmount, _endTime, 0};
        std::string pInfo = portfolioStorge.get()[_portfolioName];
        
        
        
        if(pInfo == "") {
            DIPC_EMIT_EVENT(ErrEvent, "Current portfolio  doesn't exist: ", _portfolioName);
            return;
        }
        PortfolioInfo info;
        info.parseJson(pInfo);
        if(info.getOrder(_orderId).orderId != ""){
            DIPC_EMIT_EVENT(ErrEvent, "Current order exist: ", _orderId);
            return;
        }
        info.addOrder(order);
        pInfo = info.toJson();

        uint64_t currentBalance = portfolioBalance.get()[_portfolioName] ;
        uint64_t finalBalance = currentBalance + tokenBalance - spent;
        DipcAssert(totalToken.get() + tokenBalance > totalToken);
        
        DipcAssert(ownerTotalToken.get() < ownerTotalToken.get() + spent);
        (*portfolioStorge)[_portfolioName] = &pInfo[0];
        
        
        
        


        (*portfolioBalance)[_portfolioName] = finalBalance;
        *totalToken = totalToken.get() + finalBalance; 
        *ownerTotalToken = ownerTotalToken.get() + spent;
        DIPC_EMIT_EVENT(createOrder, "portfolioName", _portfolioName, "OrderInfo", &order.toJson()[0], "portfolioBalance", finalBalance);
    }

    
    EXPORT void PortfolioManage::dealOrder(char* _portfolioName, char* _orderId){
        isOwner();
        std::string pInfo = portfolioStorge.get()[_portfolioName];
        
        
        PortfolioInfo info;
        info.parseJson(pInfo);
        

        
         Order ord = info.getOrder(_orderId);
         
         
        if(ord.orderId != "" && ord.orderStatus == 0){
            
            uint64_t timenow = dipc::timestamp();
            if(ord.endTime > timenow){
                ord.orderStatus = 1;
            }else {
                ord.orderStatus = 3;
            }
        } else {
          

            return;
        }
        

        uint64_t sellValue = 0;
        if(ord.orderType == 0){
            sellValue = ord.stockAmount * ord.stockPrice;
        }
        uint64_t currentBalance =  portfolioBalance.get()[_portfolioName];
        

        DipcAssert(currentBalance + sellValue >= currentBalance);
        DipcAssert((ownerTotalToken.get() - sellValue) <= ownerTotalToken.get());
        


        (*portfolioBalance)[_portfolioName] = currentBalance + sellValue;
        *ownerTotalToken = ownerTotalToken.get() - sellValue;
        (*portfolioStorge)[_portfolioName] = &info.toJson()[0];
        
        
        
        

        DIPC_EMIT_EVENT(dealPortfolio, "orderId", _orderId, "orderInfo", &ord.toJson()[0]);
    }
    
    EXPORT void PortfolioManage::revocationOrder(char* _portfolioName, char* _orderId){
        std::string pInfo = portfolioStorge.get()[_portfolioName];
        
        
        PortfolioInfo info;
        info.parseJson(pInfo);
        Order ord = info.getOrder(_orderId);
        
        
        if(ord.orderId != "" && ord.orderStatus == 0){
            std::string callerStr = caller().toString();
            
            
            
            DipcAssert(info.getOwnerAddress() == caller().toString());
            

            uint64_t timenow = dipc::timestamp();
            if(ord.endTime > timenow){
                ord.orderStatus = 2;
            }else {
                ord.orderStatus = 3;
            }
        } else {
            return;
        }
        uint64_t lockToken = 0;
        if(ord.orderType == 1){
            lockToken = ord.stockPrice * ord.stockAmount;
        }
        uint64_t currentBalance =  portfolioBalance.get()[_portfolioName];
        
        
        
        

        DipcAssert(currentBalance + lockToken >= currentBalance);
        DipcAssert(ownerTotalToken.get() - lockToken <= ownerTotalToken.get());

        
        (*portfolioBalance)[_portfolioName] = currentBalance + lockToken;
        *ownerTotalToken = ownerTotalToken.get() - lockToken;
        (*portfolioStorge)[_portfolioName] = &info.toJson()[0];
        DIPC_EMIT_EVENT(revocationPortfolio, "orderId", _orderId, "orderInfo", &ord.toJson()[0]);
    }
    
    EXPORT void PortfolioManage::withdrawPortfolio(char* _portfolioName, uint64_t _withdrawBalance){
         if(!userCanWithdraw.get()){
             return;
         }
         uint64_t currentBalance =  portfolioBalance.get()[_portfolioName];
         DipcAssert(currentBalance - _withdrawBalance < currentBalance);
         auto coinBalance = changeUint64ToU256WithChangeRate(currentBalance, changeRate.get());
         (*portfolioBalance)[_portfolioName] = currentBalance - _withdrawBalance;
         callTransfer(caller(), coinBalance);
    }
    
    EXPORT void PortfolioManage::withdrawPool(uint64_t _balance){
        isOwner();
        Address ownerAddr = Address(owner.get()); 
        callTransfer(ownerAddr, _balance);
        *ownerTotalToken = ownerTotalToken.get() - _balance * changeRate.get();
        *totalToken = totalToken.get() - _balance * changeRate.get();
        DIPC_EMIT_EVENT(tokenCount, "ownerTotalToken", ownerTotalToken.get(), "totalToken", totalToken.get());
    }
    
    PAYABLE void PortfolioManage::depositPool(uint64_t _depositValue){
        isOwner();
        
        uint64_t tokenBalance = changeU256ToUint64WithChangeRate(callValue(), changeRate.get()); 
        *ownerTotalToken = ownerTotalToken.get() + tokenBalance;
        *totalToken = totalToken.get() + tokenBalance;
        DIPC_EMIT_EVENT(tokenCount, "ownerTotalToken", ownerTotalToken.get(), "totalToken", totalToken.get());
    }
     
    CONSTANT uint64_t PortfolioManage::queryTotalToken(){
        return totalToken.get();
    }

     
    CONSTANT uint64_t PortfolioManage::queryPortfolioBalance(char* _portfolioName){
        return portfolioBalance.get()[_portfolioName];
    }

    
    CONSTANT bool PortfolioManage::queryPortfolioNameIfUsed(char* _portfolioName){
        if(portfolioStorge.get()[_portfolioName] != ""){
            return true;
        } 
        return false;
    }

    
    CONSTANT uint64_t PortfolioManage::queryChangeRate(){
        return changeRate.get();
    }

2019-12-19_15:14:53.298295: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:427] searchContext  
    
     
    EXPORT void PortfolioManage::setChangeRate(uint64_t _changeRate){
        isOwner();
        *changeRate = _changeRate;
    }
     
    EXPORT void PortfolioManage::setUserCanWithdraw(bool _canWithdraw){
        isOwner();
        *userCanWithdraw = _canWithdraw;
    }

    
    PAYABLE void PortfolioManage::createPortfolio(char* _portfolioName, char* _portfolioDesc){
        if(portfolioStorge.get()[_portfolioName] != ""){
            DIPC_EMIT_EVENT(ErrEvent, "Current portfolio exist: ", _portfolioName);
            return;
        } 
        std::string callerAddr = caller().toString();
        uint64_t tokenBalance = getTotalBalance();
        
        PortfolioInfo info(_portfolioName, _portfolioDesc, &callerAddr[0]);
        std::string portfolioStr = info.toJson();
        
        
        

        (*portfolioStorge)[_portfolioName] = portfolioStr;
        DipcAssert(totalToken.get() + tokenBalance > totalToken);
        (*portfolioBalance)[_portfolioName] = tokenBalance;
        *totalToken = totalToken.get() + tokenBalance; 
        
        DIPC_EMIT_EVENT(portfolioInfo, _portfolioName, &portfolioStr[0], "portfolioBalance", tokenBalance);
    }

    
    PAYABLE void PortfolioManage::depositPortfolio(char* _portfolioName){
        uint64_t tokenBalance = getTotalBalance();
        
        uint64_t currentBalance = portfolioBalance.get()[_portfolioName];
        uint64_t finalBalance  = currentBalance + tokenBalance;
        DipcAssert(totalToken.get() + tokenBalance > totalToken);
        DipcAssert(finalBalance > currentBalance);
        (*portfolioBalance)[_portfolioName] = finalBalance;
        *totalToken = totalToken.get() + finalBalance; 
        DIPC_EMIT_EVENT(depositPortfolio, "portfolioName", _portfolioName, "portfolioBalance", finalBalance);
    }
    
    PAYABLE void PortfolioManage::createOrder(char* _portfolioName, char* _orderId, uint16_t _orderType, char* _stockCode, uint64_t _stockPrice, uint64_t _stockAmount, uint64_t _endTime){
        uint64_t tokenBalance = getTotalBalance();
        DIPC_EMIT_EVENT(createOrder, "portfolioName", _portfolioName, "OrderInfo", "ignore", "tokenBalance", tokenBalance);
        uint64_t spent = 0;
        if(_orderType == 1){
            spent = _stockPrice * _stockAmount;
            DipcAssert((portfolioBalance.get()[_portfolioName] + tokenBalance) > spent);
        }
        struct Order order{_orderId, _orderType, _stockCode, _stockPrice, _stockAmount, _endTime, 0};
        std::string pInfo = portfolioStorge.get()[_portfolioName];
        
        
        
        if(pInfo == "") {
            DIPC_EMIT_EVENT(ErrEvent, "Current portfolio  doesn't exist: ", _portfolioName);
            return;
        }
        PortfolioInfo info;
        info.parseJson(pInfo);
        if(info.getOrder(_orderId).orderId != ""){
            DIPC_EMIT_EVENT(ErrEvent, "Current order exist: ", _orderId);
            return;
        }
        info.addOrder(order);
        pInfo = info.toJson();

        uint64_t currentBalance = portfolioBalance.get()[_portfolioName] ;
        uint64_t finalBalance = currentBalance + tokenBalance - spent;
        DipcAssert(totalToken.get() + tokenBalance > totalToken);
        
        DipcAssert(ownerTotalToken.get() < ownerTotalToken.get() + spent);
        (*portfolioStorge)[_portfolioName] = &pInfo[0];
        
        
        
        


        (*portfolioBalance)[_portfolioName] = finalBalance;
        *totalToken = totalToken.get() + finalBalance; 
        *ownerTotalToken = ownerTotalToken.get() + spent;
        DIPC_EMIT_EVENT(createOrder, "portfolioName", _portfolioName, "OrderInfo", &order.toJson()[0], "portfolioBalance", finalBalance);
    }

    
    EXPORT void PortfolioManage::dealOrder(char* _portfolioName, char* _orderId){
        isOwner();
        std::string pInfo = portfolioStorge.get()[_portfolioName];
        
        
        PortfolioInfo info;
        info.parseJson(pInfo);
        

        
         Order ord = info.getOrder(_orderId);
         
         
        if(ord.orderId != "" && ord.orderStatus == 0){
            
            uint64_t timenow = dipc::timestamp();
            if(ord.endTime > timenow){
                ord.orderStatus = 1;
            }else {
                ord.orderStatus = 3;
            }
        } else {
          

            return;
        }
        

        uint64_t sellValue = 0;
        if(ord.orderType == 0){
            sellValue = ord.stockAmount * ord.stockPrice;
        }
        uint64_t currentBalance =  portfolioBalance.get()[_portfolioName];
        

        DipcAssert(currentBalance + sellValue >= currentBalance);
        DipcAssert((ownerTotalToken.get() - sellValue) <= ownerTotalToken.get());
        


        (*portfolioBalance)[_portfolioName] = currentBalance + sellValue;
        *ownerTotalToken = ownerTotalToken.get() - sellValue;
        (*portfolioStorge)[_portfolioName] = &info.toJson()[0];
        
        
        
        

        DIPC_EMIT_EVENT(dealPortfolio, "orderId", _orderId, "orderInfo", &ord.toJson()[0]);
    }
    
    EXPORT void PortfolioManage::revocationOrder(char* _portfolioName, char* _orderId){
        std::string pInfo = portfolioStorge.get()[_portfolioName];
        
        
        PortfolioInfo info;
        info.parseJson(pInfo);
        Order ord = info.getOrder(_orderId);
        
        
        if(ord.orderId != "" && ord.orderStatus == 0){
            std::string callerStr = caller().toString();
            
            
            
            DipcAssert(info.getOwnerAddress() == caller().toString());
            

            uint64_t timenow = dipc::timestamp();
            if(ord.endTime > timenow){
                ord.orderStatus = 2;
            }else {
                ord.orderStatus = 3;
            }
        } else {
            return;
        }
        uint64_t lockToken = 0;
        if(ord.orderType == 1){
            lockToken = ord.stockPrice * ord.stockAmount;
        }
        uint64_t currentBalance =  portfolioBalance.get()[_portfolioName];
        
        
        
        

        DipcAssert(currentBalance + lockToken >= currentBalance);
        DipcAssert(ownerTotalToken.get() - lockToken <= ownerTotalToken.get());

        
        (*portfolioBalance)[_portfolioName] = currentBalance + lockToken;
        *ownerTotalToken = ownerTotalToken.get() - lockToken;
        (*portfolioStorge)[_portfolioName] = &info.toJson()[0];
        DIPC_EMIT_EVENT(revocationPortfolio, "orderId", _orderId, "orderInfo", &ord.toJson()[0]);
    }
    
    EXPORT void PortfolioManage::withdrawPortfolio(char* _portfolioName, uint64_t _withdrawBalance){
         if(!userCanWithdraw.get()){
             return;
         }
         uint64_t currentBalance =  portfolioBalance.get()[_portfolioName];
         DipcAssert(currentBalance - _withdrawBalance < currentBalance);
         auto coinBalance = changeUint64ToU256WithChangeRate(currentBalance, changeRate.get());
         (*portfolioBalance)[_portfolioName] = currentBalance - _withdrawBalance;
         callTransfer(caller(), coinBalance);
    }
    
    EXPORT void PortfolioManage::withdrawPool(uint64_t _balance){
        isOwner();
        Address ownerAddr = Address(owner.get()); 
        callTransfer(ownerAddr, _balance);
        *ownerTotalToken = ownerTotalToken.get() - _balance * changeRate.get();
        *totalToken = totalToken.get() - _balance * changeRate.get();
        DIPC_EMIT_EVENT(tokenCount, "ownerTotalToken", ownerTotalToken.get(), "totalToken", totalToken.get());
    }
    
    PAYABLE void PortfolioManage::depositPool(uint64_t _depositValue){
        isOwner();
        
        uint64_t tokenBalance = changeU256ToUint64WithChangeRate(callValue(), changeRate.get()); 
        *ownerTotalToken = ownerTotalToken.get() + tokenBalance;
        *totalToken = totalToken.get() + tokenBalance;
        DIPC_EMIT_EVENT(tokenCount, "ownerTotalToken", ownerTotalToken.get(), "totalToken", totalToken.get());
    }
     
    CONSTANT uint64_t PortfolioManage::queryTotalToken(){
        return totalToken.get();
    }

     
    CONSTANT uint64_t PortfolioManage::queryPortfolioBalance(char* _portfolioName){
        return portfolioBalance.get()[_portfolioName];
    }

    
    CONSTANT bool PortfolioManage::queryPortfolioNameIfUsed(char* _portfolioName){
        if(portfolioStorge.get()[_portfolioName] != ""){
            return true;
        } 
        return false;
    }

    
    CONSTANT uint64_t PortfolioManage::queryChangeRate(){
        return changeRate.get();
    }

2019-12-19_15:14:53.301911: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:442] finalContract  this new  #include "PortfolioManage.hpp"

    
    PAYABLE void PortfolioManage::init(){
        *owner = caller().toString();
        *changeRate = 10000;
        *userCanWithdraw = false;
        uint64_t tokenBalance = getTotalBalance();
        
        *ownerTotalToken = tokenBalance;
        *totalToken = ownerTotalToken.get();
        
        
        DIPC_EMIT_EVENT(initEvent, "ownerTotalToken" ,tokenBalance);
    } codetext new #include "PortfolioManage.hpp"

    
    PAYABLE void PortfolioManage::init(){
        *owner = caller().toString();
        *changeRate = 10000;
        *userCanWithdraw = false;
        uint64_t tokenBalance = getTotalBalance();
        
        *ownerTotalToken = tokenBalance;
        *totalToken = ownerTotalToken.get();
        
        
        DIPC_EMIT_EVENT(initEvent, "ownerTotalToken" ,tokenBalance);
    }
    
     
    EXPORT void PortfolioManage::setChangeRate(uint64_t _changeRate){
        isOwner();
        *changeRate = _changeRate;
    }
     
    EXPORT void PortfolioManage::setUserCanWithdraw(bool _canWithdraw){
        isOwner();
        *userCanWithdraw = _canWithdraw;
    }

    
    PAYABLE void PortfolioManage::createPortfolio(char* _portfolioName, char* _portfolioDesc){
        if(portfolioStorge.get()[_portfolioName] != ""){
            DIPC_EMIT_EVENT(ErrEvent, "Current portfolio exist: ", _portfolioName);
            return;
        } 
        std::string callerAddr = caller().toString();
        uint64_t tokenBalance = getTotalBalance();
        
        PortfolioInfo info(_portfolioName, _portfolioDesc, &callerAddr[0]);
        std::string portfolioStr = info.toJson();
        
        
        

        (*portfolioStorge)[_portfolioName] = portfolioStr;
        DipcAssert(totalToken.get() + tokenBalance > totalToken);
        (*portfolioBalance)[_portfolioName] = tokenBalance;
        *totalToken = totalToken.get() + tokenBalance; 
        
        DIPC_EMIT_EVENT(portfolioInfo, _portfolioName, &portfolioStr[0], "portfolioBalance", tokenBalance);
    }

    
    PAYABLE void PortfolioManage::depositPortfolio(char* _portfolioName){
        uint64_t tokenBalance = getTotalBalance();
        
        uint64_t currentBalance = portfolioBalance.get()[_portfolioName];
        uint64_t finalBalance  = currentBalance + tokenBalance;
        DipcAssert(totalToken.get() + tokenBalance > totalToken);
        DipcAssert(finalBalance > currentBalance);
        (*portfolioBalance)[_portfolioName] = finalBalance;
        *totalToken = totalToken.get() + finalBalance; 
        DIPC_EMIT_EVENT(depositPortfolio, "portfolioName", _portfolioName, "portfolioBalance", finalBalance);
    }
    
    PAYABLE void PortfolioManage::createOrder(char* _portfolioName, char* _orderId, uint16_t _orderType, char* _stockCode, uint64_t _stockPrice, uint64_t _stockAmount, uint64_t _endTime){
        uint64_t tokenBalance = getTotalBalance();
        DIPC_EMIT_EVENT(createOrder, "portfolioName", _portfolioName, "OrderInfo", "ignore", "tokenBalance", tokenBalance);
        uint64_t spent = 0;
        if(_orderType == 1){
            spent = _stockPrice * _stockAmount;
            DipcAssert((portfolioBalance.get()[_portfolioName] + tokenBalance) > spent);
        }
        struct Order order{_orderId, _orderType, _stockCode, _stockPrice, _stockAmount, _endTime, 0};
        std::string pInfo = portfolioStorge.get()[_portfolioName];
        
        
        
        if(pInfo == "") {
            DIPC_EMIT_EVENT(ErrEvent, "Current portfolio  doesn't exist: ", _portfolioName);
            return;
        }
        PortfolioInfo info;
        info.parseJson(pInfo);
        if(info.getOrder(_orderId).orderId != ""){
            DIPC_EMIT_EVENT(ErrEvent, "Current order exist: ", _orderId);
            return;
        }
        info.addOrder(order);
        pInfo = info.toJson();

        uint64_t currentBalance = portfolioBalance.get()[_portfolioName] ;
        uint64_t finalBalance = currentBalance + tokenBalance - spent;
        DipcAssert(totalToken.get() + tokenBalance > totalToken);
        
        DipcAssert(ownerTotalToken.get() < ownerTotalToken.get() + spent);
        (*portfolioStorge)[_portfolioName] = &pInfo[0];
        
        
        
        


        (*portfolioBalance)[_portfolioName] = finalBalance;
        *totalToken = totalToken.get() + finalBalance; 
        *ownerTotalToken = ownerTotalToken.get() + spent;
        DIPC_EMIT_EVENT(createOrder, "portfolioName", _portfolioName, "OrderInfo", &order.toJson()[0], "portfolioBalance", finalBalance);
    }

    
    EXPORT void PortfolioManage::dealOrder(char* _portfolioName, char* _orderId){
        isOwner();
        std::string pInfo = portfolioStorge.get()[_portfolioName];
        
        
        PortfolioInfo info;
        info.parseJson(pInfo);
        

        
         Order ord = info.getOrder(_orderId);
         
         
        if(ord.orderId != "" && ord.orderStatus == 0){
            
            uint64_t timenow = dipc::timestamp();
            if(ord.endTime > timenow){
                ord.orderStatus = 1;
            }else {
                ord.orderStatus = 3;
            }
        } else {
          

            return;
        }
        

        uint64_t sellValue = 0;
        if(ord.orderType == 0){
            sellValue = ord.stockAmount * ord.stockPrice;
        }
        uint64_t currentBalance =  portfolioBalance.get()[_portfolioName];
        

        DipcAssert(currentBalance + sellValue >= currentBalance);
        DipcAssert((ownerTotalToken.get() - sellValue) <= ownerTotalToken.get());
        


        (*portfolioBalance)[_portfolioName] = currentBalance + sellValue;
        *ownerTotalToken = ownerTotalToken.get() - sellValue;
        (*portfolioStorge)[_portfolioName] = &info.toJson()[0];
        
        
        
        

        DIPC_EMIT_EVENT(dealPortfolio, "orderId", _orderId, "orderInfo", &ord.toJson()[0]);
    }
    
    EXPORT void PortfolioManage::revocationOrder(char* _portfolioName, char* _orderId){
        std::string pInfo = portfolioStorge.get()[_portfolioName];
        
        
        PortfolioInfo info;
        info.parseJson(pInfo);
        Order ord = info.getOrder(_orderId);
        
        
        if(ord.orderId != "" && ord.orderStatus == 0){
            std::string callerStr = caller().toString();
            
            
            
            DipcAssert(info.getOwnerAddress() == caller().toString());
            

            uint64_t timenow = dipc::timestamp();
            if(ord.endTime > timenow){
                ord.orderStatus = 2;
            }else {
                ord.orderStatus = 3;
            }
        } else {
            return;
        }
        uint64_t lockToken = 0;
        if(ord.orderType == 1){
            lockToken = ord.stockPrice * ord.stockAmount;
        }
        uint64_t currentBalance =  portfolioBalance.get()[_portfolioName];
        
        
        
        

        DipcAssert(currentBalance + lockToken >= currentBalance);
        DipcAssert(ownerTotalToken.get() - lockToken <= ownerTotalToken.get());

        
        (*portfolioBalance)[_portfolioName] = currentBalance + lockToken;
        *ownerTotalToken = ownerTotalToken.get() - lockToken;
        (*portfolioStorge)[_portfolioName] = &info.toJson()[0];
        DIPC_EMIT_EVENT(revocationPortfolio, "orderId", _orderId, "orderInfo", &ord.toJson()[0]);
    }
    
    EXPORT void PortfolioManage::withdrawPortfolio(char* _portfolioName, uint64_t _withdrawBalance){
         if(!userCanWithdraw.get()){
             return;
         }
         uint64_t currentBalance =  portfolioBalance.get()[_portfolioName];
         DipcAssert(currentBalance - _withdrawBalance < currentBalance);
         auto coinBalance = changeUint64ToU256WithChangeRate(currentBalance, changeRate.get());
         (*portfolioBalance)[_portfolioName] = currentBalance - _withdrawBalance;
         callTransfer(caller(), coinBalance);
    }
    
    EXPORT void PortfolioManage::withdrawPool(uint64_t _balance){
        isOwner();
        Address ownerAddr = Address(owner.get()); 
        callTransfer(ownerAddr, _balance);
        *ownerTotalToken = ownerTotalToken.get() - _balance * changeRate.get();
        *totalToken = totalToken.get() - _balance * changeRate.get();
        DIPC_EMIT_EVENT(tokenCount, "ownerTotalToken", ownerTotalToken.get(), "totalToken", totalToken.get());
    }
    
    PAYABLE void PortfolioManage::depositPool(uint64_t _depositValue){
        isOwner();
        
        uint64_t tokenBalance = changeU256ToUint64WithChangeRate(callValue(), changeRate.get()); 
        *ownerTotalToken = ownerTotalToken.get() + tokenBalance;
        *totalToken = totalToken.get() + tokenBalance;
        DIPC_EMIT_EVENT(tokenCount, "ownerTotalToken", ownerTotalToken.get(), "totalToken", totalToken.get());
    }
     
    CONSTANT uint64_t PortfolioManage::queryTotalToken(){
        return totalToken.get();
    }

     
    CONSTANT uint64_t PortfolioManage::queryPortfolioBalance(char* _portfolioName){
        return portfolioBalance.get()[_portfolioName];
    }

    
    CONSTANT bool PortfolioManage::queryPortfolioNameIfUsed(char* _portfolioName){
        if(portfolioStorge.get()[_portfolioName] != ""){
            return true;
        } 
        return false;
    }

    
    CONSTANT uint64_t PortfolioManage::queryChangeRate(){
        return changeRate.get();
    }

2019-12-19_15:14:53.301939: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:604] finalContract  final content =======   : #include "PortfolioManage.hpp"

    
    PAYABLE void PortfolioManage::init(){
        *owner = caller().toString();
        *changeRate = 10000;
        *userCanWithdraw = false;
        uint64_t tokenBalance = getTotalBalance();
        
        *ownerTotalToken = tokenBalance;
        *totalToken = ownerTotalToken.get();
        
        
        DIPC_EMIT_EVENT(initEvent, "ownerTotalToken" ,tokenBalance);
    }
    
     
    EXPORT void PortfolioManage::setChangeRate(uint64_t _changeRate){
        isOwner();
        *changeRate = _changeRate;
    }
     
    EXPORT void PortfolioManage::setUserCanWithdraw(bool _canWithdraw){
        isOwner();
        *userCanWithdraw = _canWithdraw;
    }

    
    PAYABLE void PortfolioManage::createPortfolio(char* _portfolioName, char* _portfolioDesc){
        if(portfolioStorge.get()[_portfolioName] != ""){
            DIPC_EMIT_EVENT(ErrEvent, "Current portfolio exist: ", _portfolioName);
            return;
        } 
        std::string callerAddr = caller().toString();
        uint64_t tokenBalance = getTotalBalance();
        
        PortfolioInfo info(_portfolioName, _portfolioDesc, &callerAddr[0]);
        std::string portfolioStr = info.toJson();
        
        
        

        (*portfolioStorge)[_portfolioName] = portfolioStr;
        DipcAssert(totalToken.get() + tokenBalance > totalToken);
        (*portfolioBalance)[_portfolioName] = tokenBalance;
        *totalToken = totalToken.get() + tokenBalance; 
        
        DIPC_EMIT_EVENT(portfolioInfo, _portfolioName, &portfolioStr[0], "portfolioBalance", tokenBalance);
    }

    
    PAYABLE void PortfolioManage::depositPortfolio(char* _portfolioName){
        uint64_t tokenBalance = getTotalBalance();
        
        uint64_t currentBalance = portfolioBalance.get()[_portfolioName];
        uint64_t finalBalance  = currentBalance + tokenBalance;
        DipcAssert(totalToken.get() + tokenBalance > totalToken);
        DipcAssert(finalBalance > currentBalance);
        (*portfolioBalance)[_portfolioName] = finalBalance;
        *totalToken = totalToken.get() + finalBalance; 
        DIPC_EMIT_EVENT(depositPortfolio, "portfolioName", _portfolioName, "portfolioBalance", finalBalance);
    }
    
    PAYABLE void PortfolioManage::createOrder(char* _portfolioName, char* _orderId, uint16_t _orderType, char* _stockCode, uint64_t _stockPrice, uint64_t _stockAmount, uint64_t _endTime){
        uint64_t tokenBalance = getTotalBalance();
        DIPC_EMIT_EVENT(createOrder, "portfolioName", _portfolioName, "OrderInfo", "ignore", "tokenBalance", tokenBalance);
        uint64_t spent = 0;
        if(_orderType == 1){
            spent = _stockPrice * _stockAmount;
            DipcAssert((portfolioBalance.get()[_portfolioName] + tokenBalance) > spent);
        }
        struct Order order{_orderId, _orderType, _stockCode, _stockPrice, _stockAmount, _endTime, 0};
        std::string pInfo = portfolioStorge.get()[_portfolioName];
        
        
        
        if(pInfo == "") {
            DIPC_EMIT_EVENT(ErrEvent, "Current portfolio  doesn't exist: ", _portfolioName);
            return;
        }
        PortfolioInfo info;
        info.parseJson(pInfo);
        if(info.getOrder(_orderId).orderId != ""){
            DIPC_EMIT_EVENT(ErrEvent, "Current order exist: ", _orderId);
            return;
        }
        info.addOrder(order);
        pInfo = info.toJson();

        uint64_t currentBalance = portfolioBalance.get()[_portfolioName] ;
        uint64_t finalBalance = currentBalance + tokenBalance - spent;
        DipcAssert(totalToken.get() + tokenBalance > totalToken);
        
        DipcAssert(ownerTotalToken.get() < ownerTotalToken.get() + spent);
        (*portfolioStorge)[_portfolioName] = &pInfo[0];
        
        
        
        


        (*portfolioBalance)[_portfolioName] = finalBalance;
        *totalToken = totalToken.get() + finalBalance; 
        *ownerTotalToken = ownerTotalToken.get() + spent;
        DIPC_EMIT_EVENT(createOrder, "portfolioName", _portfolioName, "OrderInfo", &order.toJson()[0], "portfolioBalance", finalBalance);
    }

    
    EXPORT void PortfolioManage::dealOrder(char* _portfolioName, char* _orderId){
        isOwner();
        std::string pInfo = portfolioStorge.get()[_portfolioName];
        
        
        PortfolioInfo info;
        info.parseJson(pInfo);
        

        
         Order ord = info.getOrder(_orderId);
         
         
        if(ord.orderId != "" && ord.orderStatus == 0){
            
            uint64_t timenow = dipc::timestamp();
            if(ord.endTime > timenow){
                ord.orderStatus = 1;
            }else {
                ord.orderStatus = 3;
            }
        } else {
          

            return;
        }
        

        uint64_t sellValue = 0;
        if(ord.orderType == 0){
            sellValue = ord.stockAmount * ord.stockPrice;
        }
        uint64_t currentBalance =  portfolioBalance.get()[_portfolioName];
        

        DipcAssert(currentBalance + sellValue >= currentBalance);
        DipcAssert((ownerTotalToken.get() - sellValue) <= ownerTotalToken.get());
        


        (*portfolioBalance)[_portfolioName] = currentBalance + sellValue;
        *ownerTotalToken = ownerTotalToken.get() - sellValue;
        (*portfolioStorge)[_portfolioName] = &info.toJson()[0];
        
        
        
        

        DIPC_EMIT_EVENT(dealPortfolio, "orderId", _orderId, "orderInfo", &ord.toJson()[0]);
    }
    
    EXPORT void PortfolioManage::revocationOrder(char* _portfolioName, char* _orderId){
        std::string pInfo = portfolioStorge.get()[_portfolioName];
        
        
        PortfolioInfo info;
        info.parseJson(pInfo);
        Order ord = info.getOrder(_orderId);
        
        
        if(ord.orderId != "" && ord.orderStatus == 0){
            std::string callerStr = caller().toString();
            
            
            
            DipcAssert(info.getOwnerAddress() == caller().toString());
            

            uint64_t timenow = dipc::timestamp();
            if(ord.endTime > timenow){
                ord.orderStatus = 2;
            }else {
                ord.orderStatus = 3;
            }
        } else {
            return;
        }
        uint64_t lockToken = 0;
        if(ord.orderType == 1){
            lockToken = ord.stockPrice * ord.stockAmount;
        }
        uint64_t currentBalance =  portfolioBalance.get()[_portfolioName];
        
        
        
        

        DipcAssert(currentBalance + lockToken >= currentBalance);
        DipcAssert(ownerTotalToken.get() - lockToken <= ownerTotalToken.get());

        
        (*portfolioBalance)[_portfolioName] = currentBalance + lockToken;
        *ownerTotalToken = ownerTotalToken.get() - lockToken;
        (*portfolioStorge)[_portfolioName] = &info.toJson()[0];
        DIPC_EMIT_EVENT(revocationPortfolio, "orderId", _orderId, "orderInfo", &ord.toJson()[0]);
    }
    
    EXPORT void PortfolioManage::withdrawPortfolio(char* _portfolioName, uint64_t _withdrawBalance){
         if(!userCanWithdraw.get()){
             return;
         }
         uint64_t currentBalance =  portfolioBalance.get()[_portfolioName];
         DipcAssert(currentBalance - _withdrawBalance < currentBalance);
         auto coinBalance = changeUint64ToU256WithChangeRate(currentBalance, changeRate.get());
         (*portfolioBalance)[_portfolioName] = currentBalance - _withdrawBalance;
         callTransfer(caller(), coinBalance);
    }
    
    EXPORT void PortfolioManage::withdrawPool(uint64_t _balance){
        isOwner();
        Address ownerAddr = Address(owner.get()); 
        callTransfer(ownerAddr, _balance);
        *ownerTotalToken = ownerTotalToken.get() - _balance * changeRate.get();
        *totalToken = totalToken.get() - _balance * changeRate.get();
        DIPC_EMIT_EVENT(tokenCount, "ownerTotalToken", ownerTotalToken.get(), "totalToken", totalToken.get());
    }
    
    PAYABLE void PortfolioManage::depositPool(uint64_t _depositValue){
        isOwner();
        
        uint64_t tokenBalance = changeU256ToUint64WithChangeRate(callValue(), changeRate.get()); 
        *ownerTotalToken = ownerTotalToken.get() + tokenBalance;
        *totalToken = totalToken.get() + tokenBalance;
        DIPC_EMIT_EVENT(tokenCount, "ownerTotalToken", ownerTotalToken.get(), "totalToken", totalToken.get());
    }
     
    CONSTANT uint64_t PortfolioManage::queryTotalToken(){
        return totalToken.get();
    }

     
    CONSTANT uint64_t PortfolioManage::queryPortfolioBalance(char* _portfolioName){
        return portfolioBalance.get()[_portfolioName];
    }

    
    CONSTANT bool PortfolioManage::queryPortfolioNameIfUsed(char* _portfolioName){
        if(portfolioStorge.get()[_portfolioName] != ""){
            return true;
        } 
        return false;
    }

    
    CONSTANT uint64_t PortfolioManage::queryChangeRate(){
        return changeRate.get();
    }

2019-12-19_15:14:53.301947: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:401] abis.ispayable :false

2019-12-19_15:14:53.301964: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:424] finalContract  this height  #include "PortfolioManage.hpp"

    
    PAYABLE void PortfolioManage::init(){
        *owner = caller().toString();
        *changeRate = 10000;
        *userCanWithdraw = false;
        uint64_t tokenBalance = getTotalBalance();
        
        *ownerTotalToken = tokenBalance;
        *totalToken = ownerTotalToken.get();
        
        
        DIPC_EMIT_EVENT(initEvent, "ownerTotalToken" ,tokenBalance);
    }
    
     
    EXPORT void PortfolioManage::setChangeRate(uint64_t _changeRate){
        isOwner();
        *changeRate = _changeRate;
    }
     
    EXPORT void PortfolioManage::setUserCanWithdraw(bool _canWithdraw){
        isOwner();
        *userCanWithdraw = _canWithdraw;
    }

    
    PAYABLE void PortfolioManage::createPortfolio(char* _portfolioName, char* _portfolioDesc){
        if(portfolioStorge.get()[_portfolioName] != ""){
            DIPC_EMIT_EVENT(ErrEvent, "Current portfolio exist: ", _portfolioName);
            return;
        } 
        std::string callerAddr = caller().toString();
        uint64_t tokenBalance = getTotalBalance();
        
        PortfolioInfo info(_portfolioName, _portfolioDesc, &callerAddr[0]);
        std::string portfolioStr = info.toJson();
        
        
        

        (*portfolioStorge)[_portfolioName] = portfolioStr;
        DipcAssert(totalToken.get() + tokenBalance > totalToken);
        (*portfolioBalance)[_portfolioName] = tokenBalance;
        *totalToken = totalToken.get() + tokenBalance; 
        
        DIPC_EMIT_EVENT(portfolioInfo, _portfolioName, &portfolioStr[0], "portfolioBalance", tokenBalance);
    }

    
    PAYABLE void PortfolioManage::depositPortfolio(char* _portfolioName){
        uint64_t tokenBalance = getTotalBalance();
        
        uint64_t currentBalance = portfolioBalance.get()[_portfolioName];
        uint64_t finalBalance  = currentBalance + tokenBalance;
        DipcAssert(totalToken.get() + tokenBalance > totalToken);
        DipcAssert(finalBalance > currentBalance);
        (*portfolioBalance)[_portfolioName] = finalBalance;
        *totalToken = totalToken.get() + finalBalance; 
        DIPC_EMIT_EVENT(depositPortfolio, "portfolioName", _portfolioName, "portfolioBalance", finalBalance);
    }
    
    PAYABLE void PortfolioManage::createOrder(char* _portfolioName, char* _orderId, uint16_t _orderType, char* _stockCode, uint64_t _stockPrice, uint64_t _stockAmount, uint64_t _endTime){
        uint64_t tokenBalance = getTotalBalance();
        DIPC_EMIT_EVENT(createOrder, "portfolioName", _portfolioName, "OrderInfo", "ignore", "tokenBalance", tokenBalance);
        uint64_t spent = 0;
        if(_orderType == 1){
            spent = _stockPrice * _stockAmount;
            DipcAssert((portfolioBalance.get()[_portfolioName] + tokenBalance) > spent);
        }
        struct Order order{_orderId, _orderType, _stockCode, _stockPrice, _stockAmount, _endTime, 0};
        std::string pInfo = portfolioStorge.get()[_portfolioName];
        
        
        
        if(pInfo == "") {
            DIPC_EMIT_EVENT(ErrEvent, "Current portfolio  doesn't exist: ", _portfolioName);
            return;
        }
        PortfolioInfo info;
        info.parseJson(pInfo);
        if(info.getOrder(_orderId).orderId != ""){
            DIPC_EMIT_EVENT(ErrEvent, "Current order exist: ", _orderId);
            return;
        }
        info.addOrder(order);
        pInfo = info.toJson();

        uint64_t currentBalance = portfolioBalance.get()[_portfolioName] ;
        uint64_t finalBalance = currentBalance + tokenBalance - spent;
        DipcAssert(totalToken.get() + tokenBalance > totalToken);
        
        DipcAssert(ownerTotalToken.get() < ownerTotalToken.get() + spent);
        (*portfolioStorge)[_portfolioName] = &pInfo[0];
        
        
        
        


        (*portfolioBalance)[_portfolioName] = finalBalance;
        *totalToken = totalToken.get() + finalBalance; 
        *ownerTotalToken = ownerTotalToken.get() + spent;
        DIPC_EMIT_EVENT(createOrder, "portfolioName", _portfolioName, "OrderInfo", &order.toJson()[0], "portfolioBalance", finalBalance);
    }

    
    EXPORT void PortfolioManage::dealOrder(char* _portfolioName, char* _orderId){
        isOwner();
        std::string pInfo = portfolioStorge.get()[_portfolioName];
        
        
        PortfolioInfo info;
        info.parseJson(pInfo);
        

        
         Order ord = info.getOrder(_orderId);
         
         
        if(ord.orderId != "" && ord.orderStatus == 0){
            
            uint64_t timenow = dipc::timestamp();
            if(ord.endTime > timenow){
                ord.orderStatus = 1;
            }else {
                ord.orderStatus = 3;
            }
        } else {
          

            return;
        }
        

        uint64_t sellValue = 0;
        if(ord.orderType == 0){
            sellValue = ord.stockAmount * ord.stockPrice;
        }
        uint64_t currentBalance =  portfolioBalance.get()[_portfolioName];
        

        DipcAssert(currentBalance + sellValue >= currentBalance);
        DipcAssert((ownerTotalToken.get() - sellValue) <= ownerTotalToken.get());
        


        (*portfolioBalance)[_portfolioName] = currentBalance + sellValue;
        *ownerTotalToken = ownerTotalToken.get() - sellValue;
        (*portfolioStorge)[_portfolioName] = &info.toJson()[0];
        
        
        
        

        DIPC_EMIT_EVENT(dealPortfolio, "orderId", _orderId, "orderInfo", &ord.toJson()[0]);
    }
    
    EXPORT void PortfolioManage::revocationOrder(char* _portfolioName, char* _orderId){
        std::string pInfo = portfolioStorge.get()[_portfolioName];
        
        
        PortfolioInfo info;
        info.parseJson(pInfo);
        Order ord = info.getOrder(_orderId);
        
        
        if(ord.orderId != "" && ord.orderStatus == 0){
            std::string callerStr = caller().toString();
            
            
            
            DipcAssert(info.getOwnerAddress() == caller().toString());
            

            uint64_t timenow = dipc::timestamp();
            if(ord.endTime > timenow){
                ord.orderStatus = 2;
            }else {
                ord.orderStatus = 3;
            }
        } else {
            return;
        }
        uint64_t lockToken = 0;
        if(ord.orderType == 1){
            lockToken = ord.stockPrice * ord.stockAmount;
        }
        uint64_t currentBalance =  portfolioBalance.get()[_portfolioName];
        
        
        
        

        DipcAssert(currentBalance + lockToken >= currentBalance);
        DipcAssert(ownerTotalToken.get() - lockToken <= ownerTotalToken.get());

        
        (*portfolioBalance)[_portfolioName] = currentBalance + lockToken;
        *ownerTotalToken = ownerTotalToken.get() - lockToken;
        (*portfolioStorge)[_portfolioName] = &info.toJson()[0];
        DIPC_EMIT_EVENT(revocationPortfolio, "orderId", _orderId, "orderInfo", &ord.toJson()[0]);
    }
    
    EXPORT void PortfolioManage::withdrawPortfolio(char* _portfolioName, uint64_t _withdrawBalance){
         if(!userCanWithdraw.get()){
             return;
         }
         uint64_t currentBalance =  portfolioBalance.get()[_portfolioName];
         DipcAssert(currentBalance - _withdrawBalance < currentBalance);
         auto coinBalance = changeUint64ToU256WithChangeRate(currentBalance, changeRate.get());
         (*portfolioBalance)[_portfolioName] = currentBalance - _withdrawBalance;
         callTransfer(caller(), coinBalance);
    }
    
    EXPORT void PortfolioManage::withdrawPool(uint64_t _balance){
        isOwner();
        Address ownerAddr = Address(owner.get()); 
        callTransfer(ownerAddr, _balance);
        *ownerTotalToken = ownerTotalToken.get() - _balance * changeRate.get();
        *totalToken = totalToken.get() - _balance * changeRate.get();
        DIPC_EMIT_EVENT(tokenCount, "ownerTotalToken", ownerTotalToken.get(), "totalToken", totalToken.get());
    }
    
    PAYABLE void PortfolioManage::depositPool(uint64_t _depositValue){
        isOwner();
        
        uint64_t tokenBalance = changeU256ToUint64WithChangeRate(callValue(), changeRate.get()); 
        *ownerTotalToken = ownerTotalToken.get() + tokenBalance;
        *totalToken = totalToken.get() + tokenBalance;
        DIPC_EMIT_EVENT(tokenCount, "ownerTotalToken", ownerTotalToken.get(), "totalToken", totalToken.get());
    }
     
    CONSTANT uint64_t PortfolioManage::queryTotalToken(){
        return totalToken.get();
    }

     
    CONSTANT uint64_t PortfolioManage::queryPortfolioBalance(char* _portfolioName){
        return portfolioBalance.get()[_portfolioName];
    }

    
    CONSTANT bool PortfolioManage::queryPortfolioNameIfUsed(char* _portfolioName){
        if(portfolioStorge.get()[_portfolioName] != ""){
            return true;
        } 
        return false;
    }

    
    CONSTANT uint64_t PortfolioManage::queryChangeRate(){
        return changeRate.get();
    } codetext height #include "PortfolioManage.hpp"

    
    PAYABLE void PortfolioManage::init(){
        *owner = caller().toString();
        *changeRate = 10000;
        *userCanWithdraw = false;
        uint64_t tokenBalance = getTotalBalance();
        
        *ownerTotalToken = tokenBalance;
        *totalToken = ownerTotalToken.get();
        
        
        DIPC_EMIT_EVENT(initEvent, "ownerTotalToken" ,tokenBalance);
    }
    
     
    EXPORT void PortfolioManage::setChangeRate(uint64_t _changeRate){
        isOwner();
        *changeRate = _changeRate;
    }
     
    EXPORT void PortfolioManage::setUserCanWithdraw(bool _canWithdraw){
        isOwner();
        *userCanWithdraw = _canWithdraw;
    }

    
    PAYABLE void PortfolioManage::createPortfolio(char* _portfolioName, char* _portfolioDesc){
        if(portfolioStorge.get()[_portfolioName] != ""){
            DIPC_EMIT_EVENT(ErrEvent, "Current portfolio exist: ", _portfolioName);
            return;
        } 
        std::string callerAddr = caller().toString();
        uint64_t tokenBalance = getTotalBalance();
        
        PortfolioInfo info(_portfolioName, _portfolioDesc, &callerAddr[0]);
        std::string portfolioStr = info.toJson();
        
        
        

        (*portfolioStorge)[_portfolioName] = portfolioStr;
        DipcAssert(totalToken.get() + tokenBalance > totalToken);
        (*portfolioBalance)[_portfolioName] = tokenBalance;
        *totalToken = totalToken.get() + tokenBalance; 
        
        DIPC_EMIT_EVENT(portfolioInfo, _portfolioName, &portfolioStr[0], "portfolioBalance", tokenBalance);
    }

    
    PAYABLE void PortfolioManage::depositPortfolio(char* _portfolioName){
        uint64_t tokenBalance = getTotalBalance();
        
        uint64_t currentBalance = portfolioBalance.get()[_portfolioName];
        uint64_t finalBalance  = currentBalance + tokenBalance;
        DipcAssert(totalToken.get() + tokenBalance > totalToken);
        DipcAssert(finalBalance > currentBalance);
        (*portfolioBalance)[_portfolioName] = finalBalance;
        *totalToken = totalToken.get() + finalBalance; 
        DIPC_EMIT_EVENT(depositPortfolio, "portfolioName", _portfolioName, "portfolioBalance", finalBalance);
    }
    
    PAYABLE void PortfolioManage::createOrder(char* _portfolioName, char* _orderId, uint16_t _orderType, char* _stockCode, uint64_t _stockPrice, uint64_t _stockAmount, uint64_t _endTime){
        uint64_t tokenBalance = getTotalBalance();
        DIPC_EMIT_EVENT(createOrder, "portfolioName", _portfolioName, "OrderInfo", "ignore", "tokenBalance", tokenBalance);
        uint64_t spent = 0;
        if(_orderType == 1){
            spent = _stockPrice * _stockAmount;
            DipcAssert((portfolioBalance.get()[_portfolioName] + tokenBalance) > spent);
        }
        struct Order order{_orderId, _orderType, _stockCode, _stockPrice, _stockAmount, _endTime, 0};
        std::string pInfo = portfolioStorge.get()[_portfolioName];
        
        
        
        if(pInfo == "") {
            DIPC_EMIT_EVENT(ErrEvent, "Current portfolio  doesn't exist: ", _portfolioName);
            return;
        }
        PortfolioInfo info;
        info.parseJson(pInfo);
        if(info.getOrder(_orderId).orderId != ""){
            DIPC_EMIT_EVENT(ErrEvent, "Current order exist: ", _orderId);
            return;
        }
        info.addOrder(order);
        pInfo = info.toJson();

        uint64_t currentBalance = portfolioBalance.get()[_portfolioName] ;
        uint64_t finalBalance = currentBalance + tokenBalance - spent;
        DipcAssert(totalToken.get() + tokenBalance > totalToken);
        
        DipcAssert(ownerTotalToken.get() < ownerTotalToken.get() + spent);
        (*portfolioStorge)[_portfolioName] = &pInfo[0];
        
        
        
        


        (*portfolioBalance)[_portfolioName] = finalBalance;
        *totalToken = totalToken.get() + finalBalance; 
        *ownerTotalToken = ownerTotalToken.get() + spent;
        DIPC_EMIT_EVENT(createOrder, "portfolioName", _portfolioName, "OrderInfo", &order.toJson()[0], "portfolioBalance", finalBalance);
    }

    
    EXPORT void PortfolioManage::dealOrder(char* _portfolioName, char* _orderId){
        isOwner();
        std::string pInfo = portfolioStorge.get()[_portfolioName];
        
        
        PortfolioInfo info;
        info.parseJson(pInfo);
        

        
         Order ord = info.getOrder(_orderId);
         
         
        if(ord.orderId != "" && ord.orderStatus == 0){
            
            uint64_t timenow = dipc::timestamp();
            if(ord.endTime > timenow){
                ord.orderStatus = 1;
            }else {
                ord.orderStatus = 3;
            }
        } else {
          

            return;
        }
        

        uint64_t sellValue = 0;
        if(ord.orderType == 0){
            sellValue = ord.stockAmount * ord.stockPrice;
        }
        uint64_t currentBalance =  portfolioBalance.get()[_portfolioName];
        

        DipcAssert(currentBalance + sellValue >= currentBalance);
        DipcAssert((ownerTotalToken.get() - sellValue) <= ownerTotalToken.get());
        


        (*portfolioBalance)[_portfolioName] = currentBalance + sellValue;
        *ownerTotalToken = ownerTotalToken.get() - sellValue;
        (*portfolioStorge)[_portfolioName] = &info.toJson()[0];
        
        
        
        

        DIPC_EMIT_EVENT(dealPortfolio, "orderId", _orderId, "orderInfo", &ord.toJson()[0]);
    }
    
    EXPORT void PortfolioManage::revocationOrder(char* _portfolioName, char* _orderId){
        std::string pInfo = portfolioStorge.get()[_portfolioName];
        
        
        PortfolioInfo info;
        info.parseJson(pInfo);
        Order ord = info.getOrder(_orderId);
        
        
        if(ord.orderId != "" && ord.orderStatus == 0){
            std::string callerStr = caller().toString();
            
            
            
            DipcAssert(info.getOwnerAddress() == caller().toString());
            

            uint64_t timenow = dipc::timestamp();
            if(ord.endTime > timenow){
                ord.orderStatus = 2;
            }else {
                ord.orderStatus = 3;
            }
        } else {
            return;
        }
        uint64_t lockToken = 0;
        if(ord.orderType == 1){
            lockToken = ord.stockPrice * ord.stockAmount;
        }
        uint64_t currentBalance =  portfolioBalance.get()[_portfolioName];
        
        
        
        

        DipcAssert(currentBalance + lockToken >= currentBalance);
        DipcAssert(ownerTotalToken.get() - lockToken <= ownerTotalToken.get());

        
        (*portfolioBalance)[_portfolioName] = currentBalance + lockToken;
        *ownerTotalToken = ownerTotalToken.get() - lockToken;
        (*portfolioStorge)[_portfolioName] = &info.toJson()[0];
        DIPC_EMIT_EVENT(revocationPortfolio, "orderId", _orderId, "orderInfo", &ord.toJson()[0]);
    }
    
    EXPORT void PortfolioManage::withdrawPortfolio(char* _portfolioName, uint64_t _withdrawBalance){
         if(!userCanWithdraw.get()){
             return;
         }
         uint64_t currentBalance =  portfolioBalance.get()[_portfolioName];
         DipcAssert(currentBalance - _withdrawBalance < currentBalance);
         auto coinBalance = changeUint64ToU256WithChangeRate(currentBalance, changeRate.get());
         (*portfolioBalance)[_portfolioName] = currentBalance - _withdrawBalance;
         callTransfer(caller(), coinBalance);
    }
    
    EXPORT void PortfolioManage::withdrawPool(uint64_t _balance){
        isOwner();
        Address ownerAddr = Address(owner.get()); 
        callTransfer(ownerAddr, _balance);
        *ownerTotalToken = ownerTotalToken.get() - _balance * changeRate.get();
        *totalToken = totalToken.get() - _balance * changeRate.get();
        DIPC_EMIT_EVENT(tokenCount, "ownerTotalToken", ownerTotalToken.get(), "totalToken", totalToken.get());
    }
    
    PAYABLE void PortfolioManage::depositPool(uint64_t _depositValue){
        isOwner();
        
        uint64_t tokenBalance = changeU256ToUint64WithChangeRate(callValue(), changeRate.get()); 
        *ownerTotalToken = ownerTotalToken.get() + tokenBalance;
        *totalToken = totalToken.get() + tokenBalance;
        DIPC_EMIT_EVENT(tokenCount, "ownerTotalToken", ownerTotalToken.get(), "totalToken", totalToken.get());
    }
     
    CONSTANT uint64_t PortfolioManage::queryTotalToken(){
        return totalToken.get();
    }

     
    CONSTANT uint64_t PortfolioManage::queryPortfolioBalance(char* _portfolioName){
        return portfolioBalance.get()[_portfolioName];
    }

    
    CONSTANT bool PortfolioManage::queryPortfolioNameIfUsed(char* _portfolioName){
        if(portfolioStorge.get()[_portfolioName] != ""){
            return true;
        } 
        return false;
    }

    
    CONSTANT uint64_t PortfolioManage::queryChangeRate(){
        return changeRate.get();
    }

2019-12-19_15:14:53.301975: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:427] searchContext  #include "PortfolioManage.hpp"

    
    PAYABLE void PortfolioManage::init(){
        *owner = caller().toString();
        *changeRate = 10000;
        *userCanWithdraw = false;
        uint64_t tokenBalance = getTotalBalance();
        
        *ownerTotalToken = tokenBalance;
        *totalToken = ownerTotalToken.get();
        
        
        DIPC_EMIT_EVENT(initEvent, "ownerTotalToken" ,tokenBalance);
    }
    
     
    EXPORT void PortfolioManage::setChangeRate(uint64_t _changeRate){
        isOwner();
        *changeRate = _changeRate;
    }
     
    EXPORT void PortfolioManage::setUserCanWithdraw(bool _canWithdraw){
        isOwner();
        *userCanWithdraw = _canWithdraw;
    }

    
    PAYABLE void PortfolioManage::createPortfolio(char* _portfolioName, char* _portfolioDesc){
        if(portfolioStorge.get()[_portfolioName] != ""){
            DIPC_EMIT_EVENT(ErrEvent, "Current portfolio exist: ", _portfolioName);
            return;
        } 
        std::string callerAddr = caller().toString();
        uint64_t tokenBalance = getTotalBalance();
        
        PortfolioInfo info(_portfolioName, _portfolioDesc, &callerAddr[0]);
        std::string portfolioStr = info.toJson();
        
        
        

        (*portfolioStorge)[_portfolioName] = portfolioStr;
        DipcAssert(totalToken.get() + tokenBalance > totalToken);
        (*portfolioBalance)[_portfolioName] = tokenBalance;
        *totalToken = totalToken.get() + tokenBalance; 
        
        DIPC_EMIT_EVENT(portfolioInfo, _portfolioName, &portfolioStr[0], "portfolioBalance", tokenBalance);
    }

    
    PAYABLE void PortfolioManage::depositPortfolio(char* _portfolioName){
        uint64_t tokenBalance = getTotalBalance();
        
        uint64_t currentBalance = portfolioBalance.get()[_portfolioName];
        uint64_t finalBalance  = currentBalance + tokenBalance;
        DipcAssert(totalToken.get() + tokenBalance > totalToken);
        DipcAssert(finalBalance > currentBalance);
        (*portfolioBalance)[_portfolioName] = finalBalance;
        *totalToken = totalToken.get() + finalBalance; 
        DIPC_EMIT_EVENT(depositPortfolio, "portfolioName", _portfolioName, "portfolioBalance", finalBalance);
    }
    
    PAYABLE void PortfolioManage::createOrder(char* _portfolioName, char* _orderId, uint16_t _orderType, char* _stockCode, uint64_t _stockPrice, uint64_t _stockAmount, uint64_t _endTime){
        uint64_t tokenBalance = getTotalBalance();
        DIPC_EMIT_EVENT(createOrder, "portfolioName", _portfolioName, "OrderInfo", "ignore", "tokenBalance", tokenBalance);
        uint64_t spent = 0;
        if(_orderType == 1){
            spent = _stockPrice * _stockAmount;
            DipcAssert((portfolioBalance.get()[_portfolioName] + tokenBalance) > spent);
        }
        struct Order order{_orderId, _orderType, _stockCode, _stockPrice, _stockAmount, _endTime, 0};
        std::string pInfo = portfolioStorge.get()[_portfolioName];
        
        
        
        if(pInfo == "") {
            DIPC_EMIT_EVENT(ErrEvent, "Current portfolio  doesn't exist: ", _portfolioName);
            return;
        }
        PortfolioInfo info;
        info.parseJson(pInfo);
        if(info.getOrder(_orderId).orderId != ""){
            DIPC_EMIT_EVENT(ErrEvent, "Current order exist: ", _orderId);
            return;
        }
        info.addOrder(order);
        pInfo = info.toJson();

        uint64_t currentBalance = portfolioBalance.get()[_portfolioName] ;
        uint64_t finalBalance = currentBalance + tokenBalance - spent;
        DipcAssert(totalToken.get() + tokenBalance > totalToken);
        
        DipcAssert(ownerTotalToken.get() < ownerTotalToken.get() + spent);
        (*portfolioStorge)[_portfolioName] = &pInfo[0];
        
        
        
        


        (*portfolioBalance)[_portfolioName] = finalBalance;
        *totalToken = totalToken.get() + finalBalance; 
        *ownerTotalToken = ownerTotalToken.get() + spent;
        DIPC_EMIT_EVENT(createOrder, "portfolioName", _portfolioName, "OrderInfo", &order.toJson()[0], "portfolioBalance", finalBalance);
    }

    
    EXPORT void PortfolioManage::dealOrder(char* _portfolioName, char* _orderId){
        isOwner();
        std::string pInfo = portfolioStorge.get()[_portfolioName];
        
        
        PortfolioInfo info;
        info.parseJson(pInfo);
        

        
         Order ord = info.getOrder(_orderId);
         
         
        if(ord.orderId != "" && ord.orderStatus == 0){
            
            uint64_t timenow = dipc::timestamp();
            if(ord.endTime > timenow){
                ord.orderStatus = 1;
            }else {
                ord.orderStatus = 3;
            }
        } else {
          

            return;
        }
        

        uint64_t sellValue = 0;
        if(ord.orderType == 0){
            sellValue = ord.stockAmount * ord.stockPrice;
        }
        uint64_t currentBalance =  portfolioBalance.get()[_portfolioName];
        

        DipcAssert(currentBalance + sellValue >= currentBalance);
        DipcAssert((ownerTotalToken.get() - sellValue) <= ownerTotalToken.get());
        


        (*portfolioBalance)[_portfolioName] = currentBalance + sellValue;
        *ownerTotalToken = ownerTotalToken.get() - sellValue;
        (*portfolioStorge)[_portfolioName] = &info.toJson()[0];
        
        
        
        

        DIPC_EMIT_EVENT(dealPortfolio, "orderId", _orderId, "orderInfo", &ord.toJson()[0]);
    }
    
    EXPORT void PortfolioManage::revocationOrder(char* _portfolioName, char* _orderId){
        std::string pInfo = portfolioStorge.get()[_portfolioName];
        
        
        PortfolioInfo info;
        info.parseJson(pInfo);
        Order ord = info.getOrder(_orderId);
        
        
        if(ord.orderId != "" && ord.orderStatus == 0){
            std::string callerStr = caller().toString();
            
            
            
            DipcAssert(info.getOwnerAddress() == caller().toString());
            

            uint64_t timenow = dipc::timestamp();
            if(ord.endTime > timenow){
                ord.orderStatus = 2;
            }else {
                ord.orderStatus = 3;
            }
        } else {
            return;
        }
        uint64_t lockToken = 0;
        if(ord.orderType == 1){
            lockToken = ord.stockPrice * ord.stockAmount;
        }
        uint64_t currentBalance =  portfolioBalance.get()[_portfolioName];
        
        
        
        

        DipcAssert(currentBalance + lockToken >= currentBalance);
        DipcAssert(ownerTotalToken.get() - lockToken <= ownerTotalToken.get());

        
        (*portfolioBalance)[_portfolioName] = currentBalance + lockToken;
        *ownerTotalToken = ownerTotalToken.get() - lockToken;
        (*portfolioStorge)[_portfolioName] = &info.toJson()[0];
        DIPC_EMIT_EVENT(revocationPortfolio, "orderId", _orderId, "orderInfo", &ord.toJson()[0]);
    }
    
    EXPORT void PortfolioManage::withdrawPortfolio(char* _portfolioName, uint64_t _withdrawBalance){
         if(!userCanWithdraw.get()){
             return;
         }
         uint64_t currentBalance =  portfolioBalance.get()[_portfolioName];
         DipcAssert(currentBalance - _withdrawBalance < currentBalance);
         auto coinBalance = changeUint64ToU256WithChangeRate(currentBalance, changeRate.get());
         (*portfolioBalance)[_portfolioName] = currentBalance - _withdrawBalance;
         callTransfer(caller(), coinBalance);
    }
    
    EXPORT void PortfolioManage::withdrawPool(uint64_t _balance){
        isOwner();
        Address ownerAddr = Address(owner.get()); 
        callTransfer(ownerAddr, _balance);
        *ownerTotalToken = ownerTotalToken.get() - _balance * changeRate.get();
        *totalToken = totalToken.get() - _balance * changeRate.get();
        DIPC_EMIT_EVENT(tokenCount, "ownerTotalToken", ownerTotalToken.get(), "totalToken", totalToken.get());
    }
    
    PAYABLE void PortfolioManage::depositPool(uint64_t _depositValue){
        isOwner();
        
        uint64_t tokenBalance = changeU256ToUint64WithChangeRate(callValue(), changeRate.get()); 
        *ownerTotalToken = ownerTotalToken.get() + tokenBalance;
        *totalToken = totalToken.get() + tokenBalance;
        DIPC_EMIT_EVENT(tokenCount, "ownerTotalToken", ownerTotalToken.get(), "totalToken", totalToken.get());
    }
     
    CONSTANT uint64_t PortfolioManage::queryTotalToken(){
        return totalToken.get();
    }

     
    CONSTANT uint64_t PortfolioManage::queryPortfolioBalance(char* _portfolioName){
        return portfolioBalance.get()[_portfolioName];
    }

    
    CONSTANT bool PortfolioManage::queryPortfolioNameIfUsed(char* _portfolioName){
        if(portfolioStorge.get()[_portfolioName] != ""){
            return true;
        } 
        return false;
    }

    
    CONSTANT uint64_t PortfolioManage::queryChangeRate(){
        return changeRate.get();
    }

2019-12-19_15:14:53.313779: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:451] log out out  Export :
     
    EXPORT void PortfolioManage::setUserCanWithdraw(bool _canWithdraw){
        

2019-12-19_15:14:53.313794: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:457] name : setUserCanWithdraw   pos1  0

2019-12-19_15:14:53.313803: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:469] pos2  559   pos1  559

2019-12-19_15:14:53.313810: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:500] pos2 after 703   pos1  559

2019-12-19_15:14:53.313817: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:509] finalContract  first #include "PortfolioManage.hpp"

    
    PAYABLE void PortfolioManage::init(){
        *owner = caller().toString();
        *changeRate = 10000;
        *userCanWithdraw = false;
        uint64_t tokenBalance = getTotalBalance();
        
        *ownerTotalToken = tokenBalance;
        *totalToken = ownerTotalToken.get();
        
        
        DIPC_EMIT_EVENT(initEvent, "ownerTotalToken" ,tokenBalance);
    }
    
     
    EXPORT void PortfolioManage::setChangeRate(uint64_t _changeRate){
        isOwner();
        *changeRate = _changeRate;
    }

2019-12-19_15:14:53.313823: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:510] codetext  first #include "PortfolioManage.hpp"

    
    PAYABLE void PortfolioManage::init(){
        *owner = caller().toString();
        *changeRate = 10000;
        *userCanWithdraw = false;
        uint64_t tokenBalance = getTotalBalance();
        
        *ownerTotalToken = tokenBalance;
        *totalToken = ownerTotalToken.get();
        
        
        DIPC_EMIT_EVENT(initEvent, "ownerTotalToken" ,tokenBalance);
    }
    
     
    EXPORT void PortfolioManage::setChangeRate(uint64_t _changeRate){
        isOwner();
        *changeRate = _changeRate;
    }
     
    EXPORT void PortfolioManage::setUserCanWithdraw(bool _canWithdraw){
        isOwner();
        *userCanWithdraw = _canWithdraw;
    }

    
    PAYABLE void PortfolioManage::createPortfolio(char* _portfolioName, char* _portfolioDesc){
        if(portfolioStorge.get()[_portfolioName] != ""){
            DIPC_EMIT_EVENT(ErrEvent, "Current portfolio exist: ", _portfolioName);
            return;
        } 
        std::string callerAddr = caller().toString();
        uint64_t tokenBalance = getTotalBalance();
        
        PortfolioInfo info(_portfolioName, _portfolioDesc, &callerAddr[0]);
        std::string portfolioStr = info.toJson();
        
        
        

        (*portfolioStorge)[_portfolioName] = portfolioStr;
        DipcAssert(totalToken.get() + tokenBalance > totalToken);
        (*portfolioBalance)[_portfolioName] = tokenBalance;
        *totalToken = totalToken.get() + tokenBalance; 
        
        DIPC_EMIT_EVENT(portfolioInfo, _portfolioName, &portfolioStr[0], "portfolioBalance", tokenBalance);
    }

    
    PAYABLE void PortfolioManage::depositPortfolio(char* _portfolioName){
        uint64_t tokenBalance = getTotalBalance();
        
        uint64_t currentBalance = portfolioBalance.get()[_portfolioName];
        uint64_t finalBalance  = currentBalance + tokenBalance;
        DipcAssert(totalToken.get() + tokenBalance > totalToken);
        DipcAssert(finalBalance > currentBalance);
        (*portfolioBalance)[_portfolioName] = finalBalance;
        *totalToken = totalToken.get() + finalBalance; 
        DIPC_EMIT_EVENT(depositPortfolio, "portfolioName", _portfolioName, "portfolioBalance", finalBalance);
    }
    
    PAYABLE void PortfolioManage::createOrder(char* _portfolioName, char* _orderId, uint16_t _orderType, char* _stockCode, uint64_t _stockPrice, uint64_t _stockAmount, uint64_t _endTime){
        uint64_t tokenBalance = getTotalBalance();
        DIPC_EMIT_EVENT(createOrder, "portfolioName", _portfolioName, "OrderInfo", "ignore", "tokenBalance", tokenBalance);
        uint64_t spent = 0;
        if(_orderType == 1){
            spent = _stockPrice * _stockAmount;
            DipcAssert((portfolioBalance.get()[_portfolioName] + tokenBalance) > spent);
        }
        struct Order order{_orderId, _orderType, _stockCode, _stockPrice, _stockAmount, _endTime, 0};
        std::string pInfo = portfolioStorge.get()[_portfolioName];
        
        
        
        if(pInfo == "") {
            DIPC_EMIT_EVENT(ErrEvent, "Current portfolio  doesn't exist: ", _portfolioName);
            return;
        }
        PortfolioInfo info;
        info.parseJson(pInfo);
        if(info.getOrder(_orderId).orderId != ""){
            DIPC_EMIT_EVENT(ErrEvent, "Current order exist: ", _orderId);
            return;
        }
        info.addOrder(order);
        pInfo = info.toJson();

        uint64_t currentBalance = portfolioBalance.get()[_portfolioName] ;
        uint64_t finalBalance = currentBalance + tokenBalance - spent;
        DipcAssert(totalToken.get() + tokenBalance > totalToken);
        
        DipcAssert(ownerTotalToken.get() < ownerTotalToken.get() + spent);
        (*portfolioStorge)[_portfolioName] = &pInfo[0];
        
        
        
        


        (*portfolioBalance)[_portfolioName] = finalBalance;
        *totalToken = totalToken.get() + finalBalance; 
        *ownerTotalToken = ownerTotalToken.get() + spent;
        DIPC_EMIT_EVENT(createOrder, "portfolioName", _portfolioName, "OrderInfo", &order.toJson()[0], "portfolioBalance", finalBalance);
    }

    
    EXPORT void PortfolioManage::dealOrder(char* _portfolioName, char* _orderId){
        isOwner();
        std::string pInfo = portfolioStorge.get()[_portfolioName];
        
        
        PortfolioInfo info;
        info.parseJson(pInfo);
        

        
         Order ord = info.getOrder(_orderId);
         
         
        if(ord.orderId != "" && ord.orderStatus == 0){
            
            uint64_t timenow = dipc::timestamp();
            if(ord.endTime > timenow){
                ord.orderStatus = 1;
            }else {
                ord.orderStatus = 3;
            }
        } else {
          

            return;
        }
        

        uint64_t sellValue = 0;
        if(ord.orderType == 0){
            sellValue = ord.stockAmount * ord.stockPrice;
        }
        uint64_t currentBalance =  portfolioBalance.get()[_portfolioName];
        

        DipcAssert(currentBalance + sellValue >= currentBalance);
        DipcAssert((ownerTotalToken.get() - sellValue) <= ownerTotalToken.get());
        


        (*portfolioBalance)[_portfolioName] = currentBalance + sellValue;
        *ownerTotalToken = ownerTotalToken.get() - sellValue;
        (*portfolioStorge)[_portfolioName] = &info.toJson()[0];
        
        
        
        

        DIPC_EMIT_EVENT(dealPortfolio, "orderId", _orderId, "orderInfo", &ord.toJson()[0]);
    }
    
    EXPORT void PortfolioManage::revocationOrder(char* _portfolioName, char* _orderId){
        std::string pInfo = portfolioStorge.get()[_portfolioName];
        
        
        PortfolioInfo info;
        info.parseJson(pInfo);
        Order ord = info.getOrder(_orderId);
        
        
        if(ord.orderId != "" && ord.orderStatus == 0){
            std::string callerStr = caller().toString();
            
            
            
            DipcAssert(info.getOwnerAddress() == caller().toString());
            

            uint64_t timenow = dipc::timestamp();
            if(ord.endTime > timenow){
                ord.orderStatus = 2;
            }else {
                ord.orderStatus = 3;
            }
        } else {
            return;
        }
        uint64_t lockToken = 0;
        if(ord.orderType == 1){
            lockToken = ord.stockPrice * ord.stockAmount;
        }
        uint64_t currentBalance =  portfolioBalance.get()[_portfolioName];
        
        
        
        

        DipcAssert(currentBalance + lockToken >= currentBalance);
        DipcAssert(ownerTotalToken.get() - lockToken <= ownerTotalToken.get());

        
        (*portfolioBalance)[_portfolioName] = currentBalance + lockToken;
        *ownerTotalToken = ownerTotalToken.get() - lockToken;
        (*portfolioStorge)[_portfolioName] = &info.toJson()[0];
        DIPC_EMIT_EVENT(revocationPortfolio, "orderId", _orderId, "orderInfo", &ord.toJson()[0]);
    }
    
    EXPORT void PortfolioManage::withdrawPortfolio(char* _portfolioName, uint64_t _withdrawBalance){
         if(!userCanWithdraw.get()){
             return;
         }
         uint64_t currentBalance =  portfolioBalance.get()[_portfolioName];
         DipcAssert(currentBalance - _withdrawBalance < currentBalance);
         auto coinBalance = changeUint64ToU256WithChangeRate(currentBalance, changeRate.get());
         (*portfolioBalance)[_portfolioName] = currentBalance - _withdrawBalance;
         callTransfer(caller(), coinBalance);
    }
    
    EXPORT void PortfolioManage::withdrawPool(uint64_t _balance){
        isOwner();
        Address ownerAddr = Address(owner.get()); 
        callTransfer(ownerAddr, _balance);
        *ownerTotalToken = ownerTotalToken.get() - _balance * changeRate.get();
        *totalToken = totalToken.get() - _balance * changeRate.get();
        DIPC_EMIT_EVENT(tokenCount, "ownerTotalToken", ownerTotalToken.get(), "totalToken", totalToken.get());
    }
    
    PAYABLE void PortfolioManage::depositPool(uint64_t _depositValue){
        isOwner();
        
        uint64_t tokenBalance = changeU256ToUint64WithChangeRate(callValue(), changeRate.get()); 
        *ownerTotalToken = ownerTotalToken.get() + tokenBalance;
        *totalToken = totalToken.get() + tokenBalance;
        DIPC_EMIT_EVENT(tokenCount, "ownerTotalToken", ownerTotalToken.get(), "totalToken", totalToken.get());
    }
     
    CONSTANT uint64_t PortfolioManage::queryTotalToken(){
        return totalToken.get();
    }

     
    CONSTANT uint64_t PortfolioManage::queryPortfolioBalance(char* _portfolioName){
        return portfolioBalance.get()[_portfolioName];
    }

    
    CONSTANT bool PortfolioManage::queryPortfolioNameIfUsed(char* _portfolioName){
        if(portfolioStorge.get()[_portfolioName] != ""){
            return true;
        } 
        return false;
    }

    
    CONSTANT uint64_t PortfolioManage::queryChangeRate(){
        return changeRate.get();
    }

2019-12-19_15:14:53.313885: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:513] s  first 
     
    EXPORT void PortfolioManage::setUserCanWithdraw(bool _canWithdraw){
        isOwner();
        *userCanWithdraw = _canWithdraw;
    }

2019-12-19_15:14:53.313894: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:593] calledFunc temp export: 
     
    EXPORT void PortfolioManage::setUserCanWithdraw(bool _canWithdraw){
        u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
isOwner();
        *userCanWithdraw = _canWithdraw;
    }

2019-12-19_15:14:53.313901: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:599] search func : 
     
    EXPORT void PortfolioManage::setUserCanWithdraw(bool _canWithdraw){
        u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
isOwner();
        *userCanWithdraw = _canWithdraw;
    }
2019-12-19_15:14:53.313908: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:424] finalContract  this height  #include "PortfolioManage.hpp"

    
    PAYABLE void PortfolioManage::init(){
        *owner = caller().toString();
        *changeRate = 10000;
        *userCanWithdraw = false;
        uint64_t tokenBalance = getTotalBalance();
        
        *ownerTotalToken = tokenBalance;
        *totalToken = ownerTotalToken.get();
        
        
        DIPC_EMIT_EVENT(initEvent, "ownerTotalToken" ,tokenBalance);
    }
    
     
    EXPORT void PortfolioManage::setChangeRate(uint64_t _changeRate){
        isOwner();
        *changeRate = _changeRate;
    }
     
    EXPORT void PortfolioManage::setUserCanWithdraw(bool _canWithdraw){
        u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
isOwner();
        *userCanWithdraw = _canWithdraw;
    } codetext height #include "PortfolioManage.hpp"

    
    PAYABLE void PortfolioManage::init(){
        *owner = caller().toString();
        *changeRate = 10000;
        *userCanWithdraw = false;
        uint64_t tokenBalance = getTotalBalance();
        
        *ownerTotalToken = tokenBalance;
        *totalToken = ownerTotalToken.get();
        
        
        DIPC_EMIT_EVENT(initEvent, "ownerTotalToken" ,tokenBalance);
    }
    
     
    EXPORT void PortfolioManage::setChangeRate(uint64_t _changeRate){
        isOwner();
        *changeRate = _changeRate;
    }
     
    EXPORT void PortfolioManage::setUserCanWithdraw(bool _canWithdraw){
        isOwner();
        *userCanWithdraw = _canWithdraw;
    }

    
    PAYABLE void PortfolioManage::createPortfolio(char* _portfolioName, char* _portfolioDesc){
        if(portfolioStorge.get()[_portfolioName] != ""){
            DIPC_EMIT_EVENT(ErrEvent, "Current portfolio exist: ", _portfolioName);
            return;
        } 
        std::string callerAddr = caller().toString();
        uint64_t tokenBalance = getTotalBalance();
        
        PortfolioInfo info(_portfolioName, _portfolioDesc, &callerAddr[0]);
        std::string portfolioStr = info.toJson();
        
        
        

        (*portfolioStorge)[_portfolioName] = portfolioStr;
        DipcAssert(totalToken.get() + tokenBalance > totalToken);
        (*portfolioBalance)[_portfolioName] = tokenBalance;
        *totalToken = totalToken.get() + tokenBalance; 
        
        DIPC_EMIT_EVENT(portfolioInfo, _portfolioName, &portfolioStr[0], "portfolioBalance", tokenBalance);
    }

    
    PAYABLE void PortfolioManage::depositPortfolio(char* _portfolioName){
        uint64_t tokenBalance = getTotalBalance();
        
        uint64_t currentBalance = portfolioBalance.get()[_portfolioName];
        uint64_t finalBalance  = currentBalance + tokenBalance;
        DipcAssert(totalToken.get() + tokenBalance > totalToken);
        DipcAssert(finalBalance > currentBalance);
        (*portfolioBalance)[_portfolioName] = finalBalance;
        *totalToken = totalToken.get() + finalBalance; 
        DIPC_EMIT_EVENT(depositPortfolio, "portfolioName", _portfolioName, "portfolioBalance", finalBalance);
    }
    
    PAYABLE void PortfolioManage::createOrder(char* _portfolioName, char* _orderId, uint16_t _orderType, char* _stockCode, uint64_t _stockPrice, uint64_t _stockAmount, uint64_t _endTime){
        uint64_t tokenBalance = getTotalBalance();
        DIPC_EMIT_EVENT(createOrder, "portfolioName", _portfolioName, "OrderInfo", "ignore", "tokenBalance", tokenBalance);
        uint64_t spent = 0;
        if(_orderType == 1){
            spent = _stockPrice * _stockAmount;
            DipcAssert((portfolioBalance.get()[_portfolioName] + tokenBalance) > spent);
        }
        struct Order order{_orderId, _orderType, _stockCode, _stockPrice, _stockAmount, _endTime, 0};
        std::string pInfo = portfolioStorge.get()[_portfolioName];
        
        
        
        if(pInfo == "") {
            DIPC_EMIT_EVENT(ErrEvent, "Current portfolio  doesn't exist: ", _portfolioName);
            return;
        }
        PortfolioInfo info;
        info.parseJson(pInfo);
        if(info.getOrder(_orderId).orderId != ""){
            DIPC_EMIT_EVENT(ErrEvent, "Current order exist: ", _orderId);
            return;
        }
        info.addOrder(order);
        pInfo = info.toJson();

        uint64_t currentBalance = portfolioBalance.get()[_portfolioName] ;
        uint64_t finalBalance = currentBalance + tokenBalance - spent;
        DipcAssert(totalToken.get() + tokenBalance > totalToken);
        
        DipcAssert(ownerTotalToken.get() < ownerTotalToken.get() + spent);
        (*portfolioStorge)[_portfolioName] = &pInfo[0];
        
        
        
        


        (*portfolioBalance)[_portfolioName] = finalBalance;
        *totalToken = totalToken.get() + finalBalance; 
        *ownerTotalToken = ownerTotalToken.get() + spent;
        DIPC_EMIT_EVENT(createOrder, "portfolioName", _portfolioName, "OrderInfo", &order.toJson()[0], "portfolioBalance", finalBalance);
    }

    
    EXPORT void PortfolioManage::dealOrder(char* _portfolioName, char* _orderId){
        isOwner();
        std::string pInfo = portfolioStorge.get()[_portfolioName];
        
        
        PortfolioInfo info;
        info.parseJson(pInfo);
        

        
         Order ord = info.getOrder(_orderId);
         
         
        if(ord.orderId != "" && ord.orderStatus == 0){
            
            uint64_t timenow = dipc::timestamp();
            if(ord.endTime > timenow){
                ord.orderStatus = 1;
            }else {
                ord.orderStatus = 3;
            }
        } else {
          

            return;
        }
        

        uint64_t sellValue = 0;
        if(ord.orderType == 0){
            sellValue = ord.stockAmount * ord.stockPrice;
        }
        uint64_t currentBalance =  portfolioBalance.get()[_portfolioName];
        

        DipcAssert(currentBalance + sellValue >= currentBalance);
        DipcAssert((ownerTotalToken.get() - sellValue) <= ownerTotalToken.get());
        


        (*portfolioBalance)[_portfolioName] = currentBalance + sellValue;
        *ownerTotalToken = ownerTotalToken.get() - sellValue;
        (*portfolioStorge)[_portfolioName] = &info.toJson()[0];
        
        
        
        

        DIPC_EMIT_EVENT(dealPortfolio, "orderId", _orderId, "orderInfo", &ord.toJson()[0]);
    }
    
    EXPORT void PortfolioManage::revocationOrder(char* _portfolioName, char* _orderId){
        std::string pInfo = portfolioStorge.get()[_portfolioName];
        
        
        PortfolioInfo info;
        info.parseJson(pInfo);
        Order ord = info.getOrder(_orderId);
        
        
        if(ord.orderId != "" && ord.orderStatus == 0){
            std::string callerStr = caller().toString();
            
            
            
            DipcAssert(info.getOwnerAddress() == caller().toString());
            

            uint64_t timenow = dipc::timestamp();
            if(ord.endTime > timenow){
                ord.orderStatus = 2;
            }else {
                ord.orderStatus = 3;
            }
        } else {
            return;
        }
        uint64_t lockToken = 0;
        if(ord.orderType == 1){
            lockToken = ord.stockPrice * ord.stockAmount;
        }
        uint64_t currentBalance =  portfolioBalance.get()[_portfolioName];
        
        
        
        

        DipcAssert(currentBalance + lockToken >= currentBalance);
        DipcAssert(ownerTotalToken.get() - lockToken <= ownerTotalToken.get());

        
        (*portfolioBalance)[_portfolioName] = currentBalance + lockToken;
        *ownerTotalToken = ownerTotalToken.get() - lockToken;
        (*portfolioStorge)[_portfolioName] = &info.toJson()[0];
        DIPC_EMIT_EVENT(revocationPortfolio, "orderId", _orderId, "orderInfo", &ord.toJson()[0]);
    }
    
    EXPORT void PortfolioManage::withdrawPortfolio(char* _portfolioName, uint64_t _withdrawBalance){
         if(!userCanWithdraw.get()){
             return;
         }
         uint64_t currentBalance =  portfolioBalance.get()[_portfolioName];
         DipcAssert(currentBalance - _withdrawBalance < currentBalance);
         auto coinBalance = changeUint64ToU256WithChangeRate(currentBalance, changeRate.get());
         (*portfolioBalance)[_portfolioName] = currentBalance - _withdrawBalance;
         callTransfer(caller(), coinBalance);
    }
    
    EXPORT void PortfolioManage::withdrawPool(uint64_t _balance){
        isOwner();
        Address ownerAddr = Address(owner.get()); 
        callTransfer(ownerAddr, _balance);
        *ownerTotalToken = ownerTotalToken.get() - _balance * changeRate.get();
        *totalToken = totalToken.get() - _balance * changeRate.get();
        DIPC_EMIT_EVENT(tokenCount, "ownerTotalToken", ownerTotalToken.get(), "totalToken", totalToken.get());
    }
    
    PAYABLE void PortfolioManage::depositPool(uint64_t _depositValue){
        isOwner();
        
        uint64_t tokenBalance = changeU256ToUint64WithChangeRate(callValue(), changeRate.get()); 
        *ownerTotalToken = ownerTotalToken.get() + tokenBalance;
        *totalToken = totalToken.get() + tokenBalance;
        DIPC_EMIT_EVENT(tokenCount, "ownerTotalToken", ownerTotalToken.get(), "totalToken", totalToken.get());
    }
     
    CONSTANT uint64_t PortfolioManage::queryTotalToken(){
        return totalToken.get();
    }

     
    CONSTANT uint64_t PortfolioManage::queryPortfolioBalance(char* _portfolioName){
        return portfolioBalance.get()[_portfolioName];
    }

    
    CONSTANT bool PortfolioManage::queryPortfolioNameIfUsed(char* _portfolioName){
        if(portfolioStorge.get()[_portfolioName] != ""){
            return true;
        } 
        return false;
    }

    
    CONSTANT uint64_t PortfolioManage::queryChangeRate(){
        return changeRate.get();
    }

2019-12-19_15:14:53.313917: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:427] searchContext  

    
    PAYABLE void PortfolioManage::createPortfolio(char* _portfolioName, char* _portfolioDesc){
        if(portfolioStorge.get()[_portfolioName] != ""){
            DIPC_EMIT_EVENT(ErrEvent, "Current portfolio exist: ", _portfolioName);
            return;
        } 
        std::string callerAddr = caller().toString();
        uint64_t tokenBalance = getTotalBalance();
        
        PortfolioInfo info(_portfolioName, _portfolioDesc, &callerAddr[0]);
        std::string portfolioStr = info.toJson();
        
        
        

        (*portfolioStorge)[_portfolioName] = portfolioStr;
        DipcAssert(totalToken.get() + tokenBalance > totalToken);
        (*portfolioBalance)[_portfolioName] = tokenBalance;
        *totalToken = totalToken.get() + tokenBalance; 
        
        DIPC_EMIT_EVENT(portfolioInfo, _portfolioName, &portfolioStr[0], "portfolioBalance", tokenBalance);
    }

    
    PAYABLE void PortfolioManage::depositPortfolio(char* _portfolioName){
        uint64_t tokenBalance = getTotalBalance();
        
        uint64_t currentBalance = portfolioBalance.get()[_portfolioName];
        uint64_t finalBalance  = currentBalance + tokenBalance;
        DipcAssert(totalToken.get() + tokenBalance > totalToken);
        DipcAssert(finalBalance > currentBalance);
        (*portfolioBalance)[_portfolioName] = finalBalance;
        *totalToken = totalToken.get() + finalBalance; 
        DIPC_EMIT_EVENT(depositPortfolio, "portfolioName", _portfolioName, "portfolioBalance", finalBalance);
    }
    
    PAYABLE void PortfolioManage::createOrder(char* _portfolioName, char* _orderId, uint16_t _orderType, char* _stockCode, uint64_t _stockPrice, uint64_t _stockAmount, uint64_t _endTime){
        uint64_t tokenBalance = getTotalBalance();
        DIPC_EMIT_EVENT(createOrder, "portfolioName", _portfolioName, "OrderInfo", "ignore", "tokenBalance", tokenBalance);
        uint64_t spent = 0;
        if(_orderType == 1){
            spent = _stockPrice * _stockAmount;
            DipcAssert((portfolioBalance.get()[_portfolioName] + tokenBalance) > spent);
        }
        struct Order order{_orderId, _orderType, _stockCode, _stockPrice, _stockAmount, _endTime, 0};
        std::string pInfo = portfolioStorge.get()[_portfolioName];
        
        
        
        if(pInfo == "") {
            DIPC_EMIT_EVENT(ErrEvent, "Current portfolio  doesn't exist: ", _portfolioName);
            return;
        }
        PortfolioInfo info;
        info.parseJson(pInfo);
        if(info.getOrder(_orderId).orderId != ""){
            DIPC_EMIT_EVENT(ErrEvent, "Current order exist: ", _orderId);
            return;
        }
        info.addOrder(order);
        pInfo = info.toJson();

        uint64_t currentBalance = portfolioBalance.get()[_portfolioName] ;
        uint64_t finalBalance = currentBalance + tokenBalance - spent;
        DipcAssert(totalToken.get() + tokenBalance > totalToken);
        
        DipcAssert(ownerTotalToken.get() < ownerTotalToken.get() + spent);
        (*portfolioStorge)[_portfolioName] = &pInfo[0];
        
        
        
        


        (*portfolioBalance)[_portfolioName] = finalBalance;
        *totalToken = totalToken.get() + finalBalance; 
        *ownerTotalToken = ownerTotalToken.get() + spent;
        DIPC_EMIT_EVENT(createOrder, "portfolioName", _portfolioName, "OrderInfo", &order.toJson()[0], "portfolioBalance", finalBalance);
    }

    
    EXPORT void PortfolioManage::dealOrder(char* _portfolioName, char* _orderId){
        isOwner();
        std::string pInfo = portfolioStorge.get()[_portfolioName];
        
        
        PortfolioInfo info;
        info.parseJson(pInfo);
        

        
         Order ord = info.getOrder(_orderId);
         
         
        if(ord.orderId != "" && ord.orderStatus == 0){
            
            uint64_t timenow = dipc::timestamp();
            if(ord.endTime > timenow){
                ord.orderStatus = 1;
            }else {
                ord.orderStatus = 3;
            }
        } else {
          

            return;
        }
        

        uint64_t sellValue = 0;
        if(ord.orderType == 0){
            sellValue = ord.stockAmount * ord.stockPrice;
        }
        uint64_t currentBalance =  portfolioBalance.get()[_portfolioName];
        

        DipcAssert(currentBalance + sellValue >= currentBalance);
        DipcAssert((ownerTotalToken.get() - sellValue) <= ownerTotalToken.get());
        


        (*portfolioBalance)[_portfolioName] = currentBalance + sellValue;
        *ownerTotalToken = ownerTotalToken.get() - sellValue;
        (*portfolioStorge)[_portfolioName] = &info.toJson()[0];
        
        
        
        

        DIPC_EMIT_EVENT(dealPortfolio, "orderId", _orderId, "orderInfo", &ord.toJson()[0]);
    }
    
    EXPORT void PortfolioManage::revocationOrder(char* _portfolioName, char* _orderId){
        std::string pInfo = portfolioStorge.get()[_portfolioName];
        
        
        PortfolioInfo info;
        info.parseJson(pInfo);
        Order ord = info.getOrder(_orderId);
        
        
        if(ord.orderId != "" && ord.orderStatus == 0){
            std::string callerStr = caller().toString();
            
            
            
            DipcAssert(info.getOwnerAddress() == caller().toString());
            

            uint64_t timenow = dipc::timestamp();
            if(ord.endTime > timenow){
                ord.orderStatus = 2;
            }else {
                ord.orderStatus = 3;
            }
        } else {
            return;
        }
        uint64_t lockToken = 0;
        if(ord.orderType == 1){
            lockToken = ord.stockPrice * ord.stockAmount;
        }
        uint64_t currentBalance =  portfolioBalance.get()[_portfolioName];
        
        
        
        

        DipcAssert(currentBalance + lockToken >= currentBalance);
        DipcAssert(ownerTotalToken.get() - lockToken <= ownerTotalToken.get());

        
        (*portfolioBalance)[_portfolioName] = currentBalance + lockToken;
        *ownerTotalToken = ownerTotalToken.get() - lockToken;
        (*portfolioStorge)[_portfolioName] = &info.toJson()[0];
        DIPC_EMIT_EVENT(revocationPortfolio, "orderId", _orderId, "orderInfo", &ord.toJson()[0]);
    }
    
    EXPORT void PortfolioManage::withdrawPortfolio(char* _portfolioName, uint64_t _withdrawBalance){
         if(!userCanWithdraw.get()){
             return;
         }
         uint64_t currentBalance =  portfolioBalance.get()[_portfolioName];
         DipcAssert(currentBalance - _withdrawBalance < currentBalance);
         auto coinBalance = changeUint64ToU256WithChangeRate(currentBalance, changeRate.get());
         (*portfolioBalance)[_portfolioName] = currentBalance - _withdrawBalance;
         callTransfer(caller(), coinBalance);
    }
    
    EXPORT void PortfolioManage::withdrawPool(uint64_t _balance){
        isOwner();
        Address ownerAddr = Address(owner.get()); 
        callTransfer(ownerAddr, _balance);
        *ownerTotalToken = ownerTotalToken.get() - _balance * changeRate.get();
        *totalToken = totalToken.get() - _balance * changeRate.get();
        DIPC_EMIT_EVENT(tokenCount, "ownerTotalToken", ownerTotalToken.get(), "totalToken", totalToken.get());
    }
    
    PAYABLE void PortfolioManage::depositPool(uint64_t _depositValue){
        isOwner();
        
        uint64_t tokenBalance = changeU256ToUint64WithChangeRate(callValue(), changeRate.get()); 
        *ownerTotalToken = ownerTotalToken.get() + tokenBalance;
        *totalToken = totalToken.get() + tokenBalance;
        DIPC_EMIT_EVENT(tokenCount, "ownerTotalToken", ownerTotalToken.get(), "totalToken", totalToken.get());
    }
     
    CONSTANT uint64_t PortfolioManage::queryTotalToken(){
        return totalToken.get();
    }

     
    CONSTANT uint64_t PortfolioManage::queryPortfolioBalance(char* _portfolioName){
        return portfolioBalance.get()[_portfolioName];
    }

    
    CONSTANT bool PortfolioManage::queryPortfolioNameIfUsed(char* _portfolioName){
        if(portfolioStorge.get()[_portfolioName] != ""){
            return true;
        } 
        return false;
    }

    
    CONSTANT uint64_t PortfolioManage::queryChangeRate(){
        return changeRate.get();
    }

2019-12-19_15:14:53.529893: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:442] finalContract  this new  #include "PortfolioManage.hpp"

    
    PAYABLE void PortfolioManage::init(){
        *owner = caller().toString();
        *changeRate = 10000;
        *userCanWithdraw = false;
        uint64_t tokenBalance = getTotalBalance();
        
        *ownerTotalToken = tokenBalance;
        *totalToken = ownerTotalToken.get();
        
        
        DIPC_EMIT_EVENT(initEvent, "ownerTotalToken" ,tokenBalance);
    }
    
     
    EXPORT void PortfolioManage::setChangeRate(uint64_t _changeRate){
        isOwner();
        *changeRate = _changeRate;
    }
     
    EXPORT void PortfolioManage::setUserCanWithdraw(bool _canWithdraw){
        u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
isOwner();
        *userCanWithdraw = _canWithdraw;
    } codetext new #include "PortfolioManage.hpp"

    
    PAYABLE void PortfolioManage::init(){
        *owner = caller().toString();
        *changeRate = 10000;
        *userCanWithdraw = false;
        uint64_t tokenBalance = getTotalBalance();
        
        *ownerTotalToken = tokenBalance;
        *totalToken = ownerTotalToken.get();
        
        
        DIPC_EMIT_EVENT(initEvent, "ownerTotalToken" ,tokenBalance);
    }
    
     
    EXPORT void PortfolioManage::setChangeRate(uint64_t _changeRate){
        isOwner();
        *changeRate = _changeRate;
    }
     
    EXPORT void PortfolioManage::setUserCanWithdraw(bool _canWithdraw){
        isOwner();
        *userCanWithdraw = _canWithdraw;
    }

    
    PAYABLE void PortfolioManage::createPortfolio(char* _portfolioName, char* _portfolioDesc){
        if(portfolioStorge.get()[_portfolioName] != ""){
            DIPC_EMIT_EVENT(ErrEvent, "Current portfolio exist: ", _portfolioName);
            return;
        } 
        std::string callerAddr = caller().toString();
        uint64_t tokenBalance = getTotalBalance();
        
        PortfolioInfo info(_portfolioName, _portfolioDesc, &callerAddr[0]);
        std::string portfolioStr = info.toJson();
        
        
        

        (*portfolioStorge)[_portfolioName] = portfolioStr;
        DipcAssert(totalToken.get() + tokenBalance > totalToken);
        (*portfolioBalance)[_portfolioName] = tokenBalance;
        *totalToken = totalToken.get() + tokenBalance; 
        
        DIPC_EMIT_EVENT(portfolioInfo, _portfolioName, &portfolioStr[0], "portfolioBalance", tokenBalance);
    }

    
    PAYABLE void PortfolioManage::depositPortfolio(char* _portfolioName){
        uint64_t tokenBalance = getTotalBalance();
        
        uint64_t currentBalance = portfolioBalance.get()[_portfolioName];
        uint64_t finalBalance  = currentBalance + tokenBalance;
        DipcAssert(totalToken.get() + tokenBalance > totalToken);
        DipcAssert(finalBalance > currentBalance);
        (*portfolioBalance)[_portfolioName] = finalBalance;
        *totalToken = totalToken.get() + finalBalance; 
        DIPC_EMIT_EVENT(depositPortfolio, "portfolioName", _portfolioName, "portfolioBalance", finalBalance);
    }
    
    PAYABLE void PortfolioManage::createOrder(char* _portfolioName, char* _orderId, uint16_t _orderType, char* _stockCode, uint64_t _stockPrice, uint64_t _stockAmount, uint64_t _endTime){
        uint64_t tokenBalance = getTotalBalance();
        DIPC_EMIT_EVENT(createOrder, "portfolioName", _portfolioName, "OrderInfo", "ignore", "tokenBalance", tokenBalance);
        uint64_t spent = 0;
        if(_orderType == 1){
            spent = _stockPrice * _stockAmount;
            DipcAssert((portfolioBalance.get()[_portfolioName] + tokenBalance) > spent);
        }
        struct Order order{_orderId, _orderType, _stockCode, _stockPrice, _stockAmount, _endTime, 0};
        std::string pInfo = portfolioStorge.get()[_portfolioName];
        
        
        
        if(pInfo == "") {
            DIPC_EMIT_EVENT(ErrEvent, "Current portfolio  doesn't exist: ", _portfolioName);
            return;
        }
        PortfolioInfo info;
        info.parseJson(pInfo);
        if(info.getOrder(_orderId).orderId != ""){
            DIPC_EMIT_EVENT(ErrEvent, "Current order exist: ", _orderId);
            return;
        }
        info.addOrder(order);
        pInfo = info.toJson();

        uint64_t currentBalance = portfolioBalance.get()[_portfolioName] ;
        uint64_t finalBalance = currentBalance + tokenBalance - spent;
        DipcAssert(totalToken.get() + tokenBalance > totalToken);
        
        DipcAssert(ownerTotalToken.get() < ownerTotalToken.get() + spent);
        (*portfolioStorge)[_portfolioName] = &pInfo[0];
        
        
        
        


        (*portfolioBalance)[_portfolioName] = finalBalance;
        *totalToken = totalToken.get() + finalBalance; 
        *ownerTotalToken = ownerTotalToken.get() + spent;
        DIPC_EMIT_EVENT(createOrder, "portfolioName", _portfolioName, "OrderInfo", &order.toJson()[0], "portfolioBalance", finalBalance);
    }

    
    EXPORT void PortfolioManage::dealOrder(char* _portfolioName, char* _orderId){
        isOwner();
        std::string pInfo = portfolioStorge.get()[_portfolioName];
        
        
        PortfolioInfo info;
        info.parseJson(pInfo);
        

        
         Order ord = info.getOrder(_orderId);
         
         
        if(ord.orderId != "" && ord.orderStatus == 0){
            
            uint64_t timenow = dipc::timestamp();
            if(ord.endTime > timenow){
                ord.orderStatus = 1;
            }else {
                ord.orderStatus = 3;
            }
        } else {
          

            return;
        }
        

        uint64_t sellValue = 0;
        if(ord.orderType == 0){
            sellValue = ord.stockAmount * ord.stockPrice;
        }
        uint64_t currentBalance =  portfolioBalance.get()[_portfolioName];
        

        DipcAssert(currentBalance + sellValue >= currentBalance);
        DipcAssert((ownerTotalToken.get() - sellValue) <= ownerTotalToken.get());
        


        (*portfolioBalance)[_portfolioName] = currentBalance + sellValue;
        *ownerTotalToken = ownerTotalToken.get() - sellValue;
        (*portfolioStorge)[_portfolioName] = &info.toJson()[0];
        
        
        
        

        DIPC_EMIT_EVENT(dealPortfolio, "orderId", _orderId, "orderInfo", &ord.toJson()[0]);
    }
    
    EXPORT void PortfolioManage::revocationOrder(char* _portfolioName, char* _orderId){
        std::string pInfo = portfolioStorge.get()[_portfolioName];
        
        
        PortfolioInfo info;
        info.parseJson(pInfo);
        Order ord = info.getOrder(_orderId);
        
        
        if(ord.orderId != "" && ord.orderStatus == 0){
            std::string callerStr = caller().toString();
            
            
            
            DipcAssert(info.getOwnerAddress() == caller().toString());
            

            uint64_t timenow = dipc::timestamp();
            if(ord.endTime > timenow){
                ord.orderStatus = 2;
            }else {
                ord.orderStatus = 3;
            }
        } else {
            return;
        }
        uint64_t lockToken = 0;
        if(ord.orderType == 1){
            lockToken = ord.stockPrice * ord.stockAmount;
        }
        uint64_t currentBalance =  portfolioBalance.get()[_portfolioName];
        
        
        
        

        DipcAssert(currentBalance + lockToken >= currentBalance);
        DipcAssert(ownerTotalToken.get() - lockToken <= ownerTotalToken.get());

        
        (*portfolioBalance)[_portfolioName] = currentBalance + lockToken;
        *ownerTotalToken = ownerTotalToken.get() - lockToken;
        (*portfolioStorge)[_portfolioName] = &info.toJson()[0];
        DIPC_EMIT_EVENT(revocationPortfolio, "orderId", _orderId, "orderInfo", &ord.toJson()[0]);
    }
    
    EXPORT void PortfolioManage::withdrawPortfolio(char* _portfolioName, uint64_t _withdrawBalance){
         if(!userCanWithdraw.get()){
             return;
         }
         uint64_t currentBalance =  portfolioBalance.get()[_portfolioName];
         DipcAssert(currentBalance - _withdrawBalance < currentBalance);
         auto coinBalance = changeUint64ToU256WithChangeRate(currentBalance, changeRate.get());
         (*portfolioBalance)[_portfolioName] = currentBalance - _withdrawBalance;
         callTransfer(caller(), coinBalance);
    }
    
    EXPORT void PortfolioManage::withdrawPool(uint64_t _balance){
        isOwner();
        Address ownerAddr = Address(owner.get()); 
        callTransfer(ownerAddr, _balance);
        *ownerTotalToken = ownerTotalToken.get() - _balance * changeRate.get();
        *totalToken = totalToken.get() - _balance * changeRate.get();
        DIPC_EMIT_EVENT(tokenCount, "ownerTotalToken", ownerTotalToken.get(), "totalToken", totalToken.get());
    }
    
    PAYABLE void PortfolioManage::depositPool(uint64_t _depositValue){
        isOwner();
        
        uint64_t tokenBalance = changeU256ToUint64WithChangeRate(callValue(), changeRate.get()); 
        *ownerTotalToken = ownerTotalToken.get() + tokenBalance;
        *totalToken = totalToken.get() + tokenBalance;
        DIPC_EMIT_EVENT(tokenCount, "ownerTotalToken", ownerTotalToken.get(), "totalToken", totalToken.get());
    }
     
    CONSTANT uint64_t PortfolioManage::queryTotalToken(){
        return totalToken.get();
    }

     
    CONSTANT uint64_t PortfolioManage::queryPortfolioBalance(char* _portfolioName){
        return portfolioBalance.get()[_portfolioName];
    }

    
    CONSTANT bool PortfolioManage::queryPortfolioNameIfUsed(char* _portfolioName){
        if(portfolioStorge.get()[_portfolioName] != ""){
            return true;
        } 
        return false;
    }

    
    CONSTANT uint64_t PortfolioManage::queryChangeRate(){
        return changeRate.get();
    }

2019-12-19_15:14:53.529923: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:604] finalContract  final content =======   : #include "PortfolioManage.hpp"

    
    PAYABLE void PortfolioManage::init(){
        *owner = caller().toString();
        *changeRate = 10000;
        *userCanWithdraw = false;
        uint64_t tokenBalance = getTotalBalance();
        
        *ownerTotalToken = tokenBalance;
        *totalToken = ownerTotalToken.get();
        
        
        DIPC_EMIT_EVENT(initEvent, "ownerTotalToken" ,tokenBalance);
    }
    
     
    EXPORT void PortfolioManage::setChangeRate(uint64_t _changeRate){
        isOwner();
        *changeRate = _changeRate;
    }
     
    EXPORT void PortfolioManage::setUserCanWithdraw(bool _canWithdraw){
        u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
isOwner();
        *userCanWithdraw = _canWithdraw;
    }

    
    PAYABLE void PortfolioManage::createPortfolio(char* _portfolioName, char* _portfolioDesc){
        if(portfolioStorge.get()[_portfolioName] != ""){
            DIPC_EMIT_EVENT(ErrEvent, "Current portfolio exist: ", _portfolioName);
            return;
        } 
        std::string callerAddr = caller().toString();
        uint64_t tokenBalance = getTotalBalance();
        
        PortfolioInfo info(_portfolioName, _portfolioDesc, &callerAddr[0]);
        std::string portfolioStr = info.toJson();
        
        
        

        (*portfolioStorge)[_portfolioName] = portfolioStr;
        DipcAssert(totalToken.get() + tokenBalance > totalToken);
        (*portfolioBalance)[_portfolioName] = tokenBalance;
        *totalToken = totalToken.get() + tokenBalance; 
        
        DIPC_EMIT_EVENT(portfolioInfo, _portfolioName, &portfolioStr[0], "portfolioBalance", tokenBalance);
    }

    
    PAYABLE void PortfolioManage::depositPortfolio(char* _portfolioName){
        uint64_t tokenBalance = getTotalBalance();
        
        uint64_t currentBalance = portfolioBalance.get()[_portfolioName];
        uint64_t finalBalance  = currentBalance + tokenBalance;
        DipcAssert(totalToken.get() + tokenBalance > totalToken);
        DipcAssert(finalBalance > currentBalance);
        (*portfolioBalance)[_portfolioName] = finalBalance;
        *totalToken = totalToken.get() + finalBalance; 
        DIPC_EMIT_EVENT(depositPortfolio, "portfolioName", _portfolioName, "portfolioBalance", finalBalance);
    }
    
    PAYABLE void PortfolioManage::createOrder(char* _portfolioName, char* _orderId, uint16_t _orderType, char* _stockCode, uint64_t _stockPrice, uint64_t _stockAmount, uint64_t _endTime){
        uint64_t tokenBalance = getTotalBalance();
        DIPC_EMIT_EVENT(createOrder, "portfolioName", _portfolioName, "OrderInfo", "ignore", "tokenBalance", tokenBalance);
        uint64_t spent = 0;
        if(_orderType == 1){
            spent = _stockPrice * _stockAmount;
            DipcAssert((portfolioBalance.get()[_portfolioName] + tokenBalance) > spent);
        }
        struct Order order{_orderId, _orderType, _stockCode, _stockPrice, _stockAmount, _endTime, 0};
        std::string pInfo = portfolioStorge.get()[_portfolioName];
        
        
        
        if(pInfo == "") {
            DIPC_EMIT_EVENT(ErrEvent, "Current portfolio  doesn't exist: ", _portfolioName);
            return;
        }
        PortfolioInfo info;
        info.parseJson(pInfo);
        if(info.getOrder(_orderId).orderId != ""){
            DIPC_EMIT_EVENT(ErrEvent, "Current order exist: ", _orderId);
            return;
        }
        info.addOrder(order);
        pInfo = info.toJson();

        uint64_t currentBalance = portfolioBalance.get()[_portfolioName] ;
        uint64_t finalBalance = currentBalance + tokenBalance - spent;
        DipcAssert(totalToken.get() + tokenBalance > totalToken);
        
        DipcAssert(ownerTotalToken.get() < ownerTotalToken.get() + spent);
        (*portfolioStorge)[_portfolioName] = &pInfo[0];
        
        
        
        


        (*portfolioBalance)[_portfolioName] = finalBalance;
        *totalToken = totalToken.get() + finalBalance; 
        *ownerTotalToken = ownerTotalToken.get() + spent;
        DIPC_EMIT_EVENT(createOrder, "portfolioName", _portfolioName, "OrderInfo", &order.toJson()[0], "portfolioBalance", finalBalance);
    }

    
    EXPORT void PortfolioManage::dealOrder(char* _portfolioName, char* _orderId){
        isOwner();
        std::string pInfo = portfolioStorge.get()[_portfolioName];
        
        
        PortfolioInfo info;
        info.parseJson(pInfo);
        

        
         Order ord = info.getOrder(_orderId);
         
         
        if(ord.orderId != "" && ord.orderStatus == 0){
            
            uint64_t timenow = dipc::timestamp();
            if(ord.endTime > timenow){
                ord.orderStatus = 1;
            }else {
                ord.orderStatus = 3;
            }
        } else {
          

            return;
        }
        

        uint64_t sellValue = 0;
        if(ord.orderType == 0){
            sellValue = ord.stockAmount * ord.stockPrice;
        }
        uint64_t currentBalance =  portfolioBalance.get()[_portfolioName];
        

        DipcAssert(currentBalance + sellValue >= currentBalance);
        DipcAssert((ownerTotalToken.get() - sellValue) <= ownerTotalToken.get());
        


        (*portfolioBalance)[_portfolioName] = currentBalance + sellValue;
        *ownerTotalToken = ownerTotalToken.get() - sellValue;
        (*portfolioStorge)[_portfolioName] = &info.toJson()[0];
        
        
        
        

        DIPC_EMIT_EVENT(dealPortfolio, "orderId", _orderId, "orderInfo", &ord.toJson()[0]);
    }
    
    EXPORT void PortfolioManage::revocationOrder(char* _portfolioName, char* _orderId){
        std::string pInfo = portfolioStorge.get()[_portfolioName];
        
        
        PortfolioInfo info;
        info.parseJson(pInfo);
        Order ord = info.getOrder(_orderId);
        
        
        if(ord.orderId != "" && ord.orderStatus == 0){
            std::string callerStr = caller().toString();
            
            
            
            DipcAssert(info.getOwnerAddress() == caller().toString());
            

            uint64_t timenow = dipc::timestamp();
            if(ord.endTime > timenow){
                ord.orderStatus = 2;
            }else {
                ord.orderStatus = 3;
            }
        } else {
            return;
        }
        uint64_t lockToken = 0;
        if(ord.orderType == 1){
            lockToken = ord.stockPrice * ord.stockAmount;
        }
        uint64_t currentBalance =  portfolioBalance.get()[_portfolioName];
        
        
        
        

        DipcAssert(currentBalance + lockToken >= currentBalance);
        DipcAssert(ownerTotalToken.get() - lockToken <= ownerTotalToken.get());

        
        (*portfolioBalance)[_portfolioName] = currentBalance + lockToken;
        *ownerTotalToken = ownerTotalToken.get() - lockToken;
        (*portfolioStorge)[_portfolioName] = &info.toJson()[0];
        DIPC_EMIT_EVENT(revocationPortfolio, "orderId", _orderId, "orderInfo", &ord.toJson()[0]);
    }
    
    EXPORT void PortfolioManage::withdrawPortfolio(char* _portfolioName, uint64_t _withdrawBalance){
         if(!userCanWithdraw.get()){
             return;
         }
         uint64_t currentBalance =  portfolioBalance.get()[_portfolioName];
         DipcAssert(currentBalance - _withdrawBalance < currentBalance);
         auto coinBalance = changeUint64ToU256WithChangeRate(currentBalance, changeRate.get());
         (*portfolioBalance)[_portfolioName] = currentBalance - _withdrawBalance;
         callTransfer(caller(), coinBalance);
    }
    
    EXPORT void PortfolioManage::withdrawPool(uint64_t _balance){
        isOwner();
        Address ownerAddr = Address(owner.get()); 
        callTransfer(ownerAddr, _balance);
        *ownerTotalToken = ownerTotalToken.get() - _balance * changeRate.get();
        *totalToken = totalToken.get() - _balance * changeRate.get();
        DIPC_EMIT_EVENT(tokenCount, "ownerTotalToken", ownerTotalToken.get(), "totalToken", totalToken.get());
    }
    
    PAYABLE void PortfolioManage::depositPool(uint64_t _depositValue){
        isOwner();
        
        uint64_t tokenBalance = changeU256ToUint64WithChangeRate(callValue(), changeRate.get()); 
        *ownerTotalToken = ownerTotalToken.get() + tokenBalance;
        *totalToken = totalToken.get() + tokenBalance;
        DIPC_EMIT_EVENT(tokenCount, "ownerTotalToken", ownerTotalToken.get(), "totalToken", totalToken.get());
    }
     
    CONSTANT uint64_t PortfolioManage::queryTotalToken(){
        return totalToken.get();
    }

     
    CONSTANT uint64_t PortfolioManage::queryPortfolioBalance(char* _portfolioName){
        return portfolioBalance.get()[_portfolioName];
    }

    
    CONSTANT bool PortfolioManage::queryPortfolioNameIfUsed(char* _portfolioName){
        if(portfolioStorge.get()[_portfolioName] != ""){
            return true;
        } 
        return false;
    }

    
    CONSTANT uint64_t PortfolioManage::queryChangeRate(){
        return changeRate.get();
    }

2019-12-19_15:14:53.529934: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:401] abis.ispayable :false

2019-12-19_15:14:53.529954: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:424] finalContract  this height  #include "PortfolioManage.hpp"

    
    PAYABLE void PortfolioManage::init(){
        *owner = caller().toString();
        *changeRate = 10000;
        *userCanWithdraw = false;
        uint64_t tokenBalance = getTotalBalance();
        
        *ownerTotalToken = tokenBalance;
        *totalToken = ownerTotalToken.get();
        
        
        DIPC_EMIT_EVENT(initEvent, "ownerTotalToken" ,tokenBalance);
    }
    
     
    EXPORT void PortfolioManage::setChangeRate(uint64_t _changeRate){
        isOwner();
        *changeRate = _changeRate;
    }
     
    EXPORT void PortfolioManage::setUserCanWithdraw(bool _canWithdraw){
        u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
isOwner();
        *userCanWithdraw = _canWithdraw;
    }

    
    PAYABLE void PortfolioManage::createPortfolio(char* _portfolioName, char* _portfolioDesc){
        if(portfolioStorge.get()[_portfolioName] != ""){
            DIPC_EMIT_EVENT(ErrEvent, "Current portfolio exist: ", _portfolioName);
            return;
        } 
        std::string callerAddr = caller().toString();
        uint64_t tokenBalance = getTotalBalance();
        
        PortfolioInfo info(_portfolioName, _portfolioDesc, &callerAddr[0]);
        std::string portfolioStr = info.toJson();
        
        
        

        (*portfolioStorge)[_portfolioName] = portfolioStr;
        DipcAssert(totalToken.get() + tokenBalance > totalToken);
        (*portfolioBalance)[_portfolioName] = tokenBalance;
        *totalToken = totalToken.get() + tokenBalance; 
        
        DIPC_EMIT_EVENT(portfolioInfo, _portfolioName, &portfolioStr[0], "portfolioBalance", tokenBalance);
    }

    
    PAYABLE void PortfolioManage::depositPortfolio(char* _portfolioName){
        uint64_t tokenBalance = getTotalBalance();
        
        uint64_t currentBalance = portfolioBalance.get()[_portfolioName];
        uint64_t finalBalance  = currentBalance + tokenBalance;
        DipcAssert(totalToken.get() + tokenBalance > totalToken);
        DipcAssert(finalBalance > currentBalance);
        (*portfolioBalance)[_portfolioName] = finalBalance;
        *totalToken = totalToken.get() + finalBalance; 
        DIPC_EMIT_EVENT(depositPortfolio, "portfolioName", _portfolioName, "portfolioBalance", finalBalance);
    }
    
    PAYABLE void PortfolioManage::createOrder(char* _portfolioName, char* _orderId, uint16_t _orderType, char* _stockCode, uint64_t _stockPrice, uint64_t _stockAmount, uint64_t _endTime){
        uint64_t tokenBalance = getTotalBalance();
        DIPC_EMIT_EVENT(createOrder, "portfolioName", _portfolioName, "OrderInfo", "ignore", "tokenBalance", tokenBalance);
        uint64_t spent = 0;
        if(_orderType == 1){
            spent = _stockPrice * _stockAmount;
            DipcAssert((portfolioBalance.get()[_portfolioName] + tokenBalance) > spent);
        }
        struct Order order{_orderId, _orderType, _stockCode, _stockPrice, _stockAmount, _endTime, 0};
        std::string pInfo = portfolioStorge.get()[_portfolioName];
        
        
        
        if(pInfo == "") {
            DIPC_EMIT_EVENT(ErrEvent, "Current portfolio  doesn't exist: ", _portfolioName);
            return;
        }
        PortfolioInfo info;
        info.parseJson(pInfo);
        if(info.getOrder(_orderId).orderId != ""){
            DIPC_EMIT_EVENT(ErrEvent, "Current order exist: ", _orderId);
            return;
        }
        info.addOrder(order);
        pInfo = info.toJson();

        uint64_t currentBalance = portfolioBalance.get()[_portfolioName] ;
        uint64_t finalBalance = currentBalance + tokenBalance - spent;
        DipcAssert(totalToken.get() + tokenBalance > totalToken);
        
        DipcAssert(ownerTotalToken.get() < ownerTotalToken.get() + spent);
        (*portfolioStorge)[_portfolioName] = &pInfo[0];
        
        
        
        


        (*portfolioBalance)[_portfolioName] = finalBalance;
        *totalToken = totalToken.get() + finalBalance; 
        *ownerTotalToken = ownerTotalToken.get() + spent;
        DIPC_EMIT_EVENT(createOrder, "portfolioName", _portfolioName, "OrderInfo", &order.toJson()[0], "portfolioBalance", finalBalance);
    }

    
    EXPORT void PortfolioManage::dealOrder(char* _portfolioName, char* _orderId){
        isOwner();
        std::string pInfo = portfolioStorge.get()[_portfolioName];
        
        
        PortfolioInfo info;
        info.parseJson(pInfo);
        

        
         Order ord = info.getOrder(_orderId);
         
         
        if(ord.orderId != "" && ord.orderStatus == 0){
            
            uint64_t timenow = dipc::timestamp();
            if(ord.endTime > timenow){
                ord.orderStatus = 1;
            }else {
                ord.orderStatus = 3;
            }
        } else {
          

            return;
        }
        

        uint64_t sellValue = 0;
        if(ord.orderType == 0){
            sellValue = ord.stockAmount * ord.stockPrice;
        }
        uint64_t currentBalance =  portfolioBalance.get()[_portfolioName];
        

        DipcAssert(currentBalance + sellValue >= currentBalance);
        DipcAssert((ownerTotalToken.get() - sellValue) <= ownerTotalToken.get());
        


        (*portfolioBalance)[_portfolioName] = currentBalance + sellValue;
        *ownerTotalToken = ownerTotalToken.get() - sellValue;
        (*portfolioStorge)[_portfolioName] = &info.toJson()[0];
        
        
        
        

        DIPC_EMIT_EVENT(dealPortfolio, "orderId", _orderId, "orderInfo", &ord.toJson()[0]);
    }
    
    EXPORT void PortfolioManage::revocationOrder(char* _portfolioName, char* _orderId){
        std::string pInfo = portfolioStorge.get()[_portfolioName];
        
        
        PortfolioInfo info;
        info.parseJson(pInfo);
        Order ord = info.getOrder(_orderId);
        
        
        if(ord.orderId != "" && ord.orderStatus == 0){
            std::string callerStr = caller().toString();
            
            
            
            DipcAssert(info.getOwnerAddress() == caller().toString());
            

            uint64_t timenow = dipc::timestamp();
            if(ord.endTime > timenow){
                ord.orderStatus = 2;
            }else {
                ord.orderStatus = 3;
            }
        } else {
            return;
        }
        uint64_t lockToken = 0;
        if(ord.orderType == 1){
            lockToken = ord.stockPrice * ord.stockAmount;
        }
        uint64_t currentBalance =  portfolioBalance.get()[_portfolioName];
        
        
        
        

        DipcAssert(currentBalance + lockToken >= currentBalance);
        DipcAssert(ownerTotalToken.get() - lockToken <= ownerTotalToken.get());

        
        (*portfolioBalance)[_portfolioName] = currentBalance + lockToken;
        *ownerTotalToken = ownerTotalToken.get() - lockToken;
        (*portfolioStorge)[_portfolioName] = &info.toJson()[0];
        DIPC_EMIT_EVENT(revocationPortfolio, "orderId", _orderId, "orderInfo", &ord.toJson()[0]);
    }
    
    EXPORT void PortfolioManage::withdrawPortfolio(char* _portfolioName, uint64_t _withdrawBalance){
         if(!userCanWithdraw.get()){
             return;
         }
         uint64_t currentBalance =  portfolioBalance.get()[_portfolioName];
         DipcAssert(currentBalance - _withdrawBalance < currentBalance);
         auto coinBalance = changeUint64ToU256WithChangeRate(currentBalance, changeRate.get());
         (*portfolioBalance)[_portfolioName] = currentBalance - _withdrawBalance;
         callTransfer(caller(), coinBalance);
    }
    
    EXPORT void PortfolioManage::withdrawPool(uint64_t _balance){
        isOwner();
        Address ownerAddr = Address(owner.get()); 
        callTransfer(ownerAddr, _balance);
        *ownerTotalToken = ownerTotalToken.get() - _balance * changeRate.get();
        *totalToken = totalToken.get() - _balance * changeRate.get();
        DIPC_EMIT_EVENT(tokenCount, "ownerTotalToken", ownerTotalToken.get(), "totalToken", totalToken.get());
    }
    
    PAYABLE void PortfolioManage::depositPool(uint64_t _depositValue){
        isOwner();
        
        uint64_t tokenBalance = changeU256ToUint64WithChangeRate(callValue(), changeRate.get()); 
        *ownerTotalToken = ownerTotalToken.get() + tokenBalance;
        *totalToken = totalToken.get() + tokenBalance;
        DIPC_EMIT_EVENT(tokenCount, "ownerTotalToken", ownerTotalToken.get(), "totalToken", totalToken.get());
    }
     
    CONSTANT uint64_t PortfolioManage::queryTotalToken(){
        return totalToken.get();
    }

     
    CONSTANT uint64_t PortfolioManage::queryPortfolioBalance(char* _portfolioName){
        return portfolioBalance.get()[_portfolioName];
    }

    
    CONSTANT bool PortfolioManage::queryPortfolioNameIfUsed(char* _portfolioName){
        if(portfolioStorge.get()[_portfolioName] != ""){
            return true;
        } 
        return false;
    }

    
    CONSTANT uint64_t PortfolioManage::queryChangeRate(){
        return changeRate.get();
    } codetext height #include "PortfolioManage.hpp"

    
    PAYABLE void PortfolioManage::init(){
        *owner = caller().toString();
        *changeRate = 10000;
        *userCanWithdraw = false;
        uint64_t tokenBalance = getTotalBalance();
        
        *ownerTotalToken = tokenBalance;
        *totalToken = ownerTotalToken.get();
        
        
        DIPC_EMIT_EVENT(initEvent, "ownerTotalToken" ,tokenBalance);
    }
    
     
    EXPORT void PortfolioManage::setChangeRate(uint64_t _changeRate){
        isOwner();
        *changeRate = _changeRate;
    }
     
    EXPORT void PortfolioManage::setUserCanWithdraw(bool _canWithdraw){
        u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
isOwner();
        *userCanWithdraw = _canWithdraw;
    }

    
    PAYABLE void PortfolioManage::createPortfolio(char* _portfolioName, char* _portfolioDesc){
        if(portfolioStorge.get()[_portfolioName] != ""){
            DIPC_EMIT_EVENT(ErrEvent, "Current portfolio exist: ", _portfolioName);
            return;
        } 
        std::string callerAddr = caller().toString();
        uint64_t tokenBalance = getTotalBalance();
        
        PortfolioInfo info(_portfolioName, _portfolioDesc, &callerAddr[0]);
        std::string portfolioStr = info.toJson();
        
        
        

        (*portfolioStorge)[_portfolioName] = portfolioStr;
        DipcAssert(totalToken.get() + tokenBalance > totalToken);
        (*portfolioBalance)[_portfolioName] = tokenBalance;
        *totalToken = totalToken.get() + tokenBalance; 
        
        DIPC_EMIT_EVENT(portfolioInfo, _portfolioName, &portfolioStr[0], "portfolioBalance", tokenBalance);
    }

    
    PAYABLE void PortfolioManage::depositPortfolio(char* _portfolioName){
        uint64_t tokenBalance = getTotalBalance();
        
        uint64_t currentBalance = portfolioBalance.get()[_portfolioName];
        uint64_t finalBalance  = currentBalance + tokenBalance;
        DipcAssert(totalToken.get() + tokenBalance > totalToken);
        DipcAssert(finalBalance > currentBalance);
        (*portfolioBalance)[_portfolioName] = finalBalance;
        *totalToken = totalToken.get() + finalBalance; 
        DIPC_EMIT_EVENT(depositPortfolio, "portfolioName", _portfolioName, "portfolioBalance", finalBalance);
    }
    
    PAYABLE void PortfolioManage::createOrder(char* _portfolioName, char* _orderId, uint16_t _orderType, char* _stockCode, uint64_t _stockPrice, uint64_t _stockAmount, uint64_t _endTime){
        uint64_t tokenBalance = getTotalBalance();
        DIPC_EMIT_EVENT(createOrder, "portfolioName", _portfolioName, "OrderInfo", "ignore", "tokenBalance", tokenBalance);
        uint64_t spent = 0;
        if(_orderType == 1){
            spent = _stockPrice * _stockAmount;
            DipcAssert((portfolioBalance.get()[_portfolioName] + tokenBalance) > spent);
        }
        struct Order order{_orderId, _orderType, _stockCode, _stockPrice, _stockAmount, _endTime, 0};
        std::string pInfo = portfolioStorge.get()[_portfolioName];
        
        
        
        if(pInfo == "") {
            DIPC_EMIT_EVENT(ErrEvent, "Current portfolio  doesn't exist: ", _portfolioName);
            return;
        }
        PortfolioInfo info;
        info.parseJson(pInfo);
        if(info.getOrder(_orderId).orderId != ""){
            DIPC_EMIT_EVENT(ErrEvent, "Current order exist: ", _orderId);
            return;
        }
        info.addOrder(order);
        pInfo = info.toJson();

        uint64_t currentBalance = portfolioBalance.get()[_portfolioName] ;
        uint64_t finalBalance = currentBalance + tokenBalance - spent;
        DipcAssert(totalToken.get() + tokenBalance > totalToken);
        
        DipcAssert(ownerTotalToken.get() < ownerTotalToken.get() + spent);
        (*portfolioStorge)[_portfolioName] = &pInfo[0];
        
        
        
        


        (*portfolioBalance)[_portfolioName] = finalBalance;
        *totalToken = totalToken.get() + finalBalance; 
        *ownerTotalToken = ownerTotalToken.get() + spent;
        DIPC_EMIT_EVENT(createOrder, "portfolioName", _portfolioName, "OrderInfo", &order.toJson()[0], "portfolioBalance", finalBalance);
    }

    
    EXPORT void PortfolioManage::dealOrder(char* _portfolioName, char* _orderId){
        isOwner();
        std::string pInfo = portfolioStorge.get()[_portfolioName];
        
        
        PortfolioInfo info;
        info.parseJson(pInfo);
        

        
         Order ord = info.getOrder(_orderId);
         
         
        if(ord.orderId != "" && ord.orderStatus == 0){
            
            uint64_t timenow = dipc::timestamp();
            if(ord.endTime > timenow){
                ord.orderStatus = 1;
            }else {
                ord.orderStatus = 3;
            }
        } else {
          

            return;
        }
        

        uint64_t sellValue = 0;
        if(ord.orderType == 0){
            sellValue = ord.stockAmount * ord.stockPrice;
        }
        uint64_t currentBalance =  portfolioBalance.get()[_portfolioName];
        

        DipcAssert(currentBalance + sellValue >= currentBalance);
        DipcAssert((ownerTotalToken.get() - sellValue) <= ownerTotalToken.get());
        


        (*portfolioBalance)[_portfolioName] = currentBalance + sellValue;
        *ownerTotalToken = ownerTotalToken.get() - sellValue;
        (*portfolioStorge)[_portfolioName] = &info.toJson()[0];
        
        
        
        

        DIPC_EMIT_EVENT(dealPortfolio, "orderId", _orderId, "orderInfo", &ord.toJson()[0]);
    }
    
    EXPORT void PortfolioManage::revocationOrder(char* _portfolioName, char* _orderId){
        std::string pInfo = portfolioStorge.get()[_portfolioName];
        
        
        PortfolioInfo info;
        info.parseJson(pInfo);
        Order ord = info.getOrder(_orderId);
        
        
        if(ord.orderId != "" && ord.orderStatus == 0){
            std::string callerStr = caller().toString();
            
            
            
            DipcAssert(info.getOwnerAddress() == caller().toString());
            

            uint64_t timenow = dipc::timestamp();
            if(ord.endTime > timenow){
                ord.orderStatus = 2;
            }else {
                ord.orderStatus = 3;
            }
        } else {
            return;
        }
        uint64_t lockToken = 0;
        if(ord.orderType == 1){
            lockToken = ord.stockPrice * ord.stockAmount;
        }
        uint64_t currentBalance =  portfolioBalance.get()[_portfolioName];
        
        
        
        

        DipcAssert(currentBalance + lockToken >= currentBalance);
        DipcAssert(ownerTotalToken.get() - lockToken <= ownerTotalToken.get());

        
        (*portfolioBalance)[_portfolioName] = currentBalance + lockToken;
        *ownerTotalToken = ownerTotalToken.get() - lockToken;
        (*portfolioStorge)[_portfolioName] = &info.toJson()[0];
        DIPC_EMIT_EVENT(revocationPortfolio, "orderId", _orderId, "orderInfo", &ord.toJson()[0]);
    }
    
    EXPORT void PortfolioManage::withdrawPortfolio(char* _portfolioName, uint64_t _withdrawBalance){
         if(!userCanWithdraw.get()){
             return;
         }
         uint64_t currentBalance =  portfolioBalance.get()[_portfolioName];
         DipcAssert(currentBalance - _withdrawBalance < currentBalance);
         auto coinBalance = changeUint64ToU256WithChangeRate(currentBalance, changeRate.get());
         (*portfolioBalance)[_portfolioName] = currentBalance - _withdrawBalance;
         callTransfer(caller(), coinBalance);
    }
    
    EXPORT void PortfolioManage::withdrawPool(uint64_t _balance){
        isOwner();
        Address ownerAddr = Address(owner.get()); 
        callTransfer(ownerAddr, _balance);
        *ownerTotalToken = ownerTotalToken.get() - _balance * changeRate.get();
        *totalToken = totalToken.get() - _balance * changeRate.get();
        DIPC_EMIT_EVENT(tokenCount, "ownerTotalToken", ownerTotalToken.get(), "totalToken", totalToken.get());
    }
    
    PAYABLE void PortfolioManage::depositPool(uint64_t _depositValue){
        isOwner();
        
        uint64_t tokenBalance = changeU256ToUint64WithChangeRate(callValue(), changeRate.get()); 
        *ownerTotalToken = ownerTotalToken.get() + tokenBalance;
        *totalToken = totalToken.get() + tokenBalance;
        DIPC_EMIT_EVENT(tokenCount, "ownerTotalToken", ownerTotalToken.get(), "totalToken", totalToken.get());
    }
     
    CONSTANT uint64_t PortfolioManage::queryTotalToken(){
        return totalToken.get();
    }

     
    CONSTANT uint64_t PortfolioManage::queryPortfolioBalance(char* _portfolioName){
        return portfolioBalance.get()[_portfolioName];
    }

    
    CONSTANT bool PortfolioManage::queryPortfolioNameIfUsed(char* _portfolioName){
        if(portfolioStorge.get()[_portfolioName] != ""){
            return true;
        } 
        return false;
    }

    
    CONSTANT uint64_t PortfolioManage::queryChangeRate(){
        return changeRate.get();
    }

2019-12-19_15:14:53.529966: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:427] searchContext  #include "PortfolioManage.hpp"

    
    PAYABLE void PortfolioManage::init(){
        *owner = caller().toString();
        *changeRate = 10000;
        *userCanWithdraw = false;
        uint64_t tokenBalance = getTotalBalance();
        
        *ownerTotalToken = tokenBalance;
        *totalToken = ownerTotalToken.get();
        
        
        DIPC_EMIT_EVENT(initEvent, "ownerTotalToken" ,tokenBalance);
    }
    
     
    EXPORT void PortfolioManage::setChangeRate(uint64_t _changeRate){
        isOwner();
        *changeRate = _changeRate;
    }
     
    EXPORT void PortfolioManage::setUserCanWithdraw(bool _canWithdraw){
        u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
isOwner();
        *userCanWithdraw = _canWithdraw;
    }

    
    PAYABLE void PortfolioManage::createPortfolio(char* _portfolioName, char* _portfolioDesc){
        if(portfolioStorge.get()[_portfolioName] != ""){
            DIPC_EMIT_EVENT(ErrEvent, "Current portfolio exist: ", _portfolioName);
            return;
        } 
        std::string callerAddr = caller().toString();
        uint64_t tokenBalance = getTotalBalance();
        
        PortfolioInfo info(_portfolioName, _portfolioDesc, &callerAddr[0]);
        std::string portfolioStr = info.toJson();
        
        
        

        (*portfolioStorge)[_portfolioName] = portfolioStr;
        DipcAssert(totalToken.get() + tokenBalance > totalToken);
        (*portfolioBalance)[_portfolioName] = tokenBalance;
        *totalToken = totalToken.get() + tokenBalance; 
        
        DIPC_EMIT_EVENT(portfolioInfo, _portfolioName, &portfolioStr[0], "portfolioBalance", tokenBalance);
    }

    
    PAYABLE void PortfolioManage::depositPortfolio(char* _portfolioName){
        uint64_t tokenBalance = getTotalBalance();
        
        uint64_t currentBalance = portfolioBalance.get()[_portfolioName];
        uint64_t finalBalance  = currentBalance + tokenBalance;
        DipcAssert(totalToken.get() + tokenBalance > totalToken);
        DipcAssert(finalBalance > currentBalance);
        (*portfolioBalance)[_portfolioName] = finalBalance;
        *totalToken = totalToken.get() + finalBalance; 
        DIPC_EMIT_EVENT(depositPortfolio, "portfolioName", _portfolioName, "portfolioBalance", finalBalance);
    }
    
    PAYABLE void PortfolioManage::createOrder(char* _portfolioName, char* _orderId, uint16_t _orderType, char* _stockCode, uint64_t _stockPrice, uint64_t _stockAmount, uint64_t _endTime){
        uint64_t tokenBalance = getTotalBalance();
        DIPC_EMIT_EVENT(createOrder, "portfolioName", _portfolioName, "OrderInfo", "ignore", "tokenBalance", tokenBalance);
        uint64_t spent = 0;
        if(_orderType == 1){
            spent = _stockPrice * _stockAmount;
            DipcAssert((portfolioBalance.get()[_portfolioName] + tokenBalance) > spent);
        }
        struct Order order{_orderId, _orderType, _stockCode, _stockPrice, _stockAmount, _endTime, 0};
        std::string pInfo = portfolioStorge.get()[_portfolioName];
        
        
        
        if(pInfo == "") {
            DIPC_EMIT_EVENT(ErrEvent, "Current portfolio  doesn't exist: ", _portfolioName);
            return;
        }
        PortfolioInfo info;
        info.parseJson(pInfo);
        if(info.getOrder(_orderId).orderId != ""){
            DIPC_EMIT_EVENT(ErrEvent, "Current order exist: ", _orderId);
            return;
        }
        info.addOrder(order);
        pInfo = info.toJson();

        uint64_t currentBalance = portfolioBalance.get()[_portfolioName] ;
        uint64_t finalBalance = currentBalance + tokenBalance - spent;
        DipcAssert(totalToken.get() + tokenBalance > totalToken);
        
        DipcAssert(ownerTotalToken.get() < ownerTotalToken.get() + spent);
        (*portfolioStorge)[_portfolioName] = &pInfo[0];
        
        
        
        


        (*portfolioBalance)[_portfolioName] = finalBalance;
        *totalToken = totalToken.get() + finalBalance; 
        *ownerTotalToken = ownerTotalToken.get() + spent;
        DIPC_EMIT_EVENT(createOrder, "portfolioName", _portfolioName, "OrderInfo", &order.toJson()[0], "portfolioBalance", finalBalance);
    }

    
    EXPORT void PortfolioManage::dealOrder(char* _portfolioName, char* _orderId){
        isOwner();
        std::string pInfo = portfolioStorge.get()[_portfolioName];
        
        
        PortfolioInfo info;
        info.parseJson(pInfo);
        

        
         Order ord = info.getOrder(_orderId);
         
         
        if(ord.orderId != "" && ord.orderStatus == 0){
            
            uint64_t timenow = dipc::timestamp();
            if(ord.endTime > timenow){
                ord.orderStatus = 1;
            }else {
                ord.orderStatus = 3;
            }
        } else {
          

            return;
        }
        

        uint64_t sellValue = 0;
        if(ord.orderType == 0){
            sellValue = ord.stockAmount * ord.stockPrice;
        }
        uint64_t currentBalance =  portfolioBalance.get()[_portfolioName];
        

        DipcAssert(currentBalance + sellValue >= currentBalance);
        DipcAssert((ownerTotalToken.get() - sellValue) <= ownerTotalToken.get());
        


        (*portfolioBalance)[_portfolioName] = currentBalance + sellValue;
        *ownerTotalToken = ownerTotalToken.get() - sellValue;
        (*portfolioStorge)[_portfolioName] = &info.toJson()[0];
        
        
        
        

        DIPC_EMIT_EVENT(dealPortfolio, "orderId", _orderId, "orderInfo", &ord.toJson()[0]);
    }
    
    EXPORT void PortfolioManage::revocationOrder(char* _portfolioName, char* _orderId){
        std::string pInfo = portfolioStorge.get()[_portfolioName];
        
        
        PortfolioInfo info;
        info.parseJson(pInfo);
        Order ord = info.getOrder(_orderId);
        
        
        if(ord.orderId != "" && ord.orderStatus == 0){
            std::string callerStr = caller().toString();
            
            
            
            DipcAssert(info.getOwnerAddress() == caller().toString());
            

            uint64_t timenow = dipc::timestamp();
            if(ord.endTime > timenow){
                ord.orderStatus = 2;
            }else {
                ord.orderStatus = 3;
            }
        } else {
            return;
        }
        uint64_t lockToken = 0;
        if(ord.orderType == 1){
            lockToken = ord.stockPrice * ord.stockAmount;
        }
        uint64_t currentBalance =  portfolioBalance.get()[_portfolioName];
        
        
        
        

        DipcAssert(currentBalance + lockToken >= currentBalance);
        DipcAssert(ownerTotalToken.get() - lockToken <= ownerTotalToken.get());

        
        (*portfolioBalance)[_portfolioName] = currentBalance + lockToken;
        *ownerTotalToken = ownerTotalToken.get() - lockToken;
        (*portfolioStorge)[_portfolioName] = &info.toJson()[0];
        DIPC_EMIT_EVENT(revocationPortfolio, "orderId", _orderId, "orderInfo", &ord.toJson()[0]);
    }
    
    EXPORT void PortfolioManage::withdrawPortfolio(char* _portfolioName, uint64_t _withdrawBalance){
         if(!userCanWithdraw.get()){
             return;
         }
         uint64_t currentBalance =  portfolioBalance.get()[_portfolioName];
         DipcAssert(currentBalance - _withdrawBalance < currentBalance);
         auto coinBalance = changeUint64ToU256WithChangeRate(currentBalance, changeRate.get());
         (*portfolioBalance)[_portfolioName] = currentBalance - _withdrawBalance;
         callTransfer(caller(), coinBalance);
    }
    
    EXPORT void PortfolioManage::withdrawPool(uint64_t _balance){
        isOwner();
        Address ownerAddr = Address(owner.get()); 
        callTransfer(ownerAddr, _balance);
        *ownerTotalToken = ownerTotalToken.get() - _balance * changeRate.get();
        *totalToken = totalToken.get() - _balance * changeRate.get();
        DIPC_EMIT_EVENT(tokenCount, "ownerTotalToken", ownerTotalToken.get(), "totalToken", totalToken.get());
    }
    
    PAYABLE void PortfolioManage::depositPool(uint64_t _depositValue){
        isOwner();
        
        uint64_t tokenBalance = changeU256ToUint64WithChangeRate(callValue(), changeRate.get()); 
        *ownerTotalToken = ownerTotalToken.get() + tokenBalance;
        *totalToken = totalToken.get() + tokenBalance;
        DIPC_EMIT_EVENT(tokenCount, "ownerTotalToken", ownerTotalToken.get(), "totalToken", totalToken.get());
    }
     
    CONSTANT uint64_t PortfolioManage::queryTotalToken(){
        return totalToken.get();
    }

     
    CONSTANT uint64_t PortfolioManage::queryPortfolioBalance(char* _portfolioName){
        return portfolioBalance.get()[_portfolioName];
    }

    
    CONSTANT bool PortfolioManage::queryPortfolioNameIfUsed(char* _portfolioName){
        if(portfolioStorge.get()[_portfolioName] != ""){
            return true;
        } 
        return false;
    }

    
    CONSTANT uint64_t PortfolioManage::queryChangeRate(){
        return changeRate.get();
    }

2019-12-19_15:14:53.630209: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:451] log out out  Export :

    
    EXPORT void PortfolioManage::dealOrder(char* _portfolioName, char* _orderId){
        

2019-12-19_15:14:53.630231: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:457] name : dealOrder   pos1  0

2019-12-19_15:14:53.630242: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:469] pos2  4195   pos1  4195

2019-12-19_15:14:53.630250: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:500] pos2 after 5576   pos1  4195

2019-12-19_15:14:53.630257: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:509] finalContract  first #include "PortfolioManage.hpp"

    
    PAYABLE void PortfolioManage::init(){
        *owner = caller().toString();
        *changeRate = 10000;
        *userCanWithdraw = false;
        uint64_t tokenBalance = getTotalBalance();
        
        *ownerTotalToken = tokenBalance;
        *totalToken = ownerTotalToken.get();
        
        
        DIPC_EMIT_EVENT(initEvent, "ownerTotalToken" ,tokenBalance);
    }
    
     
    EXPORT void PortfolioManage::setChangeRate(uint64_t _changeRate){
        isOwner();
        *changeRate = _changeRate;
    }
     
    EXPORT void PortfolioManage::setUserCanWithdraw(bool _canWithdraw){
        u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
isOwner();
        *userCanWithdraw = _canWithdraw;
    }

    
    PAYABLE void PortfolioManage::createPortfolio(char* _portfolioName, char* _portfolioDesc){
        if(portfolioStorge.get()[_portfolioName] != ""){
            DIPC_EMIT_EVENT(ErrEvent, "Current portfolio exist: ", _portfolioName);
            return;
        } 
        std::string callerAddr = caller().toString();
        uint64_t tokenBalance = getTotalBalance();
        
        PortfolioInfo info(_portfolioName, _portfolioDesc, &callerAddr[0]);
        std::string portfolioStr = info.toJson();
        
        
        

        (*portfolioStorge)[_portfolioName] = portfolioStr;
        DipcAssert(totalToken.get() + tokenBalance > totalToken);
        (*portfolioBalance)[_portfolioName] = tokenBalance;
        *totalToken = totalToken.get() + tokenBalance; 
        
        DIPC_EMIT_EVENT(portfolioInfo, _portfolioName, &portfolioStr[0], "portfolioBalance", tokenBalance);
    }

    
    PAYABLE void PortfolioManage::depositPortfolio(char* _portfolioName){
        uint64_t tokenBalance = getTotalBalance();
        
        uint64_t currentBalance = portfolioBalance.get()[_portfolioName];
        uint64_t finalBalance  = currentBalance + tokenBalance;
        DipcAssert(totalToken.get() + tokenBalance > totalToken);
        DipcAssert(finalBalance > currentBalance);
        (*portfolioBalance)[_portfolioName] = finalBalance;
        *totalToken = totalToken.get() + finalBalance; 
        DIPC_EMIT_EVENT(depositPortfolio, "portfolioName", _portfolioName, "portfolioBalance", finalBalance);
    }
    
    PAYABLE void PortfolioManage::createOrder(char* _portfolioName, char* _orderId, uint16_t _orderType, char* _stockCode, uint64_t _stockPrice, uint64_t _stockAmount, uint64_t _endTime){
        uint64_t tokenBalance = getTotalBalance();
        DIPC_EMIT_EVENT(createOrder, "portfolioName", _portfolioName, "OrderInfo", "ignore", "tokenBalance", tokenBalance);
        uint64_t spent = 0;
        if(_orderType == 1){
            spent = _stockPrice * _stockAmount;
            DipcAssert((portfolioBalance.get()[_portfolioName] + tokenBalance) > spent);
        }
        struct Order order{_orderId, _orderType, _stockCode, _stockPrice, _stockAmount, _endTime, 0};
        std::string pInfo = portfolioStorge.get()[_portfolioName];
        
        
        
        if(pInfo == "") {
            DIPC_EMIT_EVENT(ErrEvent, "Current portfolio  doesn't exist: ", _portfolioName);
            return;
        }
        PortfolioInfo info;
        info.parseJson(pInfo);
        if(info.getOrder(_orderId).orderId != ""){
            DIPC_EMIT_EVENT(ErrEvent, "Current order exist: ", _orderId);
            return;
        }
        info.addOrder(order);
        pInfo = info.toJson();

        uint64_t currentBalance = portfolioBalance.get()[_portfolioName] ;
        uint64_t finalBalance = currentBalance + tokenBalance - spent;
        DipcAssert(totalToken.get() + tokenBalance > totalToken);
        
        DipcAssert(ownerTotalToken.get() < ownerTotalToken.get() + spent);
        (*portfolioStorge)[_portfolioName] = &pInfo[0];
        
        
        
        


        (*portfolioBalance)[_portfolioName] = finalBalance;
        *totalToken = totalToken.get() + finalBalance; 
        *ownerTotalToken = ownerTotalToken.get() + spent;
        DIPC_EMIT_EVENT(createOrder, "portfolioName", _portfolioName, "OrderInfo", &order.toJson()[0], "portfolioBalance", finalBalance);
    }

2019-12-19_15:14:53.630265: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:510] codetext  first #include "PortfolioManage.hpp"

    
    PAYABLE void PortfolioManage::init(){
        *owner = caller().toString();
        *changeRate = 10000;
        *userCanWithdraw = false;
        uint64_t tokenBalance = getTotalBalance();
        
        *ownerTotalToken = tokenBalance;
        *totalToken = ownerTotalToken.get();
        
        
        DIPC_EMIT_EVENT(initEvent, "ownerTotalToken" ,tokenBalance);
    }
    
     
    EXPORT void PortfolioManage::setChangeRate(uint64_t _changeRate){
        isOwner();
        *changeRate = _changeRate;
    }
     
    EXPORT void PortfolioManage::setUserCanWithdraw(bool _canWithdraw){
        u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
isOwner();
        *userCanWithdraw = _canWithdraw;
    }

    
    PAYABLE void PortfolioManage::createPortfolio(char* _portfolioName, char* _portfolioDesc){
        if(portfolioStorge.get()[_portfolioName] != ""){
            DIPC_EMIT_EVENT(ErrEvent, "Current portfolio exist: ", _portfolioName);
            return;
        } 
        std::string callerAddr = caller().toString();
        uint64_t tokenBalance = getTotalBalance();
        
        PortfolioInfo info(_portfolioName, _portfolioDesc, &callerAddr[0]);
        std::string portfolioStr = info.toJson();
        
        
        

        (*portfolioStorge)[_portfolioName] = portfolioStr;
        DipcAssert(totalToken.get() + tokenBalance > totalToken);
        (*portfolioBalance)[_portfolioName] = tokenBalance;
        *totalToken = totalToken.get() + tokenBalance; 
        
        DIPC_EMIT_EVENT(portfolioInfo, _portfolioName, &portfolioStr[0], "portfolioBalance", tokenBalance);
    }

    
    PAYABLE void PortfolioManage::depositPortfolio(char* _portfolioName){
        uint64_t tokenBalance = getTotalBalance();
        
        uint64_t currentBalance = portfolioBalance.get()[_portfolioName];
        uint64_t finalBalance  = currentBalance + tokenBalance;
        DipcAssert(totalToken.get() + tokenBalance > totalToken);
        DipcAssert(finalBalance > currentBalance);
        (*portfolioBalance)[_portfolioName] = finalBalance;
        *totalToken = totalToken.get() + finalBalance; 
        DIPC_EMIT_EVENT(depositPortfolio, "portfolioName", _portfolioName, "portfolioBalance", finalBalance);
    }
    
    PAYABLE void PortfolioManage::createOrder(char* _portfolioName, char* _orderId, uint16_t _orderType, char* _stockCode, uint64_t _stockPrice, uint64_t _stockAmount, uint64_t _endTime){
        uint64_t tokenBalance = getTotalBalance();
        DIPC_EMIT_EVENT(createOrder, "portfolioName", _portfolioName, "OrderInfo", "ignore", "tokenBalance", tokenBalance);
        uint64_t spent = 0;
        if(_orderType == 1){
            spent = _stockPrice * _stockAmount;
            DipcAssert((portfolioBalance.get()[_portfolioName] + tokenBalance) > spent);
        }
        struct Order order{_orderId, _orderType, _stockCode, _stockPrice, _stockAmount, _endTime, 0};
        std::string pInfo = portfolioStorge.get()[_portfolioName];
        
        
        
        if(pInfo == "") {
            DIPC_EMIT_EVENT(ErrEvent, "Current portfolio  doesn't exist: ", _portfolioName);
            return;
        }
        PortfolioInfo info;
        info.parseJson(pInfo);
        if(info.getOrder(_orderId).orderId != ""){
            DIPC_EMIT_EVENT(ErrEvent, "Current order exist: ", _orderId);
            return;
        }
        info.addOrder(order);
        pInfo = info.toJson();

        uint64_t currentBalance = portfolioBalance.get()[_portfolioName] ;
        uint64_t finalBalance = currentBalance + tokenBalance - spent;
        DipcAssert(totalToken.get() + tokenBalance > totalToken);
        
        DipcAssert(ownerTotalToken.get() < ownerTotalToken.get() + spent);
        (*portfolioStorge)[_portfolioName] = &pInfo[0];
        
        
        
        


        (*portfolioBalance)[_portfolioName] = finalBalance;
        *totalToken = totalToken.get() + finalBalance; 
        *ownerTotalToken = ownerTotalToken.get() + spent;
        DIPC_EMIT_EVENT(createOrder, "portfolioName", _portfolioName, "OrderInfo", &order.toJson()[0], "portfolioBalance", finalBalance);
    }

    
    EXPORT void PortfolioManage::dealOrder(char* _portfolioName, char* _orderId){
        isOwner();
        std::string pInfo = portfolioStorge.get()[_portfolioName];
        
        
        PortfolioInfo info;
        info.parseJson(pInfo);
        

        
         Order ord = info.getOrder(_orderId);
         
         
        if(ord.orderId != "" && ord.orderStatus == 0){
            
            uint64_t timenow = dipc::timestamp();
            if(ord.endTime > timenow){
                ord.orderStatus = 1;
            }else {
                ord.orderStatus = 3;
            }
        } else {
          

            return;
        }
        

        uint64_t sellValue = 0;
        if(ord.orderType == 0){
            sellValue = ord.stockAmount * ord.stockPrice;
        }
        uint64_t currentBalance =  portfolioBalance.get()[_portfolioName];
        

        DipcAssert(currentBalance + sellValue >= currentBalance);
        DipcAssert((ownerTotalToken.get() - sellValue) <= ownerTotalToken.get());
        


        (*portfolioBalance)[_portfolioName] = currentBalance + sellValue;
        *ownerTotalToken = ownerTotalToken.get() - sellValue;
        (*portfolioStorge)[_portfolioName] = &info.toJson()[0];
        
        
        
        

        DIPC_EMIT_EVENT(dealPortfolio, "orderId", _orderId, "orderInfo", &ord.toJson()[0]);
    }
    
    EXPORT void PortfolioManage::revocationOrder(char* _portfolioName, char* _orderId){
        std::string pInfo = portfolioStorge.get()[_portfolioName];
        
        
        PortfolioInfo info;
        info.parseJson(pInfo);
        Order ord = info.getOrder(_orderId);
        
        
        if(ord.orderId != "" && ord.orderStatus == 0){
            std::string callerStr = caller().toString();
            
            
            
            DipcAssert(info.getOwnerAddress() == caller().toString());
            

            uint64_t timenow = dipc::timestamp();
            if(ord.endTime > timenow){
                ord.orderStatus = 2;
            }else {
                ord.orderStatus = 3;
            }
        } else {
            return;
        }
        uint64_t lockToken = 0;
        if(ord.orderType == 1){
            lockToken = ord.stockPrice * ord.stockAmount;
        }
        uint64_t currentBalance =  portfolioBalance.get()[_portfolioName];
        
        
        
        

        DipcAssert(currentBalance + lockToken >= currentBalance);
        DipcAssert(ownerTotalToken.get() - lockToken <= ownerTotalToken.get());

        
        (*portfolioBalance)[_portfolioName] = currentBalance + lockToken;
        *ownerTotalToken = ownerTotalToken.get() - lockToken;
        (*portfolioStorge)[_portfolioName] = &info.toJson()[0];
        DIPC_EMIT_EVENT(revocationPortfolio, "orderId", _orderId, "orderInfo", &ord.toJson()[0]);
    }
    
    EXPORT void PortfolioManage::withdrawPortfolio(char* _portfolioName, uint64_t _withdrawBalance){
         if(!userCanWithdraw.get()){
             return;
         }
         uint64_t currentBalance =  portfolioBalance.get()[_portfolioName];
         DipcAssert(currentBalance - _withdrawBalance < currentBalance);
         auto coinBalance = changeUint64ToU256WithChangeRate(currentBalance, changeRate.get());
         (*portfolioBalance)[_portfolioName] = currentBalance - _withdrawBalance;
         callTransfer(caller(), coinBalance);
    }
    
    EXPORT void PortfolioManage::withdrawPool(uint64_t _balance){
        isOwner();
        Address ownerAddr = Address(owner.get()); 
        callTransfer(ownerAddr, _balance);
        *ownerTotalToken = ownerTotalToken.get() - _balance * changeRate.get();
        *totalToken = totalToken.get() - _balance * changeRate.get();
        DIPC_EMIT_EVENT(tokenCount, "ownerTotalToken", ownerTotalToken.get(), "totalToken", totalToken.get());
    }
    
    PAYABLE void PortfolioManage::depositPool(uint64_t _depositValue){
        isOwner();
        
        uint64_t tokenBalance = changeU256ToUint64WithChangeRate(callValue(), changeRate.get()); 
        *ownerTotalToken = ownerTotalToken.get() + tokenBalance;
        *totalToken = totalToken.get() + tokenBalance;
        DIPC_EMIT_EVENT(tokenCount, "ownerTotalToken", ownerTotalToken.get(), "totalToken", totalToken.get());
    }
     
    CONSTANT uint64_t PortfolioManage::queryTotalToken(){
        return totalToken.get();
    }

     
    CONSTANT uint64_t PortfolioManage::queryPortfolioBalance(char* _portfolioName){
        return portfolioBalance.get()[_portfolioName];
    }

    
    CONSTANT bool PortfolioManage::queryPortfolioNameIfUsed(char* _portfolioName){
        if(portfolioStorge.get()[_portfolioName] != ""){
            return true;
        } 
        return false;
    }

    
    CONSTANT uint64_t PortfolioManage::queryChangeRate(){
        return changeRate.get();
    }

2019-12-19_15:14:53.630274: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:513] s  first 

    
    EXPORT void PortfolioManage::dealOrder(char* _portfolioName, char* _orderId){
        isOwner();
        std::string pInfo = portfolioStorge.get()[_portfolioName];
        
        
        PortfolioInfo info;
        info.parseJson(pInfo);
        

        
         Order ord = info.getOrder(_orderId);
         
         
        if(ord.orderId != "" && ord.orderStatus == 0){
            
            uint64_t timenow = dipc::timestamp();
            if(ord.endTime > timenow){
                ord.orderStatus = 1;
            }else {
                ord.orderStatus = 3;
            }
        } else {
          

            return;
        }
        

        uint64_t sellValue = 0;
        if(ord.orderType == 0){
            sellValue = ord.stockAmount * ord.stockPrice;
        }
        uint64_t currentBalance =  portfolioBalance.get()[_portfolioName];
        

        DipcAssert(currentBalance + sellValue >= currentBalance);
        DipcAssert((ownerTotalToken.get() - sellValue) <= ownerTotalToken.get());
        


        (*portfolioBalance)[_portfolioName] = currentBalance + sellValue;
        *ownerTotalToken = ownerTotalToken.get() - sellValue;
        (*portfolioStorge)[_portfolioName] = &info.toJson()[0];
        
        
        
        

        DIPC_EMIT_EVENT(dealPortfolio, "orderId", _orderId, "orderInfo", &ord.toJson()[0]);
    }

2019-12-19_15:14:53.630281: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:593] calledFunc temp export: 

    
    EXPORT void PortfolioManage::dealOrder(char* _portfolioName, char* _orderId){
        u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
isOwner();
        std::string pInfo = portfolioStorge.get()[_portfolioName];
        
        
        PortfolioInfo info;
        info.parseJson(pInfo);
        

        
         Order ord = info.getOrder(_orderId);
         
         
        if(ord.orderId != "" && ord.orderStatus == 0){
            
            uint64_t timenow = dipc::timestamp();
            if(ord.endTime > timenow){
                ord.orderStatus = 1;
            }else {
                ord.orderStatus = 3;
            }
        } else {
          

            return;
        }
        

        uint64_t sellValue = 0;
        if(ord.orderType == 0){
            sellValue = ord.stockAmount * ord.stockPrice;
        }
        uint64_t currentBalance =  portfolioBalance.get()[_portfolioName];
        

        DipcAssert(currentBalance + sellValue >= currentBalance);
        DipcAssert((ownerTotalToken.get() - sellValue) <= ownerTotalToken.get());
        


        (*portfolioBalance)[_portfolioName] = currentBalance + sellValue;
        *ownerTotalToken = ownerTotalToken.get() - sellValue;
        (*portfolioStorge)[_portfolioName] = &info.toJson()[0];
        
        
        
        

        DIPC_EMIT_EVENT(dealPortfolio, "orderId", _orderId, "orderInfo", &ord.toJson()[0]);
    }

2019-12-19_15:14:53.630288: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:599] search func : 

    
    EXPORT void PortfolioManage::dealOrder(char* _portfolioName, char* _orderId){
        u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
isOwner();
        std::string pInfo = portfolioStorge.get()[_portfolioName];
        
        
        PortfolioInfo info;
        info.parseJson(pInfo);
        

        
         Order ord = info.getOrder(_orderId);
         
         
        if(ord.orderId != "" && ord.orderStatus == 0){
            
            uint64_t timenow = dipc::timestamp();
            if(ord.endTime > timenow){
                ord.orderStatus = 1;
            }else {
                ord.orderStatus = 3;
            }
        } else {
          

            return;
        }
        

        uint64_t sellValue = 0;
        if(ord.orderType == 0){
            sellValue = ord.stockAmount * ord.stockPrice;
        }
        uint64_t currentBalance =  portfolioBalance.get()[_portfolioName];
        

        DipcAssert(currentBalance + sellValue >= currentBalance);
        DipcAssert((ownerTotalToken.get() - sellValue) <= ownerTotalToken.get());
        


        (*portfolioBalance)[_portfolioName] = currentBalance + sellValue;
        *ownerTotalToken = ownerTotalToken.get() - sellValue;
        (*portfolioStorge)[_portfolioName] = &info.toJson()[0];
        
        
        
        

        DIPC_EMIT_EVENT(dealPortfolio, "orderId", _orderId, "orderInfo", &ord.toJson()[0]);
    }
2019-12-19_15:14:53.630295: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:424] finalContract  this height  #include "PortfolioManage.hpp"

    
    PAYABLE void PortfolioManage::init(){
        *owner = caller().toString();
        *changeRate = 10000;
        *userCanWithdraw = false;
        uint64_t tokenBalance = getTotalBalance();
        
        *ownerTotalToken = tokenBalance;
        *totalToken = ownerTotalToken.get();
        
        
        DIPC_EMIT_EVENT(initEvent, "ownerTotalToken" ,tokenBalance);
    }
    
     
    EXPORT void PortfolioManage::setChangeRate(uint64_t _changeRate){
        isOwner();
        *changeRate = _changeRate;
    }
     
    EXPORT void PortfolioManage::setUserCanWithdraw(bool _canWithdraw){
        u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
isOwner();
        *userCanWithdraw = _canWithdraw;
    }

    
    PAYABLE void PortfolioManage::createPortfolio(char* _portfolioName, char* _portfolioDesc){
        if(portfolioStorge.get()[_portfolioName] != ""){
            DIPC_EMIT_EVENT(ErrEvent, "Current portfolio exist: ", _portfolioName);
            return;
        } 
        std::string callerAddr = caller().toString();
        uint64_t tokenBalance = getTotalBalance();
        
        PortfolioInfo info(_portfolioName, _portfolioDesc, &callerAddr[0]);
        std::string portfolioStr = info.toJson();
        
        
        

        (*portfolioStorge)[_portfolioName] = portfolioStr;
        DipcAssert(totalToken.get() + tokenBalance > totalToken);
        (*portfolioBalance)[_portfolioName] = tokenBalance;
        *totalToken = totalToken.get() + tokenBalance; 
        
        DIPC_EMIT_EVENT(portfolioInfo, _portfolioName, &portfolioStr[0], "portfolioBalance", tokenBalance);
    }

    
    PAYABLE void PortfolioManage::depositPortfolio(char* _portfolioName){
        uint64_t tokenBalance = getTotalBalance();
        
        uint64_t currentBalance = portfolioBalance.get()[_portfolioName];
        uint64_t finalBalance  = currentBalance + tokenBalance;
        DipcAssert(totalToken.get() + tokenBalance > totalToken);
        DipcAssert(finalBalance > currentBalance);
        (*portfolioBalance)[_portfolioName] = finalBalance;
        *totalToken = totalToken.get() + finalBalance; 
        DIPC_EMIT_EVENT(depositPortfolio, "portfolioName", _portfolioName, "portfolioBalance", finalBalance);
    }
    
    PAYABLE void PortfolioManage::createOrder(char* _portfolioName, char* _orderId, uint16_t _orderType, char* _stockCode, uint64_t _stockPrice, uint64_t _stockAmount, uint64_t _endTime){
        uint64_t tokenBalance = getTotalBalance();
        DIPC_EMIT_EVENT(createOrder, "portfolioName", _portfolioName, "OrderInfo", "ignore", "tokenBalance", tokenBalance);
        uint64_t spent = 0;
        if(_orderType == 1){
            spent = _stockPrice * _stockAmount;
            DipcAssert((portfolioBalance.get()[_portfolioName] + tokenBalance) > spent);
        }
        struct Order order{_orderId, _orderType, _stockCode, _stockPrice, _stockAmount, _endTime, 0};
        std::string pInfo = portfolioStorge.get()[_portfolioName];
        
        
        
        if(pInfo == "") {
            DIPC_EMIT_EVENT(ErrEvent, "Current portfolio  doesn't exist: ", _portfolioName);
            return;
        }
        PortfolioInfo info;
        info.parseJson(pInfo);
        if(info.getOrder(_orderId).orderId != ""){
            DIPC_EMIT_EVENT(ErrEvent, "Current order exist: ", _orderId);
            return;
        }
        info.addOrder(order);
        pInfo = info.toJson();

        uint64_t currentBalance = portfolioBalance.get()[_portfolioName] ;
        uint64_t finalBalance = currentBalance + tokenBalance - spent;
        DipcAssert(totalToken.get() + tokenBalance > totalToken);
        
        DipcAssert(ownerTotalToken.get() < ownerTotalToken.get() + spent);
        (*portfolioStorge)[_portfolioName] = &pInfo[0];
        
        
        
        


        (*portfolioBalance)[_portfolioName] = finalBalance;
        *totalToken = totalToken.get() + finalBalance; 
        *ownerTotalToken = ownerTotalToken.get() + spent;
        DIPC_EMIT_EVENT(createOrder, "portfolioName", _portfolioName, "OrderInfo", &order.toJson()[0], "portfolioBalance", finalBalance);
    }

    
    EXPORT void PortfolioManage::dealOrder(char* _portfolioName, char* _orderId){
        u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
isOwner();
        std::string pInfo = portfolioStorge.get()[_portfolioName];
        
        
        PortfolioInfo info;
        info.parseJson(pInfo);
        

        
         Order ord = info.getOrder(_orderId);
         
         
        if(ord.orderId != "" && ord.orderStatus == 0){
            
            uint64_t timenow = dipc::timestamp();
            if(ord.endTime > timenow){
                ord.orderStatus = 1;
            }else {
                ord.orderStatus = 3;
            }
        } else {
          

            return;
        }
        

        uint64_t sellValue = 0;
        if(ord.orderType == 0){
            sellValue = ord.stockAmount * ord.stockPrice;
        }
        uint64_t currentBalance =  portfolioBalance.get()[_portfolioName];
        

        DipcAssert(currentBalance + sellValue >= currentBalance);
        DipcAssert((ownerTotalToken.get() - sellValue) <= ownerTotalToken.get());
        


        (*portfolioBalance)[_portfolioName] = currentBalance + sellValue;
        *ownerTotalToken = ownerTotalToken.get() - sellValue;
        (*portfolioStorge)[_portfolioName] = &info.toJson()[0];
        
        
        
        

        DIPC_EMIT_EVENT(dealPortfolio, "orderId", _orderId, "orderInfo", &ord.toJson()[0]);
    } codetext height #include "PortfolioManage.hpp"

    
    PAYABLE void PortfolioManage::init(){
        *owner = caller().toString();
        *changeRate = 10000;
        *userCanWithdraw = false;
        uint64_t tokenBalance = getTotalBalance();
        
        *ownerTotalToken = tokenBalance;
        *totalToken = ownerTotalToken.get();
        
        
        DIPC_EMIT_EVENT(initEvent, "ownerTotalToken" ,tokenBalance);
    }
    
     
    EXPORT void PortfolioManage::setChangeRate(uint64_t _changeRate){
        isOwner();
        *changeRate = _changeRate;
    }
     
    EXPORT void PortfolioManage::setUserCanWithdraw(bool _canWithdraw){
        u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
isOwner();
        *userCanWithdraw = _canWithdraw;
    }

    
    PAYABLE void PortfolioManage::createPortfolio(char* _portfolioName, char* _portfolioDesc){
        if(portfolioStorge.get()[_portfolioName] != ""){
            DIPC_EMIT_EVENT(ErrEvent, "Current portfolio exist: ", _portfolioName);
            return;
        } 
        std::string callerAddr = caller().toString();
        uint64_t tokenBalance = getTotalBalance();
        
        PortfolioInfo info(_portfolioName, _portfolioDesc, &callerAddr[0]);
        std::string portfolioStr = info.toJson();
        
        
        

        (*portfolioStorge)[_portfolioName] = portfolioStr;
        DipcAssert(totalToken.get() + tokenBalance > totalToken);
        (*portfolioBalance)[_portfolioName] = tokenBalance;
        *totalToken = totalToken.get() + tokenBalance; 
        
        DIPC_EMIT_EVENT(portfolioInfo, _portfolioName, &portfolioStr[0], "portfolioBalance", tokenBalance);
    }

    
    PAYABLE void PortfolioManage::depositPortfolio(char* _portfolioName){
        uint64_t tokenBalance = getTotalBalance();
        
        uint64_t currentBalance = portfolioBalance.get()[_portfolioName];
        uint64_t finalBalance  = currentBalance + tokenBalance;
        DipcAssert(totalToken.get() + tokenBalance > totalToken);
        DipcAssert(finalBalance > currentBalance);
        (*portfolioBalance)[_portfolioName] = finalBalance;
        *totalToken = totalToken.get() + finalBalance; 
        DIPC_EMIT_EVENT(depositPortfolio, "portfolioName", _portfolioName, "portfolioBalance", finalBalance);
    }
    
    PAYABLE void PortfolioManage::createOrder(char* _portfolioName, char* _orderId, uint16_t _orderType, char* _stockCode, uint64_t _stockPrice, uint64_t _stockAmount, uint64_t _endTime){
        uint64_t tokenBalance = getTotalBalance();
        DIPC_EMIT_EVENT(createOrder, "portfolioName", _portfolioName, "OrderInfo", "ignore", "tokenBalance", tokenBalance);
        uint64_t spent = 0;
        if(_orderType == 1){
            spent = _stockPrice * _stockAmount;
            DipcAssert((portfolioBalance.get()[_portfolioName] + tokenBalance) > spent);
        }
        struct Order order{_orderId, _orderType, _stockCode, _stockPrice, _stockAmount, _endTime, 0};
        std::string pInfo = portfolioStorge.get()[_portfolioName];
        
        
        
        if(pInfo == "") {
            DIPC_EMIT_EVENT(ErrEvent, "Current portfolio  doesn't exist: ", _portfolioName);
            return;
        }
        PortfolioInfo info;
        info.parseJson(pInfo);
        if(info.getOrder(_orderId).orderId != ""){
            DIPC_EMIT_EVENT(ErrEvent, "Current order exist: ", _orderId);
            return;
        }
        info.addOrder(order);
        pInfo = info.toJson();

        uint64_t currentBalance = portfolioBalance.get()[_portfolioName] ;
        uint64_t finalBalance = currentBalance + tokenBalance - spent;
        DipcAssert(totalToken.get() + tokenBalance > totalToken);
        
        DipcAssert(ownerTotalToken.get() < ownerTotalToken.get() + spent);
        (*portfolioStorge)[_portfolioName] = &pInfo[0];
        
        
        
        


        (*portfolioBalance)[_portfolioName] = finalBalance;
        *totalToken = totalToken.get() + finalBalance; 
        *ownerTotalToken = ownerTotalToken.get() + spent;
        DIPC_EMIT_EVENT(createOrder, "portfolioName", _portfolioName, "OrderInfo", &order.toJson()[0], "portfolioBalance", finalBalance);
    }

    
    EXPORT void PortfolioManage::dealOrder(char* _portfolioName, char* _orderId){
        isOwner();
        std::string pInfo = portfolioStorge.get()[_portfolioName];
        
        
        PortfolioInfo info;
        info.parseJson(pInfo);
        

        
         Order ord = info.getOrder(_orderId);
         
         
        if(ord.orderId != "" && ord.orderStatus == 0){
            
            uint64_t timenow = dipc::timestamp();
            if(ord.endTime > timenow){
                ord.orderStatus = 1;
            }else {
                ord.orderStatus = 3;
            }
        } else {
          

            return;
        }
        

        uint64_t sellValue = 0;
        if(ord.orderType == 0){
            sellValue = ord.stockAmount * ord.stockPrice;
        }
        uint64_t currentBalance =  portfolioBalance.get()[_portfolioName];
        

        DipcAssert(currentBalance + sellValue >= currentBalance);
        DipcAssert((ownerTotalToken.get() - sellValue) <= ownerTotalToken.get());
        


        (*portfolioBalance)[_portfolioName] = currentBalance + sellValue;
        *ownerTotalToken = ownerTotalToken.get() - sellValue;
        (*portfolioStorge)[_portfolioName] = &info.toJson()[0];
        
        
        
        

        DIPC_EMIT_EVENT(dealPortfolio, "orderId", _orderId, "orderInfo", &ord.toJson()[0]);
    }
    
    EXPORT void PortfolioManage::revocationOrder(char* _portfolioName, char* _orderId){
        std::string pInfo = portfolioStorge.get()[_portfolioName];
        
        
        PortfolioInfo info;
        info.parseJson(pInfo);
        Order ord = info.getOrder(_orderId);
        
        
        if(ord.orderId != "" && ord.orderStatus == 0){
            std::string callerStr = caller().toString();
            
            
            
            DipcAssert(info.getOwnerAddress() == caller().toString());
            

            uint64_t timenow = dipc::timestamp();
            if(ord.endTime > timenow){
                ord.orderStatus = 2;
            }else {
                ord.orderStatus = 3;
            }
        } else {
            return;
        }
        uint64_t lockToken = 0;
        if(ord.orderType == 1){
            lockToken = ord.stockPrice * ord.stockAmount;
        }
        uint64_t currentBalance =  portfolioBalance.get()[_portfolioName];
        
        
        
        

        DipcAssert(currentBalance + lockToken >= currentBalance);
        DipcAssert(ownerTotalToken.get() - lockToken <= ownerTotalToken.get());

        
        (*portfolioBalance)[_portfolioName] = currentBalance + lockToken;
        *ownerTotalToken = ownerTotalToken.get() - lockToken;
        (*portfolioStorge)[_portfolioName] = &info.toJson()[0];
        DIPC_EMIT_EVENT(revocationPortfolio, "orderId", _orderId, "orderInfo", &ord.toJson()[0]);
    }
    
    EXPORT void PortfolioManage::withdrawPortfolio(char* _portfolioName, uint64_t _withdrawBalance){
         if(!userCanWithdraw.get()){
             return;
         }
         uint64_t currentBalance =  portfolioBalance.get()[_portfolioName];
         DipcAssert(currentBalance - _withdrawBalance < currentBalance);
         auto coinBalance = changeUint64ToU256WithChangeRate(currentBalance, changeRate.get());
         (*portfolioBalance)[_portfolioName] = currentBalance - _withdrawBalance;
         callTransfer(caller(), coinBalance);
    }
    
    EXPORT void PortfolioManage::withdrawPool(uint64_t _balance){
        isOwner();
        Address ownerAddr = Address(owner.get()); 
        callTransfer(ownerAddr, _balance);
        *ownerTotalToken = ownerTotalToken.get() - _balance * changeRate.get();
        *totalToken = totalToken.get() - _balance * changeRate.get();
        DIPC_EMIT_EVENT(tokenCount, "ownerTotalToken", ownerTotalToken.get(), "totalToken", totalToken.get());
    }
    
    PAYABLE void PortfolioManage::depositPool(uint64_t _depositValue){
        isOwner();
        
        uint64_t tokenBalance = changeU256ToUint64WithChangeRate(callValue(), changeRate.get()); 
        *ownerTotalToken = ownerTotalToken.get() + tokenBalance;
        *totalToken = totalToken.get() + tokenBalance;
        DIPC_EMIT_EVENT(tokenCount, "ownerTotalToken", ownerTotalToken.get(), "totalToken", totalToken.get());
    }
     
    CONSTANT uint64_t PortfolioManage::queryTotalToken(){
        return totalToken.get();
    }

     
    CONSTANT uint64_t PortfolioManage::queryPortfolioBalance(char* _portfolioName){
        return portfolioBalance.get()[_portfolioName];
    }

    
    CONSTANT bool PortfolioManage::queryPortfolioNameIfUsed(char* _portfolioName){
        if(portfolioStorge.get()[_portfolioName] != ""){
            return true;
        } 
        return false;
    }

    
    CONSTANT uint64_t PortfolioManage::queryChangeRate(){
        return changeRate.get();
    }

2019-12-19_15:14:53.630305: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:427] searchContext  
    
    EXPORT void PortfolioManage::revocationOrder(char* _portfolioName, char* _orderId){
        std::string pInfo = portfolioStorge.get()[_portfolioName];
        
        
        PortfolioInfo info;
        info.parseJson(pInfo);
        Order ord = info.getOrder(_orderId);
        
        
        if(ord.orderId != "" && ord.orderStatus == 0){
            std::string callerStr = caller().toString();
            
            
            
            DipcAssert(info.getOwnerAddress() == caller().toString());
            

            uint64_t timenow = dipc::timestamp();
            if(ord.endTime > timenow){
                ord.orderStatus = 2;
            }else {
                ord.orderStatus = 3;
            }
        } else {
            return;
        }
        uint64_t lockToken = 0;
        if(ord.orderType == 1){
            lockToken = ord.stockPrice * ord.stockAmount;
        }
        uint64_t currentBalance =  portfolioBalance.get()[_portfolioName];
        
        
        
        

        DipcAssert(currentBalance + lockToken >= currentBalance);
        DipcAssert(ownerTotalToken.get() - lockToken <= ownerTotalToken.get());

        
        (*portfolioBalance)[_portfolioName] = currentBalance + lockToken;
        *ownerTotalToken = ownerTotalToken.get() - lockToken;
        (*portfolioStorge)[_portfolioName] = &info.toJson()[0];
        DIPC_EMIT_EVENT(revocationPortfolio, "orderId", _orderId, "orderInfo", &ord.toJson()[0]);
    }
    
    EXPORT void PortfolioManage::withdrawPortfolio(char* _portfolioName, uint64_t _withdrawBalance){
         if(!userCanWithdraw.get()){
             return;
         }
         uint64_t currentBalance =  portfolioBalance.get()[_portfolioName];
         DipcAssert(currentBalance - _withdrawBalance < currentBalance);
         auto coinBalance = changeUint64ToU256WithChangeRate(currentBalance, changeRate.get());
         (*portfolioBalance)[_portfolioName] = currentBalance - _withdrawBalance;
         callTransfer(caller(), coinBalance);
    }
    
    EXPORT void PortfolioManage::withdrawPool(uint64_t _balance){
        isOwner();
        Address ownerAddr = Address(owner.get()); 
        callTransfer(ownerAddr, _balance);
        *ownerTotalToken = ownerTotalToken.get() - _balance * changeRate.get();
        *totalToken = totalToken.get() - _balance * changeRate.get();
        DIPC_EMIT_EVENT(tokenCount, "ownerTotalToken", ownerTotalToken.get(), "totalToken", totalToken.get());
    }
    
    PAYABLE void PortfolioManage::depositPool(uint64_t _depositValue){
        isOwner();
        
        uint64_t tokenBalance = changeU256ToUint64WithChangeRate(callValue(), changeRate.get()); 
        *ownerTotalToken = ownerTotalToken.get() + tokenBalance;
        *totalToken = totalToken.get() + tokenBalance;
        DIPC_EMIT_EVENT(tokenCount, "ownerTotalToken", ownerTotalToken.get(), "totalToken", totalToken.get());
    }
     
    CONSTANT uint64_t PortfolioManage::queryTotalToken(){
        return totalToken.get();
    }

     
    CONSTANT uint64_t PortfolioManage::queryPortfolioBalance(char* _portfolioName){
        return portfolioBalance.get()[_portfolioName];
    }

    
    CONSTANT bool PortfolioManage::queryPortfolioNameIfUsed(char* _portfolioName){
        if(portfolioStorge.get()[_portfolioName] != ""){
            return true;
        } 
        return false;
    }

    
    CONSTANT uint64_t PortfolioManage::queryChangeRate(){
        return changeRate.get();
    }

2019-12-19_15:14:53.718714: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:442] finalContract  this new  #include "PortfolioManage.hpp"

    
    PAYABLE void PortfolioManage::init(){
        *owner = caller().toString();
        *changeRate = 10000;
        *userCanWithdraw = false;
        uint64_t tokenBalance = getTotalBalance();
        
        *ownerTotalToken = tokenBalance;
        *totalToken = ownerTotalToken.get();
        
        
        DIPC_EMIT_EVENT(initEvent, "ownerTotalToken" ,tokenBalance);
    }
    
     
    EXPORT void PortfolioManage::setChangeRate(uint64_t _changeRate){
        isOwner();
        *changeRate = _changeRate;
    }
     
    EXPORT void PortfolioManage::setUserCanWithdraw(bool _canWithdraw){
        u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
isOwner();
        *userCanWithdraw = _canWithdraw;
    }

    
    PAYABLE void PortfolioManage::createPortfolio(char* _portfolioName, char* _portfolioDesc){
        if(portfolioStorge.get()[_portfolioName] != ""){
            DIPC_EMIT_EVENT(ErrEvent, "Current portfolio exist: ", _portfolioName);
            return;
        } 
        std::string callerAddr = caller().toString();
        uint64_t tokenBalance = getTotalBalance();
        
        PortfolioInfo info(_portfolioName, _portfolioDesc, &callerAddr[0]);
        std::string portfolioStr = info.toJson();
        
        
        

        (*portfolioStorge)[_portfolioName] = portfolioStr;
        DipcAssert(totalToken.get() + tokenBalance > totalToken);
        (*portfolioBalance)[_portfolioName] = tokenBalance;
        *totalToken = totalToken.get() + tokenBalance; 
        
        DIPC_EMIT_EVENT(portfolioInfo, _portfolioName, &portfolioStr[0], "portfolioBalance", tokenBalance);
    }

    
    PAYABLE void PortfolioManage::depositPortfolio(char* _portfolioName){
        uint64_t tokenBalance = getTotalBalance();
        
        uint64_t currentBalance = portfolioBalance.get()[_portfolioName];
        uint64_t finalBalance  = currentBalance + tokenBalance;
        DipcAssert(totalToken.get() + tokenBalance > totalToken);
        DipcAssert(finalBalance > currentBalance);
        (*portfolioBalance)[_portfolioName] = finalBalance;
        *totalToken = totalToken.get() + finalBalance; 
        DIPC_EMIT_EVENT(depositPortfolio, "portfolioName", _portfolioName, "portfolioBalance", finalBalance);
    }
    
    PAYABLE void PortfolioManage::createOrder(char* _portfolioName, char* _orderId, uint16_t _orderType, char* _stockCode, uint64_t _stockPrice, uint64_t _stockAmount, uint64_t _endTime){
        uint64_t tokenBalance = getTotalBalance();
        DIPC_EMIT_EVENT(createOrder, "portfolioName", _portfolioName, "OrderInfo", "ignore", "tokenBalance", tokenBalance);
        uint64_t spent = 0;
        if(_orderType == 1){
            spent = _stockPrice * _stockAmount;
            DipcAssert((portfolioBalance.get()[_portfolioName] + tokenBalance) > spent);
        }
        struct Order order{_orderId, _orderType, _stockCode, _stockPrice, _stockAmount, _endTime, 0};
        std::string pInfo = portfolioStorge.get()[_portfolioName];
        
        
        
        if(pInfo == "") {
            DIPC_EMIT_EVENT(ErrEvent, "Current portfolio  doesn't exist: ", _portfolioName);
            return;
        }
        PortfolioInfo info;
        info.parseJson(pInfo);
        if(info.getOrder(_orderId).orderId != ""){
            DIPC_EMIT_EVENT(ErrEvent, "Current order exist: ", _orderId);
            return;
        }
        info.addOrder(order);
        pInfo = info.toJson();

        uint64_t currentBalance = portfolioBalance.get()[_portfolioName] ;
        uint64_t finalBalance = currentBalance + tokenBalance - spent;
        DipcAssert(totalToken.get() + tokenBalance > totalToken);
        
        DipcAssert(ownerTotalToken.get() < ownerTotalToken.get() + spent);
        (*portfolioStorge)[_portfolioName] = &pInfo[0];
        
        
        
        


        (*portfolioBalance)[_portfolioName] = finalBalance;
        *totalToken = totalToken.get() + finalBalance; 
        *ownerTotalToken = ownerTotalToken.get() + spent;
        DIPC_EMIT_EVENT(createOrder, "portfolioName", _portfolioName, "OrderInfo", &order.toJson()[0], "portfolioBalance", finalBalance);
    }

    
    EXPORT void PortfolioManage::dealOrder(char* _portfolioName, char* _orderId){
        u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
isOwner();
        std::string pInfo = portfolioStorge.get()[_portfolioName];
        
        
        PortfolioInfo info;
        info.parseJson(pInfo);
        

        
         Order ord = info.getOrder(_orderId);
         
         
        if(ord.orderId != "" && ord.orderStatus == 0){
            
            uint64_t timenow = dipc::timestamp();
            if(ord.endTime > timenow){
                ord.orderStatus = 1;
            }else {
                ord.orderStatus = 3;
            }
        } else {
          

            return;
        }
        

        uint64_t sellValue = 0;
        if(ord.orderType == 0){
            sellValue = ord.stockAmount * ord.stockPrice;
        }
        uint64_t currentBalance =  portfolioBalance.get()[_portfolioName];
        

        DipcAssert(currentBalance + sellValue >= currentBalance);
        DipcAssert((ownerTotalToken.get() - sellValue) <= ownerTotalToken.get());
        


        (*portfolioBalance)[_portfolioName] = currentBalance + sellValue;
        *ownerTotalToken = ownerTotalToken.get() - sellValue;
        (*portfolioStorge)[_portfolioName] = &info.toJson()[0];
        
        
        
        

        DIPC_EMIT_EVENT(dealPortfolio, "orderId", _orderId, "orderInfo", &ord.toJson()[0]);
    } codetext new #include "PortfolioManage.hpp"

    
    PAYABLE void PortfolioManage::init(){
        *owner = caller().toString();
        *changeRate = 10000;
        *userCanWithdraw = false;
        uint64_t tokenBalance = getTotalBalance();
        
        *ownerTotalToken = tokenBalance;
        *totalToken = ownerTotalToken.get();
        
        
        DIPC_EMIT_EVENT(initEvent, "ownerTotalToken" ,tokenBalance);
    }
    
     
    EXPORT void PortfolioManage::setChangeRate(uint64_t _changeRate){
        isOwner();
        *changeRate = _changeRate;
    }
     
    EXPORT void PortfolioManage::setUserCanWithdraw(bool _canWithdraw){
        u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
isOwner();
        *userCanWithdraw = _canWithdraw;
    }

    
    PAYABLE void PortfolioManage::createPortfolio(char* _portfolioName, char* _portfolioDesc){
        if(portfolioStorge.get()[_portfolioName] != ""){
            DIPC_EMIT_EVENT(ErrEvent, "Current portfolio exist: ", _portfolioName);
            return;
        } 
        std::string callerAddr = caller().toString();
        uint64_t tokenBalance = getTotalBalance();
        
        PortfolioInfo info(_portfolioName, _portfolioDesc, &callerAddr[0]);
        std::string portfolioStr = info.toJson();
        
        
        

        (*portfolioStorge)[_portfolioName] = portfolioStr;
        DipcAssert(totalToken.get() + tokenBalance > totalToken);
        (*portfolioBalance)[_portfolioName] = tokenBalance;
        *totalToken = totalToken.get() + tokenBalance; 
        
        DIPC_EMIT_EVENT(portfolioInfo, _portfolioName, &portfolioStr[0], "portfolioBalance", tokenBalance);
    }

    
    PAYABLE void PortfolioManage::depositPortfolio(char* _portfolioName){
        uint64_t tokenBalance = getTotalBalance();
        
        uint64_t currentBalance = portfolioBalance.get()[_portfolioName];
        uint64_t finalBalance  = currentBalance + tokenBalance;
        DipcAssert(totalToken.get() + tokenBalance > totalToken);
        DipcAssert(finalBalance > currentBalance);
        (*portfolioBalance)[_portfolioName] = finalBalance;
        *totalToken = totalToken.get() + finalBalance; 
        DIPC_EMIT_EVENT(depositPortfolio, "portfolioName", _portfolioName, "portfolioBalance", finalBalance);
    }
    
    PAYABLE void PortfolioManage::createOrder(char* _portfolioName, char* _orderId, uint16_t _orderType, char* _stockCode, uint64_t _stockPrice, uint64_t _stockAmount, uint64_t _endTime){
        uint64_t tokenBalance = getTotalBalance();
        DIPC_EMIT_EVENT(createOrder, "portfolioName", _portfolioName, "OrderInfo", "ignore", "tokenBalance", tokenBalance);
        uint64_t spent = 0;
        if(_orderType == 1){
            spent = _stockPrice * _stockAmount;
            DipcAssert((portfolioBalance.get()[_portfolioName] + tokenBalance) > spent);
        }
        struct Order order{_orderId, _orderType, _stockCode, _stockPrice, _stockAmount, _endTime, 0};
        std::string pInfo = portfolioStorge.get()[_portfolioName];
        
        
        
        if(pInfo == "") {
            DIPC_EMIT_EVENT(ErrEvent, "Current portfolio  doesn't exist: ", _portfolioName);
            return;
        }
        PortfolioInfo info;
        info.parseJson(pInfo);
        if(info.getOrder(_orderId).orderId != ""){
            DIPC_EMIT_EVENT(ErrEvent, "Current order exist: ", _orderId);
            return;
        }
        info.addOrder(order);
        pInfo = info.toJson();

        uint64_t currentBalance = portfolioBalance.get()[_portfolioName] ;
        uint64_t finalBalance = currentBalance + tokenBalance - spent;
        DipcAssert(totalToken.get() + tokenBalance > totalToken);
        
        DipcAssert(ownerTotalToken.get() < ownerTotalToken.get() + spent);
        (*portfolioStorge)[_portfolioName] = &pInfo[0];
        
        
        
        


        (*portfolioBalance)[_portfolioName] = finalBalance;
        *totalToken = totalToken.get() + finalBalance; 
        *ownerTotalToken = ownerTotalToken.get() + spent;
        DIPC_EMIT_EVENT(createOrder, "portfolioName", _portfolioName, "OrderInfo", &order.toJson()[0], "portfolioBalance", finalBalance);
    }

    
    EXPORT void PortfolioManage::dealOrder(char* _portfolioName, char* _orderId){
        isOwner();
        std::string pInfo = portfolioStorge.get()[_portfolioName];
        
        
        PortfolioInfo info;
        info.parseJson(pInfo);
        

        
         Order ord = info.getOrder(_orderId);
         
         
        if(ord.orderId != "" && ord.orderStatus == 0){
            
            uint64_t timenow = dipc::timestamp();
            if(ord.endTime > timenow){
                ord.orderStatus = 1;
            }else {
                ord.orderStatus = 3;
            }
        } else {
          

            return;
        }
        

        uint64_t sellValue = 0;
        if(ord.orderType == 0){
            sellValue = ord.stockAmount * ord.stockPrice;
        }
        uint64_t currentBalance =  portfolioBalance.get()[_portfolioName];
        

        DipcAssert(currentBalance + sellValue >= currentBalance);
        DipcAssert((ownerTotalToken.get() - sellValue) <= ownerTotalToken.get());
        


        (*portfolioBalance)[_portfolioName] = currentBalance + sellValue;
        *ownerTotalToken = ownerTotalToken.get() - sellValue;
        (*portfolioStorge)[_portfolioName] = &info.toJson()[0];
        
        
        
        

        DIPC_EMIT_EVENT(dealPortfolio, "orderId", _orderId, "orderInfo", &ord.toJson()[0]);
    }
    
    EXPORT void PortfolioManage::revocationOrder(char* _portfolioName, char* _orderId){
        std::string pInfo = portfolioStorge.get()[_portfolioName];
        
        
        PortfolioInfo info;
        info.parseJson(pInfo);
        Order ord = info.getOrder(_orderId);
        
        
        if(ord.orderId != "" && ord.orderStatus == 0){
            std::string callerStr = caller().toString();
            
            
            
            DipcAssert(info.getOwnerAddress() == caller().toString());
            

            uint64_t timenow = dipc::timestamp();
            if(ord.endTime > timenow){
                ord.orderStatus = 2;
            }else {
                ord.orderStatus = 3;
            }
        } else {
            return;
        }
        uint64_t lockToken = 0;
        if(ord.orderType == 1){
            lockToken = ord.stockPrice * ord.stockAmount;
        }
        uint64_t currentBalance =  portfolioBalance.get()[_portfolioName];
        
        
        
        

        DipcAssert(currentBalance + lockToken >= currentBalance);
        DipcAssert(ownerTotalToken.get() - lockToken <= ownerTotalToken.get());

        
        (*portfolioBalance)[_portfolioName] = currentBalance + lockToken;
        *ownerTotalToken = ownerTotalToken.get() - lockToken;
        (*portfolioStorge)[_portfolioName] = &info.toJson()[0];
        DIPC_EMIT_EVENT(revocationPortfolio, "orderId", _orderId, "orderInfo", &ord.toJson()[0]);
    }
    
    EXPORT void PortfolioManage::withdrawPortfolio(char* _portfolioName, uint64_t _withdrawBalance){
         if(!userCanWithdraw.get()){
             return;
         }
         uint64_t currentBalance =  portfolioBalance.get()[_portfolioName];
         DipcAssert(currentBalance - _withdrawBalance < currentBalance);
         auto coinBalance = changeUint64ToU256WithChangeRate(currentBalance, changeRate.get());
         (*portfolioBalance)[_portfolioName] = currentBalance - _withdrawBalance;
         callTransfer(caller(), coinBalance);
    }
    
    EXPORT void PortfolioManage::withdrawPool(uint64_t _balance){
        isOwner();
        Address ownerAddr = Address(owner.get()); 
        callTransfer(ownerAddr, _balance);
        *ownerTotalToken = ownerTotalToken.get() - _balance * changeRate.get();
        *totalToken = totalToken.get() - _balance * changeRate.get();
        DIPC_EMIT_EVENT(tokenCount, "ownerTotalToken", ownerTotalToken.get(), "totalToken", totalToken.get());
    }
    
    PAYABLE void PortfolioManage::depositPool(uint64_t _depositValue){
        isOwner();
        
        uint64_t tokenBalance = changeU256ToUint64WithChangeRate(callValue(), changeRate.get()); 
        *ownerTotalToken = ownerTotalToken.get() + tokenBalance;
        *totalToken = totalToken.get() + tokenBalance;
        DIPC_EMIT_EVENT(tokenCount, "ownerTotalToken", ownerTotalToken.get(), "totalToken", totalToken.get());
    }
     
    CONSTANT uint64_t PortfolioManage::queryTotalToken(){
        return totalToken.get();
    }

     
    CONSTANT uint64_t PortfolioManage::queryPortfolioBalance(char* _portfolioName){
        return portfolioBalance.get()[_portfolioName];
    }

    
    CONSTANT bool PortfolioManage::queryPortfolioNameIfUsed(char* _portfolioName){
        if(portfolioStorge.get()[_portfolioName] != ""){
            return true;
        } 
        return false;
    }

    
    CONSTANT uint64_t PortfolioManage::queryChangeRate(){
        return changeRate.get();
    }

2019-12-19_15:14:53.718745: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:604] finalContract  final content =======   : #include "PortfolioManage.hpp"

    
    PAYABLE void PortfolioManage::init(){
        *owner = caller().toString();
        *changeRate = 10000;
        *userCanWithdraw = false;
        uint64_t tokenBalance = getTotalBalance();
        
        *ownerTotalToken = tokenBalance;
        *totalToken = ownerTotalToken.get();
        
        
        DIPC_EMIT_EVENT(initEvent, "ownerTotalToken" ,tokenBalance);
    }
    
     
    EXPORT void PortfolioManage::setChangeRate(uint64_t _changeRate){
        isOwner();
        *changeRate = _changeRate;
    }
     
    EXPORT void PortfolioManage::setUserCanWithdraw(bool _canWithdraw){
        u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
isOwner();
        *userCanWithdraw = _canWithdraw;
    }

    
    PAYABLE void PortfolioManage::createPortfolio(char* _portfolioName, char* _portfolioDesc){
        if(portfolioStorge.get()[_portfolioName] != ""){
            DIPC_EMIT_EVENT(ErrEvent, "Current portfolio exist: ", _portfolioName);
            return;
        } 
        std::string callerAddr = caller().toString();
        uint64_t tokenBalance = getTotalBalance();
        
        PortfolioInfo info(_portfolioName, _portfolioDesc, &callerAddr[0]);
        std::string portfolioStr = info.toJson();
        
        
        

        (*portfolioStorge)[_portfolioName] = portfolioStr;
        DipcAssert(totalToken.get() + tokenBalance > totalToken);
        (*portfolioBalance)[_portfolioName] = tokenBalance;
        *totalToken = totalToken.get() + tokenBalance; 
        
        DIPC_EMIT_EVENT(portfolioInfo, _portfolioName, &portfolioStr[0], "portfolioBalance", tokenBalance);
    }

    
    PAYABLE void PortfolioManage::depositPortfolio(char* _portfolioName){
        uint64_t tokenBalance = getTotalBalance();
        
        uint64_t currentBalance = portfolioBalance.get()[_portfolioName];
        uint64_t finalBalance  = currentBalance + tokenBalance;
        DipcAssert(totalToken.get() + tokenBalance > totalToken);
        DipcAssert(finalBalance > currentBalance);
        (*portfolioBalance)[_portfolioName] = finalBalance;
        *totalToken = totalToken.get() + finalBalance; 
        DIPC_EMIT_EVENT(depositPortfolio, "portfolioName", _portfolioName, "portfolioBalance", finalBalance);
    }
    
    PAYABLE void PortfolioManage::createOrder(char* _portfolioName, char* _orderId, uint16_t _orderType, char* _stockCode, uint64_t _stockPrice, uint64_t _stockAmount, uint64_t _endTime){
        uint64_t tokenBalance = getTotalBalance();
        DIPC_EMIT_EVENT(createOrder, "portfolioName", _portfolioName, "OrderInfo", "ignore", "tokenBalance", tokenBalance);
        uint64_t spent = 0;
        if(_orderType == 1){
            spent = _stockPrice * _stockAmount;
            DipcAssert((portfolioBalance.get()[_portfolioName] + tokenBalance) > spent);
        }
        struct Order order{_orderId, _orderType, _stockCode, _stockPrice, _stockAmount, _endTime, 0};
        std::string pInfo = portfolioStorge.get()[_portfolioName];
        
        
        
        if(pInfo == "") {
            DIPC_EMIT_EVENT(ErrEvent, "Current portfolio  doesn't exist: ", _portfolioName);
            return;
        }
        PortfolioInfo info;
        info.parseJson(pInfo);
        if(info.getOrder(_orderId).orderId != ""){
            DIPC_EMIT_EVENT(ErrEvent, "Current order exist: ", _orderId);
            return;
        }
        info.addOrder(order);
        pInfo = info.toJson();

        uint64_t currentBalance = portfolioBalance.get()[_portfolioName] ;
        uint64_t finalBalance = currentBalance + tokenBalance - spent;
        DipcAssert(totalToken.get() + tokenBalance > totalToken);
        
        DipcAssert(ownerTotalToken.get() < ownerTotalToken.get() + spent);
        (*portfolioStorge)[_portfolioName] = &pInfo[0];
        
        
        
        


        (*portfolioBalance)[_portfolioName] = finalBalance;
        *totalToken = totalToken.get() + finalBalance; 
        *ownerTotalToken = ownerTotalToken.get() + spent;
        DIPC_EMIT_EVENT(createOrder, "portfolioName", _portfolioName, "OrderInfo", &order.toJson()[0], "portfolioBalance", finalBalance);
    }

    
    EXPORT void PortfolioManage::dealOrder(char* _portfolioName, char* _orderId){
        u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
isOwner();
        std::string pInfo = portfolioStorge.get()[_portfolioName];
        
        
        PortfolioInfo info;
        info.parseJson(pInfo);
        

        
         Order ord = info.getOrder(_orderId);
         
         
        if(ord.orderId != "" && ord.orderStatus == 0){
            
            uint64_t timenow = dipc::timestamp();
            if(ord.endTime > timenow){
                ord.orderStatus = 1;
            }else {
                ord.orderStatus = 3;
            }
        } else {
          

            return;
        }
        

        uint64_t sellValue = 0;
        if(ord.orderType == 0){
            sellValue = ord.stockAmount * ord.stockPrice;
        }
        uint64_t currentBalance =  portfolioBalance.get()[_portfolioName];
        

        DipcAssert(currentBalance + sellValue >= currentBalance);
        DipcAssert((ownerTotalToken.get() - sellValue) <= ownerTotalToken.get());
        


        (*portfolioBalance)[_portfolioName] = currentBalance + sellValue;
        *ownerTotalToken = ownerTotalToken.get() - sellValue;
        (*portfolioStorge)[_portfolioName] = &info.toJson()[0];
        
        
        
        

        DIPC_EMIT_EVENT(dealPortfolio, "orderId", _orderId, "orderInfo", &ord.toJson()[0]);
    }
    
    EXPORT void PortfolioManage::revocationOrder(char* _portfolioName, char* _orderId){
        std::string pInfo = portfolioStorge.get()[_portfolioName];
        
        
        PortfolioInfo info;
        info.parseJson(pInfo);
        Order ord = info.getOrder(_orderId);
        
        
        if(ord.orderId != "" && ord.orderStatus == 0){
            std::string callerStr = caller().toString();
            
            
            
            DipcAssert(info.getOwnerAddress() == caller().toString());
            

            uint64_t timenow = dipc::timestamp();
            if(ord.endTime > timenow){
                ord.orderStatus = 2;
            }else {
                ord.orderStatus = 3;
            }
        } else {
            return;
        }
        uint64_t lockToken = 0;
        if(ord.orderType == 1){
            lockToken = ord.stockPrice * ord.stockAmount;
        }
        uint64_t currentBalance =  portfolioBalance.get()[_portfolioName];
        
        
        
        

        DipcAssert(currentBalance + lockToken >= currentBalance);
        DipcAssert(ownerTotalToken.get() - lockToken <= ownerTotalToken.get());

        
        (*portfolioBalance)[_portfolioName] = currentBalance + lockToken;
        *ownerTotalToken = ownerTotalToken.get() - lockToken;
        (*portfolioStorge)[_portfolioName] = &info.toJson()[0];
        DIPC_EMIT_EVENT(revocationPortfolio, "orderId", _orderId, "orderInfo", &ord.toJson()[0]);
    }
    
    EXPORT void PortfolioManage::withdrawPortfolio(char* _portfolioName, uint64_t _withdrawBalance){
         if(!userCanWithdraw.get()){
             return;
         }
         uint64_t currentBalance =  portfolioBalance.get()[_portfolioName];
         DipcAssert(currentBalance - _withdrawBalance < currentBalance);
         auto coinBalance = changeUint64ToU256WithChangeRate(currentBalance, changeRate.get());
         (*portfolioBalance)[_portfolioName] = currentBalance - _withdrawBalance;
         callTransfer(caller(), coinBalance);
    }
    
    EXPORT void PortfolioManage::withdrawPool(uint64_t _balance){
        isOwner();
        Address ownerAddr = Address(owner.get()); 
        callTransfer(ownerAddr, _balance);
        *ownerTotalToken = ownerTotalToken.get() - _balance * changeRate.get();
        *totalToken = totalToken.get() - _balance * changeRate.get();
        DIPC_EMIT_EVENT(tokenCount, "ownerTotalToken", ownerTotalToken.get(), "totalToken", totalToken.get());
    }
    
    PAYABLE void PortfolioManage::depositPool(uint64_t _depositValue){
        isOwner();
        
        uint64_t tokenBalance = changeU256ToUint64WithChangeRate(callValue(), changeRate.get()); 
        *ownerTotalToken = ownerTotalToken.get() + tokenBalance;
        *totalToken = totalToken.get() + tokenBalance;
        DIPC_EMIT_EVENT(tokenCount, "ownerTotalToken", ownerTotalToken.get(), "totalToken", totalToken.get());
    }
     
    CONSTANT uint64_t PortfolioManage::queryTotalToken(){
        return totalToken.get();
    }

     
    CONSTANT uint64_t PortfolioManage::queryPortfolioBalance(char* _portfolioName){
        return portfolioBalance.get()[_portfolioName];
    }

    
    CONSTANT bool PortfolioManage::queryPortfolioNameIfUsed(char* _portfolioName){
        if(portfolioStorge.get()[_portfolioName] != ""){
            return true;
        } 
        return false;
    }

    
    CONSTANT uint64_t PortfolioManage::queryChangeRate(){
        return changeRate.get();
    }

2019-12-19_15:14:53.718815: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:401] abis.ispayable :false

2019-12-19_15:14:53.718836: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:424] finalContract  this height  #include "PortfolioManage.hpp"

    
    PAYABLE void PortfolioManage::init(){
        *owner = caller().toString();
        *changeRate = 10000;
        *userCanWithdraw = false;
        uint64_t tokenBalance = getTotalBalance();
        
        *ownerTotalToken = tokenBalance;
        *totalToken = ownerTotalToken.get();
        
        
        DIPC_EMIT_EVENT(initEvent, "ownerTotalToken" ,tokenBalance);
    }
    
     
    EXPORT void PortfolioManage::setChangeRate(uint64_t _changeRate){
        isOwner();
        *changeRate = _changeRate;
    }
     
    EXPORT void PortfolioManage::setUserCanWithdraw(bool _canWithdraw){
        u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
isOwner();
        *userCanWithdraw = _canWithdraw;
    }

    
    PAYABLE void PortfolioManage::createPortfolio(char* _portfolioName, char* _portfolioDesc){
        if(portfolioStorge.get()[_portfolioName] != ""){
            DIPC_EMIT_EVENT(ErrEvent, "Current portfolio exist: ", _portfolioName);
            return;
        } 
        std::string callerAddr = caller().toString();
        uint64_t tokenBalance = getTotalBalance();
        
        PortfolioInfo info(_portfolioName, _portfolioDesc, &callerAddr[0]);
        std::string portfolioStr = info.toJson();
        
        
        

        (*portfolioStorge)[_portfolioName] = portfolioStr;
        DipcAssert(totalToken.get() + tokenBalance > totalToken);
        (*portfolioBalance)[_portfolioName] = tokenBalance;
        *totalToken = totalToken.get() + tokenBalance; 
        
        DIPC_EMIT_EVENT(portfolioInfo, _portfolioName, &portfolioStr[0], "portfolioBalance", tokenBalance);
    }

    
    PAYABLE void PortfolioManage::depositPortfolio(char* _portfolioName){
        uint64_t tokenBalance = getTotalBalance();
        
        uint64_t currentBalance = portfolioBalance.get()[_portfolioName];
        uint64_t finalBalance  = currentBalance + tokenBalance;
        DipcAssert(totalToken.get() + tokenBalance > totalToken);
        DipcAssert(finalBalance > currentBalance);
        (*portfolioBalance)[_portfolioName] = finalBalance;
        *totalToken = totalToken.get() + finalBalance; 
        DIPC_EMIT_EVENT(depositPortfolio, "portfolioName", _portfolioName, "portfolioBalance", finalBalance);
    }
    
    PAYABLE void PortfolioManage::createOrder(char* _portfolioName, char* _orderId, uint16_t _orderType, char* _stockCode, uint64_t _stockPrice, uint64_t _stockAmount, uint64_t _endTime){
        uint64_t tokenBalance = getTotalBalance();
        DIPC_EMIT_EVENT(createOrder, "portfolioName", _portfolioName, "OrderInfo", "ignore", "tokenBalance", tokenBalance);
        uint64_t spent = 0;
        if(_orderType == 1){
            spent = _stockPrice * _stockAmount;
            DipcAssert((portfolioBalance.get()[_portfolioName] + tokenBalance) > spent);
        }
        struct Order order{_orderId, _orderType, _stockCode, _stockPrice, _stockAmount, _endTime, 0};
        std::string pInfo = portfolioStorge.get()[_portfolioName];
        
        
        
        if(pInfo == "") {
            DIPC_EMIT_EVENT(ErrEvent, "Current portfolio  doesn't exist: ", _portfolioName);
            return;
        }
        PortfolioInfo info;
        info.parseJson(pInfo);
        if(info.getOrder(_orderId).orderId != ""){
            DIPC_EMIT_EVENT(ErrEvent, "Current order exist: ", _orderId);
            return;
        }
        info.addOrder(order);
        pInfo = info.toJson();

        uint64_t currentBalance = portfolioBalance.get()[_portfolioName] ;
        uint64_t finalBalance = currentBalance + tokenBalance - spent;
        DipcAssert(totalToken.get() + tokenBalance > totalToken);
        
        DipcAssert(ownerTotalToken.get() < ownerTotalToken.get() + spent);
        (*portfolioStorge)[_portfolioName] = &pInfo[0];
        
        
        
        


        (*portfolioBalance)[_portfolioName] = finalBalance;
        *totalToken = totalToken.get() + finalBalance; 
        *ownerTotalToken = ownerTotalToken.get() + spent;
        DIPC_EMIT_EVENT(createOrder, "portfolioName", _portfolioName, "OrderInfo", &order.toJson()[0], "portfolioBalance", finalBalance);
    }

    
    EXPORT void PortfolioManage::dealOrder(char* _portfolioName, char* _orderId){
        u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
isOwner();
        std::string pInfo = portfolioStorge.get()[_portfolioName];
        
        
        PortfolioInfo info;
        info.parseJson(pInfo);
        

        
         Order ord = info.getOrder(_orderId);
         
         
        if(ord.orderId != "" && ord.orderStatus == 0){
            
            uint64_t timenow = dipc::timestamp();
            if(ord.endTime > timenow){
                ord.orderStatus = 1;
            }else {
                ord.orderStatus = 3;
            }
        } else {
          

            return;
        }
        

        uint64_t sellValue = 0;
        if(ord.orderType == 0){
            sellValue = ord.stockAmount * ord.stockPrice;
        }
        uint64_t currentBalance =  portfolioBalance.get()[_portfolioName];
        

        DipcAssert(currentBalance + sellValue >= currentBalance);
        DipcAssert((ownerTotalToken.get() - sellValue) <= ownerTotalToken.get());
        


        (*portfolioBalance)[_portfolioName] = currentBalance + sellValue;
        *ownerTotalToken = ownerTotalToken.get() - sellValue;
        (*portfolioStorge)[_portfolioName] = &info.toJson()[0];
        
        
        
        

        DIPC_EMIT_EVENT(dealPortfolio, "orderId", _orderId, "orderInfo", &ord.toJson()[0]);
    }
    
    EXPORT void PortfolioManage::revocationOrder(char* _portfolioName, char* _orderId){
        std::string pInfo = portfolioStorge.get()[_portfolioName];
        
        
        PortfolioInfo info;
        info.parseJson(pInfo);
        Order ord = info.getOrder(_orderId);
        
        
        if(ord.orderId != "" && ord.orderStatus == 0){
            std::string callerStr = caller().toString();
            
            
            
            DipcAssert(info.getOwnerAddress() == caller().toString());
            

            uint64_t timenow = dipc::timestamp();
            if(ord.endTime > timenow){
                ord.orderStatus = 2;
            }else {
                ord.orderStatus = 3;
            }
        } else {
            return;
        }
        uint64_t lockToken = 0;
        if(ord.orderType == 1){
            lockToken = ord.stockPrice * ord.stockAmount;
        }
        uint64_t currentBalance =  portfolioBalance.get()[_portfolioName];
        
        
        
        

        DipcAssert(currentBalance + lockToken >= currentBalance);
        DipcAssert(ownerTotalToken.get() - lockToken <= ownerTotalToken.get());

        
        (*portfolioBalance)[_portfolioName] = currentBalance + lockToken;
        *ownerTotalToken = ownerTotalToken.get() - lockToken;
        (*portfolioStorge)[_portfolioName] = &info.toJson()[0];
        DIPC_EMIT_EVENT(revocationPortfolio, "orderId", _orderId, "orderInfo", &ord.toJson()[0]);
    }
    
    EXPORT void PortfolioManage::withdrawPortfolio(char* _portfolioName, uint64_t _withdrawBalance){
         if(!userCanWithdraw.get()){
             return;
         }
         uint64_t currentBalance =  portfolioBalance.get()[_portfolioName];
         DipcAssert(currentBalance - _withdrawBalance < currentBalance);
         auto coinBalance = changeUint64ToU256WithChangeRate(currentBalance, changeRate.get());
         (*portfolioBalance)[_portfolioName] = currentBalance - _withdrawBalance;
         callTransfer(caller(), coinBalance);
    }
    
    EXPORT void PortfolioManage::withdrawPool(uint64_t _balance){
        isOwner();
        Address ownerAddr = Address(owner.get()); 
        callTransfer(ownerAddr, _balance);
        *ownerTotalToken = ownerTotalToken.get() - _balance * changeRate.get();
        *totalToken = totalToken.get() - _balance * changeRate.get();
        DIPC_EMIT_EVENT(tokenCount, "ownerTotalToken", ownerTotalToken.get(), "totalToken", totalToken.get());
    }
    
    PAYABLE void PortfolioManage::depositPool(uint64_t _depositValue){
        isOwner();
        
        uint64_t tokenBalance = changeU256ToUint64WithChangeRate(callValue(), changeRate.get()); 
        *ownerTotalToken = ownerTotalToken.get() + tokenBalance;
        *totalToken = totalToken.get() + tokenBalance;
        DIPC_EMIT_EVENT(tokenCount, "ownerTotalToken", ownerTotalToken.get(), "totalToken", totalToken.get());
    }
     
    CONSTANT uint64_t PortfolioManage::queryTotalToken(){
        return totalToken.get();
    }

     
    CONSTANT uint64_t PortfolioManage::queryPortfolioBalance(char* _portfolioName){
        return portfolioBalance.get()[_portfolioName];
    }

    
    CONSTANT bool PortfolioManage::queryPortfolioNameIfUsed(char* _portfolioName){
        if(portfolioStorge.get()[_portfolioName] != ""){
            return true;
        } 
        return false;
    }

    
    CONSTANT uint64_t PortfolioManage::queryChangeRate(){
        return changeRate.get();
    } codetext height #include "PortfolioManage.hpp"

    
    PAYABLE void PortfolioManage::init(){
        *owner = caller().toString();
        *changeRate = 10000;
        *userCanWithdraw = false;
        uint64_t tokenBalance = getTotalBalance();
        
        *ownerTotalToken = tokenBalance;
        *totalToken = ownerTotalToken.get();
        
        
        DIPC_EMIT_EVENT(initEvent, "ownerTotalToken" ,tokenBalance);
    }
    
     
    EXPORT void PortfolioManage::setChangeRate(uint64_t _changeRate){
        isOwner();
        *changeRate = _changeRate;
    }
     
    EXPORT void PortfolioManage::setUserCanWithdraw(bool _canWithdraw){
        u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
isOwner();
        *userCanWithdraw = _canWithdraw;
    }

    
    PAYABLE void PortfolioManage::createPortfolio(char* _portfolioName, char* _portfolioDesc){
        if(portfolioStorge.get()[_portfolioName] != ""){
            DIPC_EMIT_EVENT(ErrEvent, "Current portfolio exist: ", _portfolioName);
            return;
        } 
        std::string callerAddr = caller().toString();
        uint64_t tokenBalance = getTotalBalance();
        
        PortfolioInfo info(_portfolioName, _portfolioDesc, &callerAddr[0]);
        std::string portfolioStr = info.toJson();
        
        
        

        (*portfolioStorge)[_portfolioName] = portfolioStr;
        DipcAssert(totalToken.get() + tokenBalance > totalToken);
        (*portfolioBalance)[_portfolioName] = tokenBalance;
        *totalToken = totalToken.get() + tokenBalance; 
        
        DIPC_EMIT_EVENT(portfolioInfo, _portfolioName, &portfolioStr[0], "portfolioBalance", tokenBalance);
    }

    
    PAYABLE void PortfolioManage::depositPortfolio(char* _portfolioName){
        uint64_t tokenBalance = getTotalBalance();
        
        uint64_t currentBalance = portfolioBalance.get()[_portfolioName];
        uint64_t finalBalance  = currentBalance + tokenBalance;
        DipcAssert(totalToken.get() + tokenBalance > totalToken);
        DipcAssert(finalBalance > currentBalance);
        (*portfolioBalance)[_portfolioName] = finalBalance;
        *totalToken = totalToken.get() + finalBalance; 
        DIPC_EMIT_EVENT(depositPortfolio, "portfolioName", _portfolioName, "portfolioBalance", finalBalance);
    }
    
    PAYABLE void PortfolioManage::createOrder(char* _portfolioName, char* _orderId, uint16_t _orderType, char* _stockCode, uint64_t _stockPrice, uint64_t _stockAmount, uint64_t _endTime){
        uint64_t tokenBalance = getTotalBalance();
        DIPC_EMIT_EVENT(createOrder, "portfolioName", _portfolioName, "OrderInfo", "ignore", "tokenBalance", tokenBalance);
        uint64_t spent = 0;
        if(_orderType == 1){
            spent = _stockPrice * _stockAmount;
            DipcAssert((portfolioBalance.get()[_portfolioName] + tokenBalance) > spent);
        }
        struct Order order{_orderId, _orderType, _stockCode, _stockPrice, _stockAmount, _endTime, 0};
        std::string pInfo = portfolioStorge.get()[_portfolioName];
        
        
        
        if(pInfo == "") {
            DIPC_EMIT_EVENT(ErrEvent, "Current portfolio  doesn't exist: ", _portfolioName);
            return;
        }
        PortfolioInfo info;
        info.parseJson(pInfo);
        if(info.getOrder(_orderId).orderId != ""){
            DIPC_EMIT_EVENT(ErrEvent, "Current order exist: ", _orderId);
            return;
        }
        info.addOrder(order);
        pInfo = info.toJson();

        uint64_t currentBalance = portfolioBalance.get()[_portfolioName] ;
        uint64_t finalBalance = currentBalance + tokenBalance - spent;
        DipcAssert(totalToken.get() + tokenBalance > totalToken);
        
        DipcAssert(ownerTotalToken.get() < ownerTotalToken.get() + spent);
        (*portfolioStorge)[_portfolioName] = &pInfo[0];
        
        
        
        


        (*portfolioBalance)[_portfolioName] = finalBalance;
        *totalToken = totalToken.get() + finalBalance; 
        *ownerTotalToken = ownerTotalToken.get() + spent;
        DIPC_EMIT_EVENT(createOrder, "portfolioName", _portfolioName, "OrderInfo", &order.toJson()[0], "portfolioBalance", finalBalance);
    }

    
    EXPORT void PortfolioManage::dealOrder(char* _portfolioName, char* _orderId){
        u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
isOwner();
        std::string pInfo = portfolioStorge.get()[_portfolioName];
        
        
        PortfolioInfo info;
        info.parseJson(pInfo);
        

        
         Order ord = info.getOrder(_orderId);
         
         
        if(ord.orderId != "" && ord.orderStatus == 0){
            
            uint64_t timenow = dipc::timestamp();
            if(ord.endTime > timenow){
                ord.orderStatus = 1;
            }else {
                ord.orderStatus = 3;
            }
        } else {
          

            return;
        }
        

        uint64_t sellValue = 0;
        if(ord.orderType == 0){
            sellValue = ord.stockAmount * ord.stockPrice;
        }
        uint64_t currentBalance =  portfolioBalance.get()[_portfolioName];
        

        DipcAssert(currentBalance + sellValue >= currentBalance);
        DipcAssert((ownerTotalToken.get() - sellValue) <= ownerTotalToken.get());
        


        (*portfolioBalance)[_portfolioName] = currentBalance + sellValue;
        *ownerTotalToken = ownerTotalToken.get() - sellValue;
        (*portfolioStorge)[_portfolioName] = &info.toJson()[0];
        
        
        
        

        DIPC_EMIT_EVENT(dealPortfolio, "orderId", _orderId, "orderInfo", &ord.toJson()[0]);
    }
    
    EXPORT void PortfolioManage::revocationOrder(char* _portfolioName, char* _orderId){
        std::string pInfo = portfolioStorge.get()[_portfolioName];
        
        
        PortfolioInfo info;
        info.parseJson(pInfo);
        Order ord = info.getOrder(_orderId);
        
        
        if(ord.orderId != "" && ord.orderStatus == 0){
            std::string callerStr = caller().toString();
            
            
            
            DipcAssert(info.getOwnerAddress() == caller().toString());
            

            uint64_t timenow = dipc::timestamp();
            if(ord.endTime > timenow){
                ord.orderStatus = 2;
            }else {
                ord.orderStatus = 3;
            }
        } else {
            return;
        }
        uint64_t lockToken = 0;
        if(ord.orderType == 1){
            lockToken = ord.stockPrice * ord.stockAmount;
        }
        uint64_t currentBalance =  portfolioBalance.get()[_portfolioName];
        
        
        
        

        DipcAssert(currentBalance + lockToken >= currentBalance);
        DipcAssert(ownerTotalToken.get() - lockToken <= ownerTotalToken.get());

        
        (*portfolioBalance)[_portfolioName] = currentBalance + lockToken;
        *ownerTotalToken = ownerTotalToken.get() - lockToken;
        (*portfolioStorge)[_portfolioName] = &info.toJson()[0];
        DIPC_EMIT_EVENT(revocationPortfolio, "orderId", _orderId, "orderInfo", &ord.toJson()[0]);
    }
    
    EXPORT void PortfolioManage::withdrawPortfolio(char* _portfolioName, uint64_t _withdrawBalance){
         if(!userCanWithdraw.get()){
             return;
         }
         uint64_t currentBalance =  portfolioBalance.get()[_portfolioName];
         DipcAssert(currentBalance - _withdrawBalance < currentBalance);
         auto coinBalance = changeUint64ToU256WithChangeRate(currentBalance, changeRate.get());
         (*portfolioBalance)[_portfolioName] = currentBalance - _withdrawBalance;
         callTransfer(caller(), coinBalance);
    }
    
    EXPORT void PortfolioManage::withdrawPool(uint64_t _balance){
        isOwner();
        Address ownerAddr = Address(owner.get()); 
        callTransfer(ownerAddr, _balance);
        *ownerTotalToken = ownerTotalToken.get() - _balance * changeRate.get();
        *totalToken = totalToken.get() - _balance * changeRate.get();
        DIPC_EMIT_EVENT(tokenCount, "ownerTotalToken", ownerTotalToken.get(), "totalToken", totalToken.get());
    }
    
    PAYABLE void PortfolioManage::depositPool(uint64_t _depositValue){
        isOwner();
        
        uint64_t tokenBalance = changeU256ToUint64WithChangeRate(callValue(), changeRate.get()); 
        *ownerTotalToken = ownerTotalToken.get() + tokenBalance;
        *totalToken = totalToken.get() + tokenBalance;
        DIPC_EMIT_EVENT(tokenCount, "ownerTotalToken", ownerTotalToken.get(), "totalToken", totalToken.get());
    }
     
    CONSTANT uint64_t PortfolioManage::queryTotalToken(){
        return totalToken.get();
    }

     
    CONSTANT uint64_t PortfolioManage::queryPortfolioBalance(char* _portfolioName){
        return portfolioBalance.get()[_portfolioName];
    }

    
    CONSTANT bool PortfolioManage::queryPortfolioNameIfUsed(char* _portfolioName){
        if(portfolioStorge.get()[_portfolioName] != ""){
            return true;
        } 
        return false;
    }

    
    CONSTANT uint64_t PortfolioManage::queryChangeRate(){
        return changeRate.get();
    }

2019-12-19_15:14:53.718847: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:427] searchContext  #include "PortfolioManage.hpp"

    
    PAYABLE void PortfolioManage::init(){
        *owner = caller().toString();
        *changeRate = 10000;
        *userCanWithdraw = false;
        uint64_t tokenBalance = getTotalBalance();
        
        *ownerTotalToken = tokenBalance;
        *totalToken = ownerTotalToken.get();
        
        
        DIPC_EMIT_EVENT(initEvent, "ownerTotalToken" ,tokenBalance);
    }
    
     
    EXPORT void PortfolioManage::setChangeRate(uint64_t _changeRate){
        isOwner();
        *changeRate = _changeRate;
    }
     
    EXPORT void PortfolioManage::setUserCanWithdraw(bool _canWithdraw){
        u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
isOwner();
        *userCanWithdraw = _canWithdraw;
    }

    
    PAYABLE void PortfolioManage::createPortfolio(char* _portfolioName, char* _portfolioDesc){
        if(portfolioStorge.get()[_portfolioName] != ""){
            DIPC_EMIT_EVENT(ErrEvent, "Current portfolio exist: ", _portfolioName);
            return;
        } 
        std::string callerAddr = caller().toString();
        uint64_t tokenBalance = getTotalBalance();
        
        PortfolioInfo info(_portfolioName, _portfolioDesc, &callerAddr[0]);
        std::string portfolioStr = info.toJson();
        
        
        

        (*portfolioStorge)[_portfolioName] = portfolioStr;
        DipcAssert(totalToken.get() + tokenBalance > totalToken);
        (*portfolioBalance)[_portfolioName] = tokenBalance;
        *totalToken = totalToken.get() + tokenBalance; 
        
        DIPC_EMIT_EVENT(portfolioInfo, _portfolioName, &portfolioStr[0], "portfolioBalance", tokenBalance);
    }

    
    PAYABLE void PortfolioManage::depositPortfolio(char* _portfolioName){
        uint64_t tokenBalance = getTotalBalance();
        
        uint64_t currentBalance = portfolioBalance.get()[_portfolioName];
        uint64_t finalBalance  = currentBalance + tokenBalance;
        DipcAssert(totalToken.get() + tokenBalance > totalToken);
        DipcAssert(finalBalance > currentBalance);
        (*portfolioBalance)[_portfolioName] = finalBalance;
        *totalToken = totalToken.get() + finalBalance; 
        DIPC_EMIT_EVENT(depositPortfolio, "portfolioName", _portfolioName, "portfolioBalance", finalBalance);
    }
    
    PAYABLE void PortfolioManage::createOrder(char* _portfolioName, char* _orderId, uint16_t _orderType, char* _stockCode, uint64_t _stockPrice, uint64_t _stockAmount, uint64_t _endTime){
        uint64_t tokenBalance = getTotalBalance();
        DIPC_EMIT_EVENT(createOrder, "portfolioName", _portfolioName, "OrderInfo", "ignore", "tokenBalance", tokenBalance);
        uint64_t spent = 0;
        if(_orderType == 1){
            spent = _stockPrice * _stockAmount;
            DipcAssert((portfolioBalance.get()[_portfolioName] + tokenBalance) > spent);
        }
        struct Order order{_orderId, _orderType, _stockCode, _stockPrice, _stockAmount, _endTime, 0};
        std::string pInfo = portfolioStorge.get()[_portfolioName];
        
        
        
        if(pInfo == "") {
            DIPC_EMIT_EVENT(ErrEvent, "Current portfolio  doesn't exist: ", _portfolioName);
            return;
        }
        PortfolioInfo info;
        info.parseJson(pInfo);
        if(info.getOrder(_orderId).orderId != ""){
            DIPC_EMIT_EVENT(ErrEvent, "Current order exist: ", _orderId);
            return;
        }
        info.addOrder(order);
        pInfo = info.toJson();

        uint64_t currentBalance = portfolioBalance.get()[_portfolioName] ;
        uint64_t finalBalance = currentBalance + tokenBalance - spent;
        DipcAssert(totalToken.get() + tokenBalance > totalToken);
        
        DipcAssert(ownerTotalToken.get() < ownerTotalToken.get() + spent);
        (*portfolioStorge)[_portfolioName] = &pInfo[0];
        
        
        
        


        (*portfolioBalance)[_portfolioName] = finalBalance;
        *totalToken = totalToken.get() + finalBalance; 
        *ownerTotalToken = ownerTotalToken.get() + spent;
        DIPC_EMIT_EVENT(createOrder, "portfolioName", _portfolioName, "OrderInfo", &order.toJson()[0], "portfolioBalance", finalBalance);
    }

    
    EXPORT void PortfolioManage::dealOrder(char* _portfolioName, char* _orderId){
        u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
isOwner();
        std::string pInfo = portfolioStorge.get()[_portfolioName];
        
        
        PortfolioInfo info;
        info.parseJson(pInfo);
        

        
         Order ord = info.getOrder(_orderId);
         
         
        if(ord.orderId != "" && ord.orderStatus == 0){
            
            uint64_t timenow = dipc::timestamp();
            if(ord.endTime > timenow){
                ord.orderStatus = 1;
            }else {
                ord.orderStatus = 3;
            }
        } else {
          

            return;
        }
        

        uint64_t sellValue = 0;
        if(ord.orderType == 0){
            sellValue = ord.stockAmount * ord.stockPrice;
        }
        uint64_t currentBalance =  portfolioBalance.get()[_portfolioName];
        

        DipcAssert(currentBalance + sellValue >= currentBalance);
        DipcAssert((ownerTotalToken.get() - sellValue) <= ownerTotalToken.get());
        


        (*portfolioBalance)[_portfolioName] = currentBalance + sellValue;
        *ownerTotalToken = ownerTotalToken.get() - sellValue;
        (*portfolioStorge)[_portfolioName] = &info.toJson()[0];
        
        
        
        

        DIPC_EMIT_EVENT(dealPortfolio, "orderId", _orderId, "orderInfo", &ord.toJson()[0]);
    }
    
    EXPORT void PortfolioManage::revocationOrder(char* _portfolioName, char* _orderId){
        std::string pInfo = portfolioStorge.get()[_portfolioName];
        
        
        PortfolioInfo info;
        info.parseJson(pInfo);
        Order ord = info.getOrder(_orderId);
        
        
        if(ord.orderId != "" && ord.orderStatus == 0){
            std::string callerStr = caller().toString();
            
            
            
            DipcAssert(info.getOwnerAddress() == caller().toString());
            

            uint64_t timenow = dipc::timestamp();
            if(ord.endTime > timenow){
                ord.orderStatus = 2;
            }else {
                ord.orderStatus = 3;
            }
        } else {
            return;
        }
        uint64_t lockToken = 0;
        if(ord.orderType == 1){
            lockToken = ord.stockPrice * ord.stockAmount;
        }
        uint64_t currentBalance =  portfolioBalance.get()[_portfolioName];
        
        
        
        

        DipcAssert(currentBalance + lockToken >= currentBalance);
        DipcAssert(ownerTotalToken.get() - lockToken <= ownerTotalToken.get());

        
        (*portfolioBalance)[_portfolioName] = currentBalance + lockToken;
        *ownerTotalToken = ownerTotalToken.get() - lockToken;
        (*portfolioStorge)[_portfolioName] = &info.toJson()[0];
        DIPC_EMIT_EVENT(revocationPortfolio, "orderId", _orderId, "orderInfo", &ord.toJson()[0]);
    }
    
    EXPORT void PortfolioManage::withdrawPortfolio(char* _portfolioName, uint64_t _withdrawBalance){
         if(!userCanWithdraw.get()){
             return;
         }
         uint64_t currentBalance =  portfolioBalance.get()[_portfolioName];
         DipcAssert(currentBalance - _withdrawBalance < currentBalance);
         auto coinBalance = changeUint64ToU256WithChangeRate(currentBalance, changeRate.get());
         (*portfolioBalance)[_portfolioName] = currentBalance - _withdrawBalance;
         callTransfer(caller(), coinBalance);
    }
    
    EXPORT void PortfolioManage::withdrawPool(uint64_t _balance){
        isOwner();
        Address ownerAddr = Address(owner.get()); 
        callTransfer(ownerAddr, _balance);
        *ownerTotalToken = ownerTotalToken.get() - _balance * changeRate.get();
        *totalToken = totalToken.get() - _balance * changeRate.get();
        DIPC_EMIT_EVENT(tokenCount, "ownerTotalToken", ownerTotalToken.get(), "totalToken", totalToken.get());
    }
    
    PAYABLE void PortfolioManage::depositPool(uint64_t _depositValue){
        isOwner();
        
        uint64_t tokenBalance = changeU256ToUint64WithChangeRate(callValue(), changeRate.get()); 
        *ownerTotalToken = ownerTotalToken.get() + tokenBalance;
        *totalToken = totalToken.get() + tokenBalance;
        DIPC_EMIT_EVENT(tokenCount, "ownerTotalToken", ownerTotalToken.get(), "totalToken", totalToken.get());
    }
     
    CONSTANT uint64_t PortfolioManage::queryTotalToken(){
        return totalToken.get();
    }

     
    CONSTANT uint64_t PortfolioManage::queryPortfolioBalance(char* _portfolioName){
        return portfolioBalance.get()[_portfolioName];
    }

    
    CONSTANT bool PortfolioManage::queryPortfolioNameIfUsed(char* _portfolioName){
        if(portfolioStorge.get()[_portfolioName] != ""){
            return true;
        } 
        return false;
    }

    
    CONSTANT uint64_t PortfolioManage::queryChangeRate(){
        return changeRate.get();
    }

2019-12-19_15:14:53.868216: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:451] log out out  Export :
    
    EXPORT void PortfolioManage::revocationOrder(char* _portfolioName, char* _orderId){
        

2019-12-19_15:14:53.868239: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:457] name : revocationOrder   pos1  0

2019-12-19_15:14:53.868253: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:469] pos2  5635   pos1  5635

2019-12-19_15:14:53.868261: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:500] pos2 after 7119   pos1  5635

2019-12-19_15:14:53.868269: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:509] finalContract  first #include "PortfolioManage.hpp"

    
    PAYABLE void PortfolioManage::init(){
        *owner = caller().toString();
        *changeRate = 10000;
        *userCanWithdraw = false;
        uint64_t tokenBalance = getTotalBalance();
        
        *ownerTotalToken = tokenBalance;
        *totalToken = ownerTotalToken.get();
        
        
        DIPC_EMIT_EVENT(initEvent, "ownerTotalToken" ,tokenBalance);
    }
    
     
    EXPORT void PortfolioManage::setChangeRate(uint64_t _changeRate){
        isOwner();
        *changeRate = _changeRate;
    }
     
    EXPORT void PortfolioManage::setUserCanWithdraw(bool _canWithdraw){
        u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
isOwner();
        *userCanWithdraw = _canWithdraw;
    }

    
    PAYABLE void PortfolioManage::createPortfolio(char* _portfolioName, char* _portfolioDesc){
        if(portfolioStorge.get()[_portfolioName] != ""){
            DIPC_EMIT_EVENT(ErrEvent, "Current portfolio exist: ", _portfolioName);
            return;
        } 
        std::string callerAddr = caller().toString();
        uint64_t tokenBalance = getTotalBalance();
        
        PortfolioInfo info(_portfolioName, _portfolioDesc, &callerAddr[0]);
        std::string portfolioStr = info.toJson();
        
        
        

        (*portfolioStorge)[_portfolioName] = portfolioStr;
        DipcAssert(totalToken.get() + tokenBalance > totalToken);
        (*portfolioBalance)[_portfolioName] = tokenBalance;
        *totalToken = totalToken.get() + tokenBalance; 
        
        DIPC_EMIT_EVENT(portfolioInfo, _portfolioName, &portfolioStr[0], "portfolioBalance", tokenBalance);
    }

    
    PAYABLE void PortfolioManage::depositPortfolio(char* _portfolioName){
        uint64_t tokenBalance = getTotalBalance();
        
        uint64_t currentBalance = portfolioBalance.get()[_portfolioName];
        uint64_t finalBalance  = currentBalance + tokenBalance;
        DipcAssert(totalToken.get() + tokenBalance > totalToken);
        DipcAssert(finalBalance > currentBalance);
        (*portfolioBalance)[_portfolioName] = finalBalance;
        *totalToken = totalToken.get() + finalBalance; 
        DIPC_EMIT_EVENT(depositPortfolio, "portfolioName", _portfolioName, "portfolioBalance", finalBalance);
    }
    
    PAYABLE void PortfolioManage::createOrder(char* _portfolioName, char* _orderId, uint16_t _orderType, char* _stockCode, uint64_t _stockPrice, uint64_t _stockAmount, uint64_t _endTime){
        uint64_t tokenBalance = getTotalBalance();
        DIPC_EMIT_EVENT(createOrder, "portfolioName", _portfolioName, "OrderInfo", "ignore", "tokenBalance", tokenBalance);
        uint64_t spent = 0;
        if(_orderType == 1){
            spent = _stockPrice * _stockAmount;
            DipcAssert((portfolioBalance.get()[_portfolioName] + tokenBalance) > spent);
        }
        struct Order order{_orderId, _orderType, _stockCode, _stockPrice, _stockAmount, _endTime, 0};
        std::string pInfo = portfolioStorge.get()[_portfolioName];
        
        
        
        if(pInfo == "") {
            DIPC_EMIT_EVENT(ErrEvent, "Current portfolio  doesn't exist: ", _portfolioName);
            return;
        }
        PortfolioInfo info;
        info.parseJson(pInfo);
        if(info.getOrder(_orderId).orderId != ""){
            DIPC_EMIT_EVENT(ErrEvent, "Current order exist: ", _orderId);
            return;
        }
        info.addOrder(order);
        pInfo = info.toJson();

        uint64_t currentBalance = portfolioBalance.get()[_portfolioName] ;
        uint64_t finalBalance = currentBalance + tokenBalance - spent;
        DipcAssert(totalToken.get() + tokenBalance > totalToken);
        
        DipcAssert(ownerTotalToken.get() < ownerTotalToken.get() + spent);
        (*portfolioStorge)[_portfolioName] = &pInfo[0];
        
        
        
        


        (*portfolioBalance)[_portfolioName] = finalBalance;
        *totalToken = totalToken.get() + finalBalance; 
        *ownerTotalToken = ownerTotalToken.get() + spent;
        DIPC_EMIT_EVENT(createOrder, "portfolioName", _portfolioName, "OrderInfo", &order.toJson()[0], "portfolioBalance", finalBalance);
    }

    
    EXPORT void PortfolioManage::dealOrder(char* _portfolioName, char* _orderId){
        u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
isOwner();
        std::string pInfo = portfolioStorge.get()[_portfolioName];
        
        
        PortfolioInfo info;
        info.parseJson(pInfo);
        

        
         Order ord = info.getOrder(_orderId);
         
         
        if(ord.orderId != "" && ord.orderStatus == 0){
            
            uint64_t timenow = dipc::timestamp();
            if(ord.endTime > timenow){
                ord.orderStatus = 1;
            }else {
                ord.orderStatus = 3;
            }
        } else {
          

            return;
        }
        

        uint64_t sellValue = 0;
        if(ord.orderType == 0){
            sellValue = ord.stockAmount * ord.stockPrice;
        }
        uint64_t currentBalance =  portfolioBalance.get()[_portfolioName];
        

        DipcAssert(currentBalance + sellValue >= currentBalance);
        DipcAssert((ownerTotalToken.get() - sellValue) <= ownerTotalToken.get());
        


        (*portfolioBalance)[_portfolioName] = currentBalance + sellValue;
        *ownerTotalToken = ownerTotalToken.get() - sellValue;
        (*portfolioStorge)[_portfolioName] = &info.toJson()[0];
        
        
        
        

        DIPC_EMIT_EVENT(dealPortfolio, "orderId", _orderId, "orderInfo", &ord.toJson()[0]);
    }

2019-12-19_15:14:53.868276: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:510] codetext  first #include "PortfolioManage.hpp"

    
    PAYABLE void PortfolioManage::init(){
        *owner = caller().toString();
        *changeRate = 10000;
        *userCanWithdraw = false;
        uint64_t tokenBalance = getTotalBalance();
        
        *ownerTotalToken = tokenBalance;
        *totalToken = ownerTotalToken.get();
        
        
        DIPC_EMIT_EVENT(initEvent, "ownerTotalToken" ,tokenBalance);
    }
    
     
    EXPORT void PortfolioManage::setChangeRate(uint64_t _changeRate){
        isOwner();
        *changeRate = _changeRate;
    }
     
    EXPORT void PortfolioManage::setUserCanWithdraw(bool _canWithdraw){
        u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
isOwner();
        *userCanWithdraw = _canWithdraw;
    }

    
    PAYABLE void PortfolioManage::createPortfolio(char* _portfolioName, char* _portfolioDesc){
        if(portfolioStorge.get()[_portfolioName] != ""){
            DIPC_EMIT_EVENT(ErrEvent, "Current portfolio exist: ", _portfolioName);
            return;
        } 
        std::string callerAddr = caller().toString();
        uint64_t tokenBalance = getTotalBalance();
        
        PortfolioInfo info(_portfolioName, _portfolioDesc, &callerAddr[0]);
        std::string portfolioStr = info.toJson();
        
        
        

        (*portfolioStorge)[_portfolioName] = portfolioStr;
        DipcAssert(totalToken.get() + tokenBalance > totalToken);
        (*portfolioBalance)[_portfolioName] = tokenBalance;
        *totalToken = totalToken.get() + tokenBalance; 
        
        DIPC_EMIT_EVENT(portfolioInfo, _portfolioName, &portfolioStr[0], "portfolioBalance", tokenBalance);
    }

    
    PAYABLE void PortfolioManage::depositPortfolio(char* _portfolioName){
        uint64_t tokenBalance = getTotalBalance();
        
        uint64_t currentBalance = portfolioBalance.get()[_portfolioName];
        uint64_t finalBalance  = currentBalance + tokenBalance;
        DipcAssert(totalToken.get() + tokenBalance > totalToken);
        DipcAssert(finalBalance > currentBalance);
        (*portfolioBalance)[_portfolioName] = finalBalance;
        *totalToken = totalToken.get() + finalBalance; 
        DIPC_EMIT_EVENT(depositPortfolio, "portfolioName", _portfolioName, "portfolioBalance", finalBalance);
    }
    
    PAYABLE void PortfolioManage::createOrder(char* _portfolioName, char* _orderId, uint16_t _orderType, char* _stockCode, uint64_t _stockPrice, uint64_t _stockAmount, uint64_t _endTime){
        uint64_t tokenBalance = getTotalBalance();
        DIPC_EMIT_EVENT(createOrder, "portfolioName", _portfolioName, "OrderInfo", "ignore", "tokenBalance", tokenBalance);
        uint64_t spent = 0;
        if(_orderType == 1){
            spent = _stockPrice * _stockAmount;
            DipcAssert((portfolioBalance.get()[_portfolioName] + tokenBalance) > spent);
        }
        struct Order order{_orderId, _orderType, _stockCode, _stockPrice, _stockAmount, _endTime, 0};
        std::string pInfo = portfolioStorge.get()[_portfolioName];
        
        
        
        if(pInfo == "") {
            DIPC_EMIT_EVENT(ErrEvent, "Current portfolio  doesn't exist: ", _portfolioName);
            return;
        }
        PortfolioInfo info;
        info.parseJson(pInfo);
        if(info.getOrder(_orderId).orderId != ""){
            DIPC_EMIT_EVENT(ErrEvent, "Current order exist: ", _orderId);
            return;
        }
        info.addOrder(order);
        pInfo = info.toJson();

        uint64_t currentBalance = portfolioBalance.get()[_portfolioName] ;
        uint64_t finalBalance = currentBalance + tokenBalance - spent;
        DipcAssert(totalToken.get() + tokenBalance > totalToken);
        
        DipcAssert(ownerTotalToken.get() < ownerTotalToken.get() + spent);
        (*portfolioStorge)[_portfolioName] = &pInfo[0];
        
        
        
        


        (*portfolioBalance)[_portfolioName] = finalBalance;
        *totalToken = totalToken.get() + finalBalance; 
        *ownerTotalToken = ownerTotalToken.get() + spent;
        DIPC_EMIT_EVENT(createOrder, "portfolioName", _portfolioName, "OrderInfo", &order.toJson()[0], "portfolioBalance", finalBalance);
    }

    
    EXPORT void PortfolioManage::dealOrder(char* _portfolioName, char* _orderId){
        u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
isOwner();
        std::string pInfo = portfolioStorge.get()[_portfolioName];
        
        
        PortfolioInfo info;
        info.parseJson(pInfo);
        

        
         Order ord = info.getOrder(_orderId);
         
         
        if(ord.orderId != "" && ord.orderStatus == 0){
            
            uint64_t timenow = dipc::timestamp();
            if(ord.endTime > timenow){
                ord.orderStatus = 1;
            }else {
                ord.orderStatus = 3;
            }
        } else {
          

            return;
        }
        

        uint64_t sellValue = 0;
        if(ord.orderType == 0){
            sellValue = ord.stockAmount * ord.stockPrice;
        }
        uint64_t currentBalance =  portfolioBalance.get()[_portfolioName];
        

        DipcAssert(currentBalance + sellValue >= currentBalance);
        DipcAssert((ownerTotalToken.get() - sellValue) <= ownerTotalToken.get());
        


        (*portfolioBalance)[_portfolioName] = currentBalance + sellValue;
        *ownerTotalToken = ownerTotalToken.get() - sellValue;
        (*portfolioStorge)[_portfolioName] = &info.toJson()[0];
        
        
        
        

        DIPC_EMIT_EVENT(dealPortfolio, "orderId", _orderId, "orderInfo", &ord.toJson()[0]);
    }
    
    EXPORT void PortfolioManage::revocationOrder(char* _portfolioName, char* _orderId){
        std::string pInfo = portfolioStorge.get()[_portfolioName];
        
        
        PortfolioInfo info;
        info.parseJson(pInfo);
        Order ord = info.getOrder(_orderId);
        
        
        if(ord.orderId != "" && ord.orderStatus == 0){
            std::string callerStr = caller().toString();
            
            
            
            DipcAssert(info.getOwnerAddress() == caller().toString());
            

            uint64_t timenow = dipc::timestamp();
            if(ord.endTime > timenow){
                ord.orderStatus = 2;
            }else {
                ord.orderStatus = 3;
            }
        } else {
            return;
        }
        uint64_t lockToken = 0;
        if(ord.orderType == 1){
            lockToken = ord.stockPrice * ord.stockAmount;
        }
        uint64_t currentBalance =  portfolioBalance.get()[_portfolioName];
        
        
        
        

        DipcAssert(currentBalance + lockToken >= currentBalance);
        DipcAssert(ownerTotalToken.get() - lockToken <= ownerTotalToken.get());

        
        (*portfolioBalance)[_portfolioName] = currentBalance + lockToken;
        *ownerTotalToken = ownerTotalToken.get() - lockToken;
        (*portfolioStorge)[_portfolioName] = &info.toJson()[0];
        DIPC_EMIT_EVENT(revocationPortfolio, "orderId", _orderId, "orderInfo", &ord.toJson()[0]);
    }
    
    EXPORT void PortfolioManage::withdrawPortfolio(char* _portfolioName, uint64_t _withdrawBalance){
         if(!userCanWithdraw.get()){
             return;
         }
         uint64_t currentBalance =  portfolioBalance.get()[_portfolioName];
         DipcAssert(currentBalance - _withdrawBalance < currentBalance);
         auto coinBalance = changeUint64ToU256WithChangeRate(currentBalance, changeRate.get());
         (*portfolioBalance)[_portfolioName] = currentBalance - _withdrawBalance;
         callTransfer(caller(), coinBalance);
    }
    
    EXPORT void PortfolioManage::withdrawPool(uint64_t _balance){
        isOwner();
        Address ownerAddr = Address(owner.get()); 
        callTransfer(ownerAddr, _balance);
        *ownerTotalToken = ownerTotalToken.get() - _balance * changeRate.get();
        *totalToken = totalToken.get() - _balance * changeRate.get();
        DIPC_EMIT_EVENT(tokenCount, "ownerTotalToken", ownerTotalToken.get(), "totalToken", totalToken.get());
    }
    
    PAYABLE void PortfolioManage::depositPool(uint64_t _depositValue){
        isOwner();
        
        uint64_t tokenBalance = changeU256ToUint64WithChangeRate(callValue(), changeRate.get()); 
        *ownerTotalToken = ownerTotalToken.get() + tokenBalance;
        *totalToken = totalToken.get() + tokenBalance;
        DIPC_EMIT_EVENT(tokenCount, "ownerTotalToken", ownerTotalToken.get(), "totalToken", totalToken.get());
    }
     
    CONSTANT uint64_t PortfolioManage::queryTotalToken(){
        return totalToken.get();
    }

     
    CONSTANT uint64_t PortfolioManage::queryPortfolioBalance(char* _portfolioName){
        return portfolioBalance.get()[_portfolioName];
    }

    
    CONSTANT bool PortfolioManage::queryPortfolioNameIfUsed(char* _portfolioName){
        if(portfolioStorge.get()[_portfolioName] != ""){
            return true;
        } 
        return false;
    }

    
    CONSTANT uint64_t PortfolioManage::queryChangeRate(){
        return changeRate.get();
    }

2019-12-19_15:14:53.868284: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:513] s  first 
    
    EXPORT void PortfolioManage::revocationOrder(char* _portfolioName, char* _orderId){
        std::string pInfo = portfolioStorge.get()[_portfolioName];
        
        
        PortfolioInfo info;
        info.parseJson(pInfo);
        Order ord = info.getOrder(_orderId);
        
        
        if(ord.orderId != "" && ord.orderStatus == 0){
            std::string callerStr = caller().toString();
            
            
            
            DipcAssert(info.getOwnerAddress() == caller().toString());
            

            uint64_t timenow = dipc::timestamp();
            if(ord.endTime > timenow){
                ord.orderStatus = 2;
            }else {
                ord.orderStatus = 3;
            }
        } else {
            return;
        }
        uint64_t lockToken = 0;
        if(ord.orderType == 1){
            lockToken = ord.stockPrice * ord.stockAmount;
        }
        uint64_t currentBalance =  portfolioBalance.get()[_portfolioName];
        
        
        
        

        DipcAssert(currentBalance + lockToken >= currentBalance);
        DipcAssert(ownerTotalToken.get() - lockToken <= ownerTotalToken.get());

        
        (*portfolioBalance)[_portfolioName] = currentBalance + lockToken;
        *ownerTotalToken = ownerTotalToken.get() - lockToken;
        (*portfolioStorge)[_portfolioName] = &info.toJson()[0];
        DIPC_EMIT_EVENT(revocationPortfolio, "orderId", _orderId, "orderInfo", &ord.toJson()[0]);
    }

2019-12-19_15:14:53.868293: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:593] calledFunc temp export: 
    
    EXPORT void PortfolioManage::revocationOrder(char* _portfolioName, char* _orderId){
        u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
std::string pInfo = portfolioStorge.get()[_portfolioName];
        
        
        PortfolioInfo info;
        info.parseJson(pInfo);
        Order ord = info.getOrder(_orderId);
        
        
        if(ord.orderId != "" && ord.orderStatus == 0){
            std::string callerStr = caller().toString();
            
            
            
            DipcAssert(info.getOwnerAddress() == caller().toString());
            

            uint64_t timenow = dipc::timestamp();
            if(ord.endTime > timenow){
                ord.orderStatus = 2;
            }else {
                ord.orderStatus = 3;
            }
        } else {
            return;
        }
        uint64_t lockToken = 0;
        if(ord.orderType == 1){
            lockToken = ord.stockPrice * ord.stockAmount;
        }
        uint64_t currentBalance =  portfolioBalance.get()[_portfolioName];
        
        
        
        

        DipcAssert(currentBalance + lockToken >= currentBalance);
        DipcAssert(ownerTotalToken.get() - lockToken <= ownerTotalToken.get());

        
        (*portfolioBalance)[_portfolioName] = currentBalance + lockToken;
        *ownerTotalToken = ownerTotalToken.get() - lockToken;
        (*portfolioStorge)[_portfolioName] = &info.toJson()[0];
        DIPC_EMIT_EVENT(revocationPortfolio, "orderId", _orderId, "orderInfo", &ord.toJson()[0]);
    }

2019-12-19_15:14:53.868300: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:599] search func : 
    
    EXPORT void PortfolioManage::revocationOrder(char* _portfolioName, char* _orderId){
        u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
std::string pInfo = portfolioStorge.get()[_portfolioName];
        
        
        PortfolioInfo info;
        info.parseJson(pInfo);
        Order ord = info.getOrder(_orderId);
        
        
        if(ord.orderId != "" && ord.orderStatus == 0){
            std::string callerStr = caller().toString();
            
            
            
            DipcAssert(info.getOwnerAddress() == caller().toString());
            

            uint64_t timenow = dipc::timestamp();
            if(ord.endTime > timenow){
                ord.orderStatus = 2;
            }else {
                ord.orderStatus = 3;
            }
        } else {
            return;
        }
        uint64_t lockToken = 0;
        if(ord.orderType == 1){
            lockToken = ord.stockPrice * ord.stockAmount;
        }
        uint64_t currentBalance =  portfolioBalance.get()[_portfolioName];
        
        
        
        

        DipcAssert(currentBalance + lockToken >= currentBalance);
        DipcAssert(ownerTotalToken.get() - lockToken <= ownerTotalToken.get());

        
        (*portfolioBalance)[_portfolioName] = currentBalance + lockToken;
        *ownerTotalToken = ownerTotalToken.get() - lockToken;
        (*portfolioStorge)[_portfolioName] = &info.toJson()[0];
        DIPC_EMIT_EVENT(revocationPortfolio, "orderId", _orderId, "orderInfo", &ord.toJson()[0]);
    }
2019-12-19_15:14:53.868308: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:424] finalContract  this height  #include "PortfolioManage.hpp"

    
    PAYABLE void PortfolioManage::init(){
        *owner = caller().toString();
        *changeRate = 10000;
        *userCanWithdraw = false;
        uint64_t tokenBalance = getTotalBalance();
        
        *ownerTotalToken = tokenBalance;
        *totalToken = ownerTotalToken.get();
        
        
        DIPC_EMIT_EVENT(initEvent, "ownerTotalToken" ,tokenBalance);
    }
    
     
    EXPORT void PortfolioManage::setChangeRate(uint64_t _changeRate){
        isOwner();
        *changeRate = _changeRate;
    }
     
    EXPORT void PortfolioManage::setUserCanWithdraw(bool _canWithdraw){
        u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
isOwner();
        *userCanWithdraw = _canWithdraw;
    }

    
    PAYABLE void PortfolioManage::createPortfolio(char* _portfolioName, char* _portfolioDesc){
        if(portfolioStorge.get()[_portfolioName] != ""){
            DIPC_EMIT_EVENT(ErrEvent, "Current portfolio exist: ", _portfolioName);
            return;
        } 
        std::string callerAddr = caller().toString();
        uint64_t tokenBalance = getTotalBalance();
        
        PortfolioInfo info(_portfolioName, _portfolioDesc, &callerAddr[0]);
        std::string portfolioStr = info.toJson();
        
        
        

        (*portfolioStorge)[_portfolioName] = portfolioStr;
        DipcAssert(totalToken.get() + tokenBalance > totalToken);
        (*portfolioBalance)[_portfolioName] = tokenBalance;
        *totalToken = totalToken.get() + tokenBalance; 
        
        DIPC_EMIT_EVENT(portfolioInfo, _portfolioName, &portfolioStr[0], "portfolioBalance", tokenBalance);
    }

    
    PAYABLE void PortfolioManage::depositPortfolio(char* _portfolioName){
        uint64_t tokenBalance = getTotalBalance();
        
        uint64_t currentBalance = portfolioBalance.get()[_portfolioName];
        uint64_t finalBalance  = currentBalance + tokenBalance;
        DipcAssert(totalToken.get() + tokenBalance > totalToken);
        DipcAssert(finalBalance > currentBalance);
        (*portfolioBalance)[_portfolioName] = finalBalance;
        *totalToken = totalToken.get() + finalBalance; 
        DIPC_EMIT_EVENT(depositPortfolio, "portfolioName", _portfolioName, "portfolioBalance", finalBalance);
    }
    
    PAYABLE void PortfolioManage::createOrder(char* _portfolioName, char* _orderId, uint16_t _orderType, char* _stockCode, uint64_t _stockPrice, uint64_t _stockAmount, uint64_t _endTime){
        uint64_t tokenBalance = getTotalBalance();
        DIPC_EMIT_EVENT(createOrder, "portfolioName", _portfolioName, "OrderInfo", "ignore", "tokenBalance", tokenBalance);
        uint64_t spent = 0;
        if(_orderType == 1){
            spent = _stockPrice * _stockAmount;
            DipcAssert((portfolioBalance.get()[_portfolioName] + tokenBalance) > spent);
        }
        struct Order order{_orderId, _orderType, _stockCode, _stockPrice, _stockAmount, _endTime, 0};
        std::string pInfo = portfolioStorge.get()[_portfolioName];
        
        
        
        if(pInfo == "") {
            DIPC_EMIT_EVENT(ErrEvent, "Current portfolio  doesn't exist: ", _portfolioName);
            return;
        }
        PortfolioInfo info;
        info.parseJson(pInfo);
        if(info.getOrder(_orderId).orderId != ""){
            DIPC_EMIT_EVENT(ErrEvent, "Current order exist: ", _orderId);
            return;
        }
        info.addOrder(order);
        pInfo = info.toJson();

        uint64_t currentBalance = portfolioBalance.get()[_portfolioName] ;
        uint64_t finalBalance = currentBalance + tokenBalance - spent;
        DipcAssert(totalToken.get() + tokenBalance > totalToken);
        
        DipcAssert(ownerTotalToken.get() < ownerTotalToken.get() + spent);
        (*portfolioStorge)[_portfolioName] = &pInfo[0];
        
        
        
        


        (*portfolioBalance)[_portfolioName] = finalBalance;
        *totalToken = totalToken.get() + finalBalance; 
        *ownerTotalToken = ownerTotalToken.get() + spent;
        DIPC_EMIT_EVENT(createOrder, "portfolioName", _portfolioName, "OrderInfo", &order.toJson()[0], "portfolioBalance", finalBalance);
    }

    
    EXPORT void PortfolioManage::dealOrder(char* _portfolioName, char* _orderId){
        u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
isOwner();
        std::string pInfo = portfolioStorge.get()[_portfolioName];
        
        
        PortfolioInfo info;
        info.parseJson(pInfo);
        

        
         Order ord = info.getOrder(_orderId);
         
         
        if(ord.orderId != "" && ord.orderStatus == 0){
            
            uint64_t timenow = dipc::timestamp();
            if(ord.endTime > timenow){
                ord.orderStatus = 1;
            }else {
                ord.orderStatus = 3;
            }
        } else {
          

            return;
        }
        

        uint64_t sellValue = 0;
        if(ord.orderType == 0){
            sellValue = ord.stockAmount * ord.stockPrice;
        }
        uint64_t currentBalance =  portfolioBalance.get()[_portfolioName];
        

        DipcAssert(currentBalance + sellValue >= currentBalance);
        DipcAssert((ownerTotalToken.get() - sellValue) <= ownerTotalToken.get());
        


        (*portfolioBalance)[_portfolioName] = currentBalance + sellValue;
        *ownerTotalToken = ownerTotalToken.get() - sellValue;
        (*portfolioStorge)[_portfolioName] = &info.toJson()[0];
        
        
        
        

        DIPC_EMIT_EVENT(dealPortfolio, "orderId", _orderId, "orderInfo", &ord.toJson()[0]);
    }
    
    EXPORT void PortfolioManage::revocationOrder(char* _portfolioName, char* _orderId){
        u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
std::string pInfo = portfolioStorge.get()[_portfolioName];
        
        
        PortfolioInfo info;
        info.parseJson(pInfo);
        Order ord = info.getOrder(_orderId);
        
        
        if(ord.orderId != "" && ord.orderStatus == 0){
            std::string callerStr = caller().toString();
            
            
            
            DipcAssert(info.getOwnerAddress() == caller().toString());
            

            uint64_t timenow = dipc::timestamp();
            if(ord.endTime > timenow){
                ord.orderStatus = 2;
            }else {
                ord.orderStatus = 3;
            }
        } else {
            return;
        }
        uint64_t lockToken = 0;
        if(ord.orderType == 1){
            lockToken = ord.stockPrice * ord.stockAmount;
        }
        uint64_t currentBalance =  portfolioBalance.get()[_portfolioName];
        
        
        
        

        DipcAssert(currentBalance + lockToken >= currentBalance);
        DipcAssert(ownerTotalToken.get() - lockToken <= ownerTotalToken.get());

        
        (*portfolioBalance)[_portfolioName] = currentBalance + lockToken;
        *ownerTotalToken = ownerTotalToken.get() - lockToken;
        (*portfolioStorge)[_portfolioName] = &info.toJson()[0];
        DIPC_EMIT_EVENT(revocationPortfolio, "orderId", _orderId, "orderInfo", &ord.toJson()[0]);
    } codetext height #include "PortfolioManage.hpp"

    
    PAYABLE void PortfolioManage::init(){
        *owner = caller().toString();
        *changeRate = 10000;
        *userCanWithdraw = false;
        uint64_t tokenBalance = getTotalBalance();
        
        *ownerTotalToken = tokenBalance;
        *totalToken = ownerTotalToken.get();
        
        
        DIPC_EMIT_EVENT(initEvent, "ownerTotalToken" ,tokenBalance);
    }
    
     
    EXPORT void PortfolioManage::setChangeRate(uint64_t _changeRate){
        isOwner();
        *changeRate = _changeRate;
    }
     
    EXPORT void PortfolioManage::setUserCanWithdraw(bool _canWithdraw){
        u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
isOwner();
        *userCanWithdraw = _canWithdraw;
    }

    
    PAYABLE void PortfolioManage::createPortfolio(char* _portfolioName, char* _portfolioDesc){
        if(portfolioStorge.get()[_portfolioName] != ""){
            DIPC_EMIT_EVENT(ErrEvent, "Current portfolio exist: ", _portfolioName);
            return;
        } 
        std::string callerAddr = caller().toString();
        uint64_t tokenBalance = getTotalBalance();
        
        PortfolioInfo info(_portfolioName, _portfolioDesc, &callerAddr[0]);
        std::string portfolioStr = info.toJson();
        
        
        

        (*portfolioStorge)[_portfolioName] = portfolioStr;
        DipcAssert(totalToken.get() + tokenBalance > totalToken);
        (*portfolioBalance)[_portfolioName] = tokenBalance;
        *totalToken = totalToken.get() + tokenBalance; 
        
        DIPC_EMIT_EVENT(portfolioInfo, _portfolioName, &portfolioStr[0], "portfolioBalance", tokenBalance);
    }

    
    PAYABLE void PortfolioManage::depositPortfolio(char* _portfolioName){
        uint64_t tokenBalance = getTotalBalance();
        
        uint64_t currentBalance = portfolioBalance.get()[_portfolioName];
        uint64_t finalBalance  = currentBalance + tokenBalance;
        DipcAssert(totalToken.get() + tokenBalance > totalToken);
        DipcAssert(finalBalance > currentBalance);
        (*portfolioBalance)[_portfolioName] = finalBalance;
        *totalToken = totalToken.get() + finalBalance; 
        DIPC_EMIT_EVENT(depositPortfolio, "portfolioName", _portfolioName, "portfolioBalance", finalBalance);
    }
    
    PAYABLE void PortfolioManage::createOrder(char* _portfolioName, char* _orderId, uint16_t _orderType, char* _stockCode, uint64_t _stockPrice, uint64_t _stockAmount, uint64_t _endTime){
        uint64_t tokenBalance = getTotalBalance();
        DIPC_EMIT_EVENT(createOrder, "portfolioName", _portfolioName, "OrderInfo", "ignore", "tokenBalance", tokenBalance);
        uint64_t spent = 0;
        if(_orderType == 1){
            spent = _stockPrice * _stockAmount;
            DipcAssert((portfolioBalance.get()[_portfolioName] + tokenBalance) > spent);
        }
        struct Order order{_orderId, _orderType, _stockCode, _stockPrice, _stockAmount, _endTime, 0};
        std::string pInfo = portfolioStorge.get()[_portfolioName];
        
        
        
        if(pInfo == "") {
            DIPC_EMIT_EVENT(ErrEvent, "Current portfolio  doesn't exist: ", _portfolioName);
            return;
        }
        PortfolioInfo info;
        info.parseJson(pInfo);
        if(info.getOrder(_orderId).orderId != ""){
            DIPC_EMIT_EVENT(ErrEvent, "Current order exist: ", _orderId);
            return;
        }
        info.addOrder(order);
        pInfo = info.toJson();

        uint64_t currentBalance = portfolioBalance.get()[_portfolioName] ;
        uint64_t finalBalance = currentBalance + tokenBalance - spent;
        DipcAssert(totalToken.get() + tokenBalance > totalToken);
        
        DipcAssert(ownerTotalToken.get() < ownerTotalToken.get() + spent);
        (*portfolioStorge)[_portfolioName] = &pInfo[0];
        
        
        
        


        (*portfolioBalance)[_portfolioName] = finalBalance;
        *totalToken = totalToken.get() + finalBalance; 
        *ownerTotalToken = ownerTotalToken.get() + spent;
        DIPC_EMIT_EVENT(createOrder, "portfolioName", _portfolioName, "OrderInfo", &order.toJson()[0], "portfolioBalance", finalBalance);
    }

    
    EXPORT void PortfolioManage::dealOrder(char* _portfolioName, char* _orderId){
        u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
isOwner();
        std::string pInfo = portfolioStorge.get()[_portfolioName];
        
        
        PortfolioInfo info;
        info.parseJson(pInfo);
        

        
         Order ord = info.getOrder(_orderId);
         
         
        if(ord.orderId != "" && ord.orderStatus == 0){
            
            uint64_t timenow = dipc::timestamp();
            if(ord.endTime > timenow){
                ord.orderStatus = 1;
            }else {
                ord.orderStatus = 3;
            }
        } else {
          

            return;
        }
        

        uint64_t sellValue = 0;
        if(ord.orderType == 0){
            sellValue = ord.stockAmount * ord.stockPrice;
        }
        uint64_t currentBalance =  portfolioBalance.get()[_portfolioName];
        

        DipcAssert(currentBalance + sellValue >= currentBalance);
        DipcAssert((ownerTotalToken.get() - sellValue) <= ownerTotalToken.get());
        


        (*portfolioBalance)[_portfolioName] = currentBalance + sellValue;
        *ownerTotalToken = ownerTotalToken.get() - sellValue;
        (*portfolioStorge)[_portfolioName] = &info.toJson()[0];
        
        
        
        

        DIPC_EMIT_EVENT(dealPortfolio, "orderId", _orderId, "orderInfo", &ord.toJson()[0]);
    }
    
    EXPORT void PortfolioManage::revocationOrder(char* _portfolioName, char* _orderId){
        std::string pInfo = portfolioStorge.get()[_portfolioName];
        
        
        PortfolioInfo info;
        info.parseJson(pInfo);
        Order ord = info.getOrder(_orderId);
        
        
        if(ord.orderId != "" && ord.orderStatus == 0){
            std::string callerStr = caller().toString();
            
            
            
            DipcAssert(info.getOwnerAddress() == caller().toString());
            

            uint64_t timenow = dipc::timestamp();
            if(ord.endTime > timenow){
                ord.orderStatus = 2;
            }else {
                ord.orderStatus = 3;
            }
        } else {
            return;
        }
        uint64_t lockToken = 0;
        if(ord.orderType == 1){
            lockToken = ord.stockPrice * ord.stockAmount;
        }
        uint64_t currentBalance =  portfolioBalance.get()[_portfolioName];
        
        
        
        

        DipcAssert(currentBalance + lockToken >= currentBalance);
        DipcAssert(ownerTotalToken.get() - lockToken <= ownerTotalToken.get());

        
        (*portfolioBalance)[_portfolioName] = currentBalance + lockToken;
        *ownerTotalToken = ownerTotalToken.get() - lockToken;
        (*portfolioStorge)[_portfolioName] = &info.toJson()[0];
        DIPC_EMIT_EVENT(revocationPortfolio, "orderId", _orderId, "orderInfo", &ord.toJson()[0]);
    }
    
    EXPORT void PortfolioManage::withdrawPortfolio(char* _portfolioName, uint64_t _withdrawBalance){
         if(!userCanWithdraw.get()){
             return;
         }
         uint64_t currentBalance =  portfolioBalance.get()[_portfolioName];
         DipcAssert(currentBalance - _withdrawBalance < currentBalance);
         auto coinBalance = changeUint64ToU256WithChangeRate(currentBalance, changeRate.get());
         (*portfolioBalance)[_portfolioName] = currentBalance - _withdrawBalance;
         callTransfer(caller(), coinBalance);
    }
    
    EXPORT void PortfolioManage::withdrawPool(uint64_t _balance){
        isOwner();
        Address ownerAddr = Address(owner.get()); 
        callTransfer(ownerAddr, _balance);
        *ownerTotalToken = ownerTotalToken.get() - _balance * changeRate.get();
        *totalToken = totalToken.get() - _balance * changeRate.get();
        DIPC_EMIT_EVENT(tokenCount, "ownerTotalToken", ownerTotalToken.get(), "totalToken", totalToken.get());
    }
    
    PAYABLE void PortfolioManage::depositPool(uint64_t _depositValue){
        isOwner();
        
        uint64_t tokenBalance = changeU256ToUint64WithChangeRate(callValue(), changeRate.get()); 
        *ownerTotalToken = ownerTotalToken.get() + tokenBalance;
        *totalToken = totalToken.get() + tokenBalance;
        DIPC_EMIT_EVENT(tokenCount, "ownerTotalToken", ownerTotalToken.get(), "totalToken", totalToken.get());
    }
     
    CONSTANT uint64_t PortfolioManage::queryTotalToken(){
        return totalToken.get();
    }

     
    CONSTANT uint64_t PortfolioManage::queryPortfolioBalance(char* _portfolioName){
        return portfolioBalance.get()[_portfolioName];
    }

    
    CONSTANT bool PortfolioManage::queryPortfolioNameIfUsed(char* _portfolioName){
        if(portfolioStorge.get()[_portfolioName] != ""){
            return true;
        } 
        return false;
    }

    
    CONSTANT uint64_t PortfolioManage::queryChangeRate(){
        return changeRate.get();
    }

2019-12-19_15:14:53.868383: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:427] searchContext  
    
    EXPORT void PortfolioManage::withdrawPortfolio(char* _portfolioName, uint64_t _withdrawBalance){
         if(!userCanWithdraw.get()){
             return;
         }
         uint64_t currentBalance =  portfolioBalance.get()[_portfolioName];
         DipcAssert(currentBalance - _withdrawBalance < currentBalance);
         auto coinBalance = changeUint64ToU256WithChangeRate(currentBalance, changeRate.get());
         (*portfolioBalance)[_portfolioName] = currentBalance - _withdrawBalance;
         callTransfer(caller(), coinBalance);
    }
    
    EXPORT void PortfolioManage::withdrawPool(uint64_t _balance){
        isOwner();
        Address ownerAddr = Address(owner.get()); 
        callTransfer(ownerAddr, _balance);
        *ownerTotalToken = ownerTotalToken.get() - _balance * changeRate.get();
        *totalToken = totalToken.get() - _balance * changeRate.get();
        DIPC_EMIT_EVENT(tokenCount, "ownerTotalToken", ownerTotalToken.get(), "totalToken", totalToken.get());
    }
    
    PAYABLE void PortfolioManage::depositPool(uint64_t _depositValue){
        isOwner();
        
        uint64_t tokenBalance = changeU256ToUint64WithChangeRate(callValue(), changeRate.get()); 
        *ownerTotalToken = ownerTotalToken.get() + tokenBalance;
        *totalToken = totalToken.get() + tokenBalance;
        DIPC_EMIT_EVENT(tokenCount, "ownerTotalToken", ownerTotalToken.get(), "totalToken", totalToken.get());
    }
     
    CONSTANT uint64_t PortfolioManage::queryTotalToken(){
        return totalToken.get();
    }

     
    CONSTANT uint64_t PortfolioManage::queryPortfolioBalance(char* _portfolioName){
        return portfolioBalance.get()[_portfolioName];
    }

    
    CONSTANT bool PortfolioManage::queryPortfolioNameIfUsed(char* _portfolioName){
        if(portfolioStorge.get()[_portfolioName] != ""){
            return true;
        } 
        return false;
    }

    
    CONSTANT uint64_t PortfolioManage::queryChangeRate(){
        return changeRate.get();
    }

2019-12-19_15:14:53.906382: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:442] finalContract  this new  #include "PortfolioManage.hpp"

    
    PAYABLE void PortfolioManage::init(){
        *owner = caller().toString();
        *changeRate = 10000;
        *userCanWithdraw = false;
        uint64_t tokenBalance = getTotalBalance();
        
        *ownerTotalToken = tokenBalance;
        *totalToken = ownerTotalToken.get();
        
        
        DIPC_EMIT_EVENT(initEvent, "ownerTotalToken" ,tokenBalance);
    }
    
     
    EXPORT void PortfolioManage::setChangeRate(uint64_t _changeRate){
        isOwner();
        *changeRate = _changeRate;
    }
     
    EXPORT void PortfolioManage::setUserCanWithdraw(bool _canWithdraw){
        u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
isOwner();
        *userCanWithdraw = _canWithdraw;
    }

    
    PAYABLE void PortfolioManage::createPortfolio(char* _portfolioName, char* _portfolioDesc){
        if(portfolioStorge.get()[_portfolioName] != ""){
            DIPC_EMIT_EVENT(ErrEvent, "Current portfolio exist: ", _portfolioName);
            return;
        } 
        std::string callerAddr = caller().toString();
        uint64_t tokenBalance = getTotalBalance();
        
        PortfolioInfo info(_portfolioName, _portfolioDesc, &callerAddr[0]);
        std::string portfolioStr = info.toJson();
        
        
        

        (*portfolioStorge)[_portfolioName] = portfolioStr;
        DipcAssert(totalToken.get() + tokenBalance > totalToken);
        (*portfolioBalance)[_portfolioName] = tokenBalance;
        *totalToken = totalToken.get() + tokenBalance; 
        
        DIPC_EMIT_EVENT(portfolioInfo, _portfolioName, &portfolioStr[0], "portfolioBalance", tokenBalance);
    }

    
    PAYABLE void PortfolioManage::depositPortfolio(char* _portfolioName){
        uint64_t tokenBalance = getTotalBalance();
        
        uint64_t currentBalance = portfolioBalance.get()[_portfolioName];
        uint64_t finalBalance  = currentBalance + tokenBalance;
        DipcAssert(totalToken.get() + tokenBalance > totalToken);
        DipcAssert(finalBalance > currentBalance);
        (*portfolioBalance)[_portfolioName] = finalBalance;
        *totalToken = totalToken.get() + finalBalance; 
        DIPC_EMIT_EVENT(depositPortfolio, "portfolioName", _portfolioName, "portfolioBalance", finalBalance);
    }
    
    PAYABLE void PortfolioManage::createOrder(char* _portfolioName, char* _orderId, uint16_t _orderType, char* _stockCode, uint64_t _stockPrice, uint64_t _stockAmount, uint64_t _endTime){
        uint64_t tokenBalance = getTotalBalance();
        DIPC_EMIT_EVENT(createOrder, "portfolioName", _portfolioName, "OrderInfo", "ignore", "tokenBalance", tokenBalance);
        uint64_t spent = 0;
        if(_orderType == 1){
            spent = _stockPrice * _stockAmount;
            DipcAssert((portfolioBalance.get()[_portfolioName] + tokenBalance) > spent);
        }
        struct Order order{_orderId, _orderType, _stockCode, _stockPrice, _stockAmount, _endTime, 0};
        std::string pInfo = portfolioStorge.get()[_portfolioName];
        
        
        
        if(pInfo == "") {
            DIPC_EMIT_EVENT(ErrEvent, "Current portfolio  doesn't exist: ", _portfolioName);
            return;
        }
        PortfolioInfo info;
        info.parseJson(pInfo);
        if(info.getOrder(_orderId).orderId != ""){
            DIPC_EMIT_EVENT(ErrEvent, "Current order exist: ", _orderId);
            return;
        }
        info.addOrder(order);
        pInfo = info.toJson();

        uint64_t currentBalance = portfolioBalance.get()[_portfolioName] ;
        uint64_t finalBalance = currentBalance + tokenBalance - spent;
        DipcAssert(totalToken.get() + tokenBalance > totalToken);
        
        DipcAssert(ownerTotalToken.get() < ownerTotalToken.get() + spent);
        (*portfolioStorge)[_portfolioName] = &pInfo[0];
        
        
        
        


        (*portfolioBalance)[_portfolioName] = finalBalance;
        *totalToken = totalToken.get() + finalBalance; 
        *ownerTotalToken = ownerTotalToken.get() + spent;
        DIPC_EMIT_EVENT(createOrder, "portfolioName", _portfolioName, "OrderInfo", &order.toJson()[0], "portfolioBalance", finalBalance);
    }

    
    EXPORT void PortfolioManage::dealOrder(char* _portfolioName, char* _orderId){
        u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
isOwner();
        std::string pInfo = portfolioStorge.get()[_portfolioName];
        
        
        PortfolioInfo info;
        info.parseJson(pInfo);
        

        
         Order ord = info.getOrder(_orderId);
         
         
        if(ord.orderId != "" && ord.orderStatus == 0){
            
            uint64_t timenow = dipc::timestamp();
            if(ord.endTime > timenow){
                ord.orderStatus = 1;
            }else {
                ord.orderStatus = 3;
            }
        } else {
          

            return;
        }
        

        uint64_t sellValue = 0;
        if(ord.orderType == 0){
            sellValue = ord.stockAmount * ord.stockPrice;
        }
        uint64_t currentBalance =  portfolioBalance.get()[_portfolioName];
        

        DipcAssert(currentBalance + sellValue >= currentBalance);
        DipcAssert((ownerTotalToken.get() - sellValue) <= ownerTotalToken.get());
        


        (*portfolioBalance)[_portfolioName] = currentBalance + sellValue;
        *ownerTotalToken = ownerTotalToken.get() - sellValue;
        (*portfolioStorge)[_portfolioName] = &info.toJson()[0];
        
        
        
        

        DIPC_EMIT_EVENT(dealPortfolio, "orderId", _orderId, "orderInfo", &ord.toJson()[0]);
    }
    
    EXPORT void PortfolioManage::revocationOrder(char* _portfolioName, char* _orderId){
        u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
std::string pInfo = portfolioStorge.get()[_portfolioName];
        
        
        PortfolioInfo info;
        info.parseJson(pInfo);
        Order ord = info.getOrder(_orderId);
        
        
        if(ord.orderId != "" && ord.orderStatus == 0){
            std::string callerStr = caller().toString();
            
            
            
            DipcAssert(info.getOwnerAddress() == caller().toString());
            

            uint64_t timenow = dipc::timestamp();
            if(ord.endTime > timenow){
                ord.orderStatus = 2;
            }else {
                ord.orderStatus = 3;
            }
        } else {
            return;
        }
        uint64_t lockToken = 0;
        if(ord.orderType == 1){
            lockToken = ord.stockPrice * ord.stockAmount;
        }
        uint64_t currentBalance =  portfolioBalance.get()[_portfolioName];
        
        
        
        

        DipcAssert(currentBalance + lockToken >= currentBalance);
        DipcAssert(ownerTotalToken.get() - lockToken <= ownerTotalToken.get());

        
        (*portfolioBalance)[_portfolioName] = currentBalance + lockToken;
        *ownerTotalToken = ownerTotalToken.get() - lockToken;
        (*portfolioStorge)[_portfolioName] = &info.toJson()[0];
        DIPC_EMIT_EVENT(revocationPortfolio, "orderId", _orderId, "orderInfo", &ord.toJson()[0]);
    } codetext new #include "PortfolioManage.hpp"

    
    PAYABLE void PortfolioManage::init(){
        *owner = caller().toString();
        *changeRate = 10000;
        *userCanWithdraw = false;
        uint64_t tokenBalance = getTotalBalance();
        
        *ownerTotalToken = tokenBalance;
        *totalToken = ownerTotalToken.get();
        
        
        DIPC_EMIT_EVENT(initEvent, "ownerTotalToken" ,tokenBalance);
    }
    
     
    EXPORT void PortfolioManage::setChangeRate(uint64_t _changeRate){
        isOwner();
        *changeRate = _changeRate;
    }
     
    EXPORT void PortfolioManage::setUserCanWithdraw(bool _canWithdraw){
        u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
isOwner();
        *userCanWithdraw = _canWithdraw;
    }

    
    PAYABLE void PortfolioManage::createPortfolio(char* _portfolioName, char* _portfolioDesc){
        if(portfolioStorge.get()[_portfolioName] != ""){
            DIPC_EMIT_EVENT(ErrEvent, "Current portfolio exist: ", _portfolioName);
            return;
        } 
        std::string callerAddr = caller().toString();
        uint64_t tokenBalance = getTotalBalance();
        
        PortfolioInfo info(_portfolioName, _portfolioDesc, &callerAddr[0]);
        std::string portfolioStr = info.toJson();
        
        
        

        (*portfolioStorge)[_portfolioName] = portfolioStr;
        DipcAssert(totalToken.get() + tokenBalance > totalToken);
        (*portfolioBalance)[_portfolioName] = tokenBalance;
        *totalToken = totalToken.get() + tokenBalance; 
        
        DIPC_EMIT_EVENT(portfolioInfo, _portfolioName, &portfolioStr[0], "portfolioBalance", tokenBalance);
    }

    
    PAYABLE void PortfolioManage::depositPortfolio(char* _portfolioName){
        uint64_t tokenBalance = getTotalBalance();
        
        uint64_t currentBalance = portfolioBalance.get()[_portfolioName];
        uint64_t finalBalance  = currentBalance + tokenBalance;
        DipcAssert(totalToken.get() + tokenBalance > totalToken);
        DipcAssert(finalBalance > currentBalance);
        (*portfolioBalance)[_portfolioName] = finalBalance;
        *totalToken = totalToken.get() + finalBalance; 
        DIPC_EMIT_EVENT(depositPortfolio, "portfolioName", _portfolioName, "portfolioBalance", finalBalance);
    }
    
    PAYABLE void PortfolioManage::createOrder(char* _portfolioName, char* _orderId, uint16_t _orderType, char* _stockCode, uint64_t _stockPrice, uint64_t _stockAmount, uint64_t _endTime){
        uint64_t tokenBalance = getTotalBalance();
        DIPC_EMIT_EVENT(createOrder, "portfolioName", _portfolioName, "OrderInfo", "ignore", "tokenBalance", tokenBalance);
        uint64_t spent = 0;
        if(_orderType == 1){
            spent = _stockPrice * _stockAmount;
            DipcAssert((portfolioBalance.get()[_portfolioName] + tokenBalance) > spent);
        }
        struct Order order{_orderId, _orderType, _stockCode, _stockPrice, _stockAmount, _endTime, 0};
        std::string pInfo = portfolioStorge.get()[_portfolioName];
        
        
        
        if(pInfo == "") {
            DIPC_EMIT_EVENT(ErrEvent, "Current portfolio  doesn't exist: ", _portfolioName);
            return;
        }
        PortfolioInfo info;
        info.parseJson(pInfo);
        if(info.getOrder(_orderId).orderId != ""){
            DIPC_EMIT_EVENT(ErrEvent, "Current order exist: ", _orderId);
            return;
        }
        info.addOrder(order);
        pInfo = info.toJson();

        uint64_t currentBalance = portfolioBalance.get()[_portfolioName] ;
        uint64_t finalBalance = currentBalance + tokenBalance - spent;
        DipcAssert(totalToken.get() + tokenBalance > totalToken);
        
        DipcAssert(ownerTotalToken.get() < ownerTotalToken.get() + spent);
        (*portfolioStorge)[_portfolioName] = &pInfo[0];
        
        
        
        


        (*portfolioBalance)[_portfolioName] = finalBalance;
        *totalToken = totalToken.get() + finalBalance; 
        *ownerTotalToken = ownerTotalToken.get() + spent;
        DIPC_EMIT_EVENT(createOrder, "portfolioName", _portfolioName, "OrderInfo", &order.toJson()[0], "portfolioBalance", finalBalance);
    }

    
    EXPORT void PortfolioManage::dealOrder(char* _portfolioName, char* _orderId){
        u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
isOwner();
        std::string pInfo = portfolioStorge.get()[_portfolioName];
        
        
        PortfolioInfo info;
        info.parseJson(pInfo);
        

        
         Order ord = info.getOrder(_orderId);
         
         
        if(ord.orderId != "" && ord.orderStatus == 0){
            
            uint64_t timenow = dipc::timestamp();
            if(ord.endTime > timenow){
                ord.orderStatus = 1;
            }else {
                ord.orderStatus = 3;
            }
        } else {
          

            return;
        }
        

        uint64_t sellValue = 0;
        if(ord.orderType == 0){
            sellValue = ord.stockAmount * ord.stockPrice;
        }
        uint64_t currentBalance =  portfolioBalance.get()[_portfolioName];
        

        DipcAssert(currentBalance + sellValue >= currentBalance);
        DipcAssert((ownerTotalToken.get() - sellValue) <= ownerTotalToken.get());
        


        (*portfolioBalance)[_portfolioName] = currentBalance + sellValue;
        *ownerTotalToken = ownerTotalToken.get() - sellValue;
        (*portfolioStorge)[_portfolioName] = &info.toJson()[0];
        
        
        
        

        DIPC_EMIT_EVENT(dealPortfolio, "orderId", _orderId, "orderInfo", &ord.toJson()[0]);
    }
    
    EXPORT void PortfolioManage::revocationOrder(char* _portfolioName, char* _orderId){
        std::string pInfo = portfolioStorge.get()[_portfolioName];
        
        
        PortfolioInfo info;
        info.parseJson(pInfo);
        Order ord = info.getOrder(_orderId);
        
        
        if(ord.orderId != "" && ord.orderStatus == 0){
            std::string callerStr = caller().toString();
            
            
            
            DipcAssert(info.getOwnerAddress() == caller().toString());
            

            uint64_t timenow = dipc::timestamp();
            if(ord.endTime > timenow){
                ord.orderStatus = 2;
            }else {
                ord.orderStatus = 3;
            }
        } else {
            return;
        }
        uint64_t lockToken = 0;
        if(ord.orderType == 1){
            lockToken = ord.stockPrice * ord.stockAmount;
        }
        uint64_t currentBalance =  portfolioBalance.get()[_portfolioName];
        
        
        
        

        DipcAssert(currentBalance + lockToken >= currentBalance);
        DipcAssert(ownerTotalToken.get() - lockToken <= ownerTotalToken.get());

        
        (*portfolioBalance)[_portfolioName] = currentBalance + lockToken;
        *ownerTotalToken = ownerTotalToken.get() - lockToken;
        (*portfolioStorge)[_portfolioName] = &info.toJson()[0];
        DIPC_EMIT_EVENT(revocationPortfolio, "orderId", _orderId, "orderInfo", &ord.toJson()[0]);
    }
    
    EXPORT void PortfolioManage::withdrawPortfolio(char* _portfolioName, uint64_t _withdrawBalance){
         if(!userCanWithdraw.get()){
             return;
         }
         uint64_t currentBalance =  portfolioBalance.get()[_portfolioName];
         DipcAssert(currentBalance - _withdrawBalance < currentBalance);
         auto coinBalance = changeUint64ToU256WithChangeRate(currentBalance, changeRate.get());
         (*portfolioBalance)[_portfolioName] = currentBalance - _withdrawBalance;
         callTransfer(caller(), coinBalance);
    }
    
    EXPORT void PortfolioManage::withdrawPool(uint64_t _balance){
        isOwner();
        Address ownerAddr = Address(owner.get()); 
        callTransfer(ownerAddr, _balance);
        *ownerTotalToken = ownerTotalToken.get() - _balance * changeRate.get();
        *totalToken = totalToken.get() - _balance * changeRate.get();
        DIPC_EMIT_EVENT(tokenCount, "ownerTotalToken", ownerTotalToken.get(), "totalToken", totalToken.get());
    }
    
    PAYABLE void PortfolioManage::depositPool(uint64_t _depositValue){
        isOwner();
        
        uint64_t tokenBalance = changeU256ToUint64WithChangeRate(callValue(), changeRate.get()); 
        *ownerTotalToken = ownerTotalToken.get() + tokenBalance;
        *totalToken = totalToken.get() + tokenBalance;
        DIPC_EMIT_EVENT(tokenCount, "ownerTotalToken", ownerTotalToken.get(), "totalToken", totalToken.get());
    }
     
    CONSTANT uint64_t PortfolioManage::queryTotalToken(){
        return totalToken.get();
    }

     
    CONSTANT uint64_t PortfolioManage::queryPortfolioBalance(char* _portfolioName){
        return portfolioBalance.get()[_portfolioName];
    }

    
    CONSTANT bool PortfolioManage::queryPortfolioNameIfUsed(char* _portfolioName){
        if(portfolioStorge.get()[_portfolioName] != ""){
            return true;
        } 
        return false;
    }

    
    CONSTANT uint64_t PortfolioManage::queryChangeRate(){
        return changeRate.get();
    }

2019-12-19_15:14:53.906409: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:604] finalContract  final content =======   : #include "PortfolioManage.hpp"

    
    PAYABLE void PortfolioManage::init(){
        *owner = caller().toString();
        *changeRate = 10000;
        *userCanWithdraw = false;
        uint64_t tokenBalance = getTotalBalance();
        
        *ownerTotalToken = tokenBalance;
        *totalToken = ownerTotalToken.get();
        
        
        DIPC_EMIT_EVENT(initEvent, "ownerTotalToken" ,tokenBalance);
    }
    
     
    EXPORT void PortfolioManage::setChangeRate(uint64_t _changeRate){
        isOwner();
        *changeRate = _changeRate;
    }
     
    EXPORT void PortfolioManage::setUserCanWithdraw(bool _canWithdraw){
        u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
isOwner();
        *userCanWithdraw = _canWithdraw;
    }

    
    PAYABLE void PortfolioManage::createPortfolio(char* _portfolioName, char* _portfolioDesc){
        if(portfolioStorge.get()[_portfolioName] != ""){
            DIPC_EMIT_EVENT(ErrEvent, "Current portfolio exist: ", _portfolioName);
            return;
        } 
        std::string callerAddr = caller().toString();
        uint64_t tokenBalance = getTotalBalance();
        
        PortfolioInfo info(_portfolioName, _portfolioDesc, &callerAddr[0]);
        std::string portfolioStr = info.toJson();
        
        
        

        (*portfolioStorge)[_portfolioName] = portfolioStr;
        DipcAssert(totalToken.get() + tokenBalance > totalToken);
        (*portfolioBalance)[_portfolioName] = tokenBalance;
        *totalToken = totalToken.get() + tokenBalance; 
        
        DIPC_EMIT_EVENT(portfolioInfo, _portfolioName, &portfolioStr[0], "portfolioBalance", tokenBalance);
    }

    
    PAYABLE void PortfolioManage::depositPortfolio(char* _portfolioName){
        uint64_t tokenBalance = getTotalBalance();
        
        uint64_t currentBalance = portfolioBalance.get()[_portfolioName];
        uint64_t finalBalance  = currentBalance + tokenBalance;
        DipcAssert(totalToken.get() + tokenBalance > totalToken);
        DipcAssert(finalBalance > currentBalance);
        (*portfolioBalance)[_portfolioName] = finalBalance;
        *totalToken = totalToken.get() + finalBalance; 
        DIPC_EMIT_EVENT(depositPortfolio, "portfolioName", _portfolioName, "portfolioBalance", finalBalance);
    }
    
    PAYABLE void PortfolioManage::createOrder(char* _portfolioName, char* _orderId, uint16_t _orderType, char* _stockCode, uint64_t _stockPrice, uint64_t _stockAmount, uint64_t _endTime){
        uint64_t tokenBalance = getTotalBalance();
        DIPC_EMIT_EVENT(createOrder, "portfolioName", _portfolioName, "OrderInfo", "ignore", "tokenBalance", tokenBalance);
        uint64_t spent = 0;
        if(_orderType == 1){
            spent = _stockPrice * _stockAmount;
            DipcAssert((portfolioBalance.get()[_portfolioName] + tokenBalance) > spent);
        }
        struct Order order{_orderId, _orderType, _stockCode, _stockPrice, _stockAmount, _endTime, 0};
        std::string pInfo = portfolioStorge.get()[_portfolioName];
        
        
        
        if(pInfo == "") {
            DIPC_EMIT_EVENT(ErrEvent, "Current portfolio  doesn't exist: ", _portfolioName);
            return;
        }
        PortfolioInfo info;
        info.parseJson(pInfo);
        if(info.getOrder(_orderId).orderId != ""){
            DIPC_EMIT_EVENT(ErrEvent, "Current order exist: ", _orderId);
            return;
        }
        info.addOrder(order);
        pInfo = info.toJson();

        uint64_t currentBalance = portfolioBalance.get()[_portfolioName] ;
        uint64_t finalBalance = currentBalance + tokenBalance - spent;
        DipcAssert(totalToken.get() + tokenBalance > totalToken);
        
        DipcAssert(ownerTotalToken.get() < ownerTotalToken.get() + spent);
        (*portfolioStorge)[_portfolioName] = &pInfo[0];
        
        
        
        


        (*portfolioBalance)[_portfolioName] = finalBalance;
        *totalToken = totalToken.get() + finalBalance; 
        *ownerTotalToken = ownerTotalToken.get() + spent;
        DIPC_EMIT_EVENT(createOrder, "portfolioName", _portfolioName, "OrderInfo", &order.toJson()[0], "portfolioBalance", finalBalance);
    }

    
    EXPORT void PortfolioManage::dealOrder(char* _portfolioName, char* _orderId){
        u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
isOwner();
        std::string pInfo = portfolioStorge.get()[_portfolioName];
        
        
        PortfolioInfo info;
        info.parseJson(pInfo);
        

        
         Order ord = info.getOrder(_orderId);
         
         
        if(ord.orderId != "" && ord.orderStatus == 0){
            
            uint64_t timenow = dipc::timestamp();
            if(ord.endTime > timenow){
                ord.orderStatus = 1;
            }else {
                ord.orderStatus = 3;
            }
        } else {
          

            return;
        }
        

        uint64_t sellValue = 0;
        if(ord.orderType == 0){
            sellValue = ord.stockAmount * ord.stockPrice;
        }
        uint64_t currentBalance =  portfolioBalance.get()[_portfolioName];
        

        DipcAssert(currentBalance + sellValue >= currentBalance);
        DipcAssert((ownerTotalToken.get() - sellValue) <= ownerTotalToken.get());
        


        (*portfolioBalance)[_portfolioName] = currentBalance + sellValue;
        *ownerTotalToken = ownerTotalToken.get() - sellValue;
        (*portfolioStorge)[_portfolioName] = &info.toJson()[0];
        
        
        
        

        DIPC_EMIT_EVENT(dealPortfolio, "orderId", _orderId, "orderInfo", &ord.toJson()[0]);
    }
    
    EXPORT void PortfolioManage::revocationOrder(char* _portfolioName, char* _orderId){
        u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
std::string pInfo = portfolioStorge.get()[_portfolioName];
        
        
        PortfolioInfo info;
        info.parseJson(pInfo);
        Order ord = info.getOrder(_orderId);
        
        
        if(ord.orderId != "" && ord.orderStatus == 0){
            std::string callerStr = caller().toString();
            
            
            
            DipcAssert(info.getOwnerAddress() == caller().toString());
            

            uint64_t timenow = dipc::timestamp();
            if(ord.endTime > timenow){
                ord.orderStatus = 2;
            }else {
                ord.orderStatus = 3;
            }
        } else {
            return;
        }
        uint64_t lockToken = 0;
        if(ord.orderType == 1){
            lockToken = ord.stockPrice * ord.stockAmount;
        }
        uint64_t currentBalance =  portfolioBalance.get()[_portfolioName];
        
        
        
        

        DipcAssert(currentBalance + lockToken >= currentBalance);
        DipcAssert(ownerTotalToken.get() - lockToken <= ownerTotalToken.get());

        
        (*portfolioBalance)[_portfolioName] = currentBalance + lockToken;
        *ownerTotalToken = ownerTotalToken.get() - lockToken;
        (*portfolioStorge)[_portfolioName] = &info.toJson()[0];
        DIPC_EMIT_EVENT(revocationPortfolio, "orderId", _orderId, "orderInfo", &ord.toJson()[0]);
    }
    
    EXPORT void PortfolioManage::withdrawPortfolio(char* _portfolioName, uint64_t _withdrawBalance){
         if(!userCanWithdraw.get()){
             return;
         }
         uint64_t currentBalance =  portfolioBalance.get()[_portfolioName];
         DipcAssert(currentBalance - _withdrawBalance < currentBalance);
         auto coinBalance = changeUint64ToU256WithChangeRate(currentBalance, changeRate.get());
         (*portfolioBalance)[_portfolioName] = currentBalance - _withdrawBalance;
         callTransfer(caller(), coinBalance);
    }
    
    EXPORT void PortfolioManage::withdrawPool(uint64_t _balance){
        isOwner();
        Address ownerAddr = Address(owner.get()); 
        callTransfer(ownerAddr, _balance);
        *ownerTotalToken = ownerTotalToken.get() - _balance * changeRate.get();
        *totalToken = totalToken.get() - _balance * changeRate.get();
        DIPC_EMIT_EVENT(tokenCount, "ownerTotalToken", ownerTotalToken.get(), "totalToken", totalToken.get());
    }
    
    PAYABLE void PortfolioManage::depositPool(uint64_t _depositValue){
        isOwner();
        
        uint64_t tokenBalance = changeU256ToUint64WithChangeRate(callValue(), changeRate.get()); 
        *ownerTotalToken = ownerTotalToken.get() + tokenBalance;
        *totalToken = totalToken.get() + tokenBalance;
        DIPC_EMIT_EVENT(tokenCount, "ownerTotalToken", ownerTotalToken.get(), "totalToken", totalToken.get());
    }
     
    CONSTANT uint64_t PortfolioManage::queryTotalToken(){
        return totalToken.get();
    }

     
    CONSTANT uint64_t PortfolioManage::queryPortfolioBalance(char* _portfolioName){
        return portfolioBalance.get()[_portfolioName];
    }

    
    CONSTANT bool PortfolioManage::queryPortfolioNameIfUsed(char* _portfolioName){
        if(portfolioStorge.get()[_portfolioName] != ""){
            return true;
        } 
        return false;
    }

    
    CONSTANT uint64_t PortfolioManage::queryChangeRate(){
        return changeRate.get();
    }

2019-12-19_15:14:53.906421: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:401] abis.ispayable :false

2019-12-19_15:14:53.906440: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:424] finalContract  this height  #include "PortfolioManage.hpp"

    
    PAYABLE void PortfolioManage::init(){
        *owner = caller().toString();
        *changeRate = 10000;
        *userCanWithdraw = false;
        uint64_t tokenBalance = getTotalBalance();
        
        *ownerTotalToken = tokenBalance;
        *totalToken = ownerTotalToken.get();
        
        
        DIPC_EMIT_EVENT(initEvent, "ownerTotalToken" ,tokenBalance);
    }
    
     
    EXPORT void PortfolioManage::setChangeRate(uint64_t _changeRate){
        isOwner();
        *changeRate = _changeRate;
    }
     
    EXPORT void PortfolioManage::setUserCanWithdraw(bool _canWithdraw){
        u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
isOwner();
        *userCanWithdraw = _canWithdraw;
    }

    
    PAYABLE void PortfolioManage::createPortfolio(char* _portfolioName, char* _portfolioDesc){
        if(portfolioStorge.get()[_portfolioName] != ""){
            DIPC_EMIT_EVENT(ErrEvent, "Current portfolio exist: ", _portfolioName);
            return;
        } 
        std::string callerAddr = caller().toString();
        uint64_t tokenBalance = getTotalBalance();
        
        PortfolioInfo info(_portfolioName, _portfolioDesc, &callerAddr[0]);
        std::string portfolioStr = info.toJson();
        
        
        

        (*portfolioStorge)[_portfolioName] = portfolioStr;
        DipcAssert(totalToken.get() + tokenBalance > totalToken);
        (*portfolioBalance)[_portfolioName] = tokenBalance;
        *totalToken = totalToken.get() + tokenBalance; 
        
        DIPC_EMIT_EVENT(portfolioInfo, _portfolioName, &portfolioStr[0], "portfolioBalance", tokenBalance);
    }

    
    PAYABLE void PortfolioManage::depositPortfolio(char* _portfolioName){
        uint64_t tokenBalance = getTotalBalance();
        
        uint64_t currentBalance = portfolioBalance.get()[_portfolioName];
        uint64_t finalBalance  = currentBalance + tokenBalance;
        DipcAssert(totalToken.get() + tokenBalance > totalToken);
        DipcAssert(finalBalance > currentBalance);
        (*portfolioBalance)[_portfolioName] = finalBalance;
        *totalToken = totalToken.get() + finalBalance; 
        DIPC_EMIT_EVENT(depositPortfolio, "portfolioName", _portfolioName, "portfolioBalance", finalBalance);
    }
    
    PAYABLE void PortfolioManage::createOrder(char* _portfolioName, char* _orderId, uint16_t _orderType, char* _stockCode, uint64_t _stockPrice, uint64_t _stockAmount, uint64_t _endTime){
        uint64_t tokenBalance = getTotalBalance();
        DIPC_EMIT_EVENT(createOrder, "portfolioName", _portfolioName, "OrderInfo", "ignore", "tokenBalance", tokenBalance);
        uint64_t spent = 0;
        if(_orderType == 1){
            spent = _stockPrice * _stockAmount;
            DipcAssert((portfolioBalance.get()[_portfolioName] + tokenBalance) > spent);
        }
        struct Order order{_orderId, _orderType, _stockCode, _stockPrice, _stockAmount, _endTime, 0};
        std::string pInfo = portfolioStorge.get()[_portfolioName];
        
        
        
        if(pInfo == "") {
            DIPC_EMIT_EVENT(ErrEvent, "Current portfolio  doesn't exist: ", _portfolioName);
            return;
        }
        PortfolioInfo info;
        info.parseJson(pInfo);
        if(info.getOrder(_orderId).orderId != ""){
            DIPC_EMIT_EVENT(ErrEvent, "Current order exist: ", _orderId);
            return;
        }
        info.addOrder(order);
        pInfo = info.toJson();

        uint64_t currentBalance = portfolioBalance.get()[_portfolioName] ;
        uint64_t finalBalance = currentBalance + tokenBalance - spent;
        DipcAssert(totalToken.get() + tokenBalance > totalToken);
        
        DipcAssert(ownerTotalToken.get() < ownerTotalToken.get() + spent);
        (*portfolioStorge)[_portfolioName] = &pInfo[0];
        
        
        
        


        (*portfolioBalance)[_portfolioName] = finalBalance;
        *totalToken = totalToken.get() + finalBalance; 
        *ownerTotalToken = ownerTotalToken.get() + spent;
        DIPC_EMIT_EVENT(createOrder, "portfolioName", _portfolioName, "OrderInfo", &order.toJson()[0], "portfolioBalance", finalBalance);
    }

    
    EXPORT void PortfolioManage::dealOrder(char* _portfolioName, char* _orderId){
        u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
isOwner();
        std::string pInfo = portfolioStorge.get()[_portfolioName];
        
        
        PortfolioInfo info;
        info.parseJson(pInfo);
        

        
         Order ord = info.getOrder(_orderId);
         
         
        if(ord.orderId != "" && ord.orderStatus == 0){
            
            uint64_t timenow = dipc::timestamp();
            if(ord.endTime > timenow){
                ord.orderStatus = 1;
            }else {
                ord.orderStatus = 3;
            }
        } else {
          

            return;
        }
        

        uint64_t sellValue = 0;
        if(ord.orderType == 0){
            sellValue = ord.stockAmount * ord.stockPrice;
        }
        uint64_t currentBalance =  portfolioBalance.get()[_portfolioName];
        

        DipcAssert(currentBalance + sellValue >= currentBalance);
        DipcAssert((ownerTotalToken.get() - sellValue) <= ownerTotalToken.get());
        


        (*portfolioBalance)[_portfolioName] = currentBalance + sellValue;
        *ownerTotalToken = ownerTotalToken.get() - sellValue;
        (*portfolioStorge)[_portfolioName] = &info.toJson()[0];
        
        
        
        

        DIPC_EMIT_EVENT(dealPortfolio, "orderId", _orderId, "orderInfo", &ord.toJson()[0]);
    }
    
    EXPORT void PortfolioManage::revocationOrder(char* _portfolioName, char* _orderId){
        u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
std::string pInfo = portfolioStorge.get()[_portfolioName];
        
        
        PortfolioInfo info;
        info.parseJson(pInfo);
        Order ord = info.getOrder(_orderId);
        
        
        if(ord.orderId != "" && ord.orderStatus == 0){
            std::string callerStr = caller().toString();
            
            
            
            DipcAssert(info.getOwnerAddress() == caller().toString());
            

            uint64_t timenow = dipc::timestamp();
            if(ord.endTime > timenow){
                ord.orderStatus = 2;
            }else {
                ord.orderStatus = 3;
            }
        } else {
            return;
        }
        uint64_t lockToken = 0;
        if(ord.orderType == 1){
            lockToken = ord.stockPrice * ord.stockAmount;
        }
        uint64_t currentBalance =  portfolioBalance.get()[_portfolioName];
        
        
        
        

        DipcAssert(currentBalance + lockToken >= currentBalance);
        DipcAssert(ownerTotalToken.get() - lockToken <= ownerTotalToken.get());

        
        (*portfolioBalance)[_portfolioName] = currentBalance + lockToken;
        *ownerTotalToken = ownerTotalToken.get() - lockToken;
        (*portfolioStorge)[_portfolioName] = &info.toJson()[0];
        DIPC_EMIT_EVENT(revocationPortfolio, "orderId", _orderId, "orderInfo", &ord.toJson()[0]);
    }
    
    EXPORT void PortfolioManage::withdrawPortfolio(char* _portfolioName, uint64_t _withdrawBalance){
         if(!userCanWithdraw.get()){
             return;
         }
         uint64_t currentBalance =  portfolioBalance.get()[_portfolioName];
         DipcAssert(currentBalance - _withdrawBalance < currentBalance);
         auto coinBalance = changeUint64ToU256WithChangeRate(currentBalance, changeRate.get());
         (*portfolioBalance)[_portfolioName] = currentBalance - _withdrawBalance;
         callTransfer(caller(), coinBalance);
    }
    
    EXPORT void PortfolioManage::withdrawPool(uint64_t _balance){
        isOwner();
        Address ownerAddr = Address(owner.get()); 
        callTransfer(ownerAddr, _balance);
        *ownerTotalToken = ownerTotalToken.get() - _balance * changeRate.get();
        *totalToken = totalToken.get() - _balance * changeRate.get();
        DIPC_EMIT_EVENT(tokenCount, "ownerTotalToken", ownerTotalToken.get(), "totalToken", totalToken.get());
    }
    
    PAYABLE void PortfolioManage::depositPool(uint64_t _depositValue){
        isOwner();
        
        uint64_t tokenBalance = changeU256ToUint64WithChangeRate(callValue(), changeRate.get()); 
        *ownerTotalToken = ownerTotalToken.get() + tokenBalance;
        *totalToken = totalToken.get() + tokenBalance;
        DIPC_EMIT_EVENT(tokenCount, "ownerTotalToken", ownerTotalToken.get(), "totalToken", totalToken.get());
    }
     
    CONSTANT uint64_t PortfolioManage::queryTotalToken(){
        return totalToken.get();
    }

     
    CONSTANT uint64_t PortfolioManage::queryPortfolioBalance(char* _portfolioName){
        return portfolioBalance.get()[_portfolioName];
    }

    
    CONSTANT bool PortfolioManage::queryPortfolioNameIfUsed(char* _portfolioName){
        if(portfolioStorge.get()[_portfolioName] != ""){
            return true;
        } 
        return false;
    }

    
    CONSTANT uint64_t PortfolioManage::queryChangeRate(){
        return changeRate.get();
    } codetext height #include "PortfolioManage.hpp"

    
    PAYABLE void PortfolioManage::init(){
        *owner = caller().toString();
        *changeRate = 10000;
        *userCanWithdraw = false;
        uint64_t tokenBalance = getTotalBalance();
        
        *ownerTotalToken = tokenBalance;
        *totalToken = ownerTotalToken.get();
        
        
        DIPC_EMIT_EVENT(initEvent, "ownerTotalToken" ,tokenBalance);
    }
    
     
    EXPORT void PortfolioManage::setChangeRate(uint64_t _changeRate){
        isOwner();
        *changeRate = _changeRate;
    }
     
    EXPORT void PortfolioManage::setUserCanWithdraw(bool _canWithdraw){
        u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
isOwner();
        *userCanWithdraw = _canWithdraw;
    }

    
    PAYABLE void PortfolioManage::createPortfolio(char* _portfolioName, char* _portfolioDesc){
        if(portfolioStorge.get()[_portfolioName] != ""){
            DIPC_EMIT_EVENT(ErrEvent, "Current portfolio exist: ", _portfolioName);
            return;
        } 
        std::string callerAddr = caller().toString();
        uint64_t tokenBalance = getTotalBalance();
        
        PortfolioInfo info(_portfolioName, _portfolioDesc, &callerAddr[0]);
        std::string portfolioStr = info.toJson();
        
        
        

        (*portfolioStorge)[_portfolioName] = portfolioStr;
        DipcAssert(totalToken.get() + tokenBalance > totalToken);
        (*portfolioBalance)[_portfolioName] = tokenBalance;
        *totalToken = totalToken.get() + tokenBalance; 
        
        DIPC_EMIT_EVENT(portfolioInfo, _portfolioName, &portfolioStr[0], "portfolioBalance", tokenBalance);
    }

    
    PAYABLE void PortfolioManage::depositPortfolio(char* _portfolioName){
        uint64_t tokenBalance = getTotalBalance();
        
        uint64_t currentBalance = portfolioBalance.get()[_portfolioName];
        uint64_t finalBalance  = currentBalance + tokenBalance;
        DipcAssert(totalToken.get() + tokenBalance > totalToken);
        DipcAssert(finalBalance > currentBalance);
        (*portfolioBalance)[_portfolioName] = finalBalance;
        *totalToken = totalToken.get() + finalBalance; 
        DIPC_EMIT_EVENT(depositPortfolio, "portfolioName", _portfolioName, "portfolioBalance", finalBalance);
    }
    
    PAYABLE void PortfolioManage::createOrder(char* _portfolioName, char* _orderId, uint16_t _orderType, char* _stockCode, uint64_t _stockPrice, uint64_t _stockAmount, uint64_t _endTime){
        uint64_t tokenBalance = getTotalBalance();
        DIPC_EMIT_EVENT(createOrder, "portfolioName", _portfolioName, "OrderInfo", "ignore", "tokenBalance", tokenBalance);
        uint64_t spent = 0;
        if(_orderType == 1){
            spent = _stockPrice * _stockAmount;
            DipcAssert((portfolioBalance.get()[_portfolioName] + tokenBalance) > spent);
        }
        struct Order order{_orderId, _orderType, _stockCode, _stockPrice, _stockAmount, _endTime, 0};
        std::string pInfo = portfolioStorge.get()[_portfolioName];
        
        
        
        if(pInfo == "") {
            DIPC_EMIT_EVENT(ErrEvent, "Current portfolio  doesn't exist: ", _portfolioName);
            return;
        }
        PortfolioInfo info;
        info.parseJson(pInfo);
        if(info.getOrder(_orderId).orderId != ""){
            DIPC_EMIT_EVENT(ErrEvent, "Current order exist: ", _orderId);
            return;
        }
        info.addOrder(order);
        pInfo = info.toJson();

        uint64_t currentBalance = portfolioBalance.get()[_portfolioName] ;
        uint64_t finalBalance = currentBalance + tokenBalance - spent;
        DipcAssert(totalToken.get() + tokenBalance > totalToken);
        
        DipcAssert(ownerTotalToken.get() < ownerTotalToken.get() + spent);
        (*portfolioStorge)[_portfolioName] = &pInfo[0];
        
        
        
        


        (*portfolioBalance)[_portfolioName] = finalBalance;
        *totalToken = totalToken.get() + finalBalance; 
        *ownerTotalToken = ownerTotalToken.get() + spent;
        DIPC_EMIT_EVENT(createOrder, "portfolioName", _portfolioName, "OrderInfo", &order.toJson()[0], "portfolioBalance", finalBalance);
    }

    
    EXPORT void PortfolioManage::dealOrder(char* _portfolioName, char* _orderId){
        u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
isOwner();
        std::string pInfo = portfolioStorge.get()[_portfolioName];
        
        
        PortfolioInfo info;
        info.parseJson(pInfo);
        

        
         Order ord = info.getOrder(_orderId);
         
         
        if(ord.orderId != "" && ord.orderStatus == 0){
            
            uint64_t timenow = dipc::timestamp();
            if(ord.endTime > timenow){
                ord.orderStatus = 1;
            }else {
                ord.orderStatus = 3;
            }
        } else {
          

            return;
        }
        

        uint64_t sellValue = 0;
        if(ord.orderType == 0){
            sellValue = ord.stockAmount * ord.stockPrice;
        }
        uint64_t currentBalance =  portfolioBalance.get()[_portfolioName];
        

        DipcAssert(currentBalance + sellValue >= currentBalance);
        DipcAssert((ownerTotalToken.get() - sellValue) <= ownerTotalToken.get());
        


        (*portfolioBalance)[_portfolioName] = currentBalance + sellValue;
        *ownerTotalToken = ownerTotalToken.get() - sellValue;
        (*portfolioStorge)[_portfolioName] = &info.toJson()[0];
        
        
        
        

        DIPC_EMIT_EVENT(dealPortfolio, "orderId", _orderId, "orderInfo", &ord.toJson()[0]);
    }
    
    EXPORT void PortfolioManage::revocationOrder(char* _portfolioName, char* _orderId){
        u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
std::string pInfo = portfolioStorge.get()[_portfolioName];
        
        
        PortfolioInfo info;
        info.parseJson(pInfo);
        Order ord = info.getOrder(_orderId);
        
        
        if(ord.orderId != "" && ord.orderStatus == 0){
            std::string callerStr = caller().toString();
            
            
            
            DipcAssert(info.getOwnerAddress() == caller().toString());
            

            uint64_t timenow = dipc::timestamp();
            if(ord.endTime > timenow){
                ord.orderStatus = 2;
            }else {
                ord.orderStatus = 3;
            }
        } else {
            return;
        }
        uint64_t lockToken = 0;
        if(ord.orderType == 1){
            lockToken = ord.stockPrice * ord.stockAmount;
        }
        uint64_t currentBalance =  portfolioBalance.get()[_portfolioName];
        
        
        
        

        DipcAssert(currentBalance + lockToken >= currentBalance);
        DipcAssert(ownerTotalToken.get() - lockToken <= ownerTotalToken.get());

        
        (*portfolioBalance)[_portfolioName] = currentBalance + lockToken;
        *ownerTotalToken = ownerTotalToken.get() - lockToken;
        (*portfolioStorge)[_portfolioName] = &info.toJson()[0];
        DIPC_EMIT_EVENT(revocationPortfolio, "orderId", _orderId, "orderInfo", &ord.toJson()[0]);
    }
    
    EXPORT void PortfolioManage::withdrawPortfolio(char* _portfolioName, uint64_t _withdrawBalance){
         if(!userCanWithdraw.get()){
             return;
         }
         uint64_t currentBalance =  portfolioBalance.get()[_portfolioName];
         DipcAssert(currentBalance - _withdrawBalance < currentBalance);
         auto coinBalance = changeUint64ToU256WithChangeRate(currentBalance, changeRate.get());
         (*portfolioBalance)[_portfolioName] = currentBalance - _withdrawBalance;
         callTransfer(caller(), coinBalance);
    }
    
    EXPORT void PortfolioManage::withdrawPool(uint64_t _balance){
        isOwner();
        Address ownerAddr = Address(owner.get()); 
        callTransfer(ownerAddr, _balance);
        *ownerTotalToken = ownerTotalToken.get() - _balance * changeRate.get();
        *totalToken = totalToken.get() - _balance * changeRate.get();
        DIPC_EMIT_EVENT(tokenCount, "ownerTotalToken", ownerTotalToken.get(), "totalToken", totalToken.get());
    }
    
    PAYABLE void PortfolioManage::depositPool(uint64_t _depositValue){
        isOwner();
        
        uint64_t tokenBalance = changeU256ToUint64WithChangeRate(callValue(), changeRate.get()); 
        *ownerTotalToken = ownerTotalToken.get() + tokenBalance;
        *totalToken = totalToken.get() + tokenBalance;
        DIPC_EMIT_EVENT(tokenCount, "ownerTotalToken", ownerTotalToken.get(), "totalToken", totalToken.get());
    }
     
    CONSTANT uint64_t PortfolioManage::queryTotalToken(){
        return totalToken.get();
    }

     
    CONSTANT uint64_t PortfolioManage::queryPortfolioBalance(char* _portfolioName){
        return portfolioBalance.get()[_portfolioName];
    }

    
    CONSTANT bool PortfolioManage::queryPortfolioNameIfUsed(char* _portfolioName){
        if(portfolioStorge.get()[_portfolioName] != ""){
            return true;
        } 
        return false;
    }

    
    CONSTANT uint64_t PortfolioManage::queryChangeRate(){
        return changeRate.get();
    }

2019-12-19_15:14:53.906451: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:427] searchContext  #include "PortfolioManage.hpp"

    
    PAYABLE void PortfolioManage::init(){
        *owner = caller().toString();
        *changeRate = 10000;
        *userCanWithdraw = false;
        uint64_t tokenBalance = getTotalBalance();
        
        *ownerTotalToken = tokenBalance;
        *totalToken = ownerTotalToken.get();
        
        
        DIPC_EMIT_EVENT(initEvent, "ownerTotalToken" ,tokenBalance);
    }
    
     
    EXPORT void PortfolioManage::setChangeRate(uint64_t _changeRate){
        isOwner();
        *changeRate = _changeRate;
    }
     
    EXPORT void PortfolioManage::setUserCanWithdraw(bool _canWithdraw){
        u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
isOwner();
        *userCanWithdraw = _canWithdraw;
    }

    
    PAYABLE void PortfolioManage::createPortfolio(char* _portfolioName, char* _portfolioDesc){
        if(portfolioStorge.get()[_portfolioName] != ""){
            DIPC_EMIT_EVENT(ErrEvent, "Current portfolio exist: ", _portfolioName);
            return;
        } 
        std::string callerAddr = caller().toString();
        uint64_t tokenBalance = getTotalBalance();
        
        PortfolioInfo info(_portfolioName, _portfolioDesc, &callerAddr[0]);
        std::string portfolioStr = info.toJson();
        
        
        

        (*portfolioStorge)[_portfolioName] = portfolioStr;
        DipcAssert(totalToken.get() + tokenBalance > totalToken);
        (*portfolioBalance)[_portfolioName] = tokenBalance;
        *totalToken = totalToken.get() + tokenBalance; 
        
        DIPC_EMIT_EVENT(portfolioInfo, _portfolioName, &portfolioStr[0], "portfolioBalance", tokenBalance);
    }

    
    PAYABLE void PortfolioManage::depositPortfolio(char* _portfolioName){
        uint64_t tokenBalance = getTotalBalance();
        
        uint64_t currentBalance = portfolioBalance.get()[_portfolioName];
        uint64_t finalBalance  = currentBalance + tokenBalance;
        DipcAssert(totalToken.get() + tokenBalance > totalToken);
        DipcAssert(finalBalance > currentBalance);
        (*portfolioBalance)[_portfolioName] = finalBalance;
        *totalToken = totalToken.get() + finalBalance; 
        DIPC_EMIT_EVENT(depositPortfolio, "portfolioName", _portfolioName, "portfolioBalance", finalBalance);
    }
    
    PAYABLE void PortfolioManage::createOrder(char* _portfolioName, char* _orderId, uint16_t _orderType, char* _stockCode, uint64_t _stockPrice, uint64_t _stockAmount, uint64_t _endTime){
        uint64_t tokenBalance = getTotalBalance();
        DIPC_EMIT_EVENT(createOrder, "portfolioName", _portfolioName, "OrderInfo", "ignore", "tokenBalance", tokenBalance);
        uint64_t spent = 0;
        if(_orderType == 1){
            spent = _stockPrice * _stockAmount;
            DipcAssert((portfolioBalance.get()[_portfolioName] + tokenBalance) > spent);
        }
        struct Order order{_orderId, _orderType, _stockCode, _stockPrice, _stockAmount, _endTime, 0};
        std::string pInfo = portfolioStorge.get()[_portfolioName];
        
        
        
        if(pInfo == "") {
            DIPC_EMIT_EVENT(ErrEvent, "Current portfolio  doesn't exist: ", _portfolioName);
            return;
        }
        PortfolioInfo info;
        info.parseJson(pInfo);
        if(info.getOrder(_orderId).orderId != ""){
            DIPC_EMIT_EVENT(ErrEvent, "Current order exist: ", _orderId);
            return;
        }
        info.addOrder(order);
        pInfo = info.toJson();

        uint64_t currentBalance = portfolioBalance.get()[_portfolioName] ;
        uint64_t finalBalance = currentBalance + tokenBalance - spent;
        DipcAssert(totalToken.get() + tokenBalance > totalToken);
        
        DipcAssert(ownerTotalToken.get() < ownerTotalToken.get() + spent);
        (*portfolioStorge)[_portfolioName] = &pInfo[0];
        
        
        
        


        (*portfolioBalance)[_portfolioName] = finalBalance;
        *totalToken = totalToken.get() + finalBalance; 
        *ownerTotalToken = ownerTotalToken.get() + spent;
        DIPC_EMIT_EVENT(createOrder, "portfolioName", _portfolioName, "OrderInfo", &order.toJson()[0], "portfolioBalance", finalBalance);
    }

    
    EXPORT void PortfolioManage::dealOrder(char* _portfolioName, char* _orderId){
        u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
isOwner();
        std::string pInfo = portfolioStorge.get()[_portfolioName];
        
        
        PortfolioInfo info;
        info.parseJson(pInfo);
        

        
         Order ord = info.getOrder(_orderId);
         
         
        if(ord.orderId != "" && ord.orderStatus == 0){
            
            uint64_t timenow = dipc::timestamp();
            if(ord.endTime > timenow){
                ord.orderStatus = 1;
            }else {
                ord.orderStatus = 3;
            }
        } else {
          

            return;
        }
        

        uint64_t sellValue = 0;
        if(ord.orderType == 0){
            sellValue = ord.stockAmount * ord.stockPrice;
        }
        uint64_t currentBalance =  portfolioBalance.get()[_portfolioName];
        

        DipcAssert(currentBalance + sellValue >= currentBalance);
        DipcAssert((ownerTotalToken.get() - sellValue) <= ownerTotalToken.get());
        


        (*portfolioBalance)[_portfolioName] = currentBalance + sellValue;
        *ownerTotalToken = ownerTotalToken.get() - sellValue;
        (*portfolioStorge)[_portfolioName] = &info.toJson()[0];
        
        
        
        

        DIPC_EMIT_EVENT(dealPortfolio, "orderId", _orderId, "orderInfo", &ord.toJson()[0]);
    }
    
    EXPORT void PortfolioManage::revocationOrder(char* _portfolioName, char* _orderId){
        u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
std::string pInfo = portfolioStorge.get()[_portfolioName];
        
        
        PortfolioInfo info;
        info.parseJson(pInfo);
        Order ord = info.getOrder(_orderId);
        
        
        if(ord.orderId != "" && ord.orderStatus == 0){
            std::string callerStr = caller().toString();
            
            
            
            DipcAssert(info.getOwnerAddress() == caller().toString());
            

            uint64_t timenow = dipc::timestamp();
            if(ord.endTime > timenow){
                ord.orderStatus = 2;
            }else {
                ord.orderStatus = 3;
            }
        } else {
            return;
        }
        uint64_t lockToken = 0;
        if(ord.orderType == 1){
            lockToken = ord.stockPrice * ord.stockAmount;
        }
        uint64_t currentBalance =  portfolioBalance.get()[_portfolioName];
        
        
        
        

        DipcAssert(currentBalance + lockToken >= currentBalance);
        DipcAssert(ownerTotalToken.get() - lockToken <= ownerTotalToken.get());

        
        (*portfolioBalance)[_portfolioName] = currentBalance + lockToken;
        *ownerTotalToken = ownerTotalToken.get() - lockToken;
        (*portfolioStorge)[_portfolioName] = &info.toJson()[0];
        DIPC_EMIT_EVENT(revocationPortfolio, "orderId", _orderId, "orderInfo", &ord.toJson()[0]);
    }
    
    EXPORT void PortfolioManage::withdrawPortfolio(char* _portfolioName, uint64_t _withdrawBalance){
         if(!userCanWithdraw.get()){
             return;
         }
         uint64_t currentBalance =  portfolioBalance.get()[_portfolioName];
         DipcAssert(currentBalance - _withdrawBalance < currentBalance);
         auto coinBalance = changeUint64ToU256WithChangeRate(currentBalance, changeRate.get());
         (*portfolioBalance)[_portfolioName] = currentBalance - _withdrawBalance;
         callTransfer(caller(), coinBalance);
    }
    
    EXPORT void PortfolioManage::withdrawPool(uint64_t _balance){
        isOwner();
        Address ownerAddr = Address(owner.get()); 
        callTransfer(ownerAddr, _balance);
        *ownerTotalToken = ownerTotalToken.get() - _balance * changeRate.get();
        *totalToken = totalToken.get() - _balance * changeRate.get();
        DIPC_EMIT_EVENT(tokenCount, "ownerTotalToken", ownerTotalToken.get(), "totalToken", totalToken.get());
    }
    
    PAYABLE void PortfolioManage::depositPool(uint64_t _depositValue){
        isOwner();
        
        uint64_t tokenBalance = changeU256ToUint64WithChangeRate(callValue(), changeRate.get()); 
        *ownerTotalToken = ownerTotalToken.get() + tokenBalance;
        *totalToken = totalToken.get() + tokenBalance;
        DIPC_EMIT_EVENT(tokenCount, "ownerTotalToken", ownerTotalToken.get(), "totalToken", totalToken.get());
    }
     
    CONSTANT uint64_t PortfolioManage::queryTotalToken(){
        return totalToken.get();
    }

     
    CONSTANT uint64_t PortfolioManage::queryPortfolioBalance(char* _portfolioName){
        return portfolioBalance.get()[_portfolioName];
    }

    
    CONSTANT bool PortfolioManage::queryPortfolioNameIfUsed(char* _portfolioName){
        if(portfolioStorge.get()[_portfolioName] != ""){
            return true;
        } 
        return false;
    }

    
    CONSTANT uint64_t PortfolioManage::queryChangeRate(){
        return changeRate.get();
    }

2019-12-19_15:14:54.101131: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:451] log out out  Export :
    
    EXPORT void PortfolioManage::withdrawPortfolio(char* _portfolioName, uint64_t _withdrawBalance){
         

2019-12-19_15:14:54.101154: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:457] name : withdrawPortfolio   pos1  0

2019-12-19_15:14:54.101167: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:469] pos2  7178   pos1  7178

2019-12-19_15:14:54.101174: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:500] pos2 after 7732   pos1  7178

2019-12-19_15:14:54.101182: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:509] finalContract  first #include "PortfolioManage.hpp"

    
    PAYABLE void PortfolioManage::init(){
        *owner = caller().toString();
        *changeRate = 10000;
        *userCanWithdraw = false;
        uint64_t tokenBalance = getTotalBalance();
        
        *ownerTotalToken = tokenBalance;
        *totalToken = ownerTotalToken.get();
        
        
        DIPC_EMIT_EVENT(initEvent, "ownerTotalToken" ,tokenBalance);
    }
    
     
    EXPORT void PortfolioManage::setChangeRate(uint64_t _changeRate){
        isOwner();
        *changeRate = _changeRate;
    }
     
    EXPORT void PortfolioManage::setUserCanWithdraw(bool _canWithdraw){
        u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
isOwner();
        *userCanWithdraw = _canWithdraw;
    }

    
    PAYABLE void PortfolioManage::createPortfolio(char* _portfolioName, char* _portfolioDesc){
        if(portfolioStorge.get()[_portfolioName] != ""){
            DIPC_EMIT_EVENT(ErrEvent, "Current portfolio exist: ", _portfolioName);
            return;
        } 
        std::string callerAddr = caller().toString();
        uint64_t tokenBalance = getTotalBalance();
        
        PortfolioInfo info(_portfolioName, _portfolioDesc, &callerAddr[0]);
        std::string portfolioStr = info.toJson();
        
        
        

        (*portfolioStorge)[_portfolioName] = portfolioStr;
        DipcAssert(totalToken.get() + tokenBalance > totalToken);
        (*portfolioBalance)[_portfolioName] = tokenBalance;
        *totalToken = totalToken.get() + tokenBalance; 
        
        DIPC_EMIT_EVENT(portfolioInfo, _portfolioName, &portfolioStr[0], "portfolioBalance", tokenBalance);
    }

    
    PAYABLE void PortfolioManage::depositPortfolio(char* _portfolioName){
        uint64_t tokenBalance = getTotalBalance();
        
        uint64_t currentBalance = portfolioBalance.get()[_portfolioName];
        uint64_t finalBalance  = currentBalance + tokenBalance;
        DipcAssert(totalToken.get() + tokenBalance > totalToken);
        DipcAssert(finalBalance > currentBalance);
        (*portfolioBalance)[_portfolioName] = finalBalance;
        *totalToken = totalToken.get() + finalBalance; 
        DIPC_EMIT_EVENT(depositPortfolio, "portfolioName", _portfolioName, "portfolioBalance", finalBalance);
    }
    
    PAYABLE void PortfolioManage::createOrder(char* _portfolioName, char* _orderId, uint16_t _orderType, char* _stockCode, uint64_t _stockPrice, uint64_t _stockAmount, uint64_t _endTime){
        uint64_t tokenBalance = getTotalBalance();
        DIPC_EMIT_EVENT(createOrder, "portfolioName", _portfolioName, "OrderInfo", "ignore", "tokenBalance", tokenBalance);
        uint64_t spent = 0;
        if(_orderType == 1){
            spent = _stockPrice * _stockAmount;
            DipcAssert((portfolioBalance.get()[_portfolioName] + tokenBalance) > spent);
        }
        struct Order order{_orderId, _orderType, _stockCode, _stockPrice, _stockAmount, _endTime, 0};
        std::string pInfo = portfolioStorge.get()[_portfolioName];
        
        
        
        if(pInfo == "") {
            DIPC_EMIT_EVENT(ErrEvent, "Current portfolio  doesn't exist: ", _portfolioName);
            return;
        }
        PortfolioInfo info;
        info.parseJson(pInfo);
        if(info.getOrder(_orderId).orderId != ""){
            DIPC_EMIT_EVENT(ErrEvent, "Current order exist: ", _orderId);
            return;
        }
        info.addOrder(order);
        pInfo = info.toJson();

        uint64_t currentBalance = portfolioBalance.get()[_portfolioName] ;
        uint64_t finalBalance = currentBalance + tokenBalance - spent;
        DipcAssert(totalToken.get() + tokenBalance > totalToken);
        
        DipcAssert(ownerTotalToken.get() < ownerTotalToken.get() + spent);
        (*portfolioStorge)[_portfolioName] = &pInfo[0];
        
        
        
        


        (*portfolioBalance)[_portfolioName] = finalBalance;
        *totalToken = totalToken.get() + finalBalance; 
        *ownerTotalToken = ownerTotalToken.get() + spent;
        DIPC_EMIT_EVENT(createOrder, "portfolioName", _portfolioName, "OrderInfo", &order.toJson()[0], "portfolioBalance", finalBalance);
    }

    
    EXPORT void PortfolioManage::dealOrder(char* _portfolioName, char* _orderId){
        u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
isOwner();
        std::string pInfo = portfolioStorge.get()[_portfolioName];
        
        
        PortfolioInfo info;
        info.parseJson(pInfo);
        

        
         Order ord = info.getOrder(_orderId);
         
         
        if(ord.orderId != "" && ord.orderStatus == 0){
            
            uint64_t timenow = dipc::timestamp();
            if(ord.endTime > timenow){
                ord.orderStatus = 1;
            }else {
                ord.orderStatus = 3;
            }
        } else {
          

            return;
        }
        

        uint64_t sellValue = 0;
        if(ord.orderType == 0){
            sellValue = ord.stockAmount * ord.stockPrice;
        }
        uint64_t currentBalance =  portfolioBalance.get()[_portfolioName];
        

        DipcAssert(currentBalance + sellValue >= currentBalance);
        DipcAssert((ownerTotalToken.get() - sellValue) <= ownerTotalToken.get());
        


        (*portfolioBalance)[_portfolioName] = currentBalance + sellValue;
        *ownerTotalToken = ownerTotalToken.get() - sellValue;
        (*portfolioStorge)[_portfolioName] = &info.toJson()[0];
        
        
        
        

        DIPC_EMIT_EVENT(dealPortfolio, "orderId", _orderId, "orderInfo", &ord.toJson()[0]);
    }
    
    EXPORT void PortfolioManage::revocationOrder(char* _portfolioName, char* _orderId){
        u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
std::string pInfo = portfolioStorge.get()[_portfolioName];
        
        
        PortfolioInfo info;
        info.parseJson(pInfo);
        Order ord = info.getOrder(_orderId);
        
        
        if(ord.orderId != "" && ord.orderStatus == 0){
            std::string callerStr = caller().toString();
            
            
            
            DipcAssert(info.getOwnerAddress() == caller().toString());
            

            uint64_t timenow = dipc::timestamp();
            if(ord.endTime > timenow){
                ord.orderStatus = 2;
            }else {
                ord.orderStatus = 3;
            }
        } else {
            return;
        }
        uint64_t lockToken = 0;
        if(ord.orderType == 1){
            lockToken = ord.stockPrice * ord.stockAmount;
        }
        uint64_t currentBalance =  portfolioBalance.get()[_portfolioName];
        
        
        
        

        DipcAssert(currentBalance + lockToken >= currentBalance);
        DipcAssert(ownerTotalToken.get() - lockToken <= ownerTotalToken.get());

        
        (*portfolioBalance)[_portfolioName] = currentBalance + lockToken;
        *ownerTotalToken = ownerTotalToken.get() - lockToken;
        (*portfolioStorge)[_portfolioName] = &info.toJson()[0];
        DIPC_EMIT_EVENT(revocationPortfolio, "orderId", _orderId, "orderInfo", &ord.toJson()[0]);
    }

2019-12-19_15:14:54.101191: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:510] codetext  first #include "PortfolioManage.hpp"

    
    PAYABLE void PortfolioManage::init(){
        *owner = caller().toString();
        *changeRate = 10000;
        *userCanWithdraw = false;
        uint64_t tokenBalance = getTotalBalance();
        
        *ownerTotalToken = tokenBalance;
        *totalToken = ownerTotalToken.get();
        
        
        DIPC_EMIT_EVENT(initEvent, "ownerTotalToken" ,tokenBalance);
    }
    
     
    EXPORT void PortfolioManage::setChangeRate(uint64_t _changeRate){
        isOwner();
        *changeRate = _changeRate;
    }
     
    EXPORT void PortfolioManage::setUserCanWithdraw(bool _canWithdraw){
        u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
isOwner();
        *userCanWithdraw = _canWithdraw;
    }

    
    PAYABLE void PortfolioManage::createPortfolio(char* _portfolioName, char* _portfolioDesc){
        if(portfolioStorge.get()[_portfolioName] != ""){
            DIPC_EMIT_EVENT(ErrEvent, "Current portfolio exist: ", _portfolioName);
            return;
        } 
        std::string callerAddr = caller().toString();
        uint64_t tokenBalance = getTotalBalance();
        
        PortfolioInfo info(_portfolioName, _portfolioDesc, &callerAddr[0]);
        std::string portfolioStr = info.toJson();
        
        
        

        (*portfolioStorge)[_portfolioName] = portfolioStr;
        DipcAssert(totalToken.get() + tokenBalance > totalToken);
        (*portfolioBalance)[_portfolioName] = tokenBalance;
        *totalToken = totalToken.get() + tokenBalance; 
        
        DIPC_EMIT_EVENT(portfolioInfo, _portfolioName, &portfolioStr[0], "portfolioBalance", tokenBalance);
    }

    
    PAYABLE void PortfolioManage::depositPortfolio(char* _portfolioName){
        uint64_t tokenBalance = getTotalBalance();
        
        uint64_t currentBalance = portfolioBalance.get()[_portfolioName];
        uint64_t finalBalance  = currentBalance + tokenBalance;
        DipcAssert(totalToken.get() + tokenBalance > totalToken);
        DipcAssert(finalBalance > currentBalance);
        (*portfolioBalance)[_portfolioName] = finalBalance;
        *totalToken = totalToken.get() + finalBalance; 
        DIPC_EMIT_EVENT(depositPortfolio, "portfolioName", _portfolioName, "portfolioBalance", finalBalance);
    }
    
    PAYABLE void PortfolioManage::createOrder(char* _portfolioName, char* _orderId, uint16_t _orderType, char* _stockCode, uint64_t _stockPrice, uint64_t _stockAmount, uint64_t _endTime){
        uint64_t tokenBalance = getTotalBalance();
        DIPC_EMIT_EVENT(createOrder, "portfolioName", _portfolioName, "OrderInfo", "ignore", "tokenBalance", tokenBalance);
        uint64_t spent = 0;
        if(_orderType == 1){
            spent = _stockPrice * _stockAmount;
            DipcAssert((portfolioBalance.get()[_portfolioName] + tokenBalance) > spent);
        }
        struct Order order{_orderId, _orderType, _stockCode, _stockPrice, _stockAmount, _endTime, 0};
        std::string pInfo = portfolioStorge.get()[_portfolioName];
        
        
        
        if(pInfo == "") {
            DIPC_EMIT_EVENT(ErrEvent, "Current portfolio  doesn't exist: ", _portfolioName);
            return;
        }
        PortfolioInfo info;
        info.parseJson(pInfo);
        if(info.getOrder(_orderId).orderId != ""){
            DIPC_EMIT_EVENT(ErrEvent, "Current order exist: ", _orderId);
            return;
        }
        info.addOrder(order);
        pInfo = info.toJson();

        uint64_t currentBalance = portfolioBalance.get()[_portfolioName] ;
        uint64_t finalBalance = currentBalance + tokenBalance - spent;
        DipcAssert(totalToken.get() + tokenBalance > totalToken);
        
        DipcAssert(ownerTotalToken.get() < ownerTotalToken.get() + spent);
        (*portfolioStorge)[_portfolioName] = &pInfo[0];
        
        
        
        


        (*portfolioBalance)[_portfolioName] = finalBalance;
        *totalToken = totalToken.get() + finalBalance; 
        *ownerTotalToken = ownerTotalToken.get() + spent;
        DIPC_EMIT_EVENT(createOrder, "portfolioName", _portfolioName, "OrderInfo", &order.toJson()[0], "portfolioBalance", finalBalance);
    }

    
    EXPORT void PortfolioManage::dealOrder(char* _portfolioName, char* _orderId){
        u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
isOwner();
        std::string pInfo = portfolioStorge.get()[_portfolioName];
        
        
        PortfolioInfo info;
        info.parseJson(pInfo);
        

        
         Order ord = info.getOrder(_orderId);
         
         
        if(ord.orderId != "" && ord.orderStatus == 0){
            
            uint64_t timenow = dipc::timestamp();
            if(ord.endTime > timenow){
                ord.orderStatus = 1;
            }else {
                ord.orderStatus = 3;
            }
        } else {
          

            return;
        }
        

        uint64_t sellValue = 0;
        if(ord.orderType == 0){
            sellValue = ord.stockAmount * ord.stockPrice;
        }
        uint64_t currentBalance =  portfolioBalance.get()[_portfolioName];
        

        DipcAssert(currentBalance + sellValue >= currentBalance);
        DipcAssert((ownerTotalToken.get() - sellValue) <= ownerTotalToken.get());
        


        (*portfolioBalance)[_portfolioName] = currentBalance + sellValue;
        *ownerTotalToken = ownerTotalToken.get() - sellValue;
        (*portfolioStorge)[_portfolioName] = &info.toJson()[0];
        
        
        
        

        DIPC_EMIT_EVENT(dealPortfolio, "orderId", _orderId, "orderInfo", &ord.toJson()[0]);
    }
    
    EXPORT void PortfolioManage::revocationOrder(char* _portfolioName, char* _orderId){
        u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
std::string pInfo = portfolioStorge.get()[_portfolioName];
        
        
        PortfolioInfo info;
        info.parseJson(pInfo);
        Order ord = info.getOrder(_orderId);
        
        
        if(ord.orderId != "" && ord.orderStatus == 0){
            std::string callerStr = caller().toString();
            
            
            
            DipcAssert(info.getOwnerAddress() == caller().toString());
            

            uint64_t timenow = dipc::timestamp();
            if(ord.endTime > timenow){
                ord.orderStatus = 2;
            }else {
                ord.orderStatus = 3;
            }
        } else {
            return;
        }
        uint64_t lockToken = 0;
        if(ord.orderType == 1){
            lockToken = ord.stockPrice * ord.stockAmount;
        }
        uint64_t currentBalance =  portfolioBalance.get()[_portfolioName];
        
        
        
        

        DipcAssert(currentBalance + lockToken >= currentBalance);
        DipcAssert(ownerTotalToken.get() - lockToken <= ownerTotalToken.get());

        
        (*portfolioBalance)[_portfolioName] = currentBalance + lockToken;
        *ownerTotalToken = ownerTotalToken.get() - lockToken;
        (*portfolioStorge)[_portfolioName] = &info.toJson()[0];
        DIPC_EMIT_EVENT(revocationPortfolio, "orderId", _orderId, "orderInfo", &ord.toJson()[0]);
    }
    
    EXPORT void PortfolioManage::withdrawPortfolio(char* _portfolioName, uint64_t _withdrawBalance){
         if(!userCanWithdraw.get()){
             return;
         }
         uint64_t currentBalance =  portfolioBalance.get()[_portfolioName];
         DipcAssert(currentBalance - _withdrawBalance < currentBalance);
         auto coinBalance = changeUint64ToU256WithChangeRate(currentBalance, changeRate.get());
         (*portfolioBalance)[_portfolioName] = currentBalance - _withdrawBalance;
         callTransfer(caller(), coinBalance);
    }
    
    EXPORT void PortfolioManage::withdrawPool(uint64_t _balance){
        isOwner();
        Address ownerAddr = Address(owner.get()); 
        callTransfer(ownerAddr, _balance);
        *ownerTotalToken = ownerTotalToken.get() - _balance * changeRate.get();
        *totalToken = totalToken.get() - _balance * changeRate.get();
        DIPC_EMIT_EVENT(tokenCount, "ownerTotalToken", ownerTotalToken.get(), "totalToken", totalToken.get());
    }
    
    PAYABLE void PortfolioManage::depositPool(uint64_t _depositValue){
        isOwner();
        
        uint64_t tokenBalance = changeU256ToUint64WithChangeRate(callValue(), changeRate.get()); 
        *ownerTotalToken = ownerTotalToken.get() + tokenBalance;
        *totalToken = totalToken.get() + tokenBalance;
        DIPC_EMIT_EVENT(tokenCount, "ownerTotalToken", ownerTotalToken.get(), "totalToken", totalToken.get());
    }
     
    CONSTANT uint64_t PortfolioManage::queryTotalToken(){
        return totalToken.get();
    }

     
    CONSTANT uint64_t PortfolioManage::queryPortfolioBalance(char* _portfolioName){
        return portfolioBalance.get()[_portfolioName];
    }

    
    CONSTANT bool PortfolioManage::queryPortfolioNameIfUsed(char* _portfolioName){
        if(portfolioStorge.get()[_portfolioName] != ""){
            return true;
        } 
        return false;
    }

    
    CONSTANT uint64_t PortfolioManage::queryChangeRate(){
        return changeRate.get();
    }

2019-12-19_15:14:54.101257: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:513] s  first 
    
    EXPORT void PortfolioManage::withdrawPortfolio(char* _portfolioName, uint64_t _withdrawBalance){
         if(!userCanWithdraw.get()){
             return;
         }
         uint64_t currentBalance =  portfolioBalance.get()[_portfolioName];
         DipcAssert(currentBalance - _withdrawBalance < currentBalance);
         auto coinBalance = changeUint64ToU256WithChangeRate(currentBalance, changeRate.get());
         (*portfolioBalance)[_portfolioName] = currentBalance - _withdrawBalance;
         callTransfer(caller(), coinBalance);
    }

2019-12-19_15:14:54.101267: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:593] calledFunc temp export: 
    
    EXPORT void PortfolioManage::withdrawPortfolio(char* _portfolioName, uint64_t _withdrawBalance){
         u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
if(!userCanWithdraw.get()){
             return;
         }
         uint64_t currentBalance =  portfolioBalance.get()[_portfolioName];
         DipcAssert(currentBalance - _withdrawBalance < currentBalance);
         auto coinBalance = changeUint64ToU256WithChangeRate(currentBalance, changeRate.get());
         (*portfolioBalance)[_portfolioName] = currentBalance - _withdrawBalance;
         callTransfer(caller(), coinBalance);
    }

2019-12-19_15:14:54.101274: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:599] search func : 
    
    EXPORT void PortfolioManage::withdrawPortfolio(char* _portfolioName, uint64_t _withdrawBalance){
         u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
if(!userCanWithdraw.get()){
             return;
         }
         uint64_t currentBalance =  portfolioBalance.get()[_portfolioName];
         DipcAssert(currentBalance - _withdrawBalance < currentBalance);
         auto coinBalance = changeUint64ToU256WithChangeRate(currentBalance, changeRate.get());
         (*portfolioBalance)[_portfolioName] = currentBalance - _withdrawBalance;
         callTransfer(caller(), coinBalance);
    }
2019-12-19_15:14:54.101281: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:424] finalContract  this height  #include "PortfolioManage.hpp"

    
    PAYABLE void PortfolioManage::init(){
        *owner = caller().toString();
        *changeRate = 10000;
        *userCanWithdraw = false;
        uint64_t tokenBalance = getTotalBalance();
        
        *ownerTotalToken = tokenBalance;
        *totalToken = ownerTotalToken.get();
        
        
        DIPC_EMIT_EVENT(initEvent, "ownerTotalToken" ,tokenBalance);
    }
    
     
    EXPORT void PortfolioManage::setChangeRate(uint64_t _changeRate){
        isOwner();
        *changeRate = _changeRate;
    }
     
    EXPORT void PortfolioManage::setUserCanWithdraw(bool _canWithdraw){
        u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
isOwner();
        *userCanWithdraw = _canWithdraw;
    }

    
    PAYABLE void PortfolioManage::createPortfolio(char* _portfolioName, char* _portfolioDesc){
        if(portfolioStorge.get()[_portfolioName] != ""){
            DIPC_EMIT_EVENT(ErrEvent, "Current portfolio exist: ", _portfolioName);
            return;
        } 
        std::string callerAddr = caller().toString();
        uint64_t tokenBalance = getTotalBalance();
        
        PortfolioInfo info(_portfolioName, _portfolioDesc, &callerAddr[0]);
        std::string portfolioStr = info.toJson();
        
        
        

        (*portfolioStorge)[_portfolioName] = portfolioStr;
        DipcAssert(totalToken.get() + tokenBalance > totalToken);
        (*portfolioBalance)[_portfolioName] = tokenBalance;
        *totalToken = totalToken.get() + tokenBalance; 
        
        DIPC_EMIT_EVENT(portfolioInfo, _portfolioName, &portfolioStr[0], "portfolioBalance", tokenBalance);
    }

    
    PAYABLE void PortfolioManage::depositPortfolio(char* _portfolioName){
        uint64_t tokenBalance = getTotalBalance();
        
        uint64_t currentBalance = portfolioBalance.get()[_portfolioName];
        uint64_t finalBalance  = currentBalance + tokenBalance;
        DipcAssert(totalToken.get() + tokenBalance > totalToken);
        DipcAssert(finalBalance > currentBalance);
        (*portfolioBalance)[_portfolioName] = finalBalance;
        *totalToken = totalToken.get() + finalBalance; 
        DIPC_EMIT_EVENT(depositPortfolio, "portfolioName", _portfolioName, "portfolioBalance", finalBalance);
    }
    
    PAYABLE void PortfolioManage::createOrder(char* _portfolioName, char* _orderId, uint16_t _orderType, char* _stockCode, uint64_t _stockPrice, uint64_t _stockAmount, uint64_t _endTime){
        uint64_t tokenBalance = getTotalBalance();
        DIPC_EMIT_EVENT(createOrder, "portfolioName", _portfolioName, "OrderInfo", "ignore", "tokenBalance", tokenBalance);
        uint64_t spent = 0;
        if(_orderType == 1){
            spent = _stockPrice * _stockAmount;
            DipcAssert((portfolioBalance.get()[_portfolioName] + tokenBalance) > spent);
        }
        struct Order order{_orderId, _orderType, _stockCode, _stockPrice, _stockAmount, _endTime, 0};
        std::string pInfo = portfolioStorge.get()[_portfolioName];
        
        
        
        if(pInfo == "") {
            DIPC_EMIT_EVENT(ErrEvent, "Current portfolio  doesn't exist: ", _portfolioName);
            return;
        }
        PortfolioInfo info;
        info.parseJson(pInfo);
        if(info.getOrder(_orderId).orderId != ""){
            DIPC_EMIT_EVENT(ErrEvent, "Current order exist: ", _orderId);
            return;
        }
        info.addOrder(order);
        pInfo = info.toJson();

        uint64_t currentBalance = portfolioBalance.get()[_portfolioName] ;
        uint64_t finalBalance = currentBalance + tokenBalance - spent;
        DipcAssert(totalToken.get() + tokenBalance > totalToken);
        
        DipcAssert(ownerTotalToken.get() < ownerTotalToken.get() + spent);
        (*portfolioStorge)[_portfolioName] = &pInfo[0];
        
        
        
        


        (*portfolioBalance)[_portfolioName] = finalBalance;
        *totalToken = totalToken.get() + finalBalance; 
        *ownerTotalToken = ownerTotalToken.get() + spent;
        DIPC_EMIT_EVENT(createOrder, "portfolioName", _portfolioName, "OrderInfo", &order.toJson()[0], "portfolioBalance", finalBalance);
    }

    
    EXPORT void PortfolioManage::dealOrder(char* _portfolioName, char* _orderId){
        u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
isOwner();
        std::string pInfo = portfolioStorge.get()[_portfolioName];
        
        
        PortfolioInfo info;
        info.parseJson(pInfo);
        

        
         Order ord = info.getOrder(_orderId);
         
         
        if(ord.orderId != "" && ord.orderStatus == 0){
            
            uint64_t timenow = dipc::timestamp();
            if(ord.endTime > timenow){
                ord.orderStatus = 1;
            }else {
                ord.orderStatus = 3;
            }
        } else {
          

            return;
        }
        

        uint64_t sellValue = 0;
        if(ord.orderType == 0){
            sellValue = ord.stockAmount * ord.stockPrice;
        }
        uint64_t currentBalance =  portfolioBalance.get()[_portfolioName];
        

        DipcAssert(currentBalance + sellValue >= currentBalance);
        DipcAssert((ownerTotalToken.get() - sellValue) <= ownerTotalToken.get());
        


        (*portfolioBalance)[_portfolioName] = currentBalance + sellValue;
        *ownerTotalToken = ownerTotalToken.get() - sellValue;
        (*portfolioStorge)[_portfolioName] = &info.toJson()[0];
        
        
        
        

        DIPC_EMIT_EVENT(dealPortfolio, "orderId", _orderId, "orderInfo", &ord.toJson()[0]);
    }
    
    EXPORT void PortfolioManage::revocationOrder(char* _portfolioName, char* _orderId){
        u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
std::string pInfo = portfolioStorge.get()[_portfolioName];
        
        
        PortfolioInfo info;
        info.parseJson(pInfo);
        Order ord = info.getOrder(_orderId);
        
        
        if(ord.orderId != "" && ord.orderStatus == 0){
            std::string callerStr = caller().toString();
            
            
            
            DipcAssert(info.getOwnerAddress() == caller().toString());
            

            uint64_t timenow = dipc::timestamp();
            if(ord.endTime > timenow){
                ord.orderStatus = 2;
            }else {
                ord.orderStatus = 3;
            }
        } else {
            return;
        }
        uint64_t lockToken = 0;
        if(ord.orderType == 1){
            lockToken = ord.stockPrice * ord.stockAmount;
        }
        uint64_t currentBalance =  portfolioBalance.get()[_portfolioName];
        
        
        
        

        DipcAssert(currentBalance + lockToken >= currentBalance);
        DipcAssert(ownerTotalToken.get() - lockToken <= ownerTotalToken.get());

        
        (*portfolioBalance)[_portfolioName] = currentBalance + lockToken;
        *ownerTotalToken = ownerTotalToken.get() - lockToken;
        (*portfolioStorge)[_portfolioName] = &info.toJson()[0];
        DIPC_EMIT_EVENT(revocationPortfolio, "orderId", _orderId, "orderInfo", &ord.toJson()[0]);
    }
    
    EXPORT void PortfolioManage::withdrawPortfolio(char* _portfolioName, uint64_t _withdrawBalance){
         u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
if(!userCanWithdraw.get()){
             return;
         }
         uint64_t currentBalance =  portfolioBalance.get()[_portfolioName];
         DipcAssert(currentBalance - _withdrawBalance < currentBalance);
         auto coinBalance = changeUint64ToU256WithChangeRate(currentBalance, changeRate.get());
         (*portfolioBalance)[_portfolioName] = currentBalance - _withdrawBalance;
         callTransfer(caller(), coinBalance);
    } codetext height #include "PortfolioManage.hpp"

    
    PAYABLE void PortfolioManage::init(){
        *owner = caller().toString();
        *changeRate = 10000;
        *userCanWithdraw = false;
        uint64_t tokenBalance = getTotalBalance();
        
        *ownerTotalToken = tokenBalance;
        *totalToken = ownerTotalToken.get();
        
        
        DIPC_EMIT_EVENT(initEvent, "ownerTotalToken" ,tokenBalance);
    }
    
     
    EXPORT void PortfolioManage::setChangeRate(uint64_t _changeRate){
        isOwner();
        *changeRate = _changeRate;
    }
     
    EXPORT void PortfolioManage::setUserCanWithdraw(bool _canWithdraw){
        u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
isOwner();
        *userCanWithdraw = _canWithdraw;
    }

    
    PAYABLE void PortfolioManage::createPortfolio(char* _portfolioName, char* _portfolioDesc){
        if(portfolioStorge.get()[_portfolioName] != ""){
            DIPC_EMIT_EVENT(ErrEvent, "Current portfolio exist: ", _portfolioName);
            return;
        } 
        std::string callerAddr = caller().toString();
        uint64_t tokenBalance = getTotalBalance();
        
        PortfolioInfo info(_portfolioName, _portfolioDesc, &callerAddr[0]);
        std::string portfolioStr = info.toJson();
        
        
        

        (*portfolioStorge)[_portfolioName] = portfolioStr;
        DipcAssert(totalToken.get() + tokenBalance > totalToken);
        (*portfolioBalance)[_portfolioName] = tokenBalance;
        *totalToken = totalToken.get() + tokenBalance; 
        
        DIPC_EMIT_EVENT(portfolioInfo, _portfolioName, &portfolioStr[0], "portfolioBalance", tokenBalance);
    }

    
    PAYABLE void PortfolioManage::depositPortfolio(char* _portfolioName){
        uint64_t tokenBalance = getTotalBalance();
        
        uint64_t currentBalance = portfolioBalance.get()[_portfolioName];
        uint64_t finalBalance  = currentBalance + tokenBalance;
        DipcAssert(totalToken.get() + tokenBalance > totalToken);
        DipcAssert(finalBalance > currentBalance);
        (*portfolioBalance)[_portfolioName] = finalBalance;
        *totalToken = totalToken.get() + finalBalance; 
        DIPC_EMIT_EVENT(depositPortfolio, "portfolioName", _portfolioName, "portfolioBalance", finalBalance);
    }
    
    PAYABLE void PortfolioManage::createOrder(char* _portfolioName, char* _orderId, uint16_t _orderType, char* _stockCode, uint64_t _stockPrice, uint64_t _stockAmount, uint64_t _endTime){
        uint64_t tokenBalance = getTotalBalance();
        DIPC_EMIT_EVENT(createOrder, "portfolioName", _portfolioName, "OrderInfo", "ignore", "tokenBalance", tokenBalance);
        uint64_t spent = 0;
        if(_orderType == 1){
            spent = _stockPrice * _stockAmount;
            DipcAssert((portfolioBalance.get()[_portfolioName] + tokenBalance) > spent);
        }
        struct Order order{_orderId, _orderType, _stockCode, _stockPrice, _stockAmount, _endTime, 0};
        std::string pInfo = portfolioStorge.get()[_portfolioName];
        
        
        
        if(pInfo == "") {
            DIPC_EMIT_EVENT(ErrEvent, "Current portfolio  doesn't exist: ", _portfolioName);
            return;
        }
        PortfolioInfo info;
        info.parseJson(pInfo);
        if(info.getOrder(_orderId).orderId != ""){
            DIPC_EMIT_EVENT(ErrEvent, "Current order exist: ", _orderId);
            return;
        }
        info.addOrder(order);
        pInfo = info.toJson();

        uint64_t currentBalance = portfolioBalance.get()[_portfolioName] ;
        uint64_t finalBalance = currentBalance + tokenBalance - spent;
        DipcAssert(totalToken.get() + tokenBalance > totalToken);
        
        DipcAssert(ownerTotalToken.get() < ownerTotalToken.get() + spent);
        (*portfolioStorge)[_portfolioName] = &pInfo[0];
        
        
        
        


        (*portfolioBalance)[_portfolioName] = finalBalance;
        *totalToken = totalToken.get() + finalBalance; 
        *ownerTotalToken = ownerTotalToken.get() + spent;
        DIPC_EMIT_EVENT(createOrder, "portfolioName", _portfolioName, "OrderInfo", &order.toJson()[0], "portfolioBalance", finalBalance);
    }

    
    EXPORT void PortfolioManage::dealOrder(char* _portfolioName, char* _orderId){
        u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
isOwner();
        std::string pInfo = portfolioStorge.get()[_portfolioName];
        
        
        PortfolioInfo info;
        info.parseJson(pInfo);
        

        
         Order ord = info.getOrder(_orderId);
         
         
        if(ord.orderId != "" && ord.orderStatus == 0){
            
            uint64_t timenow = dipc::timestamp();
            if(ord.endTime > timenow){
                ord.orderStatus = 1;
            }else {
                ord.orderStatus = 3;
            }
        } else {
          

            return;
        }
        

        uint64_t sellValue = 0;
        if(ord.orderType == 0){
            sellValue = ord.stockAmount * ord.stockPrice;
        }
        uint64_t currentBalance =  portfolioBalance.get()[_portfolioName];
        

        DipcAssert(currentBalance + sellValue >= currentBalance);
        DipcAssert((ownerTotalToken.get() - sellValue) <= ownerTotalToken.get());
        


        (*portfolioBalance)[_portfolioName] = currentBalance + sellValue;
        *ownerTotalToken = ownerTotalToken.get() - sellValue;
        (*portfolioStorge)[_portfolioName] = &info.toJson()[0];
        
        
        
        

        DIPC_EMIT_EVENT(dealPortfolio, "orderId", _orderId, "orderInfo", &ord.toJson()[0]);
    }
    
    EXPORT void PortfolioManage::revocationOrder(char* _portfolioName, char* _orderId){
        u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
std::string pInfo = portfolioStorge.get()[_portfolioName];
        
        
        PortfolioInfo info;
        info.parseJson(pInfo);
        Order ord = info.getOrder(_orderId);
        
        
        if(ord.orderId != "" && ord.orderStatus == 0){
            std::string callerStr = caller().toString();
            
            
            
            DipcAssert(info.getOwnerAddress() == caller().toString());
            

            uint64_t timenow = dipc::timestamp();
            if(ord.endTime > timenow){
                ord.orderStatus = 2;
            }else {
                ord.orderStatus = 3;
            }
        } else {
            return;
        }
        uint64_t lockToken = 0;
        if(ord.orderType == 1){
            lockToken = ord.stockPrice * ord.stockAmount;
        }
        uint64_t currentBalance =  portfolioBalance.get()[_portfolioName];
        
        
        
        

        DipcAssert(currentBalance + lockToken >= currentBalance);
        DipcAssert(ownerTotalToken.get() - lockToken <= ownerTotalToken.get());

        
        (*portfolioBalance)[_portfolioName] = currentBalance + lockToken;
        *ownerTotalToken = ownerTotalToken.get() - lockToken;
        (*portfolioStorge)[_portfolioName] = &info.toJson()[0];
        DIPC_EMIT_EVENT(revocationPortfolio, "orderId", _orderId, "orderInfo", &ord.toJson()[0]);
    }
    
    EXPORT void PortfolioManage::withdrawPortfolio(char* _portfolioName, uint64_t _withdrawBalance){
         if(!userCanWithdraw.get()){
             return;
         }
         uint64_t currentBalance =  portfolioBalance.get()[_portfolioName];
         DipcAssert(currentBalance - _withdrawBalance < currentBalance);
         auto coinBalance = changeUint64ToU256WithChangeRate(currentBalance, changeRate.get());
         (*portfolioBalance)[_portfolioName] = currentBalance - _withdrawBalance;
         callTransfer(caller(), coinBalance);
    }
    
    EXPORT void PortfolioManage::withdrawPool(uint64_t _balance){
        isOwner();
        Address ownerAddr = Address(owner.get()); 
        callTransfer(ownerAddr, _balance);
        *ownerTotalToken = ownerTotalToken.get() - _balance * changeRate.get();
        *totalToken = totalToken.get() - _balance * changeRate.get();
        DIPC_EMIT_EVENT(tokenCount, "ownerTotalToken", ownerTotalToken.get(), "totalToken", totalToken.get());
    }
    
    PAYABLE void PortfolioManage::depositPool(uint64_t _depositValue){
        isOwner();
        
        uint64_t tokenBalance = changeU256ToUint64WithChangeRate(callValue(), changeRate.get()); 
        *ownerTotalToken = ownerTotalToken.get() + tokenBalance;
        *totalToken = totalToken.get() + tokenBalance;
        DIPC_EMIT_EVENT(tokenCount, "ownerTotalToken", ownerTotalToken.get(), "totalToken", totalToken.get());
    }
     
    CONSTANT uint64_t PortfolioManage::queryTotalToken(){
        return totalToken.get();
    }

     
    CONSTANT uint64_t PortfolioManage::queryPortfolioBalance(char* _portfolioName){
        return portfolioBalance.get()[_portfolioName];
    }

    
    CONSTANT bool PortfolioManage::queryPortfolioNameIfUsed(char* _portfolioName){
        if(portfolioStorge.get()[_portfolioName] != ""){
            return true;
        } 
        return false;
    }

    
    CONSTANT uint64_t PortfolioManage::queryChangeRate(){
        return changeRate.get();
    }

2019-12-19_15:14:54.101292: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:427] searchContext  
    
    EXPORT void PortfolioManage::withdrawPool(uint64_t _balance){
        isOwner();
        Address ownerAddr = Address(owner.get()); 
        callTransfer(ownerAddr, _balance);
        *ownerTotalToken = ownerTotalToken.get() - _balance * changeRate.get();
        *totalToken = totalToken.get() - _balance * changeRate.get();
        DIPC_EMIT_EVENT(tokenCount, "ownerTotalToken", ownerTotalToken.get(), "totalToken", totalToken.get());
    }
    
    PAYABLE void PortfolioManage::depositPool(uint64_t _depositValue){
        isOwner();
        
        uint64_t tokenBalance = changeU256ToUint64WithChangeRate(callValue(), changeRate.get()); 
        *ownerTotalToken = ownerTotalToken.get() + tokenBalance;
        *totalToken = totalToken.get() + tokenBalance;
        DIPC_EMIT_EVENT(tokenCount, "ownerTotalToken", ownerTotalToken.get(), "totalToken", totalToken.get());
    }
     
    CONSTANT uint64_t PortfolioManage::queryTotalToken(){
        return totalToken.get();
    }

     
    CONSTANT uint64_t PortfolioManage::queryPortfolioBalance(char* _portfolioName){
        return portfolioBalance.get()[_portfolioName];
    }

    
    CONSTANT bool PortfolioManage::queryPortfolioNameIfUsed(char* _portfolioName){
        if(portfolioStorge.get()[_portfolioName] != ""){
            return true;
        } 
        return false;
    }

    
    CONSTANT uint64_t PortfolioManage::queryChangeRate(){
        return changeRate.get();
    }

2019-12-19_15:14:54.129015: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:442] finalContract  this new  #include "PortfolioManage.hpp"

    
    PAYABLE void PortfolioManage::init(){
        *owner = caller().toString();
        *changeRate = 10000;
        *userCanWithdraw = false;
        uint64_t tokenBalance = getTotalBalance();
        
        *ownerTotalToken = tokenBalance;
        *totalToken = ownerTotalToken.get();
        
        
        DIPC_EMIT_EVENT(initEvent, "ownerTotalToken" ,tokenBalance);
    }
    
     
    EXPORT void PortfolioManage::setChangeRate(uint64_t _changeRate){
        isOwner();
        *changeRate = _changeRate;
    }
     
    EXPORT void PortfolioManage::setUserCanWithdraw(bool _canWithdraw){
        u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
isOwner();
        *userCanWithdraw = _canWithdraw;
    }

    
    PAYABLE void PortfolioManage::createPortfolio(char* _portfolioName, char* _portfolioDesc){
        if(portfolioStorge.get()[_portfolioName] != ""){
            DIPC_EMIT_EVENT(ErrEvent, "Current portfolio exist: ", _portfolioName);
            return;
        } 
        std::string callerAddr = caller().toString();
        uint64_t tokenBalance = getTotalBalance();
        
        PortfolioInfo info(_portfolioName, _portfolioDesc, &callerAddr[0]);
        std::string portfolioStr = info.toJson();
        
        
        

        (*portfolioStorge)[_portfolioName] = portfolioStr;
        DipcAssert(totalToken.get() + tokenBalance > totalToken);
        (*portfolioBalance)[_portfolioName] = tokenBalance;
        *totalToken = totalToken.get() + tokenBalance; 
        
        DIPC_EMIT_EVENT(portfolioInfo, _portfolioName, &portfolioStr[0], "portfolioBalance", tokenBalance);
    }

    
    PAYABLE void PortfolioManage::depositPortfolio(char* _portfolioName){
        uint64_t tokenBalance = getTotalBalance();
        
        uint64_t currentBalance = portfolioBalance.get()[_portfolioName];
        uint64_t finalBalance  = currentBalance + tokenBalance;
        DipcAssert(totalToken.get() + tokenBalance > totalToken);
        DipcAssert(finalBalance > currentBalance);
        (*portfolioBalance)[_portfolioName] = finalBalance;
        *totalToken = totalToken.get() + finalBalance; 
        DIPC_EMIT_EVENT(depositPortfolio, "portfolioName", _portfolioName, "portfolioBalance", finalBalance);
    }
    
    PAYABLE void PortfolioManage::createOrder(char* _portfolioName, char* _orderId, uint16_t _orderType, char* _stockCode, uint64_t _stockPrice, uint64_t _stockAmount, uint64_t _endTime){
        uint64_t tokenBalance = getTotalBalance();
        DIPC_EMIT_EVENT(createOrder, "portfolioName", _portfolioName, "OrderInfo", "ignore", "tokenBalance", tokenBalance);
        uint64_t spent = 0;
        if(_orderType == 1){
            spent = _stockPrice * _stockAmount;
            DipcAssert((portfolioBalance.get()[_portfolioName] + tokenBalance) > spent);
        }
        struct Order order{_orderId, _orderType, _stockCode, _stockPrice, _stockAmount, _endTime, 0};
        std::string pInfo = portfolioStorge.get()[_portfolioName];
        
        
        
        if(pInfo == "") {
            DIPC_EMIT_EVENT(ErrEvent, "Current portfolio  doesn't exist: ", _portfolioName);
            return;
        }
        PortfolioInfo info;
        info.parseJson(pInfo);
        if(info.getOrder(_orderId).orderId != ""){
            DIPC_EMIT_EVENT(ErrEvent, "Current order exist: ", _orderId);
            return;
        }
        info.addOrder(order);
        pInfo = info.toJson();

        uint64_t currentBalance = portfolioBalance.get()[_portfolioName] ;
        uint64_t finalBalance = currentBalance + tokenBalance - spent;
        DipcAssert(totalToken.get() + tokenBalance > totalToken);
        
        DipcAssert(ownerTotalToken.get() < ownerTotalToken.get() + spent);
        (*portfolioStorge)[_portfolioName] = &pInfo[0];
        
        
        
        


        (*portfolioBalance)[_portfolioName] = finalBalance;
        *totalToken = totalToken.get() + finalBalance; 
        *ownerTotalToken = ownerTotalToken.get() + spent;
        DIPC_EMIT_EVENT(createOrder, "portfolioName", _portfolioName, "OrderInfo", &order.toJson()[0], "portfolioBalance", finalBalance);
    }

    
    EXPORT void PortfolioManage::dealOrder(char* _portfolioName, char* _orderId){
        u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
isOwner();
        std::string pInfo = portfolioStorge.get()[_portfolioName];
        
        
        PortfolioInfo info;
        info.parseJson(pInfo);
        

        
         Order ord = info.getOrder(_orderId);
         
         
        if(ord.orderId != "" && ord.orderStatus == 0){
            
            uint64_t timenow = dipc::timestamp();
            if(ord.endTime > timenow){
                ord.orderStatus = 1;
            }else {
                ord.orderStatus = 3;
            }
        } else {
          

            return;
        }
        

        uint64_t sellValue = 0;
        if(ord.orderType == 0){
            sellValue = ord.stockAmount * ord.stockPrice;
        }
        uint64_t currentBalance =  portfolioBalance.get()[_portfolioName];
        

        DipcAssert(currentBalance + sellValue >= currentBalance);
        DipcAssert((ownerTotalToken.get() - sellValue) <= ownerTotalToken.get());
        


        (*portfolioBalance)[_portfolioName] = currentBalance + sellValue;
        *ownerTotalToken = ownerTotalToken.get() - sellValue;
        (*portfolioStorge)[_portfolioName] = &info.toJson()[0];
        
        
        
        

        DIPC_EMIT_EVENT(dealPortfolio, "orderId", _orderId, "orderInfo", &ord.toJson()[0]);
    }
    
    EXPORT void PortfolioManage::revocationOrder(char* _portfolioName, char* _orderId){
        u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
std::string pInfo = portfolioStorge.get()[_portfolioName];
        
        
        PortfolioInfo info;
        info.parseJson(pInfo);
        Order ord = info.getOrder(_orderId);
        
        
        if(ord.orderId != "" && ord.orderStatus == 0){
            std::string callerStr = caller().toString();
            
            
            
            DipcAssert(info.getOwnerAddress() == caller().toString());
            

            uint64_t timenow = dipc::timestamp();
            if(ord.endTime > timenow){
                ord.orderStatus = 2;
            }else {
                ord.orderStatus = 3;
            }
        } else {
            return;
        }
        uint64_t lockToken = 0;
        if(ord.orderType == 1){
            lockToken = ord.stockPrice * ord.stockAmount;
        }
        uint64_t currentBalance =  portfolioBalance.get()[_portfolioName];
        
        
        
        

        DipcAssert(currentBalance + lockToken >= currentBalance);
        DipcAssert(ownerTotalToken.get() - lockToken <= ownerTotalToken.get());

        
        (*portfolioBalance)[_portfolioName] = currentBalance + lockToken;
        *ownerTotalToken = ownerTotalToken.get() - lockToken;
        (*portfolioStorge)[_portfolioName] = &info.toJson()[0];
        DIPC_EMIT_EVENT(revocationPortfolio, "orderId", _orderId, "orderInfo", &ord.toJson()[0]);
    }
    
    EXPORT void PortfolioManage::withdrawPortfolio(char* _portfolioName, uint64_t _withdrawBalance){
         u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
if(!userCanWithdraw.get()){
             return;
         }
         uint64_t currentBalance =  portfolioBalance.get()[_portfolioName];
         DipcAssert(currentBalance - _withdrawBalance < currentBalance);
         auto coinBalance = changeUint64ToU256WithChangeRate(currentBalance, changeRate.get());
         (*portfolioBalance)[_portfolioName] = currentBalance - _withdrawBalance;
         callTransfer(caller(), coinBalance);
    } codetext new #include "PortfolioManage.hpp"

    
    PAYABLE void PortfolioManage::init(){
        *owner = caller().toString();
        *changeRate = 10000;
        *userCanWithdraw = false;
        uint64_t tokenBalance = getTotalBalance();
        
        *ownerTotalToken = tokenBalance;
        *totalToken = ownerTotalToken.get();
        
        
        DIPC_EMIT_EVENT(initEvent, "ownerTotalToken" ,tokenBalance);
    }
    
     
    EXPORT void PortfolioManage::setChangeRate(uint64_t _changeRate){
        isOwner();
        *changeRate = _changeRate;
    }
     
    EXPORT void PortfolioManage::setUserCanWithdraw(bool _canWithdraw){
        u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
isOwner();
        *userCanWithdraw = _canWithdraw;
    }

    
    PAYABLE void PortfolioManage::createPortfolio(char* _portfolioName, char* _portfolioDesc){
        if(portfolioStorge.get()[_portfolioName] != ""){
            DIPC_EMIT_EVENT(ErrEvent, "Current portfolio exist: ", _portfolioName);
            return;
        } 
        std::string callerAddr = caller().toString();
        uint64_t tokenBalance = getTotalBalance();
        
        PortfolioInfo info(_portfolioName, _portfolioDesc, &callerAddr[0]);
        std::string portfolioStr = info.toJson();
        
        
        

        (*portfolioStorge)[_portfolioName] = portfolioStr;
        DipcAssert(totalToken.get() + tokenBalance > totalToken);
        (*portfolioBalance)[_portfolioName] = tokenBalance;
        *totalToken = totalToken.get() + tokenBalance; 
        
        DIPC_EMIT_EVENT(portfolioInfo, _portfolioName, &portfolioStr[0], "portfolioBalance", tokenBalance);
    }

    
    PAYABLE void PortfolioManage::depositPortfolio(char* _portfolioName){
        uint64_t tokenBalance = getTotalBalance();
        
        uint64_t currentBalance = portfolioBalance.get()[_portfolioName];
        uint64_t finalBalance  = currentBalance + tokenBalance;
        DipcAssert(totalToken.get() + tokenBalance > totalToken);
        DipcAssert(finalBalance > currentBalance);
        (*portfolioBalance)[_portfolioName] = finalBalance;
        *totalToken = totalToken.get() + finalBalance; 
        DIPC_EMIT_EVENT(depositPortfolio, "portfolioName", _portfolioName, "portfolioBalance", finalBalance);
    }
    
    PAYABLE void PortfolioManage::createOrder(char* _portfolioName, char* _orderId, uint16_t _orderType, char* _stockCode, uint64_t _stockPrice, uint64_t _stockAmount, uint64_t _endTime){
        uint64_t tokenBalance = getTotalBalance();
        DIPC_EMIT_EVENT(createOrder, "portfolioName", _portfolioName, "OrderInfo", "ignore", "tokenBalance", tokenBalance);
        uint64_t spent = 0;
        if(_orderType == 1){
            spent = _stockPrice * _stockAmount;
            DipcAssert((portfolioBalance.get()[_portfolioName] + tokenBalance) > spent);
        }
        struct Order order{_orderId, _orderType, _stockCode, _stockPrice, _stockAmount, _endTime, 0};
        std::string pInfo = portfolioStorge.get()[_portfolioName];
        
        
        
        if(pInfo == "") {
            DIPC_EMIT_EVENT(ErrEvent, "Current portfolio  doesn't exist: ", _portfolioName);
            return;
        }
        PortfolioInfo info;
        info.parseJson(pInfo);
        if(info.getOrder(_orderId).orderId != ""){
            DIPC_EMIT_EVENT(ErrEvent, "Current order exist: ", _orderId);
            return;
        }
        info.addOrder(order);
        pInfo = info.toJson();

        uint64_t currentBalance = portfolioBalance.get()[_portfolioName] ;
        uint64_t finalBalance = currentBalance + tokenBalance - spent;
        DipcAssert(totalToken.get() + tokenBalance > totalToken);
        
        DipcAssert(ownerTotalToken.get() < ownerTotalToken.get() + spent);
        (*portfolioStorge)[_portfolioName] = &pInfo[0];
        
        
        
        


        (*portfolioBalance)[_portfolioName] = finalBalance;
        *totalToken = totalToken.get() + finalBalance; 
        *ownerTotalToken = ownerTotalToken.get() + spent;
        DIPC_EMIT_EVENT(createOrder, "portfolioName", _portfolioName, "OrderInfo", &order.toJson()[0], "portfolioBalance", finalBalance);
    }

    
    EXPORT void PortfolioManage::dealOrder(char* _portfolioName, char* _orderId){
        u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
isOwner();
        std::string pInfo = portfolioStorge.get()[_portfolioName];
        
        
        PortfolioInfo info;
        info.parseJson(pInfo);
        

        
         Order ord = info.getOrder(_orderId);
         
         
        if(ord.orderId != "" && ord.orderStatus == 0){
            
            uint64_t timenow = dipc::timestamp();
            if(ord.endTime > timenow){
                ord.orderStatus = 1;
            }else {
                ord.orderStatus = 3;
            }
        } else {
          

            return;
        }
        

        uint64_t sellValue = 0;
        if(ord.orderType == 0){
            sellValue = ord.stockAmount * ord.stockPrice;
        }
        uint64_t currentBalance =  portfolioBalance.get()[_portfolioName];
        

        DipcAssert(currentBalance + sellValue >= currentBalance);
        DipcAssert((ownerTotalToken.get() - sellValue) <= ownerTotalToken.get());
        


        (*portfolioBalance)[_portfolioName] = currentBalance + sellValue;
        *ownerTotalToken = ownerTotalToken.get() - sellValue;
        (*portfolioStorge)[_portfolioName] = &info.toJson()[0];
        
        
        
        

        DIPC_EMIT_EVENT(dealPortfolio, "orderId", _orderId, "orderInfo", &ord.toJson()[0]);
    }
    
    EXPORT void PortfolioManage::revocationOrder(char* _portfolioName, char* _orderId){
        u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
std::string pInfo = portfolioStorge.get()[_portfolioName];
        
        
        PortfolioInfo info;
        info.parseJson(pInfo);
        Order ord = info.getOrder(_orderId);
        
        
        if(ord.orderId != "" && ord.orderStatus == 0){
            std::string callerStr = caller().toString();
            
            
            
            DipcAssert(info.getOwnerAddress() == caller().toString());
            

            uint64_t timenow = dipc::timestamp();
            if(ord.endTime > timenow){
                ord.orderStatus = 2;
            }else {
                ord.orderStatus = 3;
            }
        } else {
            return;
        }
        uint64_t lockToken = 0;
        if(ord.orderType == 1){
            lockToken = ord.stockPrice * ord.stockAmount;
        }
        uint64_t currentBalance =  portfolioBalance.get()[_portfolioName];
        
        
        
        

        DipcAssert(currentBalance + lockToken >= currentBalance);
        DipcAssert(ownerTotalToken.get() - lockToken <= ownerTotalToken.get());

        
        (*portfolioBalance)[_portfolioName] = currentBalance + lockToken;
        *ownerTotalToken = ownerTotalToken.get() - lockToken;
        (*portfolioStorge)[_portfolioName] = &info.toJson()[0];
        DIPC_EMIT_EVENT(revocationPortfolio, "orderId", _orderId, "orderInfo", &ord.toJson()[0]);
    }
    
    EXPORT void PortfolioManage::withdrawPortfolio(char* _portfolioName, uint64_t _withdrawBalance){
         if(!userCanWithdraw.get()){
             return;
         }
         uint64_t currentBalance =  portfolioBalance.get()[_portfolioName];
         DipcAssert(currentBalance - _withdrawBalance < currentBalance);
         auto coinBalance = changeUint64ToU256WithChangeRate(currentBalance, changeRate.get());
         (*portfolioBalance)[_portfolioName] = currentBalance - _withdrawBalance;
         callTransfer(caller(), coinBalance);
    }
    
    EXPORT void PortfolioManage::withdrawPool(uint64_t _balance){
        isOwner();
        Address ownerAddr = Address(owner.get()); 
        callTransfer(ownerAddr, _balance);
        *ownerTotalToken = ownerTotalToken.get() - _balance * changeRate.get();
        *totalToken = totalToken.get() - _balance * changeRate.get();
        DIPC_EMIT_EVENT(tokenCount, "ownerTotalToken", ownerTotalToken.get(), "totalToken", totalToken.get());
    }
    
    PAYABLE void PortfolioManage::depositPool(uint64_t _depositValue){
        isOwner();
        
        uint64_t tokenBalance = changeU256ToUint64WithChangeRate(callValue(), changeRate.get()); 
        *ownerTotalToken = ownerTotalToken.get() + tokenBalance;
        *totalToken = totalToken.get() + tokenBalance;
        DIPC_EMIT_EVENT(tokenCount, "ownerTotalToken", ownerTotalToken.get(), "totalToken", totalToken.get());
    }
     
    CONSTANT uint64_t PortfolioManage::queryTotalToken(){
        return totalToken.get();
    }

     
    CONSTANT uint64_t PortfolioManage::queryPortfolioBalance(char* _portfolioName){
        return portfolioBalance.get()[_portfolioName];
    }

    
    CONSTANT bool PortfolioManage::queryPortfolioNameIfUsed(char* _portfolioName){
        if(portfolioStorge.get()[_portfolioName] != ""){
            return true;
        } 
        return false;
    }

    
    CONSTANT uint64_t PortfolioManage::queryChangeRate(){
        return changeRate.get();
    }

2019-12-19_15:14:54.129045: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:604] finalContract  final content =======   : #include "PortfolioManage.hpp"

    
    PAYABLE void PortfolioManage::init(){
        *owner = caller().toString();
        *changeRate = 10000;
        *userCanWithdraw = false;
        uint64_t tokenBalance = getTotalBalance();
        
        *ownerTotalToken = tokenBalance;
        *totalToken = ownerTotalToken.get();
        
        
        DIPC_EMIT_EVENT(initEvent, "ownerTotalToken" ,tokenBalance);
    }
    
     
    EXPORT void PortfolioManage::setChangeRate(uint64_t _changeRate){
        isOwner();
        *changeRate = _changeRate;
    }
     
    EXPORT void PortfolioManage::setUserCanWithdraw(bool _canWithdraw){
        u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
isOwner();
        *userCanWithdraw = _canWithdraw;
    }

    
    PAYABLE void PortfolioManage::createPortfolio(char* _portfolioName, char* _portfolioDesc){
        if(portfolioStorge.get()[_portfolioName] != ""){
            DIPC_EMIT_EVENT(ErrEvent, "Current portfolio exist: ", _portfolioName);
            return;
        } 
        std::string callerAddr = caller().toString();
        uint64_t tokenBalance = getTotalBalance();
        
        PortfolioInfo info(_portfolioName, _portfolioDesc, &callerAddr[0]);
        std::string portfolioStr = info.toJson();
        
        
        

        (*portfolioStorge)[_portfolioName] = portfolioStr;
        DipcAssert(totalToken.get() + tokenBalance > totalToken);
        (*portfolioBalance)[_portfolioName] = tokenBalance;
        *totalToken = totalToken.get() + tokenBalance; 
        
        DIPC_EMIT_EVENT(portfolioInfo, _portfolioName, &portfolioStr[0], "portfolioBalance", tokenBalance);
    }

    
    PAYABLE void PortfolioManage::depositPortfolio(char* _portfolioName){
        uint64_t tokenBalance = getTotalBalance();
        
        uint64_t currentBalance = portfolioBalance.get()[_portfolioName];
        uint64_t finalBalance  = currentBalance + tokenBalance;
        DipcAssert(totalToken.get() + tokenBalance > totalToken);
        DipcAssert(finalBalance > currentBalance);
        (*portfolioBalance)[_portfolioName] = finalBalance;
        *totalToken = totalToken.get() + finalBalance; 
        DIPC_EMIT_EVENT(depositPortfolio, "portfolioName", _portfolioName, "portfolioBalance", finalBalance);
    }
    
    PAYABLE void PortfolioManage::createOrder(char* _portfolioName, char* _orderId, uint16_t _orderType, char* _stockCode, uint64_t _stockPrice, uint64_t _stockAmount, uint64_t _endTime){
        uint64_t tokenBalance = getTotalBalance();
        DIPC_EMIT_EVENT(createOrder, "portfolioName", _portfolioName, "OrderInfo", "ignore", "tokenBalance", tokenBalance);
        uint64_t spent = 0;
        if(_orderType == 1){
            spent = _stockPrice * _stockAmount;
            DipcAssert((portfolioBalance.get()[_portfolioName] + tokenBalance) > spent);
        }
        struct Order order{_orderId, _orderType, _stockCode, _stockPrice, _stockAmount, _endTime, 0};
        std::string pInfo = portfolioStorge.get()[_portfolioName];
        
        
        
        if(pInfo == "") {
            DIPC_EMIT_EVENT(ErrEvent, "Current portfolio  doesn't exist: ", _portfolioName);
            return;
        }
        PortfolioInfo info;
        info.parseJson(pInfo);
        if(info.getOrder(_orderId).orderId != ""){
            DIPC_EMIT_EVENT(ErrEvent, "Current order exist: ", _orderId);
            return;
        }
        info.addOrder(order);
        pInfo = info.toJson();

        uint64_t currentBalance = portfolioBalance.get()[_portfolioName] ;
        uint64_t finalBalance = currentBalance + tokenBalance - spent;
        DipcAssert(totalToken.get() + tokenBalance > totalToken);
        
        DipcAssert(ownerTotalToken.get() < ownerTotalToken.get() + spent);
        (*portfolioStorge)[_portfolioName] = &pInfo[0];
        
        
        
        


        (*portfolioBalance)[_portfolioName] = finalBalance;
        *totalToken = totalToken.get() + finalBalance; 
        *ownerTotalToken = ownerTotalToken.get() + spent;
        DIPC_EMIT_EVENT(createOrder, "portfolioName", _portfolioName, "OrderInfo", &order.toJson()[0], "portfolioBalance", finalBalance);
    }

    
    EXPORT void PortfolioManage::dealOrder(char* _portfolioName, char* _orderId){
        u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
isOwner();
        std::string pInfo = portfolioStorge.get()[_portfolioName];
        
        
        PortfolioInfo info;
        info.parseJson(pInfo);
        

        
         Order ord = info.getOrder(_orderId);
         
         
        if(ord.orderId != "" && ord.orderStatus == 0){
            
            uint64_t timenow = dipc::timestamp();
            if(ord.endTime > timenow){
                ord.orderStatus = 1;
            }else {
                ord.orderStatus = 3;
            }
        } else {
          

            return;
        }
        

        uint64_t sellValue = 0;
        if(ord.orderType == 0){
            sellValue = ord.stockAmount * ord.stockPrice;
        }
        uint64_t currentBalance =  portfolioBalance.get()[_portfolioName];
        

        DipcAssert(currentBalance + sellValue >= currentBalance);
        DipcAssert((ownerTotalToken.get() - sellValue) <= ownerTotalToken.get());
        


        (*portfolioBalance)[_portfolioName] = currentBalance + sellValue;
        *ownerTotalToken = ownerTotalToken.get() - sellValue;
        (*portfolioStorge)[_portfolioName] = &info.toJson()[0];
        
        
        
        

        DIPC_EMIT_EVENT(dealPortfolio, "orderId", _orderId, "orderInfo", &ord.toJson()[0]);
    }
    
    EXPORT void PortfolioManage::revocationOrder(char* _portfolioName, char* _orderId){
        u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
std::string pInfo = portfolioStorge.get()[_portfolioName];
        
        
        PortfolioInfo info;
        info.parseJson(pInfo);
        Order ord = info.getOrder(_orderId);
        
        
        if(ord.orderId != "" && ord.orderStatus == 0){
            std::string callerStr = caller().toString();
            
            
            
            DipcAssert(info.getOwnerAddress() == caller().toString());
            

            uint64_t timenow = dipc::timestamp();
            if(ord.endTime > timenow){
                ord.orderStatus = 2;
            }else {
                ord.orderStatus = 3;
            }
        } else {
            return;
        }
        uint64_t lockToken = 0;
        if(ord.orderType == 1){
            lockToken = ord.stockPrice * ord.stockAmount;
        }
        uint64_t currentBalance =  portfolioBalance.get()[_portfolioName];
        
        
        
        

        DipcAssert(currentBalance + lockToken >= currentBalance);
        DipcAssert(ownerTotalToken.get() - lockToken <= ownerTotalToken.get());

        
        (*portfolioBalance)[_portfolioName] = currentBalance + lockToken;
        *ownerTotalToken = ownerTotalToken.get() - lockToken;
        (*portfolioStorge)[_portfolioName] = &info.toJson()[0];
        DIPC_EMIT_EVENT(revocationPortfolio, "orderId", _orderId, "orderInfo", &ord.toJson()[0]);
    }
    
    EXPORT void PortfolioManage::withdrawPortfolio(char* _portfolioName, uint64_t _withdrawBalance){
         u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
if(!userCanWithdraw.get()){
             return;
         }
         uint64_t currentBalance =  portfolioBalance.get()[_portfolioName];
         DipcAssert(currentBalance - _withdrawBalance < currentBalance);
         auto coinBalance = changeUint64ToU256WithChangeRate(currentBalance, changeRate.get());
         (*portfolioBalance)[_portfolioName] = currentBalance - _withdrawBalance;
         callTransfer(caller(), coinBalance);
    }
    
    EXPORT void PortfolioManage::withdrawPool(uint64_t _balance){
        isOwner();
        Address ownerAddr = Address(owner.get()); 
        callTransfer(ownerAddr, _balance);
        *ownerTotalToken = ownerTotalToken.get() - _balance * changeRate.get();
        *totalToken = totalToken.get() - _balance * changeRate.get();
        DIPC_EMIT_EVENT(tokenCount, "ownerTotalToken", ownerTotalToken.get(), "totalToken", totalToken.get());
    }
    
    PAYABLE void PortfolioManage::depositPool(uint64_t _depositValue){
        isOwner();
        
        uint64_t tokenBalance = changeU256ToUint64WithChangeRate(callValue(), changeRate.get()); 
        *ownerTotalToken = ownerTotalToken.get() + tokenBalance;
        *totalToken = totalToken.get() + tokenBalance;
        DIPC_EMIT_EVENT(tokenCount, "ownerTotalToken", ownerTotalToken.get(), "totalToken", totalToken.get());
    }
     
    CONSTANT uint64_t PortfolioManage::queryTotalToken(){
        return totalToken.get();
    }

     
    CONSTANT uint64_t PortfolioManage::queryPortfolioBalance(char* _portfolioName){
        return portfolioBalance.get()[_portfolioName];
    }

    
    CONSTANT bool PortfolioManage::queryPortfolioNameIfUsed(char* _portfolioName){
        if(portfolioStorge.get()[_portfolioName] != ""){
            return true;
        } 
        return false;
    }

    
    CONSTANT uint64_t PortfolioManage::queryChangeRate(){
        return changeRate.get();
    }

2019-12-19_15:14:54.129056: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:401] abis.ispayable :false

2019-12-19_15:14:54.129074: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:424] finalContract  this height  #include "PortfolioManage.hpp"

    
    PAYABLE void PortfolioManage::init(){
        *owner = caller().toString();
        *changeRate = 10000;
        *userCanWithdraw = false;
        uint64_t tokenBalance = getTotalBalance();
        
        *ownerTotalToken = tokenBalance;
        *totalToken = ownerTotalToken.get();
        
        
        DIPC_EMIT_EVENT(initEvent, "ownerTotalToken" ,tokenBalance);
    }
    
     
    EXPORT void PortfolioManage::setChangeRate(uint64_t _changeRate){
        isOwner();
        *changeRate = _changeRate;
    }
     
    EXPORT void PortfolioManage::setUserCanWithdraw(bool _canWithdraw){
        u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
isOwner();
        *userCanWithdraw = _canWithdraw;
    }

    
    PAYABLE void PortfolioManage::createPortfolio(char* _portfolioName, char* _portfolioDesc){
        if(portfolioStorge.get()[_portfolioName] != ""){
            DIPC_EMIT_EVENT(ErrEvent, "Current portfolio exist: ", _portfolioName);
            return;
        } 
        std::string callerAddr = caller().toString();
        uint64_t tokenBalance = getTotalBalance();
        
        PortfolioInfo info(_portfolioName, _portfolioDesc, &callerAddr[0]);
        std::string portfolioStr = info.toJson();
        
        
        

        (*portfolioStorge)[_portfolioName] = portfolioStr;
        DipcAssert(totalToken.get() + tokenBalance > totalToken);
        (*portfolioBalance)[_portfolioName] = tokenBalance;
        *totalToken = totalToken.get() + tokenBalance; 
        
        DIPC_EMIT_EVENT(portfolioInfo, _portfolioName, &portfolioStr[0], "portfolioBalance", tokenBalance);
    }

    
    PAYABLE void PortfolioManage::depositPortfolio(char* _portfolioName){
        uint64_t tokenBalance = getTotalBalance();
        
        uint64_t currentBalance = portfolioBalance.get()[_portfolioName];
        uint64_t finalBalance  = currentBalance + tokenBalance;
        DipcAssert(totalToken.get() + tokenBalance > totalToken);
        DipcAssert(finalBalance > currentBalance);
        (*portfolioBalance)[_portfolioName] = finalBalance;
        *totalToken = totalToken.get() + finalBalance; 
        DIPC_EMIT_EVENT(depositPortfolio, "portfolioName", _portfolioName, "portfolioBalance", finalBalance);
    }
    
    PAYABLE void PortfolioManage::createOrder(char* _portfolioName, char* _orderId, uint16_t _orderType, char* _stockCode, uint64_t _stockPrice, uint64_t _stockAmount, uint64_t _endTime){
        uint64_t tokenBalance = getTotalBalance();
        DIPC_EMIT_EVENT(createOrder, "portfolioName", _portfolioName, "OrderInfo", "ignore", "tokenBalance", tokenBalance);
        uint64_t spent = 0;
        if(_orderType == 1){
            spent = _stockPrice * _stockAmount;
            DipcAssert((portfolioBalance.get()[_portfolioName] + tokenBalance) > spent);
        }
        struct Order order{_orderId, _orderType, _stockCode, _stockPrice, _stockAmount, _endTime, 0};
        std::string pInfo = portfolioStorge.get()[_portfolioName];
        
        
        
        if(pInfo == "") {
            DIPC_EMIT_EVENT(ErrEvent, "Current portfolio  doesn't exist: ", _portfolioName);
            return;
        }
        PortfolioInfo info;
        info.parseJson(pInfo);
        if(info.getOrder(_orderId).orderId != ""){
            DIPC_EMIT_EVENT(ErrEvent, "Current order exist: ", _orderId);
            return;
        }
        info.addOrder(order);
        pInfo = info.toJson();

        uint64_t currentBalance = portfolioBalance.get()[_portfolioName] ;
        uint64_t finalBalance = currentBalance + tokenBalance - spent;
        DipcAssert(totalToken.get() + tokenBalance > totalToken);
        
        DipcAssert(ownerTotalToken.get() < ownerTotalToken.get() + spent);
        (*portfolioStorge)[_portfolioName] = &pInfo[0];
        
        
        
        


        (*portfolioBalance)[_portfolioName] = finalBalance;
        *totalToken = totalToken.get() + finalBalance; 
        *ownerTotalToken = ownerTotalToken.get() + spent;
        DIPC_EMIT_EVENT(createOrder, "portfolioName", _portfolioName, "OrderInfo", &order.toJson()[0], "portfolioBalance", finalBalance);
    }

    
    EXPORT void PortfolioManage::dealOrder(char* _portfolioName, char* _orderId){
        u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
isOwner();
        std::string pInfo = portfolioStorge.get()[_portfolioName];
        
        
        PortfolioInfo info;
        info.parseJson(pInfo);
        

        
         Order ord = info.getOrder(_orderId);
         
         
        if(ord.orderId != "" && ord.orderStatus == 0){
            
            uint64_t timenow = dipc::timestamp();
            if(ord.endTime > timenow){
                ord.orderStatus = 1;
            }else {
                ord.orderStatus = 3;
            }
        } else {
          

            return;
        }
        

        uint64_t sellValue = 0;
        if(ord.orderType == 0){
            sellValue = ord.stockAmount * ord.stockPrice;
        }
        uint64_t currentBalance =  portfolioBalance.get()[_portfolioName];
        

        DipcAssert(currentBalance + sellValue >= currentBalance);
        DipcAssert((ownerTotalToken.get() - sellValue) <= ownerTotalToken.get());
        


        (*portfolioBalance)[_portfolioName] = currentBalance + sellValue;
        *ownerTotalToken = ownerTotalToken.get() - sellValue;
        (*portfolioStorge)[_portfolioName] = &info.toJson()[0];
        
        
        
        

        DIPC_EMIT_EVENT(dealPortfolio, "orderId", _orderId, "orderInfo", &ord.toJson()[0]);
    }
    
    EXPORT void PortfolioManage::revocationOrder(char* _portfolioName, char* _orderId){
        u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
std::string pInfo = portfolioStorge.get()[_portfolioName];
        
        
        PortfolioInfo info;
        info.parseJson(pInfo);
        Order ord = info.getOrder(_orderId);
        
        
        if(ord.orderId != "" && ord.orderStatus == 0){
            std::string callerStr = caller().toString();
            
            
            
            DipcAssert(info.getOwnerAddress() == caller().toString());
            

            uint64_t timenow = dipc::timestamp();
            if(ord.endTime > timenow){
                ord.orderStatus = 2;
            }else {
                ord.orderStatus = 3;
            }
        } else {
            return;
        }
        uint64_t lockToken = 0;
        if(ord.orderType == 1){
            lockToken = ord.stockPrice * ord.stockAmount;
        }
        uint64_t currentBalance =  portfolioBalance.get()[_portfolioName];
        
        
        
        

        DipcAssert(currentBalance + lockToken >= currentBalance);
        DipcAssert(ownerTotalToken.get() - lockToken <= ownerTotalToken.get());

        
        (*portfolioBalance)[_portfolioName] = currentBalance + lockToken;
        *ownerTotalToken = ownerTotalToken.get() - lockToken;
        (*portfolioStorge)[_portfolioName] = &info.toJson()[0];
        DIPC_EMIT_EVENT(revocationPortfolio, "orderId", _orderId, "orderInfo", &ord.toJson()[0]);
    }
    
    EXPORT void PortfolioManage::withdrawPortfolio(char* _portfolioName, uint64_t _withdrawBalance){
         u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
if(!userCanWithdraw.get()){
             return;
         }
         uint64_t currentBalance =  portfolioBalance.get()[_portfolioName];
         DipcAssert(currentBalance - _withdrawBalance < currentBalance);
         auto coinBalance = changeUint64ToU256WithChangeRate(currentBalance, changeRate.get());
         (*portfolioBalance)[_portfolioName] = currentBalance - _withdrawBalance;
         callTransfer(caller(), coinBalance);
    }
    
    EXPORT void PortfolioManage::withdrawPool(uint64_t _balance){
        isOwner();
        Address ownerAddr = Address(owner.get()); 
        callTransfer(ownerAddr, _balance);
        *ownerTotalToken = ownerTotalToken.get() - _balance * changeRate.get();
        *totalToken = totalToken.get() - _balance * changeRate.get();
        DIPC_EMIT_EVENT(tokenCount, "ownerTotalToken", ownerTotalToken.get(), "totalToken", totalToken.get());
    }
    
    PAYABLE void PortfolioManage::depositPool(uint64_t _depositValue){
        isOwner();
        
        uint64_t tokenBalance = changeU256ToUint64WithChangeRate(callValue(), changeRate.get()); 
        *ownerTotalToken = ownerTotalToken.get() + tokenBalance;
        *totalToken = totalToken.get() + tokenBalance;
        DIPC_EMIT_EVENT(tokenCount, "ownerTotalToken", ownerTotalToken.get(), "totalToken", totalToken.get());
    }
     
    CONSTANT uint64_t PortfolioManage::queryTotalToken(){
        return totalToken.get();
    }

     
    CONSTANT uint64_t PortfolioManage::queryPortfolioBalance(char* _portfolioName){
        return portfolioBalance.get()[_portfolioName];
    }

    
    CONSTANT bool PortfolioManage::queryPortfolioNameIfUsed(char* _portfolioName){
        if(portfolioStorge.get()[_portfolioName] != ""){
            return true;
        } 
        return false;
    }

    
    CONSTANT uint64_t PortfolioManage::queryChangeRate(){
        return changeRate.get();
    } codetext height #include "PortfolioManage.hpp"

    
    PAYABLE void PortfolioManage::init(){
        *owner = caller().toString();
        *changeRate = 10000;
        *userCanWithdraw = false;
        uint64_t tokenBalance = getTotalBalance();
        
        *ownerTotalToken = tokenBalance;
        *totalToken = ownerTotalToken.get();
        
        
        DIPC_EMIT_EVENT(initEvent, "ownerTotalToken" ,tokenBalance);
    }
    
     
    EXPORT void PortfolioManage::setChangeRate(uint64_t _changeRate){
        isOwner();
        *changeRate = _changeRate;
    }
     
    EXPORT void PortfolioManage::setUserCanWithdraw(bool _canWithdraw){
        u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
isOwner();
        *userCanWithdraw = _canWithdraw;
    }

    
    PAYABLE void PortfolioManage::createPortfolio(char* _portfolioName, char* _portfolioDesc){
        if(portfolioStorge.get()[_portfolioName] != ""){
            DIPC_EMIT_EVENT(ErrEvent, "Current portfolio exist: ", _portfolioName);
            return;
        } 
        std::string callerAddr = caller().toString();
        uint64_t tokenBalance = getTotalBalance();
        
        PortfolioInfo info(_portfolioName, _portfolioDesc, &callerAddr[0]);
        std::string portfolioStr = info.toJson();
        
        
        

        (*portfolioStorge)[_portfolioName] = portfolioStr;
        DipcAssert(totalToken.get() + tokenBalance > totalToken);
        (*portfolioBalance)[_portfolioName] = tokenBalance;
        *totalToken = totalToken.get() + tokenBalance; 
        
        DIPC_EMIT_EVENT(portfolioInfo, _portfolioName, &portfolioStr[0], "portfolioBalance", tokenBalance);
    }

    
    PAYABLE void PortfolioManage::depositPortfolio(char* _portfolioName){
        uint64_t tokenBalance = getTotalBalance();
        
        uint64_t currentBalance = portfolioBalance.get()[_portfolioName];
        uint64_t finalBalance  = currentBalance + tokenBalance;
        DipcAssert(totalToken.get() + tokenBalance > totalToken);
        DipcAssert(finalBalance > currentBalance);
        (*portfolioBalance)[_portfolioName] = finalBalance;
        *totalToken = totalToken.get() + finalBalance; 
        DIPC_EMIT_EVENT(depositPortfolio, "portfolioName", _portfolioName, "portfolioBalance", finalBalance);
    }
    
    PAYABLE void PortfolioManage::createOrder(char* _portfolioName, char* _orderId, uint16_t _orderType, char* _stockCode, uint64_t _stockPrice, uint64_t _stockAmount, uint64_t _endTime){
        uint64_t tokenBalance = getTotalBalance();
        DIPC_EMIT_EVENT(createOrder, "portfolioName", _portfolioName, "OrderInfo", "ignore", "tokenBalance", tokenBalance);
        uint64_t spent = 0;
        if(_orderType == 1){
            spent = _stockPrice * _stockAmount;
            DipcAssert((portfolioBalance.get()[_portfolioName] + tokenBalance) > spent);
        }
        struct Order order{_orderId, _orderType, _stockCode, _stockPrice, _stockAmount, _endTime, 0};
        std::string pInfo = portfolioStorge.get()[_portfolioName];
        
        
        
        if(pInfo == "") {
            DIPC_EMIT_EVENT(ErrEvent, "Current portfolio  doesn't exist: ", _portfolioName);
            return;
        }
        PortfolioInfo info;
        info.parseJson(pInfo);
        if(info.getOrder(_orderId).orderId != ""){
            DIPC_EMIT_EVENT(ErrEvent, "Current order exist: ", _orderId);
            return;
        }
        info.addOrder(order);
        pInfo = info.toJson();

        uint64_t currentBalance = portfolioBalance.get()[_portfolioName] ;
        uint64_t finalBalance = currentBalance + tokenBalance - spent;
        DipcAssert(totalToken.get() + tokenBalance > totalToken);
        
        DipcAssert(ownerTotalToken.get() < ownerTotalToken.get() + spent);
        (*portfolioStorge)[_portfolioName] = &pInfo[0];
        
        
        
        


        (*portfolioBalance)[_portfolioName] = finalBalance;
        *totalToken = totalToken.get() + finalBalance; 
        *ownerTotalToken = ownerTotalToken.get() + spent;
        DIPC_EMIT_EVENT(createOrder, "portfolioName", _portfolioName, "OrderInfo", &order.toJson()[0], "portfolioBalance", finalBalance);
    }

    
    EXPORT void PortfolioManage::dealOrder(char* _portfolioName, char* _orderId){
        u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
isOwner();
        std::string pInfo = portfolioStorge.get()[_portfolioName];
        
        
        PortfolioInfo info;
        info.parseJson(pInfo);
        

        
         Order ord = info.getOrder(_orderId);
         
         
        if(ord.orderId != "" && ord.orderStatus == 0){
            
            uint64_t timenow = dipc::timestamp();
            if(ord.endTime > timenow){
                ord.orderStatus = 1;
            }else {
                ord.orderStatus = 3;
            }
        } else {
          

            return;
        }
        

        uint64_t sellValue = 0;
        if(ord.orderType == 0){
            sellValue = ord.stockAmount * ord.stockPrice;
        }
        uint64_t currentBalance =  portfolioBalance.get()[_portfolioName];
        

        DipcAssert(currentBalance + sellValue >= currentBalance);
        DipcAssert((ownerTotalToken.get() - sellValue) <= ownerTotalToken.get());
        


        (*portfolioBalance)[_portfolioName] = currentBalance + sellValue;
        *ownerTotalToken = ownerTotalToken.get() - sellValue;
        (*portfolioStorge)[_portfolioName] = &info.toJson()[0];
        
        
        
        

        DIPC_EMIT_EVENT(dealPortfolio, "orderId", _orderId, "orderInfo", &ord.toJson()[0]);
    }
    
    EXPORT void PortfolioManage::revocationOrder(char* _portfolioName, char* _orderId){
        u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
std::string pInfo = portfolioStorge.get()[_portfolioName];
        
        
        PortfolioInfo info;
        info.parseJson(pInfo);
        Order ord = info.getOrder(_orderId);
        
        
        if(ord.orderId != "" && ord.orderStatus == 0){
            std::string callerStr = caller().toString();
            
            
            
            DipcAssert(info.getOwnerAddress() == caller().toString());
            

            uint64_t timenow = dipc::timestamp();
            if(ord.endTime > timenow){
                ord.orderStatus = 2;
            }else {
                ord.orderStatus = 3;
            }
        } else {
            return;
        }
        uint64_t lockToken = 0;
        if(ord.orderType == 1){
            lockToken = ord.stockPrice * ord.stockAmount;
        }
        uint64_t currentBalance =  portfolioBalance.get()[_portfolioName];
        
        
        
        

        DipcAssert(currentBalance + lockToken >= currentBalance);
        DipcAssert(ownerTotalToken.get() - lockToken <= ownerTotalToken.get());

        
        (*portfolioBalance)[_portfolioName] = currentBalance + lockToken;
        *ownerTotalToken = ownerTotalToken.get() - lockToken;
        (*portfolioStorge)[_portfolioName] = &info.toJson()[0];
        DIPC_EMIT_EVENT(revocationPortfolio, "orderId", _orderId, "orderInfo", &ord.toJson()[0]);
    }
    
    EXPORT void PortfolioManage::withdrawPortfolio(char* _portfolioName, uint64_t _withdrawBalance){
         u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
if(!userCanWithdraw.get()){
             return;
         }
         uint64_t currentBalance =  portfolioBalance.get()[_portfolioName];
         DipcAssert(currentBalance - _withdrawBalance < currentBalance);
         auto coinBalance = changeUint64ToU256WithChangeRate(currentBalance, changeRate.get());
         (*portfolioBalance)[_portfolioName] = currentBalance - _withdrawBalance;
         callTransfer(caller(), coinBalance);
    }
    
    EXPORT void PortfolioManage::withdrawPool(uint64_t _balance){
        isOwner();
        Address ownerAddr = Address(owner.get()); 
        callTransfer(ownerAddr, _balance);
        *ownerTotalToken = ownerTotalToken.get() - _balance * changeRate.get();
        *totalToken = totalToken.get() - _balance * changeRate.get();
        DIPC_EMIT_EVENT(tokenCount, "ownerTotalToken", ownerTotalToken.get(), "totalToken", totalToken.get());
    }
    
    PAYABLE void PortfolioManage::depositPool(uint64_t _depositValue){
        isOwner();
        
        uint64_t tokenBalance = changeU256ToUint64WithChangeRate(callValue(), changeRate.get()); 
        *ownerTotalToken = ownerTotalToken.get() + tokenBalance;
        *totalToken = totalToken.get() + tokenBalance;
        DIPC_EMIT_EVENT(tokenCount, "ownerTotalToken", ownerTotalToken.get(), "totalToken", totalToken.get());
    }
     
    CONSTANT uint64_t PortfolioManage::queryTotalToken(){
        return totalToken.get();
    }

     
    CONSTANT uint64_t PortfolioManage::queryPortfolioBalance(char* _portfolioName){
        return portfolioBalance.get()[_portfolioName];
    }

    
    CONSTANT bool PortfolioManage::queryPortfolioNameIfUsed(char* _portfolioName){
        if(portfolioStorge.get()[_portfolioName] != ""){
            return true;
        } 
        return false;
    }

    
    CONSTANT uint64_t PortfolioManage::queryChangeRate(){
        return changeRate.get();
    }

2019-12-19_15:14:54.129150: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:427] searchContext  #include "PortfolioManage.hpp"

    
    PAYABLE void PortfolioManage::init(){
        *owner = caller().toString();
        *changeRate = 10000;
        *userCanWithdraw = false;
        uint64_t tokenBalance = getTotalBalance();
        
        *ownerTotalToken = tokenBalance;
        *totalToken = ownerTotalToken.get();
        
        
        DIPC_EMIT_EVENT(initEvent, "ownerTotalToken" ,tokenBalance);
    }
    
     
    EXPORT void PortfolioManage::setChangeRate(uint64_t _changeRate){
        isOwner();
        *changeRate = _changeRate;
    }
     
    EXPORT void PortfolioManage::setUserCanWithdraw(bool _canWithdraw){
        u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
isOwner();
        *userCanWithdraw = _canWithdraw;
    }

    
    PAYABLE void PortfolioManage::createPortfolio(char* _portfolioName, char* _portfolioDesc){
        if(portfolioStorge.get()[_portfolioName] != ""){
            DIPC_EMIT_EVENT(ErrEvent, "Current portfolio exist: ", _portfolioName);
            return;
        } 
        std::string callerAddr = caller().toString();
        uint64_t tokenBalance = getTotalBalance();
        
        PortfolioInfo info(_portfolioName, _portfolioDesc, &callerAddr[0]);
        std::string portfolioStr = info.toJson();
        
        
        

        (*portfolioStorge)[_portfolioName] = portfolioStr;
        DipcAssert(totalToken.get() + tokenBalance > totalToken);
        (*portfolioBalance)[_portfolioName] = tokenBalance;
        *totalToken = totalToken.get() + tokenBalance; 
        
        DIPC_EMIT_EVENT(portfolioInfo, _portfolioName, &portfolioStr[0], "portfolioBalance", tokenBalance);
    }

    
    PAYABLE void PortfolioManage::depositPortfolio(char* _portfolioName){
        uint64_t tokenBalance = getTotalBalance();
        
        uint64_t currentBalance = portfolioBalance.get()[_portfolioName];
        uint64_t finalBalance  = currentBalance + tokenBalance;
        DipcAssert(totalToken.get() + tokenBalance > totalToken);
        DipcAssert(finalBalance > currentBalance);
        (*portfolioBalance)[_portfolioName] = finalBalance;
        *totalToken = totalToken.get() + finalBalance; 
        DIPC_EMIT_EVENT(depositPortfolio, "portfolioName", _portfolioName, "portfolioBalance", finalBalance);
    }
    
    PAYABLE void PortfolioManage::createOrder(char* _portfolioName, char* _orderId, uint16_t _orderType, char* _stockCode, uint64_t _stockPrice, uint64_t _stockAmount, uint64_t _endTime){
        uint64_t tokenBalance = getTotalBalance();
        DIPC_EMIT_EVENT(createOrder, "portfolioName", _portfolioName, "OrderInfo", "ignore", "tokenBalance", tokenBalance);
        uint64_t spent = 0;
        if(_orderType == 1){
            spent = _stockPrice * _stockAmount;
            DipcAssert((portfolioBalance.get()[_portfolioName] + tokenBalance) > spent);
        }
        struct Order order{_orderId, _orderType, _stockCode, _stockPrice, _stockAmount, _endTime, 0};
        std::string pInfo = portfolioStorge.get()[_portfolioName];
        
        
        
        if(pInfo == "") {
            DIPC_EMIT_EVENT(ErrEvent, "Current portfolio  doesn't exist: ", _portfolioName);
            return;
        }
        PortfolioInfo info;
        info.parseJson(pInfo);
        if(info.getOrder(_orderId).orderId != ""){
            DIPC_EMIT_EVENT(ErrEvent, "Current order exist: ", _orderId);
            return;
        }
        info.addOrder(order);
        pInfo = info.toJson();

        uint64_t currentBalance = portfolioBalance.get()[_portfolioName] ;
        uint64_t finalBalance = currentBalance + tokenBalance - spent;
        DipcAssert(totalToken.get() + tokenBalance > totalToken);
        
        DipcAssert(ownerTotalToken.get() < ownerTotalToken.get() + spent);
        (*portfolioStorge)[_portfolioName] = &pInfo[0];
        
        
        
        


        (*portfolioBalance)[_portfolioName] = finalBalance;
        *totalToken = totalToken.get() + finalBalance; 
        *ownerTotalToken = ownerTotalToken.get() + spent;
        DIPC_EMIT_EVENT(createOrder, "portfolioName", _portfolioName, "OrderInfo", &order.toJson()[0], "portfolioBalance", finalBalance);
    }

    
    EXPORT void PortfolioManage::dealOrder(char* _portfolioName, char* _orderId){
        u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
isOwner();
        std::string pInfo = portfolioStorge.get()[_portfolioName];
        
        
        PortfolioInfo info;
        info.parseJson(pInfo);
        

        
         Order ord = info.getOrder(_orderId);
         
         
        if(ord.orderId != "" && ord.orderStatus == 0){
            
            uint64_t timenow = dipc::timestamp();
            if(ord.endTime > timenow){
                ord.orderStatus = 1;
            }else {
                ord.orderStatus = 3;
            }
        } else {
          

            return;
        }
        

        uint64_t sellValue = 0;
        if(ord.orderType == 0){
            sellValue = ord.stockAmount * ord.stockPrice;
        }
        uint64_t currentBalance =  portfolioBalance.get()[_portfolioName];
        

        DipcAssert(currentBalance + sellValue >= currentBalance);
        DipcAssert((ownerTotalToken.get() - sellValue) <= ownerTotalToken.get());
        


        (*portfolioBalance)[_portfolioName] = currentBalance + sellValue;
        *ownerTotalToken = ownerTotalToken.get() - sellValue;
        (*portfolioStorge)[_portfolioName] = &info.toJson()[0];
        
        
        
        

        DIPC_EMIT_EVENT(dealPortfolio, "orderId", _orderId, "orderInfo", &ord.toJson()[0]);
    }
    
    EXPORT void PortfolioManage::revocationOrder(char* _portfolioName, char* _orderId){
        u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
std::string pInfo = portfolioStorge.get()[_portfolioName];
        
        
        PortfolioInfo info;
        info.parseJson(pInfo);
        Order ord = info.getOrder(_orderId);
        
        
        if(ord.orderId != "" && ord.orderStatus == 0){
            std::string callerStr = caller().toString();
            
            
            
            DipcAssert(info.getOwnerAddress() == caller().toString());
            

            uint64_t timenow = dipc::timestamp();
            if(ord.endTime > timenow){
                ord.orderStatus = 2;
            }else {
                ord.orderStatus = 3;
            }
        } else {
            return;
        }
        uint64_t lockToken = 0;
        if(ord.orderType == 1){
            lockToken = ord.stockPrice * ord.stockAmount;
        }
        uint64_t currentBalance =  portfolioBalance.get()[_portfolioName];
        
        
        
        

        DipcAssert(currentBalance + lockToken >= currentBalance);
        DipcAssert(ownerTotalToken.get() - lockToken <= ownerTotalToken.get());

        
        (*portfolioBalance)[_portfolioName] = currentBalance + lockToken;
        *ownerTotalToken = ownerTotalToken.get() - lockToken;
        (*portfolioStorge)[_portfolioName] = &info.toJson()[0];
        DIPC_EMIT_EVENT(revocationPortfolio, "orderId", _orderId, "orderInfo", &ord.toJson()[0]);
    }
    
    EXPORT void PortfolioManage::withdrawPortfolio(char* _portfolioName, uint64_t _withdrawBalance){
         u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
if(!userCanWithdraw.get()){
             return;
         }
         uint64_t currentBalance =  portfolioBalance.get()[_portfolioName];
         DipcAssert(currentBalance - _withdrawBalance < currentBalance);
         auto coinBalance = changeUint64ToU256WithChangeRate(currentBalance, changeRate.get());
         (*portfolioBalance)[_portfolioName] = currentBalance - _withdrawBalance;
         callTransfer(caller(), coinBalance);
    }
    
    EXPORT void PortfolioManage::withdrawPool(uint64_t _balance){
        isOwner();
        Address ownerAddr = Address(owner.get()); 
        callTransfer(ownerAddr, _balance);
        *ownerTotalToken = ownerTotalToken.get() - _balance * changeRate.get();
        *totalToken = totalToken.get() - _balance * changeRate.get();
        DIPC_EMIT_EVENT(tokenCount, "ownerTotalToken", ownerTotalToken.get(), "totalToken", totalToken.get());
    }
    
    PAYABLE void PortfolioManage::depositPool(uint64_t _depositValue){
        isOwner();
        
        uint64_t tokenBalance = changeU256ToUint64WithChangeRate(callValue(), changeRate.get()); 
        *ownerTotalToken = ownerTotalToken.get() + tokenBalance;
        *totalToken = totalToken.get() + tokenBalance;
        DIPC_EMIT_EVENT(tokenCount, "ownerTotalToken", ownerTotalToken.get(), "totalToken", totalToken.get());
    }
     
    CONSTANT uint64_t PortfolioManage::queryTotalToken(){
        return totalToken.get();
    }

     
    CONSTANT uint64_t PortfolioManage::queryPortfolioBalance(char* _portfolioName){
        return portfolioBalance.get()[_portfolioName];
    }

    
    CONSTANT bool PortfolioManage::queryPortfolioNameIfUsed(char* _portfolioName){
        if(portfolioStorge.get()[_portfolioName] != ""){
            return true;
        } 
        return false;
    }

    
    CONSTANT uint64_t PortfolioManage::queryChangeRate(){
        return changeRate.get();
    }

2019-12-19_15:14:54.336332: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:451] log out out  Export :
    
    EXPORT void PortfolioManage::withdrawPool(uint64_t _balance){
        

2019-12-19_15:14:54.336356: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:457] name : withdrawPool   pos1  0

2019-12-19_15:14:54.336369: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:469] pos2  7791   pos1  7791

2019-12-19_15:14:54.336377: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:500] pos2 after 8242   pos1  7791

2019-12-19_15:14:54.336385: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:509] finalContract  first #include "PortfolioManage.hpp"

    
    PAYABLE void PortfolioManage::init(){
        *owner = caller().toString();
        *changeRate = 10000;
        *userCanWithdraw = false;
        uint64_t tokenBalance = getTotalBalance();
        
        *ownerTotalToken = tokenBalance;
        *totalToken = ownerTotalToken.get();
        
        
        DIPC_EMIT_EVENT(initEvent, "ownerTotalToken" ,tokenBalance);
    }
    
     
    EXPORT void PortfolioManage::setChangeRate(uint64_t _changeRate){
        isOwner();
        *changeRate = _changeRate;
    }
     
    EXPORT void PortfolioManage::setUserCanWithdraw(bool _canWithdraw){
        u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
isOwner();
        *userCanWithdraw = _canWithdraw;
    }

    
    PAYABLE void PortfolioManage::createPortfolio(char* _portfolioName, char* _portfolioDesc){
        if(portfolioStorge.get()[_portfolioName] != ""){
            DIPC_EMIT_EVENT(ErrEvent, "Current portfolio exist: ", _portfolioName);
            return;
        } 
        std::string callerAddr = caller().toString();
        uint64_t tokenBalance = getTotalBalance();
        
        PortfolioInfo info(_portfolioName, _portfolioDesc, &callerAddr[0]);
        std::string portfolioStr = info.toJson();
        
        
        

        (*portfolioStorge)[_portfolioName] = portfolioStr;
        DipcAssert(totalToken.get() + tokenBalance > totalToken);
        (*portfolioBalance)[_portfolioName] = tokenBalance;
        *totalToken = totalToken.get() + tokenBalance; 
        
        DIPC_EMIT_EVENT(portfolioInfo, _portfolioName, &portfolioStr[0], "portfolioBalance", tokenBalance);
    }

    
    PAYABLE void PortfolioManage::depositPortfolio(char* _portfolioName){
        uint64_t tokenBalance = getTotalBalance();
        
        uint64_t currentBalance = portfolioBalance.get()[_portfolioName];
        uint64_t finalBalance  = currentBalance + tokenBalance;
        DipcAssert(totalToken.get() + tokenBalance > totalToken);
        DipcAssert(finalBalance > currentBalance);
        (*portfolioBalance)[_portfolioName] = finalBalance;
        *totalToken = totalToken.get() + finalBalance; 
        DIPC_EMIT_EVENT(depositPortfolio, "portfolioName", _portfolioName, "portfolioBalance", finalBalance);
    }
    
    PAYABLE void PortfolioManage::createOrder(char* _portfolioName, char* _orderId, uint16_t _orderType, char* _stockCode, uint64_t _stockPrice, uint64_t _stockAmount, uint64_t _endTime){
        uint64_t tokenBalance = getTotalBalance();
        DIPC_EMIT_EVENT(createOrder, "portfolioName", _portfolioName, "OrderInfo", "ignore", "tokenBalance", tokenBalance);
        uint64_t spent = 0;
        if(_orderType == 1){
            spent = _stockPrice * _stockAmount;
            DipcAssert((portfolioBalance.get()[_portfolioName] + tokenBalance) > spent);
        }
        struct Order order{_orderId, _orderType, _stockCode, _stockPrice, _stockAmount, _endTime, 0};
        std::string pInfo = portfolioStorge.get()[_portfolioName];
        
        
        
        if(pInfo == "") {
            DIPC_EMIT_EVENT(ErrEvent, "Current portfolio  doesn't exist: ", _portfolioName);
            return;
        }
        PortfolioInfo info;
        info.parseJson(pInfo);
        if(info.getOrder(_orderId).orderId != ""){
            DIPC_EMIT_EVENT(ErrEvent, "Current order exist: ", _orderId);
            return;
        }
        info.addOrder(order);
        pInfo = info.toJson();

        uint64_t currentBalance = portfolioBalance.get()[_portfolioName] ;
        uint64_t finalBalance = currentBalance + tokenBalance - spent;
        DipcAssert(totalToken.get() + tokenBalance > totalToken);
        
        DipcAssert(ownerTotalToken.get() < ownerTotalToken.get() + spent);
        (*portfolioStorge)[_portfolioName] = &pInfo[0];
        
        
        
        


        (*portfolioBalance)[_portfolioName] = finalBalance;
        *totalToken = totalToken.get() + finalBalance; 
        *ownerTotalToken = ownerTotalToken.get() + spent;
        DIPC_EMIT_EVENT(createOrder, "portfolioName", _portfolioName, "OrderInfo", &order.toJson()[0], "portfolioBalance", finalBalance);
    }

    
    EXPORT void PortfolioManage::dealOrder(char* _portfolioName, char* _orderId){
        u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
isOwner();
        std::string pInfo = portfolioStorge.get()[_portfolioName];
        
        
        PortfolioInfo info;
        info.parseJson(pInfo);
        

        
         Order ord = info.getOrder(_orderId);
         
         
        if(ord.orderId != "" && ord.orderStatus == 0){
            
            uint64_t timenow = dipc::timestamp();
            if(ord.endTime > timenow){
                ord.orderStatus = 1;
            }else {
                ord.orderStatus = 3;
            }
        } else {
          

            return;
        }
        

        uint64_t sellValue = 0;
        if(ord.orderType == 0){
            sellValue = ord.stockAmount * ord.stockPrice;
        }
        uint64_t currentBalance =  portfolioBalance.get()[_portfolioName];
        

        DipcAssert(currentBalance + sellValue >= currentBalance);
        DipcAssert((ownerTotalToken.get() - sellValue) <= ownerTotalToken.get());
        


        (*portfolioBalance)[_portfolioName] = currentBalance + sellValue;
        *ownerTotalToken = ownerTotalToken.get() - sellValue;
        (*portfolioStorge)[_portfolioName] = &info.toJson()[0];
        
        
        
        

        DIPC_EMIT_EVENT(dealPortfolio, "orderId", _orderId, "orderInfo", &ord.toJson()[0]);
    }
    
    EXPORT void PortfolioManage::revocationOrder(char* _portfolioName, char* _orderId){
        u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
std::string pInfo = portfolioStorge.get()[_portfolioName];
        
        
        PortfolioInfo info;
        info.parseJson(pInfo);
        Order ord = info.getOrder(_orderId);
        
        
        if(ord.orderId != "" && ord.orderStatus == 0){
            std::string callerStr = caller().toString();
            
            
            
            DipcAssert(info.getOwnerAddress() == caller().toString());
            

            uint64_t timenow = dipc::timestamp();
            if(ord.endTime > timenow){
                ord.orderStatus = 2;
            }else {
                ord.orderStatus = 3;
            }
        } else {
            return;
        }
        uint64_t lockToken = 0;
        if(ord.orderType == 1){
            lockToken = ord.stockPrice * ord.stockAmount;
        }
        uint64_t currentBalance =  portfolioBalance.get()[_portfolioName];
        
        
        
        

        DipcAssert(currentBalance + lockToken >= currentBalance);
        DipcAssert(ownerTotalToken.get() - lockToken <= ownerTotalToken.get());

        
        (*portfolioBalance)[_portfolioName] = currentBalance + lockToken;
        *ownerTotalToken = ownerTotalToken.get() - lockToken;
        (*portfolioStorge)[_portfolioName] = &info.toJson()[0];
        DIPC_EMIT_EVENT(revocationPortfolio, "orderId", _orderId, "orderInfo", &ord.toJson()[0]);
    }
    
    EXPORT void PortfolioManage::withdrawPortfolio(char* _portfolioName, uint64_t _withdrawBalance){
         u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
if(!userCanWithdraw.get()){
             return;
         }
         uint64_t currentBalance =  portfolioBalance.get()[_portfolioName];
         DipcAssert(currentBalance - _withdrawBalance < currentBalance);
         auto coinBalance = changeUint64ToU256WithChangeRate(currentBalance, changeRate.get());
         (*portfolioBalance)[_portfolioName] = currentBalance - _withdrawBalance;
         callTransfer(caller(), coinBalance);
    }

2019-12-19_15:14:54.336394: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:510] codetext  first #include "PortfolioManage.hpp"

    
    PAYABLE void PortfolioManage::init(){
        *owner = caller().toString();
        *changeRate = 10000;
        *userCanWithdraw = false;
        uint64_t tokenBalance = getTotalBalance();
        
        *ownerTotalToken = tokenBalance;
        *totalToken = ownerTotalToken.get();
        
        
        DIPC_EMIT_EVENT(initEvent, "ownerTotalToken" ,tokenBalance);
    }
    
     
    EXPORT void PortfolioManage::setChangeRate(uint64_t _changeRate){
        isOwner();
        *changeRate = _changeRate;
    }
     
    EXPORT void PortfolioManage::setUserCanWithdraw(bool _canWithdraw){
        u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
isOwner();
        *userCanWithdraw = _canWithdraw;
    }

    
    PAYABLE void PortfolioManage::createPortfolio(char* _portfolioName, char* _portfolioDesc){
        if(portfolioStorge.get()[_portfolioName] != ""){
            DIPC_EMIT_EVENT(ErrEvent, "Current portfolio exist: ", _portfolioName);
            return;
        } 
        std::string callerAddr = caller().toString();
        uint64_t tokenBalance = getTotalBalance();
        
        PortfolioInfo info(_portfolioName, _portfolioDesc, &callerAddr[0]);
        std::string portfolioStr = info.toJson();
        
        
        

        (*portfolioStorge)[_portfolioName] = portfolioStr;
        DipcAssert(totalToken.get() + tokenBalance > totalToken);
        (*portfolioBalance)[_portfolioName] = tokenBalance;
        *totalToken = totalToken.get() + tokenBalance; 
        
        DIPC_EMIT_EVENT(portfolioInfo, _portfolioName, &portfolioStr[0], "portfolioBalance", tokenBalance);
    }

    
    PAYABLE void PortfolioManage::depositPortfolio(char* _portfolioName){
        uint64_t tokenBalance = getTotalBalance();
        
        uint64_t currentBalance = portfolioBalance.get()[_portfolioName];
        uint64_t finalBalance  = currentBalance + tokenBalance;
        DipcAssert(totalToken.get() + tokenBalance > totalToken);
        DipcAssert(finalBalance > currentBalance);
        (*portfolioBalance)[_portfolioName] = finalBalance;
        *totalToken = totalToken.get() + finalBalance; 
        DIPC_EMIT_EVENT(depositPortfolio, "portfolioName", _portfolioName, "portfolioBalance", finalBalance);
    }
    
    PAYABLE void PortfolioManage::createOrder(char* _portfolioName, char* _orderId, uint16_t _orderType, char* _stockCode, uint64_t _stockPrice, uint64_t _stockAmount, uint64_t _endTime){
        uint64_t tokenBalance = getTotalBalance();
        DIPC_EMIT_EVENT(createOrder, "portfolioName", _portfolioName, "OrderInfo", "ignore", "tokenBalance", tokenBalance);
        uint64_t spent = 0;
        if(_orderType == 1){
            spent = _stockPrice * _stockAmount;
            DipcAssert((portfolioBalance.get()[_portfolioName] + tokenBalance) > spent);
        }
        struct Order order{_orderId, _orderType, _stockCode, _stockPrice, _stockAmount, _endTime, 0};
        std::string pInfo = portfolioStorge.get()[_portfolioName];
        
        
        
        if(pInfo == "") {
            DIPC_EMIT_EVENT(ErrEvent, "Current portfolio  doesn't exist: ", _portfolioName);
            return;
        }
        PortfolioInfo info;
        info.parseJson(pInfo);
        if(info.getOrder(_orderId).orderId != ""){
            DIPC_EMIT_EVENT(ErrEvent, "Current order exist: ", _orderId);
            return;
        }
        info.addOrder(order);
        pInfo = info.toJson();

        uint64_t currentBalance = portfolioBalance.get()[_portfolioName] ;
        uint64_t finalBalance = currentBalance + tokenBalance - spent;
        DipcAssert(totalToken.get() + tokenBalance > totalToken);
        
        DipcAssert(ownerTotalToken.get() < ownerTotalToken.get() + spent);
        (*portfolioStorge)[_portfolioName] = &pInfo[0];
        
        
        
        


        (*portfolioBalance)[_portfolioName] = finalBalance;
        *totalToken = totalToken.get() + finalBalance; 
        *ownerTotalToken = ownerTotalToken.get() + spent;
        DIPC_EMIT_EVENT(createOrder, "portfolioName", _portfolioName, "OrderInfo", &order.toJson()[0], "portfolioBalance", finalBalance);
    }

    
    EXPORT void PortfolioManage::dealOrder(char* _portfolioName, char* _orderId){
        u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
isOwner();
        std::string pInfo = portfolioStorge.get()[_portfolioName];
        
        
        PortfolioInfo info;
        info.parseJson(pInfo);
        

        
         Order ord = info.getOrder(_orderId);
         
         
        if(ord.orderId != "" && ord.orderStatus == 0){
            
            uint64_t timenow = dipc::timestamp();
            if(ord.endTime > timenow){
                ord.orderStatus = 1;
            }else {
                ord.orderStatus = 3;
            }
        } else {
          

            return;
        }
        

        uint64_t sellValue = 0;
        if(ord.orderType == 0){
            sellValue = ord.stockAmount * ord.stockPrice;
        }
        uint64_t currentBalance =  portfolioBalance.get()[_portfolioName];
        

        DipcAssert(currentBalance + sellValue >= currentBalance);
        DipcAssert((ownerTotalToken.get() - sellValue) <= ownerTotalToken.get());
        


        (*portfolioBalance)[_portfolioName] = currentBalance + sellValue;
        *ownerTotalToken = ownerTotalToken.get() - sellValue;
        (*portfolioStorge)[_portfolioName] = &info.toJson()[0];
        
        
        
        

        DIPC_EMIT_EVENT(dealPortfolio, "orderId", _orderId, "orderInfo", &ord.toJson()[0]);
    }
    
    EXPORT void PortfolioManage::revocationOrder(char* _portfolioName, char* _orderId){
        u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
std::string pInfo = portfolioStorge.get()[_portfolioName];
        
        
        PortfolioInfo info;
        info.parseJson(pInfo);
        Order ord = info.getOrder(_orderId);
        
        
        if(ord.orderId != "" && ord.orderStatus == 0){
            std::string callerStr = caller().toString();
            
            
            
            DipcAssert(info.getOwnerAddress() == caller().toString());
            

            uint64_t timenow = dipc::timestamp();
            if(ord.endTime > timenow){
                ord.orderStatus = 2;
            }else {
                ord.orderStatus = 3;
            }
        } else {
            return;
        }
        uint64_t lockToken = 0;
        if(ord.orderType == 1){
            lockToken = ord.stockPrice * ord.stockAmount;
        }
        uint64_t currentBalance =  portfolioBalance.get()[_portfolioName];
        
        
        
        

        DipcAssert(currentBalance + lockToken >= currentBalance);
        DipcAssert(ownerTotalToken.get() - lockToken <= ownerTotalToken.get());

        
        (*portfolioBalance)[_portfolioName] = currentBalance + lockToken;
        *ownerTotalToken = ownerTotalToken.get() - lockToken;
        (*portfolioStorge)[_portfolioName] = &info.toJson()[0];
        DIPC_EMIT_EVENT(revocationPortfolio, "orderId", _orderId, "orderInfo", &ord.toJson()[0]);
    }
    
    EXPORT void PortfolioManage::withdrawPortfolio(char* _portfolioName, uint64_t _withdrawBalance){
         u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
if(!userCanWithdraw.get()){
             return;
         }
         uint64_t currentBalance =  portfolioBalance.get()[_portfolioName];
         DipcAssert(currentBalance - _withdrawBalance < currentBalance);
         auto coinBalance = changeUint64ToU256WithChangeRate(currentBalance, changeRate.get());
         (*portfolioBalance)[_portfolioName] = currentBalance - _withdrawBalance;
         callTransfer(caller(), coinBalance);
    }
    
    EXPORT void PortfolioManage::withdrawPool(uint64_t _balance){
        isOwner();
        Address ownerAddr = Address(owner.get()); 
        callTransfer(ownerAddr, _balance);
        *ownerTotalToken = ownerTotalToken.get() - _balance * changeRate.get();
        *totalToken = totalToken.get() - _balance * changeRate.get();
        DIPC_EMIT_EVENT(tokenCount, "ownerTotalToken", ownerTotalToken.get(), "totalToken", totalToken.get());
    }
    
    PAYABLE void PortfolioManage::depositPool(uint64_t _depositValue){
        isOwner();
        
        uint64_t tokenBalance = changeU256ToUint64WithChangeRate(callValue(), changeRate.get()); 
        *ownerTotalToken = ownerTotalToken.get() + tokenBalance;
        *totalToken = totalToken.get() + tokenBalance;
        DIPC_EMIT_EVENT(tokenCount, "ownerTotalToken", ownerTotalToken.get(), "totalToken", totalToken.get());
    }
     
    CONSTANT uint64_t PortfolioManage::queryTotalToken(){
        return totalToken.get();
    }

     
    CONSTANT uint64_t PortfolioManage::queryPortfolioBalance(char* _portfolioName){
        return portfolioBalance.get()[_portfolioName];
    }

    
    CONSTANT bool PortfolioManage::queryPortfolioNameIfUsed(char* _portfolioName){
        if(portfolioStorge.get()[_portfolioName] != ""){
            return true;
        } 
        return false;
    }

    
    CONSTANT uint64_t PortfolioManage::queryChangeRate(){
        return changeRate.get();
    }

2019-12-19_15:14:54.336402: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:513] s  first 
    
    EXPORT void PortfolioManage::withdrawPool(uint64_t _balance){
        isOwner();
        Address ownerAddr = Address(owner.get()); 
        callTransfer(ownerAddr, _balance);
        *ownerTotalToken = ownerTotalToken.get() - _balance * changeRate.get();
        *totalToken = totalToken.get() - _balance * changeRate.get();
        DIPC_EMIT_EVENT(tokenCount, "ownerTotalToken", ownerTotalToken.get(), "totalToken", totalToken.get());
    }

2019-12-19_15:14:54.336409: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:593] calledFunc temp export: 
    
    EXPORT void PortfolioManage::withdrawPool(uint64_t _balance){
        u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
isOwner();
        Address ownerAddr = Address(owner.get()); 
        callTransfer(ownerAddr, _balance);
        *ownerTotalToken = ownerTotalToken.get() - _balance * changeRate.get();
        *totalToken = totalToken.get() - _balance * changeRate.get();
        DIPC_EMIT_EVENT(tokenCount, "ownerTotalToken", ownerTotalToken.get(), "totalToken", totalToken.get());
    }

2019-12-19_15:14:54.336417: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:599] search func : 
    
    EXPORT void PortfolioManage::withdrawPool(uint64_t _balance){
        u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
isOwner();
        Address ownerAddr = Address(owner.get()); 
        callTransfer(ownerAddr, _balance);
        *ownerTotalToken = ownerTotalToken.get() - _balance * changeRate.get();
        *totalToken = totalToken.get() - _balance * changeRate.get();
        DIPC_EMIT_EVENT(tokenCount, "ownerTotalToken", ownerTotalToken.get(), "totalToken", totalToken.get());
    }
2019-12-19_15:14:54.336424: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:424] finalContract  this height  #include "PortfolioManage.hpp"

    
    PAYABLE void PortfolioManage::init(){
        *owner = caller().toString();
        *changeRate = 10000;
        *userCanWithdraw = false;
        uint64_t tokenBalance = getTotalBalance();
        
        *ownerTotalToken = tokenBalance;
        *totalToken = ownerTotalToken.get();
        
        
        DIPC_EMIT_EVENT(initEvent, "ownerTotalToken" ,tokenBalance);
    }
    
     
    EXPORT void PortfolioManage::setChangeRate(uint64_t _changeRate){
        isOwner();
        *changeRate = _changeRate;
    }
     
    EXPORT void PortfolioManage::setUserCanWithdraw(bool _canWithdraw){
        u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
isOwner();
        *userCanWithdraw = _canWithdraw;
    }

    
    PAYABLE void PortfolioManage::createPortfolio(char* _portfolioName, char* _portfolioDesc){
        if(portfolioStorge.get()[_portfolioName] != ""){
            DIPC_EMIT_EVENT(ErrEvent, "Current portfolio exist: ", _portfolioName);
            return;
        } 
        std::string callerAddr = caller().toString();
        uint64_t tokenBalance = getTotalBalance();
        
        PortfolioInfo info(_portfolioName, _portfolioDesc, &callerAddr[0]);
        std::string portfolioStr = info.toJson();
        
        
        

        (*portfolioStorge)[_portfolioName] = portfolioStr;
        DipcAssert(totalToken.get() + tokenBalance > totalToken);
        (*portfolioBalance)[_portfolioName] = tokenBalance;
        *totalToken = totalToken.get() + tokenBalance; 
        
        DIPC_EMIT_EVENT(portfolioInfo, _portfolioName, &portfolioStr[0], "portfolioBalance", tokenBalance);
    }

    
    PAYABLE void PortfolioManage::depositPortfolio(char* _portfolioName){
        uint64_t tokenBalance = getTotalBalance();
        
        uint64_t currentBalance = portfolioBalance.get()[_portfolioName];
        uint64_t finalBalance  = currentBalance + tokenBalance;
        DipcAssert(totalToken.get() + tokenBalance > totalToken);
        DipcAssert(finalBalance > currentBalance);
        (*portfolioBalance)[_portfolioName] = finalBalance;
        *totalToken = totalToken.get() + finalBalance; 
        DIPC_EMIT_EVENT(depositPortfolio, "portfolioName", _portfolioName, "portfolioBalance", finalBalance);
    }
    
    PAYABLE void PortfolioManage::createOrder(char* _portfolioName, char* _orderId, uint16_t _orderType, char* _stockCode, uint64_t _stockPrice, uint64_t _stockAmount, uint64_t _endTime){
        uint64_t tokenBalance = getTotalBalance();
        DIPC_EMIT_EVENT(createOrder, "portfolioName", _portfolioName, "OrderInfo", "ignore", "tokenBalance", tokenBalance);
        uint64_t spent = 0;
        if(_orderType == 1){
            spent = _stockPrice * _stockAmount;
            DipcAssert((portfolioBalance.get()[_portfolioName] + tokenBalance) > spent);
        }
        struct Order order{_orderId, _orderType, _stockCode, _stockPrice, _stockAmount, _endTime, 0};
        std::string pInfo = portfolioStorge.get()[_portfolioName];
        
        
        
        if(pInfo == "") {
            DIPC_EMIT_EVENT(ErrEvent, "Current portfolio  doesn't exist: ", _portfolioName);
            return;
        }
        PortfolioInfo info;
        info.parseJson(pInfo);
        if(info.getOrder(_orderId).orderId != ""){
            DIPC_EMIT_EVENT(ErrEvent, "Current order exist: ", _orderId);
            return;
        }
        info.addOrder(order);
        pInfo = info.toJson();

        uint64_t currentBalance = portfolioBalance.get()[_portfolioName] ;
        uint64_t finalBalance = currentBalance + tokenBalance - spent;
        DipcAssert(totalToken.get() + tokenBalance > totalToken);
        
        DipcAssert(ownerTotalToken.get() < ownerTotalToken.get() + spent);
        (*portfolioStorge)[_portfolioName] = &pInfo[0];
        
        
        
        


        (*portfolioBalance)[_portfolioName] = finalBalance;
        *totalToken = totalToken.get() + finalBalance; 
        *ownerTotalToken = ownerTotalToken.get() + spent;
        DIPC_EMIT_EVENT(createOrder, "portfolioName", _portfolioName, "OrderInfo", &order.toJson()[0], "portfolioBalance", finalBalance);
    }

    
    EXPORT void PortfolioManage::dealOrder(char* _portfolioName, char* _orderId){
        u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
isOwner();
        std::string pInfo = portfolioStorge.get()[_portfolioName];
        
        
        PortfolioInfo info;
        info.parseJson(pInfo);
        

        
         Order ord = info.getOrder(_orderId);
         
         
        if(ord.orderId != "" && ord.orderStatus == 0){
            
            uint64_t timenow = dipc::timestamp();
            if(ord.endTime > timenow){
                ord.orderStatus = 1;
            }else {
                ord.orderStatus = 3;
            }
        } else {
          

            return;
        }
        

        uint64_t sellValue = 0;
        if(ord.orderType == 0){
            sellValue = ord.stockAmount * ord.stockPrice;
        }
        uint64_t currentBalance =  portfolioBalance.get()[_portfolioName];
        

        DipcAssert(currentBalance + sellValue >= currentBalance);
        DipcAssert((ownerTotalToken.get() - sellValue) <= ownerTotalToken.get());
        


        (*portfolioBalance)[_portfolioName] = currentBalance + sellValue;
        *ownerTotalToken = ownerTotalToken.get() - sellValue;
        (*portfolioStorge)[_portfolioName] = &info.toJson()[0];
        
        
        
        

        DIPC_EMIT_EVENT(dealPortfolio, "orderId", _orderId, "orderInfo", &ord.toJson()[0]);
    }
    
    EXPORT void PortfolioManage::revocationOrder(char* _portfolioName, char* _orderId){
        u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
std::string pInfo = portfolioStorge.get()[_portfolioName];
        
        
        PortfolioInfo info;
        info.parseJson(pInfo);
        Order ord = info.getOrder(_orderId);
        
        
        if(ord.orderId != "" && ord.orderStatus == 0){
            std::string callerStr = caller().toString();
            
            
            
            DipcAssert(info.getOwnerAddress() == caller().toString());
            

            uint64_t timenow = dipc::timestamp();
            if(ord.endTime > timenow){
                ord.orderStatus = 2;
            }else {
                ord.orderStatus = 3;
            }
        } else {
            return;
        }
        uint64_t lockToken = 0;
        if(ord.orderType == 1){
            lockToken = ord.stockPrice * ord.stockAmount;
        }
        uint64_t currentBalance =  portfolioBalance.get()[_portfolioName];
        
        
        
        

        DipcAssert(currentBalance + lockToken >= currentBalance);
        DipcAssert(ownerTotalToken.get() - lockToken <= ownerTotalToken.get());

        
        (*portfolioBalance)[_portfolioName] = currentBalance + lockToken;
        *ownerTotalToken = ownerTotalToken.get() - lockToken;
        (*portfolioStorge)[_portfolioName] = &info.toJson()[0];
        DIPC_EMIT_EVENT(revocationPortfolio, "orderId", _orderId, "orderInfo", &ord.toJson()[0]);
    }
    
    EXPORT void PortfolioManage::withdrawPortfolio(char* _portfolioName, uint64_t _withdrawBalance){
         u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
if(!userCanWithdraw.get()){
             return;
         }
         uint64_t currentBalance =  portfolioBalance.get()[_portfolioName];
         DipcAssert(currentBalance - _withdrawBalance < currentBalance);
         auto coinBalance = changeUint64ToU256WithChangeRate(currentBalance, changeRate.get());
         (*portfolioBalance)[_portfolioName] = currentBalance - _withdrawBalance;
         callTransfer(caller(), coinBalance);
    }
    
    EXPORT void PortfolioManage::withdrawPool(uint64_t _balance){
        u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
isOwner();
        Address ownerAddr = Address(owner.get()); 
        callTransfer(ownerAddr, _balance);
        *ownerTotalToken = ownerTotalToken.get() - _balance * changeRate.get();
        *totalToken = totalToken.get() - _balance * changeRate.get();
        DIPC_EMIT_EVENT(tokenCount, "ownerTotalToken", ownerTotalToken.get(), "totalToken", totalToken.get());
    } codetext height #include "PortfolioManage.hpp"

    
    PAYABLE void PortfolioManage::init(){
        *owner = caller().toString();
        *changeRate = 10000;
        *userCanWithdraw = false;
        uint64_t tokenBalance = getTotalBalance();
        
        *ownerTotalToken = tokenBalance;
        *totalToken = ownerTotalToken.get();
        
        
        DIPC_EMIT_EVENT(initEvent, "ownerTotalToken" ,tokenBalance);
    }
    
     
    EXPORT void PortfolioManage::setChangeRate(uint64_t _changeRate){
        isOwner();
        *changeRate = _changeRate;
    }
     
    EXPORT void PortfolioManage::setUserCanWithdraw(bool _canWithdraw){
        u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
isOwner();
        *userCanWithdraw = _canWithdraw;
    }

    
    PAYABLE void PortfolioManage::createPortfolio(char* _portfolioName, char* _portfolioDesc){
        if(portfolioStorge.get()[_portfolioName] != ""){
            DIPC_EMIT_EVENT(ErrEvent, "Current portfolio exist: ", _portfolioName);
            return;
        } 
        std::string callerAddr = caller().toString();
        uint64_t tokenBalance = getTotalBalance();
        
        PortfolioInfo info(_portfolioName, _portfolioDesc, &callerAddr[0]);
        std::string portfolioStr = info.toJson();
        
        
        

        (*portfolioStorge)[_portfolioName] = portfolioStr;
        DipcAssert(totalToken.get() + tokenBalance > totalToken);
        (*portfolioBalance)[_portfolioName] = tokenBalance;
        *totalToken = totalToken.get() + tokenBalance; 
        
        DIPC_EMIT_EVENT(portfolioInfo, _portfolioName, &portfolioStr[0], "portfolioBalance", tokenBalance);
    }

    
    PAYABLE void PortfolioManage::depositPortfolio(char* _portfolioName){
        uint64_t tokenBalance = getTotalBalance();
        
        uint64_t currentBalance = portfolioBalance.get()[_portfolioName];
        uint64_t finalBalance  = currentBalance + tokenBalance;
        DipcAssert(totalToken.get() + tokenBalance > totalToken);
        DipcAssert(finalBalance > currentBalance);
        (*portfolioBalance)[_portfolioName] = finalBalance;
        *totalToken = totalToken.get() + finalBalance; 
        DIPC_EMIT_EVENT(depositPortfolio, "portfolioName", _portfolioName, "portfolioBalance", finalBalance);
    }
    
    PAYABLE void PortfolioManage::createOrder(char* _portfolioName, char* _orderId, uint16_t _orderType, char* _stockCode, uint64_t _stockPrice, uint64_t _stockAmount, uint64_t _endTime){
        uint64_t tokenBalance = getTotalBalance();
        DIPC_EMIT_EVENT(createOrder, "portfolioName", _portfolioName, "OrderInfo", "ignore", "tokenBalance", tokenBalance);
        uint64_t spent = 0;
        if(_orderType == 1){
            spent = _stockPrice * _stockAmount;
            DipcAssert((portfolioBalance.get()[_portfolioName] + tokenBalance) > spent);
        }
        struct Order order{_orderId, _orderType, _stockCode, _stockPrice, _stockAmount, _endTime, 0};
        std::string pInfo = portfolioStorge.get()[_portfolioName];
        
        
        
        if(pInfo == "") {
            DIPC_EMIT_EVENT(ErrEvent, "Current portfolio  doesn't exist: ", _portfolioName);
            return;
        }
        PortfolioInfo info;
        info.parseJson(pInfo);
        if(info.getOrder(_orderId).orderId != ""){
            DIPC_EMIT_EVENT(ErrEvent, "Current order exist: ", _orderId);
            return;
        }
        info.addOrder(order);
        pInfo = info.toJson();

        uint64_t currentBalance = portfolioBalance.get()[_portfolioName] ;
        uint64_t finalBalance = currentBalance + tokenBalance - spent;
        DipcAssert(totalToken.get() + tokenBalance > totalToken);
        
        DipcAssert(ownerTotalToken.get() < ownerTotalToken.get() + spent);
        (*portfolioStorge)[_portfolioName] = &pInfo[0];
        
        
        
        


        (*portfolioBalance)[_portfolioName] = finalBalance;
        *totalToken = totalToken.get() + finalBalance; 
        *ownerTotalToken = ownerTotalToken.get() + spent;
        DIPC_EMIT_EVENT(createOrder, "portfolioName", _portfolioName, "OrderInfo", &order.toJson()[0], "portfolioBalance", finalBalance);
    }

    
    EXPORT void PortfolioManage::dealOrder(char* _portfolioName, char* _orderId){
        u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
isOwner();
        std::string pInfo = portfolioStorge.get()[_portfolioName];
        
        
        PortfolioInfo info;
        info.parseJson(pInfo);
        

        
         Order ord = info.getOrder(_orderId);
         
         
        if(ord.orderId != "" && ord.orderStatus == 0){
            
            uint64_t timenow = dipc::timestamp();
            if(ord.endTime > timenow){
                ord.orderStatus = 1;
            }else {
                ord.orderStatus = 3;
            }
        } else {
          

            return;
        }
        

        uint64_t sellValue = 0;
        if(ord.orderType == 0){
            sellValue = ord.stockAmount * ord.stockPrice;
        }
        uint64_t currentBalance =  portfolioBalance.get()[_portfolioName];
        

        DipcAssert(currentBalance + sellValue >= currentBalance);
        DipcAssert((ownerTotalToken.get() - sellValue) <= ownerTotalToken.get());
        


        (*portfolioBalance)[_portfolioName] = currentBalance + sellValue;
        *ownerTotalToken = ownerTotalToken.get() - sellValue;
        (*portfolioStorge)[_portfolioName] = &info.toJson()[0];
        
        
        
        

        DIPC_EMIT_EVENT(dealPortfolio, "orderId", _orderId, "orderInfo", &ord.toJson()[0]);
    }
    
    EXPORT void PortfolioManage::revocationOrder(char* _portfolioName, char* _orderId){
        u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
std::string pInfo = portfolioStorge.get()[_portfolioName];
        
        
        PortfolioInfo info;
        info.parseJson(pInfo);
        Order ord = info.getOrder(_orderId);
        
        
        if(ord.orderId != "" && ord.orderStatus == 0){
            std::string callerStr = caller().toString();
            
            
            
            DipcAssert(info.getOwnerAddress() == caller().toString());
            

            uint64_t timenow = dipc::timestamp();
            if(ord.endTime > timenow){
                ord.orderStatus = 2;
            }else {
                ord.orderStatus = 3;
            }
        } else {
            return;
        }
        uint64_t lockToken = 0;
        if(ord.orderType == 1){
            lockToken = ord.stockPrice * ord.stockAmount;
        }
        uint64_t currentBalance =  portfolioBalance.get()[_portfolioName];
        
        
        
        

        DipcAssert(currentBalance + lockToken >= currentBalance);
        DipcAssert(ownerTotalToken.get() - lockToken <= ownerTotalToken.get());

        
        (*portfolioBalance)[_portfolioName] = currentBalance + lockToken;
        *ownerTotalToken = ownerTotalToken.get() - lockToken;
        (*portfolioStorge)[_portfolioName] = &info.toJson()[0];
        DIPC_EMIT_EVENT(revocationPortfolio, "orderId", _orderId, "orderInfo", &ord.toJson()[0]);
    }
    
    EXPORT void PortfolioManage::withdrawPortfolio(char* _portfolioName, uint64_t _withdrawBalance){
         u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
if(!userCanWithdraw.get()){
             return;
         }
         uint64_t currentBalance =  portfolioBalance.get()[_portfolioName];
         DipcAssert(currentBalance - _withdrawBalance < currentBalance);
         auto coinBalance = changeUint64ToU256WithChangeRate(currentBalance, changeRate.get());
         (*portfolioBalance)[_portfolioName] = currentBalance - _withdrawBalance;
         callTransfer(caller(), coinBalance);
    }
    
    EXPORT void PortfolioManage::withdrawPool(uint64_t _balance){
        isOwner();
        Address ownerAddr = Address(owner.get()); 
        callTransfer(ownerAddr, _balance);
        *ownerTotalToken = ownerTotalToken.get() - _balance * changeRate.get();
        *totalToken = totalToken.get() - _balance * changeRate.get();
        DIPC_EMIT_EVENT(tokenCount, "ownerTotalToken", ownerTotalToken.get(), "totalToken", totalToken.get());
    }
    
    PAYABLE void PortfolioManage::depositPool(uint64_t _depositValue){
        isOwner();
        
        uint64_t tokenBalance = changeU256ToUint64WithChangeRate(callValue(), changeRate.get()); 
        *ownerTotalToken = ownerTotalToken.get() + tokenBalance;
        *totalToken = totalToken.get() + tokenBalance;
        DIPC_EMIT_EVENT(tokenCount, "ownerTotalToken", ownerTotalToken.get(), "totalToken", totalToken.get());
    }
     
    CONSTANT uint64_t PortfolioManage::queryTotalToken(){
        return totalToken.get();
    }

     
    CONSTANT uint64_t PortfolioManage::queryPortfolioBalance(char* _portfolioName){
        return portfolioBalance.get()[_portfolioName];
    }

    
    CONSTANT bool PortfolioManage::queryPortfolioNameIfUsed(char* _portfolioName){
        if(portfolioStorge.get()[_portfolioName] != ""){
            return true;
        } 
        return false;
    }

    
    CONSTANT uint64_t PortfolioManage::queryChangeRate(){
        return changeRate.get();
    }

2019-12-19_15:14:54.336436: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:427] searchContext  
    
    PAYABLE void PortfolioManage::depositPool(uint64_t _depositValue){
        isOwner();
        
        uint64_t tokenBalance = changeU256ToUint64WithChangeRate(callValue(), changeRate.get()); 
        *ownerTotalToken = ownerTotalToken.get() + tokenBalance;
        *totalToken = totalToken.get() + tokenBalance;
        DIPC_EMIT_EVENT(tokenCount, "ownerTotalToken", ownerTotalToken.get(), "totalToken", totalToken.get());
    }
     
    CONSTANT uint64_t PortfolioManage::queryTotalToken(){
        return totalToken.get();
    }

     
    CONSTANT uint64_t PortfolioManage::queryPortfolioBalance(char* _portfolioName){
        return portfolioBalance.get()[_portfolioName];
    }

    
    CONSTANT bool PortfolioManage::queryPortfolioNameIfUsed(char* _portfolioName){
        if(portfolioStorge.get()[_portfolioName] != ""){
            return true;
        } 
        return false;
    }

    
    CONSTANT uint64_t PortfolioManage::queryChangeRate(){
        return changeRate.get();
    }

2019-12-19_15:14:54.356280: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:442] finalContract  this new  #include "PortfolioManage.hpp"

    
    PAYABLE void PortfolioManage::init(){
        *owner = caller().toString();
        *changeRate = 10000;
        *userCanWithdraw = false;
        uint64_t tokenBalance = getTotalBalance();
        
        *ownerTotalToken = tokenBalance;
        *totalToken = ownerTotalToken.get();
        
        
        DIPC_EMIT_EVENT(initEvent, "ownerTotalToken" ,tokenBalance);
    }
    
     
    EXPORT void PortfolioManage::setChangeRate(uint64_t _changeRate){
        isOwner();
        *changeRate = _changeRate;
    }
     
    EXPORT void PortfolioManage::setUserCanWithdraw(bool _canWithdraw){
        u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
isOwner();
        *userCanWithdraw = _canWithdraw;
    }

    
    PAYABLE void PortfolioManage::createPortfolio(char* _portfolioName, char* _portfolioDesc){
        if(portfolioStorge.get()[_portfolioName] != ""){
            DIPC_EMIT_EVENT(ErrEvent, "Current portfolio exist: ", _portfolioName);
            return;
        } 
        std::string callerAddr = caller().toString();
        uint64_t tokenBalance = getTotalBalance();
        
        PortfolioInfo info(_portfolioName, _portfolioDesc, &callerAddr[0]);
        std::string portfolioStr = info.toJson();
        
        
        

        (*portfolioStorge)[_portfolioName] = portfolioStr;
        DipcAssert(totalToken.get() + tokenBalance > totalToken);
        (*portfolioBalance)[_portfolioName] = tokenBalance;
        *totalToken = totalToken.get() + tokenBalance; 
        
        DIPC_EMIT_EVENT(portfolioInfo, _portfolioName, &portfolioStr[0], "portfolioBalance", tokenBalance);
    }

    
    PAYABLE void PortfolioManage::depositPortfolio(char* _portfolioName){
        uint64_t tokenBalance = getTotalBalance();
        
        uint64_t currentBalance = portfolioBalance.get()[_portfolioName];
        uint64_t finalBalance  = currentBalance + tokenBalance;
        DipcAssert(totalToken.get() + tokenBalance > totalToken);
        DipcAssert(finalBalance > currentBalance);
        (*portfolioBalance)[_portfolioName] = finalBalance;
        *totalToken = totalToken.get() + finalBalance; 
        DIPC_EMIT_EVENT(depositPortfolio, "portfolioName", _portfolioName, "portfolioBalance", finalBalance);
    }
    
    PAYABLE void PortfolioManage::createOrder(char* _portfolioName, char* _orderId, uint16_t _orderType, char* _stockCode, uint64_t _stockPrice, uint64_t _stockAmount, uint64_t _endTime){
        uint64_t tokenBalance = getTotalBalance();
        DIPC_EMIT_EVENT(createOrder, "portfolioName", _portfolioName, "OrderInfo", "ignore", "tokenBalance", tokenBalance);
        uint64_t spent = 0;
        if(_orderType == 1){
            spent = _stockPrice * _stockAmount;
            DipcAssert((portfolioBalance.get()[_portfolioName] + tokenBalance) > spent);
        }
        struct Order order{_orderId, _orderType, _stockCode, _stockPrice, _stockAmount, _endTime, 0};
        std::string pInfo = portfolioStorge.get()[_portfolioName];
        
        
        
        if(pInfo == "") {
            DIPC_EMIT_EVENT(ErrEvent, "Current portfolio  doesn't exist: ", _portfolioName);
            return;
        }
        PortfolioInfo info;
        info.parseJson(pInfo);
        if(info.getOrder(_orderId).orderId != ""){
            DIPC_EMIT_EVENT(ErrEvent, "Current order exist: ", _orderId);
            return;
        }
        info.addOrder(order);
        pInfo = info.toJson();

        uint64_t currentBalance = portfolioBalance.get()[_portfolioName] ;
        uint64_t finalBalance = currentBalance + tokenBalance - spent;
        DipcAssert(totalToken.get() + tokenBalance > totalToken);
        
        DipcAssert(ownerTotalToken.get() < ownerTotalToken.get() + spent);
        (*portfolioStorge)[_portfolioName] = &pInfo[0];
        
        
        
        


        (*portfolioBalance)[_portfolioName] = finalBalance;
        *totalToken = totalToken.get() + finalBalance; 
        *ownerTotalToken = ownerTotalToken.get() + spent;
        DIPC_EMIT_EVENT(createOrder, "portfolioName", _portfolioName, "OrderInfo", &order.toJson()[0], "portfolioBalance", finalBalance);
    }

    
    EXPORT void PortfolioManage::dealOrder(char* _portfolioName, char* _orderId){
        u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
isOwner();
        std::string pInfo = portfolioStorge.get()[_portfolioName];
        
        
        PortfolioInfo info;
        info.parseJson(pInfo);
        

        
         Order ord = info.getOrder(_orderId);
         
         
        if(ord.orderId != "" && ord.orderStatus == 0){
            
            uint64_t timenow = dipc::timestamp();
            if(ord.endTime > timenow){
                ord.orderStatus = 1;
            }else {
                ord.orderStatus = 3;
            }
        } else {
          

            return;
        }
        

        uint64_t sellValue = 0;
        if(ord.orderType == 0){
            sellValue = ord.stockAmount * ord.stockPrice;
        }
        uint64_t currentBalance =  portfolioBalance.get()[_portfolioName];
        

        DipcAssert(currentBalance + sellValue >= currentBalance);
        DipcAssert((ownerTotalToken.get() - sellValue) <= ownerTotalToken.get());
        


        (*portfolioBalance)[_portfolioName] = currentBalance + sellValue;
        *ownerTotalToken = ownerTotalToken.get() - sellValue;
        (*portfolioStorge)[_portfolioName] = &info.toJson()[0];
        
        
        
        

        DIPC_EMIT_EVENT(dealPortfolio, "orderId", _orderId, "orderInfo", &ord.toJson()[0]);
    }
    
    EXPORT void PortfolioManage::revocationOrder(char* _portfolioName, char* _orderId){
        u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
std::string pInfo = portfolioStorge.get()[_portfolioName];
        
        
        PortfolioInfo info;
        info.parseJson(pInfo);
        Order ord = info.getOrder(_orderId);
        
        
        if(ord.orderId != "" && ord.orderStatus == 0){
            std::string callerStr = caller().toString();
            
            
            
            DipcAssert(info.getOwnerAddress() == caller().toString());
            

            uint64_t timenow = dipc::timestamp();
            if(ord.endTime > timenow){
                ord.orderStatus = 2;
            }else {
                ord.orderStatus = 3;
            }
        } else {
            return;
        }
        uint64_t lockToken = 0;
        if(ord.orderType == 1){
            lockToken = ord.stockPrice * ord.stockAmount;
        }
        uint64_t currentBalance =  portfolioBalance.get()[_portfolioName];
        
        
        
        

        DipcAssert(currentBalance + lockToken >= currentBalance);
        DipcAssert(ownerTotalToken.get() - lockToken <= ownerTotalToken.get());

        
        (*portfolioBalance)[_portfolioName] = currentBalance + lockToken;
        *ownerTotalToken = ownerTotalToken.get() - lockToken;
        (*portfolioStorge)[_portfolioName] = &info.toJson()[0];
        DIPC_EMIT_EVENT(revocationPortfolio, "orderId", _orderId, "orderInfo", &ord.toJson()[0]);
    }
    
    EXPORT void PortfolioManage::withdrawPortfolio(char* _portfolioName, uint64_t _withdrawBalance){
         u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
if(!userCanWithdraw.get()){
             return;
         }
         uint64_t currentBalance =  portfolioBalance.get()[_portfolioName];
         DipcAssert(currentBalance - _withdrawBalance < currentBalance);
         auto coinBalance = changeUint64ToU256WithChangeRate(currentBalance, changeRate.get());
         (*portfolioBalance)[_portfolioName] = currentBalance - _withdrawBalance;
         callTransfer(caller(), coinBalance);
    }
    
    EXPORT void PortfolioManage::withdrawPool(uint64_t _balance){
        u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
isOwner();
        Address ownerAddr = Address(owner.get()); 
        callTransfer(ownerAddr, _balance);
        *ownerTotalToken = ownerTotalToken.get() - _balance * changeRate.get();
        *totalToken = totalToken.get() - _balance * changeRate.get();
        DIPC_EMIT_EVENT(tokenCount, "ownerTotalToken", ownerTotalToken.get(), "totalToken", totalToken.get());
    } codetext new #include "PortfolioManage.hpp"

    
    PAYABLE void PortfolioManage::init(){
        *owner = caller().toString();
        *changeRate = 10000;
        *userCanWithdraw = false;
        uint64_t tokenBalance = getTotalBalance();
        
        *ownerTotalToken = tokenBalance;
        *totalToken = ownerTotalToken.get();
        
        
        DIPC_EMIT_EVENT(initEvent, "ownerTotalToken" ,tokenBalance);
    }
    
     
    EXPORT void PortfolioManage::setChangeRate(uint64_t _changeRate){
        isOwner();
        *changeRate = _changeRate;
    }
     
    EXPORT void PortfolioManage::setUserCanWithdraw(bool _canWithdraw){
        u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
isOwner();
        *userCanWithdraw = _canWithdraw;
    }

    
    PAYABLE void PortfolioManage::createPortfolio(char* _portfolioName, char* _portfolioDesc){
        if(portfolioStorge.get()[_portfolioName] != ""){
            DIPC_EMIT_EVENT(ErrEvent, "Current portfolio exist: ", _portfolioName);
            return;
        } 
        std::string callerAddr = caller().toString();
        uint64_t tokenBalance = getTotalBalance();
        
        PortfolioInfo info(_portfolioName, _portfolioDesc, &callerAddr[0]);
        std::string portfolioStr = info.toJson();
        
        
        

        (*portfolioStorge)[_portfolioName] = portfolioStr;
        DipcAssert(totalToken.get() + tokenBalance > totalToken);
        (*portfolioBalance)[_portfolioName] = tokenBalance;
        *totalToken = totalToken.get() + tokenBalance; 
        
        DIPC_EMIT_EVENT(portfolioInfo, _portfolioName, &portfolioStr[0], "portfolioBalance", tokenBalance);
    }

    
    PAYABLE void PortfolioManage::depositPortfolio(char* _portfolioName){
        uint64_t tokenBalance = getTotalBalance();
        
        uint64_t currentBalance = portfolioBalance.get()[_portfolioName];
        uint64_t finalBalance  = currentBalance + tokenBalance;
        DipcAssert(totalToken.get() + tokenBalance > totalToken);
        DipcAssert(finalBalance > currentBalance);
        (*portfolioBalance)[_portfolioName] = finalBalance;
        *totalToken = totalToken.get() + finalBalance; 
        DIPC_EMIT_EVENT(depositPortfolio, "portfolioName", _portfolioName, "portfolioBalance", finalBalance);
    }
    
    PAYABLE void PortfolioManage::createOrder(char* _portfolioName, char* _orderId, uint16_t _orderType, char* _stockCode, uint64_t _stockPrice, uint64_t _stockAmount, uint64_t _endTime){
        uint64_t tokenBalance = getTotalBalance();
        DIPC_EMIT_EVENT(createOrder, "portfolioName", _portfolioName, "OrderInfo", "ignore", "tokenBalance", tokenBalance);
        uint64_t spent = 0;
        if(_orderType == 1){
            spent = _stockPrice * _stockAmount;
            DipcAssert((portfolioBalance.get()[_portfolioName] + tokenBalance) > spent);
        }
        struct Order order{_orderId, _orderType, _stockCode, _stockPrice, _stockAmount, _endTime, 0};
        std::string pInfo = portfolioStorge.get()[_portfolioName];
        
        
        
        if(pInfo == "") {
            DIPC_EMIT_EVENT(ErrEvent, "Current portfolio  doesn't exist: ", _portfolioName);
            return;
        }
        PortfolioInfo info;
        info.parseJson(pInfo);
        if(info.getOrder(_orderId).orderId != ""){
            DIPC_EMIT_EVENT(ErrEvent, "Current order exist: ", _orderId);
            return;
        }
        info.addOrder(order);
        pInfo = info.toJson();

        uint64_t currentBalance = portfolioBalance.get()[_portfolioName] ;
        uint64_t finalBalance = currentBalance + tokenBalance - spent;
        DipcAssert(totalToken.get() + tokenBalance > totalToken);
        
        DipcAssert(ownerTotalToken.get() < ownerTotalToken.get() + spent);
        (*portfolioStorge)[_portfolioName] = &pInfo[0];
        
        
        
        


        (*portfolioBalance)[_portfolioName] = finalBalance;
        *totalToken = totalToken.get() + finalBalance; 
        *ownerTotalToken = ownerTotalToken.get() + spent;
        DIPC_EMIT_EVENT(createOrder, "portfolioName", _portfolioName, "OrderInfo", &order.toJson()[0], "portfolioBalance", finalBalance);
    }

    
    EXPORT void PortfolioManage::dealOrder(char* _portfolioName, char* _orderId){
        u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
isOwner();
        std::string pInfo = portfolioStorge.get()[_portfolioName];
        
        
        PortfolioInfo info;
        info.parseJson(pInfo);
        

        
         Order ord = info.getOrder(_orderId);
         
         
        if(ord.orderId != "" && ord.orderStatus == 0){
            
            uint64_t timenow = dipc::timestamp();
            if(ord.endTime > timenow){
                ord.orderStatus = 1;
            }else {
                ord.orderStatus = 3;
            }
        } else {
          

            return;
        }
        

        uint64_t sellValue = 0;
        if(ord.orderType == 0){
            sellValue = ord.stockAmount * ord.stockPrice;
        }
        uint64_t currentBalance =  portfolioBalance.get()[_portfolioName];
        

        DipcAssert(currentBalance + sellValue >= currentBalance);
        DipcAssert((ownerTotalToken.get() - sellValue) <= ownerTotalToken.get());
        


        (*portfolioBalance)[_portfolioName] = currentBalance + sellValue;
        *ownerTotalToken = ownerTotalToken.get() - sellValue;
        (*portfolioStorge)[_portfolioName] = &info.toJson()[0];
        
        
        
        

        DIPC_EMIT_EVENT(dealPortfolio, "orderId", _orderId, "orderInfo", &ord.toJson()[0]);
    }
    
    EXPORT void PortfolioManage::revocationOrder(char* _portfolioName, char* _orderId){
        u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
std::string pInfo = portfolioStorge.get()[_portfolioName];
        
        
        PortfolioInfo info;
        info.parseJson(pInfo);
        Order ord = info.getOrder(_orderId);
        
        
        if(ord.orderId != "" && ord.orderStatus == 0){
            std::string callerStr = caller().toString();
            
            
            
            DipcAssert(info.getOwnerAddress() == caller().toString());
            

            uint64_t timenow = dipc::timestamp();
            if(ord.endTime > timenow){
                ord.orderStatus = 2;
            }else {
                ord.orderStatus = 3;
            }
        } else {
            return;
        }
        uint64_t lockToken = 0;
        if(ord.orderType == 1){
            lockToken = ord.stockPrice * ord.stockAmount;
        }
        uint64_t currentBalance =  portfolioBalance.get()[_portfolioName];
        
        
        
        

        DipcAssert(currentBalance + lockToken >= currentBalance);
        DipcAssert(ownerTotalToken.get() - lockToken <= ownerTotalToken.get());

        
        (*portfolioBalance)[_portfolioName] = currentBalance + lockToken;
        *ownerTotalToken = ownerTotalToken.get() - lockToken;
        (*portfolioStorge)[_portfolioName] = &info.toJson()[0];
        DIPC_EMIT_EVENT(revocationPortfolio, "orderId", _orderId, "orderInfo", &ord.toJson()[0]);
    }
    
    EXPORT void PortfolioManage::withdrawPortfolio(char* _portfolioName, uint64_t _withdrawBalance){
         u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
if(!userCanWithdraw.get()){
             return;
         }
         uint64_t currentBalance =  portfolioBalance.get()[_portfolioName];
         DipcAssert(currentBalance - _withdrawBalance < currentBalance);
         auto coinBalance = changeUint64ToU256WithChangeRate(currentBalance, changeRate.get());
         (*portfolioBalance)[_portfolioName] = currentBalance - _withdrawBalance;
         callTransfer(caller(), coinBalance);
    }
    
    EXPORT void PortfolioManage::withdrawPool(uint64_t _balance){
        isOwner();
        Address ownerAddr = Address(owner.get()); 
        callTransfer(ownerAddr, _balance);
        *ownerTotalToken = ownerTotalToken.get() - _balance * changeRate.get();
        *totalToken = totalToken.get() - _balance * changeRate.get();
        DIPC_EMIT_EVENT(tokenCount, "ownerTotalToken", ownerTotalToken.get(), "totalToken", totalToken.get());
    }
    
    PAYABLE void PortfolioManage::depositPool(uint64_t _depositValue){
        isOwner();
        
        uint64_t tokenBalance = changeU256ToUint64WithChangeRate(callValue(), changeRate.get()); 
        *ownerTotalToken = ownerTotalToken.get() + tokenBalance;
        *totalToken = totalToken.get() + tokenBalance;
        DIPC_EMIT_EVENT(tokenCount, "ownerTotalToken", ownerTotalToken.get(), "totalToken", totalToken.get());
    }
     
    CONSTANT uint64_t PortfolioManage::queryTotalToken(){
        return totalToken.get();
    }

     
    CONSTANT uint64_t PortfolioManage::queryPortfolioBalance(char* _portfolioName){
        return portfolioBalance.get()[_portfolioName];
    }

    
    CONSTANT bool PortfolioManage::queryPortfolioNameIfUsed(char* _portfolioName){
        if(portfolioStorge.get()[_portfolioName] != ""){
            return true;
        } 
        return false;
    }

    
    CONSTANT uint64_t PortfolioManage::queryChangeRate(){
        return changeRate.get();
    }

2019-12-19_15:14:54.356385: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:604] finalContract  final content =======   : #include "PortfolioManage.hpp"

    
    PAYABLE void PortfolioManage::init(){
        *owner = caller().toString();
        *changeRate = 10000;
        *userCanWithdraw = false;
        uint64_t tokenBalance = getTotalBalance();
        
        *ownerTotalToken = tokenBalance;
        *totalToken = ownerTotalToken.get();
        
        
        DIPC_EMIT_EVENT(initEvent, "ownerTotalToken" ,tokenBalance);
    }
    
     
    EXPORT void PortfolioManage::setChangeRate(uint64_t _changeRate){
        isOwner();
        *changeRate = _changeRate;
    }
     
    EXPORT void PortfolioManage::setUserCanWithdraw(bool _canWithdraw){
        u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
isOwner();
        *userCanWithdraw = _canWithdraw;
    }

    
    PAYABLE void PortfolioManage::createPortfolio(char* _portfolioName, char* _portfolioDesc){
        if(portfolioStorge.get()[_portfolioName] != ""){
            DIPC_EMIT_EVENT(ErrEvent, "Current portfolio exist: ", _portfolioName);
            return;
        } 
        std::string callerAddr = caller().toString();
        uint64_t tokenBalance = getTotalBalance();
        
        PortfolioInfo info(_portfolioName, _portfolioDesc, &callerAddr[0]);
        std::string portfolioStr = info.toJson();
        
        
        

        (*portfolioStorge)[_portfolioName] = portfolioStr;
        DipcAssert(totalToken.get() + tokenBalance > totalToken);
        (*portfolioBalance)[_portfolioName] = tokenBalance;
        *totalToken = totalToken.get() + tokenBalance; 
        
        DIPC_EMIT_EVENT(portfolioInfo, _portfolioName, &portfolioStr[0], "portfolioBalance", tokenBalance);
    }

    
    PAYABLE void PortfolioManage::depositPortfolio(char* _portfolioName){
        uint64_t tokenBalance = getTotalBalance();
        
        uint64_t currentBalance = portfolioBalance.get()[_portfolioName];
        uint64_t finalBalance  = currentBalance + tokenBalance;
        DipcAssert(totalToken.get() + tokenBalance > totalToken);
        DipcAssert(finalBalance > currentBalance);
        (*portfolioBalance)[_portfolioName] = finalBalance;
        *totalToken = totalToken.get() + finalBalance; 
        DIPC_EMIT_EVENT(depositPortfolio, "portfolioName", _portfolioName, "portfolioBalance", finalBalance);
    }
    
    PAYABLE void PortfolioManage::createOrder(char* _portfolioName, char* _orderId, uint16_t _orderType, char* _stockCode, uint64_t _stockPrice, uint64_t _stockAmount, uint64_t _endTime){
        uint64_t tokenBalance = getTotalBalance();
        DIPC_EMIT_EVENT(createOrder, "portfolioName", _portfolioName, "OrderInfo", "ignore", "tokenBalance", tokenBalance);
        uint64_t spent = 0;
        if(_orderType == 1){
            spent = _stockPrice * _stockAmount;
            DipcAssert((portfolioBalance.get()[_portfolioName] + tokenBalance) > spent);
        }
        struct Order order{_orderId, _orderType, _stockCode, _stockPrice, _stockAmount, _endTime, 0};
        std::string pInfo = portfolioStorge.get()[_portfolioName];
        
        
        
        if(pInfo == "") {
            DIPC_EMIT_EVENT(ErrEvent, "Current portfolio  doesn't exist: ", _portfolioName);
            return;
        }
        PortfolioInfo info;
        info.parseJson(pInfo);
        if(info.getOrder(_orderId).orderId != ""){
            DIPC_EMIT_EVENT(ErrEvent, "Current order exist: ", _orderId);
            return;
        }
        info.addOrder(order);
        pInfo = info.toJson();

        uint64_t currentBalance = portfolioBalance.get()[_portfolioName] ;
        uint64_t finalBalance = currentBalance + tokenBalance - spent;
        DipcAssert(totalToken.get() + tokenBalance > totalToken);
        
        DipcAssert(ownerTotalToken.get() < ownerTotalToken.get() + spent);
        (*portfolioStorge)[_portfolioName] = &pInfo[0];
        
        
        
        


        (*portfolioBalance)[_portfolioName] = finalBalance;
        *totalToken = totalToken.get() + finalBalance; 
        *ownerTotalToken = ownerTotalToken.get() + spent;
        DIPC_EMIT_EVENT(createOrder, "portfolioName", _portfolioName, "OrderInfo", &order.toJson()[0], "portfolioBalance", finalBalance);
    }

    
    EXPORT void PortfolioManage::dealOrder(char* _portfolioName, char* _orderId){
        u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
isOwner();
        std::string pInfo = portfolioStorge.get()[_portfolioName];
        
        
        PortfolioInfo info;
        info.parseJson(pInfo);
        

        
         Order ord = info.getOrder(_orderId);
         
         
        if(ord.orderId != "" && ord.orderStatus == 0){
            
            uint64_t timenow = dipc::timestamp();
            if(ord.endTime > timenow){
                ord.orderStatus = 1;
            }else {
                ord.orderStatus = 3;
            }
        } else {
          

            return;
        }
        

        uint64_t sellValue = 0;
        if(ord.orderType == 0){
            sellValue = ord.stockAmount * ord.stockPrice;
        }
        uint64_t currentBalance =  portfolioBalance.get()[_portfolioName];
        

        DipcAssert(currentBalance + sellValue >= currentBalance);
        DipcAssert((ownerTotalToken.get() - sellValue) <= ownerTotalToken.get());
        


        (*portfolioBalance)[_portfolioName] = currentBalance + sellValue;
        *ownerTotalToken = ownerTotalToken.get() - sellValue;
        (*portfolioStorge)[_portfolioName] = &info.toJson()[0];
        
        
        
        

        DIPC_EMIT_EVENT(dealPortfolio, "orderId", _orderId, "orderInfo", &ord.toJson()[0]);
    }
    
    EXPORT void PortfolioManage::revocationOrder(char* _portfolioName, char* _orderId){
        u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
std::string pInfo = portfolioStorge.get()[_portfolioName];
        
        
        PortfolioInfo info;
        info.parseJson(pInfo);
        Order ord = info.getOrder(_orderId);
        
        
        if(ord.orderId != "" && ord.orderStatus == 0){
            std::string callerStr = caller().toString();
            
            
            
            DipcAssert(info.getOwnerAddress() == caller().toString());
            

            uint64_t timenow = dipc::timestamp();
            if(ord.endTime > timenow){
                ord.orderStatus = 2;
            }else {
                ord.orderStatus = 3;
            }
        } else {
            return;
        }
        uint64_t lockToken = 0;
        if(ord.orderType == 1){
            lockToken = ord.stockPrice * ord.stockAmount;
        }
        uint64_t currentBalance =  portfolioBalance.get()[_portfolioName];
        
        
        
        

        DipcAssert(currentBalance + lockToken >= currentBalance);
        DipcAssert(ownerTotalToken.get() - lockToken <= ownerTotalToken.get());

        
        (*portfolioBalance)[_portfolioName] = currentBalance + lockToken;
        *ownerTotalToken = ownerTotalToken.get() - lockToken;
        (*portfolioStorge)[_portfolioName] = &info.toJson()[0];
        DIPC_EMIT_EVENT(revocationPortfolio, "orderId", _orderId, "orderInfo", &ord.toJson()[0]);
    }
    
    EXPORT void PortfolioManage::withdrawPortfolio(char* _portfolioName, uint64_t _withdrawBalance){
         u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
if(!userCanWithdraw.get()){
             return;
         }
         uint64_t currentBalance =  portfolioBalance.get()[_portfolioName];
         DipcAssert(currentBalance - _withdrawBalance < currentBalance);
         auto coinBalance = changeUint64ToU256WithChangeRate(currentBalance, changeRate.get());
         (*portfolioBalance)[_portfolioName] = currentBalance - _withdrawBalance;
         callTransfer(caller(), coinBalance);
    }
    
    EXPORT void PortfolioManage::withdrawPool(uint64_t _balance){
        u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
isOwner();
        Address ownerAddr = Address(owner.get()); 
        callTransfer(ownerAddr, _balance);
        *ownerTotalToken = ownerTotalToken.get() - _balance * changeRate.get();
        *totalToken = totalToken.get() - _balance * changeRate.get();
        DIPC_EMIT_EVENT(tokenCount, "ownerTotalToken", ownerTotalToken.get(), "totalToken", totalToken.get());
    }
    
    PAYABLE void PortfolioManage::depositPool(uint64_t _depositValue){
        isOwner();
        
        uint64_t tokenBalance = changeU256ToUint64WithChangeRate(callValue(), changeRate.get()); 
        *ownerTotalToken = ownerTotalToken.get() + tokenBalance;
        *totalToken = totalToken.get() + tokenBalance;
        DIPC_EMIT_EVENT(tokenCount, "ownerTotalToken", ownerTotalToken.get(), "totalToken", totalToken.get());
    }
     
    CONSTANT uint64_t PortfolioManage::queryTotalToken(){
        return totalToken.get();
    }

     
    CONSTANT uint64_t PortfolioManage::queryPortfolioBalance(char* _portfolioName){
        return portfolioBalance.get()[_portfolioName];
    }

    
    CONSTANT bool PortfolioManage::queryPortfolioNameIfUsed(char* _portfolioName){
        if(portfolioStorge.get()[_portfolioName] != ""){
            return true;
        } 
        return false;
    }

    
    CONSTANT uint64_t PortfolioManage::queryChangeRate(){
        return changeRate.get();
    }

2019-12-19_15:14:54.356399: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:401] abis.ispayable :false

2019-12-19_15:14:54.356417: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:424] finalContract  this height  #include "PortfolioManage.hpp"

    
    PAYABLE void PortfolioManage::init(){
        *owner = caller().toString();
        *changeRate = 10000;
        *userCanWithdraw = false;
        uint64_t tokenBalance = getTotalBalance();
        
        *ownerTotalToken = tokenBalance;
        *totalToken = ownerTotalToken.get();
        
        
        DIPC_EMIT_EVENT(initEvent, "ownerTotalToken" ,tokenBalance);
    }
    
     
    EXPORT void PortfolioManage::setChangeRate(uint64_t _changeRate){
        isOwner();
        *changeRate = _changeRate;
    }
     
    EXPORT void PortfolioManage::setUserCanWithdraw(bool _canWithdraw){
        u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
isOwner();
        *userCanWithdraw = _canWithdraw;
    }

    
    PAYABLE void PortfolioManage::createPortfolio(char* _portfolioName, char* _portfolioDesc){
        if(portfolioStorge.get()[_portfolioName] != ""){
            DIPC_EMIT_EVENT(ErrEvent, "Current portfolio exist: ", _portfolioName);
            return;
        } 
        std::string callerAddr = caller().toString();
        uint64_t tokenBalance = getTotalBalance();
        
        PortfolioInfo info(_portfolioName, _portfolioDesc, &callerAddr[0]);
        std::string portfolioStr = info.toJson();
        
        
        

        (*portfolioStorge)[_portfolioName] = portfolioStr;
        DipcAssert(totalToken.get() + tokenBalance > totalToken);
        (*portfolioBalance)[_portfolioName] = tokenBalance;
        *totalToken = totalToken.get() + tokenBalance; 
        
        DIPC_EMIT_EVENT(portfolioInfo, _portfolioName, &portfolioStr[0], "portfolioBalance", tokenBalance);
    }

    
    PAYABLE void PortfolioManage::depositPortfolio(char* _portfolioName){
        uint64_t tokenBalance = getTotalBalance();
        
        uint64_t currentBalance = portfolioBalance.get()[_portfolioName];
        uint64_t finalBalance  = currentBalance + tokenBalance;
        DipcAssert(totalToken.get() + tokenBalance > totalToken);
        DipcAssert(finalBalance > currentBalance);
        (*portfolioBalance)[_portfolioName] = finalBalance;
        *totalToken = totalToken.get() + finalBalance; 
        DIPC_EMIT_EVENT(depositPortfolio, "portfolioName", _portfolioName, "portfolioBalance", finalBalance);
    }
    
    PAYABLE void PortfolioManage::createOrder(char* _portfolioName, char* _orderId, uint16_t _orderType, char* _stockCode, uint64_t _stockPrice, uint64_t _stockAmount, uint64_t _endTime){
        uint64_t tokenBalance = getTotalBalance();
        DIPC_EMIT_EVENT(createOrder, "portfolioName", _portfolioName, "OrderInfo", "ignore", "tokenBalance", tokenBalance);
        uint64_t spent = 0;
        if(_orderType == 1){
            spent = _stockPrice * _stockAmount;
            DipcAssert((portfolioBalance.get()[_portfolioName] + tokenBalance) > spent);
        }
        struct Order order{_orderId, _orderType, _stockCode, _stockPrice, _stockAmount, _endTime, 0};
        std::string pInfo = portfolioStorge.get()[_portfolioName];
        
        
        
        if(pInfo == "") {
            DIPC_EMIT_EVENT(ErrEvent, "Current portfolio  doesn't exist: ", _portfolioName);
            return;
        }
        PortfolioInfo info;
        info.parseJson(pInfo);
        if(info.getOrder(_orderId).orderId != ""){
            DIPC_EMIT_EVENT(ErrEvent, "Current order exist: ", _orderId);
            return;
        }
        info.addOrder(order);
        pInfo = info.toJson();

        uint64_t currentBalance = portfolioBalance.get()[_portfolioName] ;
        uint64_t finalBalance = currentBalance + tokenBalance - spent;
        DipcAssert(totalToken.get() + tokenBalance > totalToken);
        
        DipcAssert(ownerTotalToken.get() < ownerTotalToken.get() + spent);
        (*portfolioStorge)[_portfolioName] = &pInfo[0];
        
        
        
        


        (*portfolioBalance)[_portfolioName] = finalBalance;
        *totalToken = totalToken.get() + finalBalance; 
        *ownerTotalToken = ownerTotalToken.get() + spent;
        DIPC_EMIT_EVENT(createOrder, "portfolioName", _portfolioName, "OrderInfo", &order.toJson()[0], "portfolioBalance", finalBalance);
    }

    
    EXPORT void PortfolioManage::dealOrder(char* _portfolioName, char* _orderId){
        u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
isOwner();
        std::string pInfo = portfolioStorge.get()[_portfolioName];
        
        
        PortfolioInfo info;
        info.parseJson(pInfo);
        

        
         Order ord = info.getOrder(_orderId);
         
         
        if(ord.orderId != "" && ord.orderStatus == 0){
            
            uint64_t timenow = dipc::timestamp();
            if(ord.endTime > timenow){
                ord.orderStatus = 1;
            }else {
                ord.orderStatus = 3;
            }
        } else {
          

            return;
        }
        

        uint64_t sellValue = 0;
        if(ord.orderType == 0){
            sellValue = ord.stockAmount * ord.stockPrice;
        }
        uint64_t currentBalance =  portfolioBalance.get()[_portfolioName];
        

        DipcAssert(currentBalance + sellValue >= currentBalance);
        DipcAssert((ownerTotalToken.get() - sellValue) <= ownerTotalToken.get());
        


        (*portfolioBalance)[_portfolioName] = currentBalance + sellValue;
        *ownerTotalToken = ownerTotalToken.get() - sellValue;
        (*portfolioStorge)[_portfolioName] = &info.toJson()[0];
        
        
        
        

        DIPC_EMIT_EVENT(dealPortfolio, "orderId", _orderId, "orderInfo", &ord.toJson()[0]);
    }
    
    EXPORT void PortfolioManage::revocationOrder(char* _portfolioName, char* _orderId){
        u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
std::string pInfo = portfolioStorge.get()[_portfolioName];
        
        
        PortfolioInfo info;
        info.parseJson(pInfo);
        Order ord = info.getOrder(_orderId);
        
        
        if(ord.orderId != "" && ord.orderStatus == 0){
            std::string callerStr = caller().toString();
            
            
            
            DipcAssert(info.getOwnerAddress() == caller().toString());
            

            uint64_t timenow = dipc::timestamp();
            if(ord.endTime > timenow){
                ord.orderStatus = 2;
            }else {
                ord.orderStatus = 3;
            }
        } else {
            return;
        }
        uint64_t lockToken = 0;
        if(ord.orderType == 1){
            lockToken = ord.stockPrice * ord.stockAmount;
        }
        uint64_t currentBalance =  portfolioBalance.get()[_portfolioName];
        
        
        
        

        DipcAssert(currentBalance + lockToken >= currentBalance);
        DipcAssert(ownerTotalToken.get() - lockToken <= ownerTotalToken.get());

        
        (*portfolioBalance)[_portfolioName] = currentBalance + lockToken;
        *ownerTotalToken = ownerTotalToken.get() - lockToken;
        (*portfolioStorge)[_portfolioName] = &info.toJson()[0];
        DIPC_EMIT_EVENT(revocationPortfolio, "orderId", _orderId, "orderInfo", &ord.toJson()[0]);
    }
    
    EXPORT void PortfolioManage::withdrawPortfolio(char* _portfolioName, uint64_t _withdrawBalance){
         u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
if(!userCanWithdraw.get()){
             return;
         }
         uint64_t currentBalance =  portfolioBalance.get()[_portfolioName];
         DipcAssert(currentBalance - _withdrawBalance < currentBalance);
         auto coinBalance = changeUint64ToU256WithChangeRate(currentBalance, changeRate.get());
         (*portfolioBalance)[_portfolioName] = currentBalance - _withdrawBalance;
         callTransfer(caller(), coinBalance);
    }
    
    EXPORT void PortfolioManage::withdrawPool(uint64_t _balance){
        u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
isOwner();
        Address ownerAddr = Address(owner.get()); 
        callTransfer(ownerAddr, _balance);
        *ownerTotalToken = ownerTotalToken.get() - _balance * changeRate.get();
        *totalToken = totalToken.get() - _balance * changeRate.get();
        DIPC_EMIT_EVENT(tokenCount, "ownerTotalToken", ownerTotalToken.get(), "totalToken", totalToken.get());
    }
    
    PAYABLE void PortfolioManage::depositPool(uint64_t _depositValue){
        isOwner();
        
        uint64_t tokenBalance = changeU256ToUint64WithChangeRate(callValue(), changeRate.get()); 
        *ownerTotalToken = ownerTotalToken.get() + tokenBalance;
        *totalToken = totalToken.get() + tokenBalance;
        DIPC_EMIT_EVENT(tokenCount, "ownerTotalToken", ownerTotalToken.get(), "totalToken", totalToken.get());
    }
     
    CONSTANT uint64_t PortfolioManage::queryTotalToken(){
        return totalToken.get();
    }

     
    CONSTANT uint64_t PortfolioManage::queryPortfolioBalance(char* _portfolioName){
        return portfolioBalance.get()[_portfolioName];
    }

    
    CONSTANT bool PortfolioManage::queryPortfolioNameIfUsed(char* _portfolioName){
        if(portfolioStorge.get()[_portfolioName] != ""){
            return true;
        } 
        return false;
    }

    
    CONSTANT uint64_t PortfolioManage::queryChangeRate(){
        return changeRate.get();
    } codetext height #include "PortfolioManage.hpp"

    
    PAYABLE void PortfolioManage::init(){
        *owner = caller().toString();
        *changeRate = 10000;
        *userCanWithdraw = false;
        uint64_t tokenBalance = getTotalBalance();
        
        *ownerTotalToken = tokenBalance;
        *totalToken = ownerTotalToken.get();
        
        
        DIPC_EMIT_EVENT(initEvent, "ownerTotalToken" ,tokenBalance);
    }
    
     
    EXPORT void PortfolioManage::setChangeRate(uint64_t _changeRate){
        isOwner();
        *changeRate = _changeRate;
    }
     
    EXPORT void PortfolioManage::setUserCanWithdraw(bool _canWithdraw){
        u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
isOwner();
        *userCanWithdraw = _canWithdraw;
    }

    
    PAYABLE void PortfolioManage::createPortfolio(char* _portfolioName, char* _portfolioDesc){
        if(portfolioStorge.get()[_portfolioName] != ""){
            DIPC_EMIT_EVENT(ErrEvent, "Current portfolio exist: ", _portfolioName);
            return;
        } 
        std::string callerAddr = caller().toString();
        uint64_t tokenBalance = getTotalBalance();
        
        PortfolioInfo info(_portfolioName, _portfolioDesc, &callerAddr[0]);
        std::string portfolioStr = info.toJson();
        
        
        

        (*portfolioStorge)[_portfolioName] = portfolioStr;
        DipcAssert(totalToken.get() + tokenBalance > totalToken);
        (*portfolioBalance)[_portfolioName] = tokenBalance;
        *totalToken = totalToken.get() + tokenBalance; 
        
        DIPC_EMIT_EVENT(portfolioInfo, _portfolioName, &portfolioStr[0], "portfolioBalance", tokenBalance);
    }

    
    PAYABLE void PortfolioManage::depositPortfolio(char* _portfolioName){
        uint64_t tokenBalance = getTotalBalance();
        
        uint64_t currentBalance = portfolioBalance.get()[_portfolioName];
        uint64_t finalBalance  = currentBalance + tokenBalance;
        DipcAssert(totalToken.get() + tokenBalance > totalToken);
        DipcAssert(finalBalance > currentBalance);
        (*portfolioBalance)[_portfolioName] = finalBalance;
        *totalToken = totalToken.get() + finalBalance; 
        DIPC_EMIT_EVENT(depositPortfolio, "portfolioName", _portfolioName, "portfolioBalance", finalBalance);
    }
    
    PAYABLE void PortfolioManage::createOrder(char* _portfolioName, char* _orderId, uint16_t _orderType, char* _stockCode, uint64_t _stockPrice, uint64_t _stockAmount, uint64_t _endTime){
        uint64_t tokenBalance = getTotalBalance();
        DIPC_EMIT_EVENT(createOrder, "portfolioName", _portfolioName, "OrderInfo", "ignore", "tokenBalance", tokenBalance);
        uint64_t spent = 0;
        if(_orderType == 1){
            spent = _stockPrice * _stockAmount;
            DipcAssert((portfolioBalance.get()[_portfolioName] + tokenBalance) > spent);
        }
        struct Order order{_orderId, _orderType, _stockCode, _stockPrice, _stockAmount, _endTime, 0};
        std::string pInfo = portfolioStorge.get()[_portfolioName];
        
        
        
        if(pInfo == "") {
            DIPC_EMIT_EVENT(ErrEvent, "Current portfolio  doesn't exist: ", _portfolioName);
            return;
        }
        PortfolioInfo info;
        info.parseJson(pInfo);
        if(info.getOrder(_orderId).orderId != ""){
            DIPC_EMIT_EVENT(ErrEvent, "Current order exist: ", _orderId);
            return;
        }
        info.addOrder(order);
        pInfo = info.toJson();

        uint64_t currentBalance = portfolioBalance.get()[_portfolioName] ;
        uint64_t finalBalance = currentBalance + tokenBalance - spent;
        DipcAssert(totalToken.get() + tokenBalance > totalToken);
        
        DipcAssert(ownerTotalToken.get() < ownerTotalToken.get() + spent);
        (*portfolioStorge)[_portfolioName] = &pInfo[0];
        
        
        
        


        (*portfolioBalance)[_portfolioName] = finalBalance;
        *totalToken = totalToken.get() + finalBalance; 
        *ownerTotalToken = ownerTotalToken.get() + spent;
        DIPC_EMIT_EVENT(createOrder, "portfolioName", _portfolioName, "OrderInfo", &order.toJson()[0], "portfolioBalance", finalBalance);
    }

    
    EXPORT void PortfolioManage::dealOrder(char* _portfolioName, char* _orderId){
        u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
isOwner();
        std::string pInfo = portfolioStorge.get()[_portfolioName];
        
        
        PortfolioInfo info;
        info.parseJson(pInfo);
        

        
         Order ord = info.getOrder(_orderId);
         
         
        if(ord.orderId != "" && ord.orderStatus == 0){
            
            uint64_t timenow = dipc::timestamp();
            if(ord.endTime > timenow){
                ord.orderStatus = 1;
            }else {
                ord.orderStatus = 3;
            }
        } else {
          

            return;
        }
        

        uint64_t sellValue = 0;
        if(ord.orderType == 0){
            sellValue = ord.stockAmount * ord.stockPrice;
        }
        uint64_t currentBalance =  portfolioBalance.get()[_portfolioName];
        

        DipcAssert(currentBalance + sellValue >= currentBalance);
        DipcAssert((ownerTotalToken.get() - sellValue) <= ownerTotalToken.get());
        


        (*portfolioBalance)[_portfolioName] = currentBalance + sellValue;
        *ownerTotalToken = ownerTotalToken.get() - sellValue;
        (*portfolioStorge)[_portfolioName] = &info.toJson()[0];
        
        
        
        

        DIPC_EMIT_EVENT(dealPortfolio, "orderId", _orderId, "orderInfo", &ord.toJson()[0]);
    }
    
    EXPORT void PortfolioManage::revocationOrder(char* _portfolioName, char* _orderId){
        u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
std::string pInfo = portfolioStorge.get()[_portfolioName];
        
        
        PortfolioInfo info;
        info.parseJson(pInfo);
        Order ord = info.getOrder(_orderId);
        
        
        if(ord.orderId != "" && ord.orderStatus == 0){
            std::string callerStr = caller().toString();
            
            
            
            DipcAssert(info.getOwnerAddress() == caller().toString());
            

            uint64_t timenow = dipc::timestamp();
            if(ord.endTime > timenow){
                ord.orderStatus = 2;
            }else {
                ord.orderStatus = 3;
            }
        } else {
            return;
        }
        uint64_t lockToken = 0;
        if(ord.orderType == 1){
            lockToken = ord.stockPrice * ord.stockAmount;
        }
        uint64_t currentBalance =  portfolioBalance.get()[_portfolioName];
        
        
        
        

        DipcAssert(currentBalance + lockToken >= currentBalance);
        DipcAssert(ownerTotalToken.get() - lockToken <= ownerTotalToken.get());

        
        (*portfolioBalance)[_portfolioName] = currentBalance + lockToken;
        *ownerTotalToken = ownerTotalToken.get() - lockToken;
        (*portfolioStorge)[_portfolioName] = &info.toJson()[0];
        DIPC_EMIT_EVENT(revocationPortfolio, "orderId", _orderId, "orderInfo", &ord.toJson()[0]);
    }
    
    EXPORT void PortfolioManage::withdrawPortfolio(char* _portfolioName, uint64_t _withdrawBalance){
         u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
if(!userCanWithdraw.get()){
             return;
         }
         uint64_t currentBalance =  portfolioBalance.get()[_portfolioName];
         DipcAssert(currentBalance - _withdrawBalance < currentBalance);
         auto coinBalance = changeUint64ToU256WithChangeRate(currentBalance, changeRate.get());
         (*portfolioBalance)[_portfolioName] = currentBalance - _withdrawBalance;
         callTransfer(caller(), coinBalance);
    }
    
    EXPORT void PortfolioManage::withdrawPool(uint64_t _balance){
        u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
isOwner();
        Address ownerAddr = Address(owner.get()); 
        callTransfer(ownerAddr, _balance);
        *ownerTotalToken = ownerTotalToken.get() - _balance * changeRate.get();
        *totalToken = totalToken.get() - _balance * changeRate.get();
        DIPC_EMIT_EVENT(tokenCount, "ownerTotalToken", ownerTotalToken.get(), "totalToken", totalToken.get());
    }
    
    PAYABLE void PortfolioManage::depositPool(uint64_t _depositValue){
        isOwner();
        
        uint64_t tokenBalance = changeU256ToUint64WithChangeRate(callValue(), changeRate.get()); 
        *ownerTotalToken = ownerTotalToken.get() + tokenBalance;
        *totalToken = totalToken.get() + tokenBalance;
        DIPC_EMIT_EVENT(tokenCount, "ownerTotalToken", ownerTotalToken.get(), "totalToken", totalToken.get());
    }
     
    CONSTANT uint64_t PortfolioManage::queryTotalToken(){
        return totalToken.get();
    }

     
    CONSTANT uint64_t PortfolioManage::queryPortfolioBalance(char* _portfolioName){
        return portfolioBalance.get()[_portfolioName];
    }

    
    CONSTANT bool PortfolioManage::queryPortfolioNameIfUsed(char* _portfolioName){
        if(portfolioStorge.get()[_portfolioName] != ""){
            return true;
        } 
        return false;
    }

    
    CONSTANT uint64_t PortfolioManage::queryChangeRate(){
        return changeRate.get();
    }

2019-12-19_15:14:54.356428: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:427] searchContext  #include "PortfolioManage.hpp"

    
    PAYABLE void PortfolioManage::init(){
        *owner = caller().toString();
        *changeRate = 10000;
        *userCanWithdraw = false;
        uint64_t tokenBalance = getTotalBalance();
        
        *ownerTotalToken = tokenBalance;
        *totalToken = ownerTotalToken.get();
        
        
        DIPC_EMIT_EVENT(initEvent, "ownerTotalToken" ,tokenBalance);
    }
    
     
    EXPORT void PortfolioManage::setChangeRate(uint64_t _changeRate){
        isOwner();
        *changeRate = _changeRate;
    }
     
    EXPORT void PortfolioManage::setUserCanWithdraw(bool _canWithdraw){
        u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
isOwner();
        *userCanWithdraw = _canWithdraw;
    }

    
    PAYABLE void PortfolioManage::createPortfolio(char* _portfolioName, char* _portfolioDesc){
        if(portfolioStorge.get()[_portfolioName] != ""){
            DIPC_EMIT_EVENT(ErrEvent, "Current portfolio exist: ", _portfolioName);
            return;
        } 
        std::string callerAddr = caller().toString();
        uint64_t tokenBalance = getTotalBalance();
        
        PortfolioInfo info(_portfolioName, _portfolioDesc, &callerAddr[0]);
        std::string portfolioStr = info.toJson();
        
        
        

        (*portfolioStorge)[_portfolioName] = portfolioStr;
        DipcAssert(totalToken.get() + tokenBalance > totalToken);
        (*portfolioBalance)[_portfolioName] = tokenBalance;
        *totalToken = totalToken.get() + tokenBalance; 
        
        DIPC_EMIT_EVENT(portfolioInfo, _portfolioName, &portfolioStr[0], "portfolioBalance", tokenBalance);
    }

    
    PAYABLE void PortfolioManage::depositPortfolio(char* _portfolioName){
        uint64_t tokenBalance = getTotalBalance();
        
        uint64_t currentBalance = portfolioBalance.get()[_portfolioName];
        uint64_t finalBalance  = currentBalance + tokenBalance;
        DipcAssert(totalToken.get() + tokenBalance > totalToken);
        DipcAssert(finalBalance > currentBalance);
        (*portfolioBalance)[_portfolioName] = finalBalance;
        *totalToken = totalToken.get() + finalBalance; 
        DIPC_EMIT_EVENT(depositPortfolio, "portfolioName", _portfolioName, "portfolioBalance", finalBalance);
    }
    
    PAYABLE void PortfolioManage::createOrder(char* _portfolioName, char* _orderId, uint16_t _orderType, char* _stockCode, uint64_t _stockPrice, uint64_t _stockAmount, uint64_t _endTime){
        uint64_t tokenBalance = getTotalBalance();
        DIPC_EMIT_EVENT(createOrder, "portfolioName", _portfolioName, "OrderInfo", "ignore", "tokenBalance", tokenBalance);
        uint64_t spent = 0;
        if(_orderType == 1){
            spent = _stockPrice * _stockAmount;
            DipcAssert((portfolioBalance.get()[_portfolioName] + tokenBalance) > spent);
        }
        struct Order order{_orderId, _orderType, _stockCode, _stockPrice, _stockAmount, _endTime, 0};
        std::string pInfo = portfolioStorge.get()[_portfolioName];
        
        
        
        if(pInfo == "") {
            DIPC_EMIT_EVENT(ErrEvent, "Current portfolio  doesn't exist: ", _portfolioName);
            return;
        }
        PortfolioInfo info;
        info.parseJson(pInfo);
        if(info.getOrder(_orderId).orderId != ""){
            DIPC_EMIT_EVENT(ErrEvent, "Current order exist: ", _orderId);
            return;
        }
        info.addOrder(order);
        pInfo = info.toJson();

        uint64_t currentBalance = portfolioBalance.get()[_portfolioName] ;
        uint64_t finalBalance = currentBalance + tokenBalance - spent;
        DipcAssert(totalToken.get() + tokenBalance > totalToken);
        
        DipcAssert(ownerTotalToken.get() < ownerTotalToken.get() + spent);
        (*portfolioStorge)[_portfolioName] = &pInfo[0];
        
        
        
        


        (*portfolioBalance)[_portfolioName] = finalBalance;
        *totalToken = totalToken.get() + finalBalance; 
        *ownerTotalToken = ownerTotalToken.get() + spent;
        DIPC_EMIT_EVENT(createOrder, "portfolioName", _portfolioName, "OrderInfo", &order.toJson()[0], "portfolioBalance", finalBalance);
    }

    
    EXPORT void PortfolioManage::dealOrder(char* _portfolioName, char* _orderId){
        u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
isOwner();
        std::string pInfo = portfolioStorge.get()[_portfolioName];
        
        
        PortfolioInfo info;
        info.parseJson(pInfo);
        

        
         Order ord = info.getOrder(_orderId);
         
         
        if(ord.orderId != "" && ord.orderStatus == 0){
            
            uint64_t timenow = dipc::timestamp();
            if(ord.endTime > timenow){
                ord.orderStatus = 1;
            }else {
                ord.orderStatus = 3;
            }
        } else {
          

            return;
        }
        

        uint64_t sellValue = 0;
        if(ord.orderType == 0){
            sellValue = ord.stockAmount * ord.stockPrice;
        }
        uint64_t currentBalance =  portfolioBalance.get()[_portfolioName];
        

        DipcAssert(currentBalance + sellValue >= currentBalance);
        DipcAssert((ownerTotalToken.get() - sellValue) <= ownerTotalToken.get());
        


        (*portfolioBalance)[_portfolioName] = currentBalance + sellValue;
        *ownerTotalToken = ownerTotalToken.get() - sellValue;
        (*portfolioStorge)[_portfolioName] = &info.toJson()[0];
        
        
        
        

        DIPC_EMIT_EVENT(dealPortfolio, "orderId", _orderId, "orderInfo", &ord.toJson()[0]);
    }
    
    EXPORT void PortfolioManage::revocationOrder(char* _portfolioName, char* _orderId){
        u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
std::string pInfo = portfolioStorge.get()[_portfolioName];
        
        
        PortfolioInfo info;
        info.parseJson(pInfo);
        Order ord = info.getOrder(_orderId);
        
        
        if(ord.orderId != "" && ord.orderStatus == 0){
            std::string callerStr = caller().toString();
            
            
            
            DipcAssert(info.getOwnerAddress() == caller().toString());
            

            uint64_t timenow = dipc::timestamp();
            if(ord.endTime > timenow){
                ord.orderStatus = 2;
            }else {
                ord.orderStatus = 3;
            }
        } else {
            return;
        }
        uint64_t lockToken = 0;
        if(ord.orderType == 1){
            lockToken = ord.stockPrice * ord.stockAmount;
        }
        uint64_t currentBalance =  portfolioBalance.get()[_portfolioName];
        
        
        
        

        DipcAssert(currentBalance + lockToken >= currentBalance);
        DipcAssert(ownerTotalToken.get() - lockToken <= ownerTotalToken.get());

        
        (*portfolioBalance)[_portfolioName] = currentBalance + lockToken;
        *ownerTotalToken = ownerTotalToken.get() - lockToken;
        (*portfolioStorge)[_portfolioName] = &info.toJson()[0];
        DIPC_EMIT_EVENT(revocationPortfolio, "orderId", _orderId, "orderInfo", &ord.toJson()[0]);
    }
    
    EXPORT void PortfolioManage::withdrawPortfolio(char* _portfolioName, uint64_t _withdrawBalance){
         u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
if(!userCanWithdraw.get()){
             return;
         }
         uint64_t currentBalance =  portfolioBalance.get()[_portfolioName];
         DipcAssert(currentBalance - _withdrawBalance < currentBalance);
         auto coinBalance = changeUint64ToU256WithChangeRate(currentBalance, changeRate.get());
         (*portfolioBalance)[_portfolioName] = currentBalance - _withdrawBalance;
         callTransfer(caller(), coinBalance);
    }
    
    EXPORT void PortfolioManage::withdrawPool(uint64_t _balance){
        u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
isOwner();
        Address ownerAddr = Address(owner.get()); 
        callTransfer(ownerAddr, _balance);
        *ownerTotalToken = ownerTotalToken.get() - _balance * changeRate.get();
        *totalToken = totalToken.get() - _balance * changeRate.get();
        DIPC_EMIT_EVENT(tokenCount, "ownerTotalToken", ownerTotalToken.get(), "totalToken", totalToken.get());
    }
    
    PAYABLE void PortfolioManage::depositPool(uint64_t _depositValue){
        isOwner();
        
        uint64_t tokenBalance = changeU256ToUint64WithChangeRate(callValue(), changeRate.get()); 
        *ownerTotalToken = ownerTotalToken.get() + tokenBalance;
        *totalToken = totalToken.get() + tokenBalance;
        DIPC_EMIT_EVENT(tokenCount, "ownerTotalToken", ownerTotalToken.get(), "totalToken", totalToken.get());
    }
     
    CONSTANT uint64_t PortfolioManage::queryTotalToken(){
        return totalToken.get();
    }

     
    CONSTANT uint64_t PortfolioManage::queryPortfolioBalance(char* _portfolioName){
        return portfolioBalance.get()[_portfolioName];
    }

    
    CONSTANT bool PortfolioManage::queryPortfolioNameIfUsed(char* _portfolioName){
        if(portfolioStorge.get()[_portfolioName] != ""){
            return true;
        } 
        return false;
    }

    
    CONSTANT uint64_t PortfolioManage::queryChangeRate(){
        return changeRate.get();
    }

2019-12-19_15:14:54.365423: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:451] log out out  Export :
    
     
    EXPORT void PortfolioManage::setChangeRate(uint64_t _changeRate){
        

2019-12-19_15:14:54.365436: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:457] name : setChangeRate   pos1  0

2019-12-19_15:14:54.365464: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:469] pos2  418   pos1  418

2019-12-19_15:14:54.365472: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:500] pos2 after 559   pos1  418

2019-12-19_15:14:54.365493: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:509] finalContract  first #include "PortfolioManage.hpp"

    
    PAYABLE void PortfolioManage::init(){
        *owner = caller().toString();
        *changeRate = 10000;
        *userCanWithdraw = false;
        uint64_t tokenBalance = getTotalBalance();
        
        *ownerTotalToken = tokenBalance;
        *totalToken = ownerTotalToken.get();
        
        
        DIPC_EMIT_EVENT(initEvent, "ownerTotalToken" ,tokenBalance);
    }

2019-12-19_15:14:54.365500: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:510] codetext  first #include "PortfolioManage.hpp"

    
    PAYABLE void PortfolioManage::init(){
        *owner = caller().toString();
        *changeRate = 10000;
        *userCanWithdraw = false;
        uint64_t tokenBalance = getTotalBalance();
        
        *ownerTotalToken = tokenBalance;
        *totalToken = ownerTotalToken.get();
        
        
        DIPC_EMIT_EVENT(initEvent, "ownerTotalToken" ,tokenBalance);
    }
    
     
    EXPORT void PortfolioManage::setChangeRate(uint64_t _changeRate){
        isOwner();
        *changeRate = _changeRate;
    }
     
    EXPORT void PortfolioManage::setUserCanWithdraw(bool _canWithdraw){
        u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
isOwner();
        *userCanWithdraw = _canWithdraw;
    }

    
    PAYABLE void PortfolioManage::createPortfolio(char* _portfolioName, char* _portfolioDesc){
        if(portfolioStorge.get()[_portfolioName] != ""){
            DIPC_EMIT_EVENT(ErrEvent, "Current portfolio exist: ", _portfolioName);
            return;
        } 
        std::string callerAddr = caller().toString();
        uint64_t tokenBalance = getTotalBalance();
        
        PortfolioInfo info(_portfolioName, _portfolioDesc, &callerAddr[0]);
        std::string portfolioStr = info.toJson();
        
        
        

        (*portfolioStorge)[_portfolioName] = portfolioStr;
        DipcAssert(totalToken.get() + tokenBalance > totalToken);
        (*portfolioBalance)[_portfolioName] = tokenBalance;
        *totalToken = totalToken.get() + tokenBalance; 
        
        DIPC_EMIT_EVENT(portfolioInfo, _portfolioName, &portfolioStr[0], "portfolioBalance", tokenBalance);
    }

    
    PAYABLE void PortfolioManage::depositPortfolio(char* _portfolioName){
        uint64_t tokenBalance = getTotalBalance();
        
        uint64_t currentBalance = portfolioBalance.get()[_portfolioName];
        uint64_t finalBalance  = currentBalance + tokenBalance;
        DipcAssert(totalToken.get() + tokenBalance > totalToken);
        DipcAssert(finalBalance > currentBalance);
        (*portfolioBalance)[_portfolioName] = finalBalance;
        *totalToken = totalToken.get() + finalBalance; 
        DIPC_EMIT_EVENT(depositPortfolio, "portfolioName", _portfolioName, "portfolioBalance", finalBalance);
    }
    
    PAYABLE void PortfolioManage::createOrder(char* _portfolioName, char* _orderId, uint16_t _orderType, char* _stockCode, uint64_t _stockPrice, uint64_t _stockAmount, uint64_t _endTime){
        uint64_t tokenBalance = getTotalBalance();
        DIPC_EMIT_EVENT(createOrder, "portfolioName", _portfolioName, "OrderInfo", "ignore", "tokenBalance", tokenBalance);
        uint64_t spent = 0;
        if(_orderType == 1){
            spent = _stockPrice * _stockAmount;
            DipcAssert((portfolioBalance.get()[_portfolioName] + tokenBalance) > spent);
        }
        struct Order order{_orderId, _orderType, _stockCode, _stockPrice, _stockAmount, _endTime, 0};
        std::string pInfo = portfolioStorge.get()[_portfolioName];
        
        
        
        if(pInfo == "") {
            DIPC_EMIT_EVENT(ErrEvent, "Current portfolio  doesn't exist: ", _portfolioName);
            return;
        }
        PortfolioInfo info;
        info.parseJson(pInfo);
        if(info.getOrder(_orderId).orderId != ""){
            DIPC_EMIT_EVENT(ErrEvent, "Current order exist: ", _orderId);
            return;
        }
        info.addOrder(order);
        pInfo = info.toJson();

        uint64_t currentBalance = portfolioBalance.get()[_portfolioName] ;
        uint64_t finalBalance = currentBalance + tokenBalance - spent;
        DipcAssert(totalToken.get() + tokenBalance > totalToken);
        
        DipcAssert(ownerTotalToken.get() < ownerTotalToken.get() + spent);
        (*portfolioStorge)[_portfolioName] = &pInfo[0];
        
        
        
        


        (*portfolioBalance)[_portfolioName] = finalBalance;
        *totalToken = totalToken.get() + finalBalance; 
        *ownerTotalToken = ownerTotalToken.get() + spent;
        DIPC_EMIT_EVENT(createOrder, "portfolioName", _portfolioName, "OrderInfo", &order.toJson()[0], "portfolioBalance", finalBalance);
    }

    
    EXPORT void PortfolioManage::dealOrder(char* _portfolioName, char* _orderId){
        u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
isOwner();
        std::string pInfo = portfolioStorge.get()[_portfolioName];
        
        
        PortfolioInfo info;
        info.parseJson(pInfo);
        

        
         Order ord = info.getOrder(_orderId);
         
         
        if(ord.orderId != "" && ord.orderStatus == 0){
            
            uint64_t timenow = dipc::timestamp();
            if(ord.endTime > timenow){
                ord.orderStatus = 1;
            }else {
                ord.orderStatus = 3;
            }
        } else {
          

            return;
        }
        

        uint64_t sellValue = 0;
        if(ord.orderType == 0){
            sellValue = ord.stockAmount * ord.stockPrice;
        }
        uint64_t currentBalance =  portfolioBalance.get()[_portfolioName];
        

        DipcAssert(currentBalance + sellValue >= currentBalance);
        DipcAssert((ownerTotalToken.get() - sellValue) <= ownerTotalToken.get());
        


        (*portfolioBalance)[_portfolioName] = currentBalance + sellValue;
        *ownerTotalToken = ownerTotalToken.get() - sellValue;
        (*portfolioStorge)[_portfolioName] = &info.toJson()[0];
        
        
        
        

        DIPC_EMIT_EVENT(dealPortfolio, "orderId", _orderId, "orderInfo", &ord.toJson()[0]);
    }
    
    EXPORT void PortfolioManage::revocationOrder(char* _portfolioName, char* _orderId){
        u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
std::string pInfo = portfolioStorge.get()[_portfolioName];
        
        
        PortfolioInfo info;
        info.parseJson(pInfo);
        Order ord = info.getOrder(_orderId);
        
        
        if(ord.orderId != "" && ord.orderStatus == 0){
            std::string callerStr = caller().toString();
            
            
            
            DipcAssert(info.getOwnerAddress() == caller().toString());
            

            uint64_t timenow = dipc::timestamp();
            if(ord.endTime > timenow){
                ord.orderStatus = 2;
            }else {
                ord.orderStatus = 3;
            }
        } else {
            return;
        }
        uint64_t lockToken = 0;
        if(ord.orderType == 1){
            lockToken = ord.stockPrice * ord.stockAmount;
        }
        uint64_t currentBalance =  portfolioBalance.get()[_portfolioName];
        
        
        
        

        DipcAssert(currentBalance + lockToken >= currentBalance);
        DipcAssert(ownerTotalToken.get() - lockToken <= ownerTotalToken.get());

        
        (*portfolioBalance)[_portfolioName] = currentBalance + lockToken;
        *ownerTotalToken = ownerTotalToken.get() - lockToken;
        (*portfolioStorge)[_portfolioName] = &info.toJson()[0];
        DIPC_EMIT_EVENT(revocationPortfolio, "orderId", _orderId, "orderInfo", &ord.toJson()[0]);
    }
    
    EXPORT void PortfolioManage::withdrawPortfolio(char* _portfolioName, uint64_t _withdrawBalance){
         u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
if(!userCanWithdraw.get()){
             return;
         }
         uint64_t currentBalance =  portfolioBalance.get()[_portfolioName];
         DipcAssert(currentBalance - _withdrawBalance < currentBalance);
         auto coinBalance = changeUint64ToU256WithChangeRate(currentBalance, changeRate.get());
         (*portfolioBalance)[_portfolioName] = currentBalance - _withdrawBalance;
         callTransfer(caller(), coinBalance);
    }
    
    EXPORT void PortfolioManage::withdrawPool(uint64_t _balance){
        u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
isOwner();
        Address ownerAddr = Address(owner.get()); 
        callTransfer(ownerAddr, _balance);
        *ownerTotalToken = ownerTotalToken.get() - _balance * changeRate.get();
        *totalToken = totalToken.get() - _balance * changeRate.get();
        DIPC_EMIT_EVENT(tokenCount, "ownerTotalToken", ownerTotalToken.get(), "totalToken", totalToken.get());
    }
    
    PAYABLE void PortfolioManage::depositPool(uint64_t _depositValue){
        isOwner();
        
        uint64_t tokenBalance = changeU256ToUint64WithChangeRate(callValue(), changeRate.get()); 
        *ownerTotalToken = ownerTotalToken.get() + tokenBalance;
        *totalToken = totalToken.get() + tokenBalance;
        DIPC_EMIT_EVENT(tokenCount, "ownerTotalToken", ownerTotalToken.get(), "totalToken", totalToken.get());
    }
     
    CONSTANT uint64_t PortfolioManage::queryTotalToken(){
        return totalToken.get();
    }

     
    CONSTANT uint64_t PortfolioManage::queryPortfolioBalance(char* _portfolioName){
        return portfolioBalance.get()[_portfolioName];
    }

    
    CONSTANT bool PortfolioManage::queryPortfolioNameIfUsed(char* _portfolioName){
        if(portfolioStorge.get()[_portfolioName] != ""){
            return true;
        } 
        return false;
    }

    
    CONSTANT uint64_t PortfolioManage::queryChangeRate(){
        return changeRate.get();
    }

2019-12-19_15:14:54.365508: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:513] s  first 
    
     
    EXPORT void PortfolioManage::setChangeRate(uint64_t _changeRate){
        isOwner();
        *changeRate = _changeRate;
    }

2019-12-19_15:14:54.365535: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:593] calledFunc temp export: 
    
     
    EXPORT void PortfolioManage::setChangeRate(uint64_t _changeRate){
        u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
isOwner();
        *changeRate = _changeRate;
    }

2019-12-19_15:14:54.365542: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:599] search func : 
    
     
    EXPORT void PortfolioManage::setChangeRate(uint64_t _changeRate){
        u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
isOwner();
        *changeRate = _changeRate;
    }
2019-12-19_15:14:54.365549: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:424] finalContract  this height  #include "PortfolioManage.hpp"

    
    PAYABLE void PortfolioManage::init(){
        *owner = caller().toString();
        *changeRate = 10000;
        *userCanWithdraw = false;
        uint64_t tokenBalance = getTotalBalance();
        
        *ownerTotalToken = tokenBalance;
        *totalToken = ownerTotalToken.get();
        
        
        DIPC_EMIT_EVENT(initEvent, "ownerTotalToken" ,tokenBalance);
    }
    
     
    EXPORT void PortfolioManage::setChangeRate(uint64_t _changeRate){
        u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
isOwner();
        *changeRate = _changeRate;
    } codetext height #include "PortfolioManage.hpp"

    
    PAYABLE void PortfolioManage::init(){
        *owner = caller().toString();
        *changeRate = 10000;
        *userCanWithdraw = false;
        uint64_t tokenBalance = getTotalBalance();
        
        *ownerTotalToken = tokenBalance;
        *totalToken = ownerTotalToken.get();
        
        
        DIPC_EMIT_EVENT(initEvent, "ownerTotalToken" ,tokenBalance);
    }
    
     
    EXPORT void PortfolioManage::setChangeRate(uint64_t _changeRate){
        isOwner();
        *changeRate = _changeRate;
    }
     
    EXPORT void PortfolioManage::setUserCanWithdraw(bool _canWithdraw){
        u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
isOwner();
        *userCanWithdraw = _canWithdraw;
    }

    
    PAYABLE void PortfolioManage::createPortfolio(char* _portfolioName, char* _portfolioDesc){
        if(portfolioStorge.get()[_portfolioName] != ""){
            DIPC_EMIT_EVENT(ErrEvent, "Current portfolio exist: ", _portfolioName);
            return;
        } 
        std::string callerAddr = caller().toString();
        uint64_t tokenBalance = getTotalBalance();
        
        PortfolioInfo info(_portfolioName, _portfolioDesc, &callerAddr[0]);
        std::string portfolioStr = info.toJson();
        
        
        

        (*portfolioStorge)[_portfolioName] = portfolioStr;
        DipcAssert(totalToken.get() + tokenBalance > totalToken);
        (*portfolioBalance)[_portfolioName] = tokenBalance;
        *totalToken = totalToken.get() + tokenBalance; 
        
        DIPC_EMIT_EVENT(portfolioInfo, _portfolioName, &portfolioStr[0], "portfolioBalance", tokenBalance);
    }

    
    PAYABLE void PortfolioManage::depositPortfolio(char* _portfolioName){
        uint64_t tokenBalance = getTotalBalance();
        
        uint64_t currentBalance = portfolioBalance.get()[_portfolioName];
        uint64_t finalBalance  = currentBalance + tokenBalance;
        DipcAssert(totalToken.get() + tokenBalance > totalToken);
        DipcAssert(finalBalance > currentBalance);
        (*portfolioBalance)[_portfolioName] = finalBalance;
        *totalToken = totalToken.get() + finalBalance; 
        DIPC_EMIT_EVENT(depositPortfolio, "portfolioName", _portfolioName, "portfolioBalance", finalBalance);
    }
    
    PAYABLE void PortfolioManage::createOrder(char* _portfolioName, char* _orderId, uint16_t _orderType, char* _stockCode, uint64_t _stockPrice, uint64_t _stockAmount, uint64_t _endTime){
        uint64_t tokenBalance = getTotalBalance();
        DIPC_EMIT_EVENT(createOrder, "portfolioName", _portfolioName, "OrderInfo", "ignore", "tokenBalance", tokenBalance);
        uint64_t spent = 0;
        if(_orderType == 1){
            spent = _stockPrice * _stockAmount;
            DipcAssert((portfolioBalance.get()[_portfolioName] + tokenBalance) > spent);
        }
        struct Order order{_orderId, _orderType, _stockCode, _stockPrice, _stockAmount, _endTime, 0};
        std::string pInfo = portfolioStorge.get()[_portfolioName];
        
        
        
        if(pInfo == "") {
            DIPC_EMIT_EVENT(ErrEvent, "Current portfolio  doesn't exist: ", _portfolioName);
            return;
        }
        PortfolioInfo info;
        info.parseJson(pInfo);
        if(info.getOrder(_orderId).orderId != ""){
            DIPC_EMIT_EVENT(ErrEvent, "Current order exist: ", _orderId);
            return;
        }
        info.addOrder(order);
        pInfo = info.toJson();

        uint64_t currentBalance = portfolioBalance.get()[_portfolioName] ;
        uint64_t finalBalance = currentBalance + tokenBalance - spent;
        DipcAssert(totalToken.get() + tokenBalance > totalToken);
        
        DipcAssert(ownerTotalToken.get() < ownerTotalToken.get() + spent);
        (*portfolioStorge)[_portfolioName] = &pInfo[0];
        
        
        
        


        (*portfolioBalance)[_portfolioName] = finalBalance;
        *totalToken = totalToken.get() + finalBalance; 
        *ownerTotalToken = ownerTotalToken.get() + spent;
        DIPC_EMIT_EVENT(createOrder, "portfolioName", _portfolioName, "OrderInfo", &order.toJson()[0], "portfolioBalance", finalBalance);
    }

    
    EXPORT void PortfolioManage::dealOrder(char* _portfolioName, char* _orderId){
        u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
isOwner();
        std::string pInfo = portfolioStorge.get()[_portfolioName];
        
        
        PortfolioInfo info;
        info.parseJson(pInfo);
        

        
         Order ord = info.getOrder(_orderId);
         
         
        if(ord.orderId != "" && ord.orderStatus == 0){
            
            uint64_t timenow = dipc::timestamp();
            if(ord.endTime > timenow){
                ord.orderStatus = 1;
            }else {
                ord.orderStatus = 3;
            }
        } else {
          

            return;
        }
        

        uint64_t sellValue = 0;
        if(ord.orderType == 0){
            sellValue = ord.stockAmount * ord.stockPrice;
        }
        uint64_t currentBalance =  portfolioBalance.get()[_portfolioName];
        

        DipcAssert(currentBalance + sellValue >= currentBalance);
        DipcAssert((ownerTotalToken.get() - sellValue) <= ownerTotalToken.get());
        


        (*portfolioBalance)[_portfolioName] = currentBalance + sellValue;
        *ownerTotalToken = ownerTotalToken.get() - sellValue;
        (*portfolioStorge)[_portfolioName] = &info.toJson()[0];
        
        
        
        

        DIPC_EMIT_EVENT(dealPortfolio, "orderId", _orderId, "orderInfo", &ord.toJson()[0]);
    }
    
    EXPORT void PortfolioManage::revocationOrder(char* _portfolioName, char* _orderId){
        u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
std::string pInfo = portfolioStorge.get()[_portfolioName];
        
        
        PortfolioInfo info;
        info.parseJson(pInfo);
        Order ord = info.getOrder(_orderId);
        
        
        if(ord.orderId != "" && ord.orderStatus == 0){
            std::string callerStr = caller().toString();
            
            
            
            DipcAssert(info.getOwnerAddress() == caller().toString());
            

            uint64_t timenow = dipc::timestamp();
            if(ord.endTime > timenow){
                ord.orderStatus = 2;
            }else {
                ord.orderStatus = 3;
            }
        } else {
            return;
        }
        uint64_t lockToken = 0;
        if(ord.orderType == 1){
            lockToken = ord.stockPrice * ord.stockAmount;
        }
        uint64_t currentBalance =  portfolioBalance.get()[_portfolioName];
        
        
        
        

        DipcAssert(currentBalance + lockToken >= currentBalance);
        DipcAssert(ownerTotalToken.get() - lockToken <= ownerTotalToken.get());

        
        (*portfolioBalance)[_portfolioName] = currentBalance + lockToken;
        *ownerTotalToken = ownerTotalToken.get() - lockToken;
        (*portfolioStorge)[_portfolioName] = &info.toJson()[0];
        DIPC_EMIT_EVENT(revocationPortfolio, "orderId", _orderId, "orderInfo", &ord.toJson()[0]);
    }
    
    EXPORT void PortfolioManage::withdrawPortfolio(char* _portfolioName, uint64_t _withdrawBalance){
         u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
if(!userCanWithdraw.get()){
             return;
         }
         uint64_t currentBalance =  portfolioBalance.get()[_portfolioName];
         DipcAssert(currentBalance - _withdrawBalance < currentBalance);
         auto coinBalance = changeUint64ToU256WithChangeRate(currentBalance, changeRate.get());
         (*portfolioBalance)[_portfolioName] = currentBalance - _withdrawBalance;
         callTransfer(caller(), coinBalance);
    }
    
    EXPORT void PortfolioManage::withdrawPool(uint64_t _balance){
        u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
isOwner();
        Address ownerAddr = Address(owner.get()); 
        callTransfer(ownerAddr, _balance);
        *ownerTotalToken = ownerTotalToken.get() - _balance * changeRate.get();
        *totalToken = totalToken.get() - _balance * changeRate.get();
        DIPC_EMIT_EVENT(tokenCount, "ownerTotalToken", ownerTotalToken.get(), "totalToken", totalToken.get());
    }
    
    PAYABLE void PortfolioManage::depositPool(uint64_t _depositValue){
        isOwner();
        
        uint64_t tokenBalance = changeU256ToUint64WithChangeRate(callValue(), changeRate.get()); 
        *ownerTotalToken = ownerTotalToken.get() + tokenBalance;
        *totalToken = totalToken.get() + tokenBalance;
        DIPC_EMIT_EVENT(tokenCount, "ownerTotalToken", ownerTotalToken.get(), "totalToken", totalToken.get());
    }
     
    CONSTANT uint64_t PortfolioManage::queryTotalToken(){
        return totalToken.get();
    }

     
    CONSTANT uint64_t PortfolioManage::queryPortfolioBalance(char* _portfolioName){
        return portfolioBalance.get()[_portfolioName];
    }

    
    CONSTANT bool PortfolioManage::queryPortfolioNameIfUsed(char* _portfolioName){
        if(portfolioStorge.get()[_portfolioName] != ""){
            return true;
        } 
        return false;
    }

    
    CONSTANT uint64_t PortfolioManage::queryChangeRate(){
        return changeRate.get();
    }

2019-12-19_15:14:54.365631: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:427] searchContext  
     
    EXPORT void PortfolioManage::setUserCanWithdraw(bool _canWithdraw){
        u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
isOwner();
        *userCanWithdraw = _canWithdraw;
    }

    
    PAYABLE void PortfolioManage::createPortfolio(char* _portfolioName, char* _portfolioDesc){
        if(portfolioStorge.get()[_portfolioName] != ""){
            DIPC_EMIT_EVENT(ErrEvent, "Current portfolio exist: ", _portfolioName);
            return;
        } 
        std::string callerAddr = caller().toString();
        uint64_t tokenBalance = getTotalBalance();
        
        PortfolioInfo info(_portfolioName, _portfolioDesc, &callerAddr[0]);
        std::string portfolioStr = info.toJson();
        
        
        

        (*portfolioStorge)[_portfolioName] = portfolioStr;
        DipcAssert(totalToken.get() + tokenBalance > totalToken);
        (*portfolioBalance)[_portfolioName] = tokenBalance;
        *totalToken = totalToken.get() + tokenBalance; 
        
        DIPC_EMIT_EVENT(portfolioInfo, _portfolioName, &portfolioStr[0], "portfolioBalance", tokenBalance);
    }

    
    PAYABLE void PortfolioManage::depositPortfolio(char* _portfolioName){
        uint64_t tokenBalance = getTotalBalance();
        
        uint64_t currentBalance = portfolioBalance.get()[_portfolioName];
        uint64_t finalBalance  = currentBalance + tokenBalance;
        DipcAssert(totalToken.get() + tokenBalance > totalToken);
        DipcAssert(finalBalance > currentBalance);
        (*portfolioBalance)[_portfolioName] = finalBalance;
        *totalToken = totalToken.get() + finalBalance; 
        DIPC_EMIT_EVENT(depositPortfolio, "portfolioName", _portfolioName, "portfolioBalance", finalBalance);
    }
    
    PAYABLE void PortfolioManage::createOrder(char* _portfolioName, char* _orderId, uint16_t _orderType, char* _stockCode, uint64_t _stockPrice, uint64_t _stockAmount, uint64_t _endTime){
        uint64_t tokenBalance = getTotalBalance();
        DIPC_EMIT_EVENT(createOrder, "portfolioName", _portfolioName, "OrderInfo", "ignore", "tokenBalance", tokenBalance);
        uint64_t spent = 0;
        if(_orderType == 1){
            spent = _stockPrice * _stockAmount;
            DipcAssert((portfolioBalance.get()[_portfolioName] + tokenBalance) > spent);
        }
        struct Order order{_orderId, _orderType, _stockCode, _stockPrice, _stockAmount, _endTime, 0};
        std::string pInfo = portfolioStorge.get()[_portfolioName];
        
        
        
        if(pInfo == "") {
            DIPC_EMIT_EVENT(ErrEvent, "Current portfolio  doesn't exist: ", _portfolioName);
            return;
        }
        PortfolioInfo info;
        info.parseJson(pInfo);
        if(info.getOrder(_orderId).orderId != ""){
            DIPC_EMIT_EVENT(ErrEvent, "Current order exist: ", _orderId);
            return;
        }
        info.addOrder(order);
        pInfo = info.toJson();

        uint64_t currentBalance = portfolioBalance.get()[_portfolioName] ;
        uint64_t finalBalance = currentBalance + tokenBalance - spent;
        DipcAssert(totalToken.get() + tokenBalance > totalToken);
        
        DipcAssert(ownerTotalToken.get() < ownerTotalToken.get() + spent);
        (*portfolioStorge)[_portfolioName] = &pInfo[0];
        
        
        
        


        (*portfolioBalance)[_portfolioName] = finalBalance;
        *totalToken = totalToken.get() + finalBalance; 
        *ownerTotalToken = ownerTotalToken.get() + spent;
        DIPC_EMIT_EVENT(createOrder, "portfolioName", _portfolioName, "OrderInfo", &order.toJson()[0], "portfolioBalance", finalBalance);
    }

    
    EXPORT void PortfolioManage::dealOrder(char* _portfolioName, char* _orderId){
        u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
isOwner();
        std::string pInfo = portfolioStorge.get()[_portfolioName];
        
        
        PortfolioInfo info;
        info.parseJson(pInfo);
        

        
         Order ord = info.getOrder(_orderId);
         
         
        if(ord.orderId != "" && ord.orderStatus == 0){
            
            uint64_t timenow = dipc::timestamp();
            if(ord.endTime > timenow){
                ord.orderStatus = 1;
            }else {
                ord.orderStatus = 3;
            }
        } else {
          

            return;
        }
        

        uint64_t sellValue = 0;
        if(ord.orderType == 0){
            sellValue = ord.stockAmount * ord.stockPrice;
        }
        uint64_t currentBalance =  portfolioBalance.get()[_portfolioName];
        

        DipcAssert(currentBalance + sellValue >= currentBalance);
        DipcAssert((ownerTotalToken.get() - sellValue) <= ownerTotalToken.get());
        


        (*portfolioBalance)[_portfolioName] = currentBalance + sellValue;
        *ownerTotalToken = ownerTotalToken.get() - sellValue;
        (*portfolioStorge)[_portfolioName] = &info.toJson()[0];
        
        
        
        

        DIPC_EMIT_EVENT(dealPortfolio, "orderId", _orderId, "orderInfo", &ord.toJson()[0]);
    }
    
    EXPORT void PortfolioManage::revocationOrder(char* _portfolioName, char* _orderId){
        u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
std::string pInfo = portfolioStorge.get()[_portfolioName];
        
        
        PortfolioInfo info;
        info.parseJson(pInfo);
        Order ord = info.getOrder(_orderId);
        
        
        if(ord.orderId != "" && ord.orderStatus == 0){
            std::string callerStr = caller().toString();
            
            
            
            DipcAssert(info.getOwnerAddress() == caller().toString());
            

            uint64_t timenow = dipc::timestamp();
            if(ord.endTime > timenow){
                ord.orderStatus = 2;
            }else {
                ord.orderStatus = 3;
            }
        } else {
            return;
        }
        uint64_t lockToken = 0;
        if(ord.orderType == 1){
            lockToken = ord.stockPrice * ord.stockAmount;
        }
        uint64_t currentBalance =  portfolioBalance.get()[_portfolioName];
        
        
        
        

        DipcAssert(currentBalance + lockToken >= currentBalance);
        DipcAssert(ownerTotalToken.get() - lockToken <= ownerTotalToken.get());

        
        (*portfolioBalance)[_portfolioName] = currentBalance + lockToken;
        *ownerTotalToken = ownerTotalToken.get() - lockToken;
        (*portfolioStorge)[_portfolioName] = &info.toJson()[0];
        DIPC_EMIT_EVENT(revocationPortfolio, "orderId", _orderId, "orderInfo", &ord.toJson()[0]);
    }
    
    EXPORT void PortfolioManage::withdrawPortfolio(char* _portfolioName, uint64_t _withdrawBalance){
         u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
if(!userCanWithdraw.get()){
             return;
         }
         uint64_t currentBalance =  portfolioBalance.get()[_portfolioName];
         DipcAssert(currentBalance - _withdrawBalance < currentBalance);
         auto coinBalance = changeUint64ToU256WithChangeRate(currentBalance, changeRate.get());
         (*portfolioBalance)[_portfolioName] = currentBalance - _withdrawBalance;
         callTransfer(caller(), coinBalance);
    }
    
    EXPORT void PortfolioManage::withdrawPool(uint64_t _balance){
        u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
isOwner();
        Address ownerAddr = Address(owner.get()); 
        callTransfer(ownerAddr, _balance);
        *ownerTotalToken = ownerTotalToken.get() - _balance * changeRate.get();
        *totalToken = totalToken.get() - _balance * changeRate.get();
        DIPC_EMIT_EVENT(tokenCount, "ownerTotalToken", ownerTotalToken.get(), "totalToken", totalToken.get());
    }
    
    PAYABLE void PortfolioManage::depositPool(uint64_t _depositValue){
        isOwner();
        
        uint64_t tokenBalance = changeU256ToUint64WithChangeRate(callValue(), changeRate.get()); 
        *ownerTotalToken = ownerTotalToken.get() + tokenBalance;
        *totalToken = totalToken.get() + tokenBalance;
        DIPC_EMIT_EVENT(tokenCount, "ownerTotalToken", ownerTotalToken.get(), "totalToken", totalToken.get());
    }
     
    CONSTANT uint64_t PortfolioManage::queryTotalToken(){
        return totalToken.get();
    }

     
    CONSTANT uint64_t PortfolioManage::queryPortfolioBalance(char* _portfolioName){
        return portfolioBalance.get()[_portfolioName];
    }

    
    CONSTANT bool PortfolioManage::queryPortfolioNameIfUsed(char* _portfolioName){
        if(portfolioStorge.get()[_portfolioName] != ""){
            return true;
        } 
        return false;
    }

    
    CONSTANT uint64_t PortfolioManage::queryChangeRate(){
        return changeRate.get();
    }

2019-12-19_15:14:54.585574: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:442] finalContract  this new  #include "PortfolioManage.hpp"

    
    PAYABLE void PortfolioManage::init(){
        *owner = caller().toString();
        *changeRate = 10000;
        *userCanWithdraw = false;
        uint64_t tokenBalance = getTotalBalance();
        
        *ownerTotalToken = tokenBalance;
        *totalToken = ownerTotalToken.get();
        
        
        DIPC_EMIT_EVENT(initEvent, "ownerTotalToken" ,tokenBalance);
    }
    
     
    EXPORT void PortfolioManage::setChangeRate(uint64_t _changeRate){
        u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
isOwner();
        *changeRate = _changeRate;
    } codetext new #include "PortfolioManage.hpp"

    
    PAYABLE void PortfolioManage::init(){
        *owner = caller().toString();
        *changeRate = 10000;
        *userCanWithdraw = false;
        uint64_t tokenBalance = getTotalBalance();
        
        *ownerTotalToken = tokenBalance;
        *totalToken = ownerTotalToken.get();
        
        
        DIPC_EMIT_EVENT(initEvent, "ownerTotalToken" ,tokenBalance);
    }
    
     
    EXPORT void PortfolioManage::setChangeRate(uint64_t _changeRate){
        isOwner();
        *changeRate = _changeRate;
    }
     
    EXPORT void PortfolioManage::setUserCanWithdraw(bool _canWithdraw){
        u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
isOwner();
        *userCanWithdraw = _canWithdraw;
    }

    
    PAYABLE void PortfolioManage::createPortfolio(char* _portfolioName, char* _portfolioDesc){
        if(portfolioStorge.get()[_portfolioName] != ""){
            DIPC_EMIT_EVENT(ErrEvent, "Current portfolio exist: ", _portfolioName);
            return;
        } 
        std::string callerAddr = caller().toString();
        uint64_t tokenBalance = getTotalBalance();
        
        PortfolioInfo info(_portfolioName, _portfolioDesc, &callerAddr[0]);
        std::string portfolioStr = info.toJson();
        
        
        

        (*portfolioStorge)[_portfolioName] = portfolioStr;
        DipcAssert(totalToken.get() + tokenBalance > totalToken);
        (*portfolioBalance)[_portfolioName] = tokenBalance;
        *totalToken = totalToken.get() + tokenBalance; 
        
        DIPC_EMIT_EVENT(portfolioInfo, _portfolioName, &portfolioStr[0], "portfolioBalance", tokenBalance);
    }

    
    PAYABLE void PortfolioManage::depositPortfolio(char* _portfolioName){
        uint64_t tokenBalance = getTotalBalance();
        
        uint64_t currentBalance = portfolioBalance.get()[_portfolioName];
        uint64_t finalBalance  = currentBalance + tokenBalance;
        DipcAssert(totalToken.get() + tokenBalance > totalToken);
        DipcAssert(finalBalance > currentBalance);
        (*portfolioBalance)[_portfolioName] = finalBalance;
        *totalToken = totalToken.get() + finalBalance; 
        DIPC_EMIT_EVENT(depositPortfolio, "portfolioName", _portfolioName, "portfolioBalance", finalBalance);
    }
    
    PAYABLE void PortfolioManage::createOrder(char* _portfolioName, char* _orderId, uint16_t _orderType, char* _stockCode, uint64_t _stockPrice, uint64_t _stockAmount, uint64_t _endTime){
        uint64_t tokenBalance = getTotalBalance();
        DIPC_EMIT_EVENT(createOrder, "portfolioName", _portfolioName, "OrderInfo", "ignore", "tokenBalance", tokenBalance);
        uint64_t spent = 0;
        if(_orderType == 1){
            spent = _stockPrice * _stockAmount;
            DipcAssert((portfolioBalance.get()[_portfolioName] + tokenBalance) > spent);
        }
        struct Order order{_orderId, _orderType, _stockCode, _stockPrice, _stockAmount, _endTime, 0};
        std::string pInfo = portfolioStorge.get()[_portfolioName];
        
        
        
        if(pInfo == "") {
            DIPC_EMIT_EVENT(ErrEvent, "Current portfolio  doesn't exist: ", _portfolioName);
            return;
        }
        PortfolioInfo info;
        info.parseJson(pInfo);
        if(info.getOrder(_orderId).orderId != ""){
            DIPC_EMIT_EVENT(ErrEvent, "Current order exist: ", _orderId);
            return;
        }
        info.addOrder(order);
        pInfo = info.toJson();

        uint64_t currentBalance = portfolioBalance.get()[_portfolioName] ;
        uint64_t finalBalance = currentBalance + tokenBalance - spent;
        DipcAssert(totalToken.get() + tokenBalance > totalToken);
        
        DipcAssert(ownerTotalToken.get() < ownerTotalToken.get() + spent);
        (*portfolioStorge)[_portfolioName] = &pInfo[0];
        
        
        
        


        (*portfolioBalance)[_portfolioName] = finalBalance;
        *totalToken = totalToken.get() + finalBalance; 
        *ownerTotalToken = ownerTotalToken.get() + spent;
        DIPC_EMIT_EVENT(createOrder, "portfolioName", _portfolioName, "OrderInfo", &order.toJson()[0], "portfolioBalance", finalBalance);
    }

    
    EXPORT void PortfolioManage::dealOrder(char* _portfolioName, char* _orderId){
        u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
isOwner();
        std::string pInfo = portfolioStorge.get()[_portfolioName];
        
        
        PortfolioInfo info;
        info.parseJson(pInfo);
        

        
         Order ord = info.getOrder(_orderId);
         
         
        if(ord.orderId != "" && ord.orderStatus == 0){
            
            uint64_t timenow = dipc::timestamp();
            if(ord.endTime > timenow){
                ord.orderStatus = 1;
            }else {
                ord.orderStatus = 3;
            }
        } else {
          

            return;
        }
        

        uint64_t sellValue = 0;
        if(ord.orderType == 0){
            sellValue = ord.stockAmount * ord.stockPrice;
        }
        uint64_t currentBalance =  portfolioBalance.get()[_portfolioName];
        

        DipcAssert(currentBalance + sellValue >= currentBalance);
        DipcAssert((ownerTotalToken.get() - sellValue) <= ownerTotalToken.get());
        


        (*portfolioBalance)[_portfolioName] = currentBalance + sellValue;
        *ownerTotalToken = ownerTotalToken.get() - sellValue;
        (*portfolioStorge)[_portfolioName] = &info.toJson()[0];
        
        
        
        

        DIPC_EMIT_EVENT(dealPortfolio, "orderId", _orderId, "orderInfo", &ord.toJson()[0]);
    }
    
    EXPORT void PortfolioManage::revocationOrder(char* _portfolioName, char* _orderId){
        u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
std::string pInfo = portfolioStorge.get()[_portfolioName];
        
        
        PortfolioInfo info;
        info.parseJson(pInfo);
        Order ord = info.getOrder(_orderId);
        
        
        if(ord.orderId != "" && ord.orderStatus == 0){
            std::string callerStr = caller().toString();
            
            
            
            DipcAssert(info.getOwnerAddress() == caller().toString());
            

            uint64_t timenow = dipc::timestamp();
            if(ord.endTime > timenow){
                ord.orderStatus = 2;
            }else {
                ord.orderStatus = 3;
            }
        } else {
            return;
        }
        uint64_t lockToken = 0;
        if(ord.orderType == 1){
            lockToken = ord.stockPrice * ord.stockAmount;
        }
        uint64_t currentBalance =  portfolioBalance.get()[_portfolioName];
        
        
        
        

        DipcAssert(currentBalance + lockToken >= currentBalance);
        DipcAssert(ownerTotalToken.get() - lockToken <= ownerTotalToken.get());

        
        (*portfolioBalance)[_portfolioName] = currentBalance + lockToken;
        *ownerTotalToken = ownerTotalToken.get() - lockToken;
        (*portfolioStorge)[_portfolioName] = &info.toJson()[0];
        DIPC_EMIT_EVENT(revocationPortfolio, "orderId", _orderId, "orderInfo", &ord.toJson()[0]);
    }
    
    EXPORT void PortfolioManage::withdrawPortfolio(char* _portfolioName, uint64_t _withdrawBalance){
         u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
if(!userCanWithdraw.get()){
             return;
         }
         uint64_t currentBalance =  portfolioBalance.get()[_portfolioName];
         DipcAssert(currentBalance - _withdrawBalance < currentBalance);
         auto coinBalance = changeUint64ToU256WithChangeRate(currentBalance, changeRate.get());
         (*portfolioBalance)[_portfolioName] = currentBalance - _withdrawBalance;
         callTransfer(caller(), coinBalance);
    }
    
    EXPORT void PortfolioManage::withdrawPool(uint64_t _balance){
        u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
isOwner();
        Address ownerAddr = Address(owner.get()); 
        callTransfer(ownerAddr, _balance);
        *ownerTotalToken = ownerTotalToken.get() - _balance * changeRate.get();
        *totalToken = totalToken.get() - _balance * changeRate.get();
        DIPC_EMIT_EVENT(tokenCount, "ownerTotalToken", ownerTotalToken.get(), "totalToken", totalToken.get());
    }
    
    PAYABLE void PortfolioManage::depositPool(uint64_t _depositValue){
        isOwner();
        
        uint64_t tokenBalance = changeU256ToUint64WithChangeRate(callValue(), changeRate.get()); 
        *ownerTotalToken = ownerTotalToken.get() + tokenBalance;
        *totalToken = totalToken.get() + tokenBalance;
        DIPC_EMIT_EVENT(tokenCount, "ownerTotalToken", ownerTotalToken.get(), "totalToken", totalToken.get());
    }
     
    CONSTANT uint64_t PortfolioManage::queryTotalToken(){
        return totalToken.get();
    }

     
    CONSTANT uint64_t PortfolioManage::queryPortfolioBalance(char* _portfolioName){
        return portfolioBalance.get()[_portfolioName];
    }

    
    CONSTANT bool PortfolioManage::queryPortfolioNameIfUsed(char* _portfolioName){
        if(portfolioStorge.get()[_portfolioName] != ""){
            return true;
        } 
        return false;
    }

    
    CONSTANT uint64_t PortfolioManage::queryChangeRate(){
        return changeRate.get();
    }

2019-12-19_15:14:54.585603: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:604] finalContract  final content =======   : #include "PortfolioManage.hpp"

    
    PAYABLE void PortfolioManage::init(){
        *owner = caller().toString();
        *changeRate = 10000;
        *userCanWithdraw = false;
        uint64_t tokenBalance = getTotalBalance();
        
        *ownerTotalToken = tokenBalance;
        *totalToken = ownerTotalToken.get();
        
        
        DIPC_EMIT_EVENT(initEvent, "ownerTotalToken" ,tokenBalance);
    }
    
     
    EXPORT void PortfolioManage::setChangeRate(uint64_t _changeRate){
        u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
isOwner();
        *changeRate = _changeRate;
    }
     
    EXPORT void PortfolioManage::setUserCanWithdraw(bool _canWithdraw){
        u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
isOwner();
        *userCanWithdraw = _canWithdraw;
    }

    
    PAYABLE void PortfolioManage::createPortfolio(char* _portfolioName, char* _portfolioDesc){
        if(portfolioStorge.get()[_portfolioName] != ""){
            DIPC_EMIT_EVENT(ErrEvent, "Current portfolio exist: ", _portfolioName);
            return;
        } 
        std::string callerAddr = caller().toString();
        uint64_t tokenBalance = getTotalBalance();
        
        PortfolioInfo info(_portfolioName, _portfolioDesc, &callerAddr[0]);
        std::string portfolioStr = info.toJson();
        
        
        

        (*portfolioStorge)[_portfolioName] = portfolioStr;
        DipcAssert(totalToken.get() + tokenBalance > totalToken);
        (*portfolioBalance)[_portfolioName] = tokenBalance;
        *totalToken = totalToken.get() + tokenBalance; 
        
        DIPC_EMIT_EVENT(portfolioInfo, _portfolioName, &portfolioStr[0], "portfolioBalance", tokenBalance);
    }

    
    PAYABLE void PortfolioManage::depositPortfolio(char* _portfolioName){
        uint64_t tokenBalance = getTotalBalance();
        
        uint64_t currentBalance = portfolioBalance.get()[_portfolioName];
        uint64_t finalBalance  = currentBalance + tokenBalance;
        DipcAssert(totalToken.get() + tokenBalance > totalToken);
        DipcAssert(finalBalance > currentBalance);
        (*portfolioBalance)[_portfolioName] = finalBalance;
        *totalToken = totalToken.get() + finalBalance; 
        DIPC_EMIT_EVENT(depositPortfolio, "portfolioName", _portfolioName, "portfolioBalance", finalBalance);
    }
    
    PAYABLE void PortfolioManage::createOrder(char* _portfolioName, char* _orderId, uint16_t _orderType, char* _stockCode, uint64_t _stockPrice, uint64_t _stockAmount, uint64_t _endTime){
        uint64_t tokenBalance = getTotalBalance();
        DIPC_EMIT_EVENT(createOrder, "portfolioName", _portfolioName, "OrderInfo", "ignore", "tokenBalance", tokenBalance);
        uint64_t spent = 0;
        if(_orderType == 1){
            spent = _stockPrice * _stockAmount;
            DipcAssert((portfolioBalance.get()[_portfolioName] + tokenBalance) > spent);
        }
        struct Order order{_orderId, _orderType, _stockCode, _stockPrice, _stockAmount, _endTime, 0};
        std::string pInfo = portfolioStorge.get()[_portfolioName];
        
        
        
        if(pInfo == "") {
            DIPC_EMIT_EVENT(ErrEvent, "Current portfolio  doesn't exist: ", _portfolioName);
            return;
        }
        PortfolioInfo info;
        info.parseJson(pInfo);
        if(info.getOrder(_orderId).orderId != ""){
            DIPC_EMIT_EVENT(ErrEvent, "Current order exist: ", _orderId);
            return;
        }
        info.addOrder(order);
        pInfo = info.toJson();

        uint64_t currentBalance = portfolioBalance.get()[_portfolioName] ;
        uint64_t finalBalance = currentBalance + tokenBalance - spent;
        DipcAssert(totalToken.get() + tokenBalance > totalToken);
        
        DipcAssert(ownerTotalToken.get() < ownerTotalToken.get() + spent);
        (*portfolioStorge)[_portfolioName] = &pInfo[0];
        
        
        
        


        (*portfolioBalance)[_portfolioName] = finalBalance;
        *totalToken = totalToken.get() + finalBalance; 
        *ownerTotalToken = ownerTotalToken.get() + spent;
        DIPC_EMIT_EVENT(createOrder, "portfolioName", _portfolioName, "OrderInfo", &order.toJson()[0], "portfolioBalance", finalBalance);
    }

    
    EXPORT void PortfolioManage::dealOrder(char* _portfolioName, char* _orderId){
        u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
isOwner();
        std::string pInfo = portfolioStorge.get()[_portfolioName];
        
        
        PortfolioInfo info;
        info.parseJson(pInfo);
        

        
         Order ord = info.getOrder(_orderId);
         
         
        if(ord.orderId != "" && ord.orderStatus == 0){
            
            uint64_t timenow = dipc::timestamp();
            if(ord.endTime > timenow){
                ord.orderStatus = 1;
            }else {
                ord.orderStatus = 3;
            }
        } else {
          

            return;
        }
        

        uint64_t sellValue = 0;
        if(ord.orderType == 0){
            sellValue = ord.stockAmount * ord.stockPrice;
        }
        uint64_t currentBalance =  portfolioBalance.get()[_portfolioName];
        

        DipcAssert(currentBalance + sellValue >= currentBalance);
        DipcAssert((ownerTotalToken.get() - sellValue) <= ownerTotalToken.get());
        


        (*portfolioBalance)[_portfolioName] = currentBalance + sellValue;
        *ownerTotalToken = ownerTotalToken.get() - sellValue;
        (*portfolioStorge)[_portfolioName] = &info.toJson()[0];
        
        
        
        

        DIPC_EMIT_EVENT(dealPortfolio, "orderId", _orderId, "orderInfo", &ord.toJson()[0]);
    }
    
    EXPORT void PortfolioManage::revocationOrder(char* _portfolioName, char* _orderId){
        u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
std::string pInfo = portfolioStorge.get()[_portfolioName];
        
        
        PortfolioInfo info;
        info.parseJson(pInfo);
        Order ord = info.getOrder(_orderId);
        
        
        if(ord.orderId != "" && ord.orderStatus == 0){
            std::string callerStr = caller().toString();
            
            
            
            DipcAssert(info.getOwnerAddress() == caller().toString());
            

            uint64_t timenow = dipc::timestamp();
            if(ord.endTime > timenow){
                ord.orderStatus = 2;
            }else {
                ord.orderStatus = 3;
            }
        } else {
            return;
        }
        uint64_t lockToken = 0;
        if(ord.orderType == 1){
            lockToken = ord.stockPrice * ord.stockAmount;
        }
        uint64_t currentBalance =  portfolioBalance.get()[_portfolioName];
        
        
        
        

        DipcAssert(currentBalance + lockToken >= currentBalance);
        DipcAssert(ownerTotalToken.get() - lockToken <= ownerTotalToken.get());

        
        (*portfolioBalance)[_portfolioName] = currentBalance + lockToken;
        *ownerTotalToken = ownerTotalToken.get() - lockToken;
        (*portfolioStorge)[_portfolioName] = &info.toJson()[0];
        DIPC_EMIT_EVENT(revocationPortfolio, "orderId", _orderId, "orderInfo", &ord.toJson()[0]);
    }
    
    EXPORT void PortfolioManage::withdrawPortfolio(char* _portfolioName, uint64_t _withdrawBalance){
         u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
if(!userCanWithdraw.get()){
             return;
         }
         uint64_t currentBalance =  portfolioBalance.get()[_portfolioName];
         DipcAssert(currentBalance - _withdrawBalance < currentBalance);
         auto coinBalance = changeUint64ToU256WithChangeRate(currentBalance, changeRate.get());
         (*portfolioBalance)[_portfolioName] = currentBalance - _withdrawBalance;
         callTransfer(caller(), coinBalance);
    }
    
    EXPORT void PortfolioManage::withdrawPool(uint64_t _balance){
        u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
isOwner();
        Address ownerAddr = Address(owner.get()); 
        callTransfer(ownerAddr, _balance);
        *ownerTotalToken = ownerTotalToken.get() - _balance * changeRate.get();
        *totalToken = totalToken.get() - _balance * changeRate.get();
        DIPC_EMIT_EVENT(tokenCount, "ownerTotalToken", ownerTotalToken.get(), "totalToken", totalToken.get());
    }
    
    PAYABLE void PortfolioManage::depositPool(uint64_t _depositValue){
        isOwner();
        
        uint64_t tokenBalance = changeU256ToUint64WithChangeRate(callValue(), changeRate.get()); 
        *ownerTotalToken = ownerTotalToken.get() + tokenBalance;
        *totalToken = totalToken.get() + tokenBalance;
        DIPC_EMIT_EVENT(tokenCount, "ownerTotalToken", ownerTotalToken.get(), "totalToken", totalToken.get());
    }
     
    CONSTANT uint64_t PortfolioManage::queryTotalToken(){
        return totalToken.get();
    }

     
    CONSTANT uint64_t PortfolioManage::queryPortfolioBalance(char* _portfolioName){
        return portfolioBalance.get()[_portfolioName];
    }

    
    CONSTANT bool PortfolioManage::queryPortfolioNameIfUsed(char* _portfolioName){
        if(portfolioStorge.get()[_portfolioName] != ""){
            return true;
        } 
        return false;
    }

    
    CONSTANT uint64_t PortfolioManage::queryChangeRate(){
        return changeRate.get();
    }

2019-12-19_15:14:54.585613: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:401] abis.ispayable :false

2019-12-19_15:14:54.585632: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:424] finalContract  this height  #include "PortfolioManage.hpp"

    
    PAYABLE void PortfolioManage::init(){
        *owner = caller().toString();
        *changeRate = 10000;
        *userCanWithdraw = false;
        uint64_t tokenBalance = getTotalBalance();
        
        *ownerTotalToken = tokenBalance;
        *totalToken = ownerTotalToken.get();
        
        
        DIPC_EMIT_EVENT(initEvent, "ownerTotalToken" ,tokenBalance);
    }
    
     
    EXPORT void PortfolioManage::setChangeRate(uint64_t _changeRate){
        u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
isOwner();
        *changeRate = _changeRate;
    }
     
    EXPORT void PortfolioManage::setUserCanWithdraw(bool _canWithdraw){
        u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
isOwner();
        *userCanWithdraw = _canWithdraw;
    }

    
    PAYABLE void PortfolioManage::createPortfolio(char* _portfolioName, char* _portfolioDesc){
        if(portfolioStorge.get()[_portfolioName] != ""){
            DIPC_EMIT_EVENT(ErrEvent, "Current portfolio exist: ", _portfolioName);
            return;
        } 
        std::string callerAddr = caller().toString();
        uint64_t tokenBalance = getTotalBalance();
        
        PortfolioInfo info(_portfolioName, _portfolioDesc, &callerAddr[0]);
        std::string portfolioStr = info.toJson();
        
        
        

        (*portfolioStorge)[_portfolioName] = portfolioStr;
        DipcAssert(totalToken.get() + tokenBalance > totalToken);
        (*portfolioBalance)[_portfolioName] = tokenBalance;
        *totalToken = totalToken.get() + tokenBalance; 
        
        DIPC_EMIT_EVENT(portfolioInfo, _portfolioName, &portfolioStr[0], "portfolioBalance", tokenBalance);
    }

    
    PAYABLE void PortfolioManage::depositPortfolio(char* _portfolioName){
        uint64_t tokenBalance = getTotalBalance();
        
        uint64_t currentBalance = portfolioBalance.get()[_portfolioName];
        uint64_t finalBalance  = currentBalance + tokenBalance;
        DipcAssert(totalToken.get() + tokenBalance > totalToken);
        DipcAssert(finalBalance > currentBalance);
        (*portfolioBalance)[_portfolioName] = finalBalance;
        *totalToken = totalToken.get() + finalBalance; 
        DIPC_EMIT_EVENT(depositPortfolio, "portfolioName", _portfolioName, "portfolioBalance", finalBalance);
    }
    
    PAYABLE void PortfolioManage::createOrder(char* _portfolioName, char* _orderId, uint16_t _orderType, char* _stockCode, uint64_t _stockPrice, uint64_t _stockAmount, uint64_t _endTime){
        uint64_t tokenBalance = getTotalBalance();
        DIPC_EMIT_EVENT(createOrder, "portfolioName", _portfolioName, "OrderInfo", "ignore", "tokenBalance", tokenBalance);
        uint64_t spent = 0;
        if(_orderType == 1){
            spent = _stockPrice * _stockAmount;
            DipcAssert((portfolioBalance.get()[_portfolioName] + tokenBalance) > spent);
        }
        struct Order order{_orderId, _orderType, _stockCode, _stockPrice, _stockAmount, _endTime, 0};
        std::string pInfo = portfolioStorge.get()[_portfolioName];
        
        
        
        if(pInfo == "") {
            DIPC_EMIT_EVENT(ErrEvent, "Current portfolio  doesn't exist: ", _portfolioName);
            return;
        }
        PortfolioInfo info;
        info.parseJson(pInfo);
        if(info.getOrder(_orderId).orderId != ""){
            DIPC_EMIT_EVENT(ErrEvent, "Current order exist: ", _orderId);
            return;
        }
        info.addOrder(order);
        pInfo = info.toJson();

        uint64_t currentBalance = portfolioBalance.get()[_portfolioName] ;
        uint64_t finalBalance = currentBalance + tokenBalance - spent;
        DipcAssert(totalToken.get() + tokenBalance > totalToken);
        
        DipcAssert(ownerTotalToken.get() < ownerTotalToken.get() + spent);
        (*portfolioStorge)[_portfolioName] = &pInfo[0];
        
        
        
        


        (*portfolioBalance)[_portfolioName] = finalBalance;
        *totalToken = totalToken.get() + finalBalance; 
        *ownerTotalToken = ownerTotalToken.get() + spent;
        DIPC_EMIT_EVENT(createOrder, "portfolioName", _portfolioName, "OrderInfo", &order.toJson()[0], "portfolioBalance", finalBalance);
    }

    
    EXPORT void PortfolioManage::dealOrder(char* _portfolioName, char* _orderId){
        u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
isOwner();
        std::string pInfo = portfolioStorge.get()[_portfolioName];
        
        
        PortfolioInfo info;
        info.parseJson(pInfo);
        

        
         Order ord = info.getOrder(_orderId);
         
         
        if(ord.orderId != "" && ord.orderStatus == 0){
            
            uint64_t timenow = dipc::timestamp();
            if(ord.endTime > timenow){
                ord.orderStatus = 1;
            }else {
                ord.orderStatus = 3;
            }
        } else {
          

            return;
        }
        

        uint64_t sellValue = 0;
        if(ord.orderType == 0){
            sellValue = ord.stockAmount * ord.stockPrice;
        }
        uint64_t currentBalance =  portfolioBalance.get()[_portfolioName];
        

        DipcAssert(currentBalance + sellValue >= currentBalance);
        DipcAssert((ownerTotalToken.get() - sellValue) <= ownerTotalToken.get());
        


        (*portfolioBalance)[_portfolioName] = currentBalance + sellValue;
        *ownerTotalToken = ownerTotalToken.get() - sellValue;
        (*portfolioStorge)[_portfolioName] = &info.toJson()[0];
        
        
        
        

        DIPC_EMIT_EVENT(dealPortfolio, "orderId", _orderId, "orderInfo", &ord.toJson()[0]);
    }
    
    EXPORT void PortfolioManage::revocationOrder(char* _portfolioName, char* _orderId){
        u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
std::string pInfo = portfolioStorge.get()[_portfolioName];
        
        
        PortfolioInfo info;
        info.parseJson(pInfo);
        Order ord = info.getOrder(_orderId);
        
        
        if(ord.orderId != "" && ord.orderStatus == 0){
            std::string callerStr = caller().toString();
            
            
            
            DipcAssert(info.getOwnerAddress() == caller().toString());
            

            uint64_t timenow = dipc::timestamp();
            if(ord.endTime > timenow){
                ord.orderStatus = 2;
            }else {
                ord.orderStatus = 3;
            }
        } else {
            return;
        }
        uint64_t lockToken = 0;
        if(ord.orderType == 1){
            lockToken = ord.stockPrice * ord.stockAmount;
        }
        uint64_t currentBalance =  portfolioBalance.get()[_portfolioName];
        
        
        
        

        DipcAssert(currentBalance + lockToken >= currentBalance);
        DipcAssert(ownerTotalToken.get() - lockToken <= ownerTotalToken.get());

        
        (*portfolioBalance)[_portfolioName] = currentBalance + lockToken;
        *ownerTotalToken = ownerTotalToken.get() - lockToken;
        (*portfolioStorge)[_portfolioName] = &info.toJson()[0];
        DIPC_EMIT_EVENT(revocationPortfolio, "orderId", _orderId, "orderInfo", &ord.toJson()[0]);
    }
    
    EXPORT void PortfolioManage::withdrawPortfolio(char* _portfolioName, uint64_t _withdrawBalance){
         u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
if(!userCanWithdraw.get()){
             return;
         }
         uint64_t currentBalance =  portfolioBalance.get()[_portfolioName];
         DipcAssert(currentBalance - _withdrawBalance < currentBalance);
         auto coinBalance = changeUint64ToU256WithChangeRate(currentBalance, changeRate.get());
         (*portfolioBalance)[_portfolioName] = currentBalance - _withdrawBalance;
         callTransfer(caller(), coinBalance);
    }
    
    EXPORT void PortfolioManage::withdrawPool(uint64_t _balance){
        u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
isOwner();
        Address ownerAddr = Address(owner.get()); 
        callTransfer(ownerAddr, _balance);
        *ownerTotalToken = ownerTotalToken.get() - _balance * changeRate.get();
        *totalToken = totalToken.get() - _balance * changeRate.get();
        DIPC_EMIT_EVENT(tokenCount, "ownerTotalToken", ownerTotalToken.get(), "totalToken", totalToken.get());
    }
    
    PAYABLE void PortfolioManage::depositPool(uint64_t _depositValue){
        isOwner();
        
        uint64_t tokenBalance = changeU256ToUint64WithChangeRate(callValue(), changeRate.get()); 
        *ownerTotalToken = ownerTotalToken.get() + tokenBalance;
        *totalToken = totalToken.get() + tokenBalance;
        DIPC_EMIT_EVENT(tokenCount, "ownerTotalToken", ownerTotalToken.get(), "totalToken", totalToken.get());
    }
     
    CONSTANT uint64_t PortfolioManage::queryTotalToken(){
        return totalToken.get();
    }

     
    CONSTANT uint64_t PortfolioManage::queryPortfolioBalance(char* _portfolioName){
        return portfolioBalance.get()[_portfolioName];
    }

    
    CONSTANT bool PortfolioManage::queryPortfolioNameIfUsed(char* _portfolioName){
        if(portfolioStorge.get()[_portfolioName] != ""){
            return true;
        } 
        return false;
    }

    
    CONSTANT uint64_t PortfolioManage::queryChangeRate(){
        return changeRate.get();
    } codetext height #include "PortfolioManage.hpp"

    
    PAYABLE void PortfolioManage::init(){
        *owner = caller().toString();
        *changeRate = 10000;
        *userCanWithdraw = false;
        uint64_t tokenBalance = getTotalBalance();
        
        *ownerTotalToken = tokenBalance;
        *totalToken = ownerTotalToken.get();
        
        
        DIPC_EMIT_EVENT(initEvent, "ownerTotalToken" ,tokenBalance);
    }
    
     
    EXPORT void PortfolioManage::setChangeRate(uint64_t _changeRate){
        u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
isOwner();
        *changeRate = _changeRate;
    }
     
    EXPORT void PortfolioManage::setUserCanWithdraw(bool _canWithdraw){
        u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
isOwner();
        *userCanWithdraw = _canWithdraw;
    }

    
    PAYABLE void PortfolioManage::createPortfolio(char* _portfolioName, char* _portfolioDesc){
        if(portfolioStorge.get()[_portfolioName] != ""){
            DIPC_EMIT_EVENT(ErrEvent, "Current portfolio exist: ", _portfolioName);
            return;
        } 
        std::string callerAddr = caller().toString();
        uint64_t tokenBalance = getTotalBalance();
        
        PortfolioInfo info(_portfolioName, _portfolioDesc, &callerAddr[0]);
        std::string portfolioStr = info.toJson();
        
        
        

        (*portfolioStorge)[_portfolioName] = portfolioStr;
        DipcAssert(totalToken.get() + tokenBalance > totalToken);
        (*portfolioBalance)[_portfolioName] = tokenBalance;
        *totalToken = totalToken.get() + tokenBalance; 
        
        DIPC_EMIT_EVENT(portfolioInfo, _portfolioName, &portfolioStr[0], "portfolioBalance", tokenBalance);
    }

    
    PAYABLE void PortfolioManage::depositPortfolio(char* _portfolioName){
        uint64_t tokenBalance = getTotalBalance();
        
        uint64_t currentBalance = portfolioBalance.get()[_portfolioName];
        uint64_t finalBalance  = currentBalance + tokenBalance;
        DipcAssert(totalToken.get() + tokenBalance > totalToken);
        DipcAssert(finalBalance > currentBalance);
        (*portfolioBalance)[_portfolioName] = finalBalance;
        *totalToken = totalToken.get() + finalBalance; 
        DIPC_EMIT_EVENT(depositPortfolio, "portfolioName", _portfolioName, "portfolioBalance", finalBalance);
    }
    
    PAYABLE void PortfolioManage::createOrder(char* _portfolioName, char* _orderId, uint16_t _orderType, char* _stockCode, uint64_t _stockPrice, uint64_t _stockAmount, uint64_t _endTime){
        uint64_t tokenBalance = getTotalBalance();
        DIPC_EMIT_EVENT(createOrder, "portfolioName", _portfolioName, "OrderInfo", "ignore", "tokenBalance", tokenBalance);
        uint64_t spent = 0;
        if(_orderType == 1){
            spent = _stockPrice * _stockAmount;
            DipcAssert((portfolioBalance.get()[_portfolioName] + tokenBalance) > spent);
        }
        struct Order order{_orderId, _orderType, _stockCode, _stockPrice, _stockAmount, _endTime, 0};
        std::string pInfo = portfolioStorge.get()[_portfolioName];
        
        
        
        if(pInfo == "") {
            DIPC_EMIT_EVENT(ErrEvent, "Current portfolio  doesn't exist: ", _portfolioName);
            return;
        }
        PortfolioInfo info;
        info.parseJson(pInfo);
        if(info.getOrder(_orderId).orderId != ""){
            DIPC_EMIT_EVENT(ErrEvent, "Current order exist: ", _orderId);
            return;
        }
        info.addOrder(order);
        pInfo = info.toJson();

        uint64_t currentBalance = portfolioBalance.get()[_portfolioName] ;
        uint64_t finalBalance = currentBalance + tokenBalance - spent;
        DipcAssert(totalToken.get() + tokenBalance > totalToken);
        
        DipcAssert(ownerTotalToken.get() < ownerTotalToken.get() + spent);
        (*portfolioStorge)[_portfolioName] = &pInfo[0];
        
        
        
        


        (*portfolioBalance)[_portfolioName] = finalBalance;
        *totalToken = totalToken.get() + finalBalance; 
        *ownerTotalToken = ownerTotalToken.get() + spent;
        DIPC_EMIT_EVENT(createOrder, "portfolioName", _portfolioName, "OrderInfo", &order.toJson()[0], "portfolioBalance", finalBalance);
    }

    
    EXPORT void PortfolioManage::dealOrder(char* _portfolioName, char* _orderId){
        u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
isOwner();
        std::string pInfo = portfolioStorge.get()[_portfolioName];
        
        
        PortfolioInfo info;
        info.parseJson(pInfo);
        

        
         Order ord = info.getOrder(_orderId);
         
         
        if(ord.orderId != "" && ord.orderStatus == 0){
            
            uint64_t timenow = dipc::timestamp();
            if(ord.endTime > timenow){
                ord.orderStatus = 1;
            }else {
                ord.orderStatus = 3;
            }
        } else {
          

            return;
        }
        

        uint64_t sellValue = 0;
        if(ord.orderType == 0){
            sellValue = ord.stockAmount * ord.stockPrice;
        }
        uint64_t currentBalance =  portfolioBalance.get()[_portfolioName];
        

        DipcAssert(currentBalance + sellValue >= currentBalance);
        DipcAssert((ownerTotalToken.get() - sellValue) <= ownerTotalToken.get());
        


        (*portfolioBalance)[_portfolioName] = currentBalance + sellValue;
        *ownerTotalToken = ownerTotalToken.get() - sellValue;
        (*portfolioStorge)[_portfolioName] = &info.toJson()[0];
        
        
        
        

        DIPC_EMIT_EVENT(dealPortfolio, "orderId", _orderId, "orderInfo", &ord.toJson()[0]);
    }
    
    EXPORT void PortfolioManage::revocationOrder(char* _portfolioName, char* _orderId){
        u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
std::string pInfo = portfolioStorge.get()[_portfolioName];
        
        
        PortfolioInfo info;
        info.parseJson(pInfo);
        Order ord = info.getOrder(_orderId);
        
        
        if(ord.orderId != "" && ord.orderStatus == 0){
            std::string callerStr = caller().toString();
            
            
            
            DipcAssert(info.getOwnerAddress() == caller().toString());
            

            uint64_t timenow = dipc::timestamp();
            if(ord.endTime > timenow){
                ord.orderStatus = 2;
            }else {
                ord.orderStatus = 3;
            }
        } else {
            return;
        }
        uint64_t lockToken = 0;
        if(ord.orderType == 1){
            lockToken = ord.stockPrice * ord.stockAmount;
        }
        uint64_t currentBalance =  portfolioBalance.get()[_portfolioName];
        
        
        
        

        DipcAssert(currentBalance + lockToken >= currentBalance);
        DipcAssert(ownerTotalToken.get() - lockToken <= ownerTotalToken.get());

        
        (*portfolioBalance)[_portfolioName] = currentBalance + lockToken;
        *ownerTotalToken = ownerTotalToken.get() - lockToken;
        (*portfolioStorge)[_portfolioName] = &info.toJson()[0];
        DIPC_EMIT_EVENT(revocationPortfolio, "orderId", _orderId, "orderInfo", &ord.toJson()[0]);
    }
    
    EXPORT void PortfolioManage::withdrawPortfolio(char* _portfolioName, uint64_t _withdrawBalance){
         u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
if(!userCanWithdraw.get()){
             return;
         }
         uint64_t currentBalance =  portfolioBalance.get()[_portfolioName];
         DipcAssert(currentBalance - _withdrawBalance < currentBalance);
         auto coinBalance = changeUint64ToU256WithChangeRate(currentBalance, changeRate.get());
         (*portfolioBalance)[_portfolioName] = currentBalance - _withdrawBalance;
         callTransfer(caller(), coinBalance);
    }
    
    EXPORT void PortfolioManage::withdrawPool(uint64_t _balance){
        u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
isOwner();
        Address ownerAddr = Address(owner.get()); 
        callTransfer(ownerAddr, _balance);
        *ownerTotalToken = ownerTotalToken.get() - _balance * changeRate.get();
        *totalToken = totalToken.get() - _balance * changeRate.get();
        DIPC_EMIT_EVENT(tokenCount, "ownerTotalToken", ownerTotalToken.get(), "totalToken", totalToken.get());
    }
    
    PAYABLE void PortfolioManage::depositPool(uint64_t _depositValue){
        isOwner();
        
        uint64_t tokenBalance = changeU256ToUint64WithChangeRate(callValue(), changeRate.get()); 
        *ownerTotalToken = ownerTotalToken.get() + tokenBalance;
        *totalToken = totalToken.get() + tokenBalance;
        DIPC_EMIT_EVENT(tokenCount, "ownerTotalToken", ownerTotalToken.get(), "totalToken", totalToken.get());
    }
     
    CONSTANT uint64_t PortfolioManage::queryTotalToken(){
        return totalToken.get();
    }

     
    CONSTANT uint64_t PortfolioManage::queryPortfolioBalance(char* _portfolioName){
        return portfolioBalance.get()[_portfolioName];
    }

    
    CONSTANT bool PortfolioManage::queryPortfolioNameIfUsed(char* _portfolioName){
        if(portfolioStorge.get()[_portfolioName] != ""){
            return true;
        } 
        return false;
    }

    
    CONSTANT uint64_t PortfolioManage::queryChangeRate(){
        return changeRate.get();
    }

2019-12-19_15:14:54.585644: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:427] searchContext  #include "PortfolioManage.hpp"

    
    PAYABLE void PortfolioManage::init(){
        *owner = caller().toString();
        *changeRate = 10000;
        *userCanWithdraw = false;
        uint64_t tokenBalance = getTotalBalance();
        
        *ownerTotalToken = tokenBalance;
        *totalToken = ownerTotalToken.get();
        
        
        DIPC_EMIT_EVENT(initEvent, "ownerTotalToken" ,tokenBalance);
    }
    
     
    EXPORT void PortfolioManage::setChangeRate(uint64_t _changeRate){
        u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
isOwner();
        *changeRate = _changeRate;
    }
     
    EXPORT void PortfolioManage::setUserCanWithdraw(bool _canWithdraw){
        u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
isOwner();
        *userCanWithdraw = _canWithdraw;
    }

    
    PAYABLE void PortfolioManage::createPortfolio(char* _portfolioName, char* _portfolioDesc){
        if(portfolioStorge.get()[_portfolioName] != ""){
            DIPC_EMIT_EVENT(ErrEvent, "Current portfolio exist: ", _portfolioName);
            return;
        } 
        std::string callerAddr = caller().toString();
        uint64_t tokenBalance = getTotalBalance();
        
        PortfolioInfo info(_portfolioName, _portfolioDesc, &callerAddr[0]);
        std::string portfolioStr = info.toJson();
        
        
        

        (*portfolioStorge)[_portfolioName] = portfolioStr;
        DipcAssert(totalToken.get() + tokenBalance > totalToken);
        (*portfolioBalance)[_portfolioName] = tokenBalance;
        *totalToken = totalToken.get() + tokenBalance; 
        
        DIPC_EMIT_EVENT(portfolioInfo, _portfolioName, &portfolioStr[0], "portfolioBalance", tokenBalance);
    }

    
    PAYABLE void PortfolioManage::depositPortfolio(char* _portfolioName){
        uint64_t tokenBalance = getTotalBalance();
        
        uint64_t currentBalance = portfolioBalance.get()[_portfolioName];
        uint64_t finalBalance  = currentBalance + tokenBalance;
        DipcAssert(totalToken.get() + tokenBalance > totalToken);
        DipcAssert(finalBalance > currentBalance);
        (*portfolioBalance)[_portfolioName] = finalBalance;
        *totalToken = totalToken.get() + finalBalance; 
        DIPC_EMIT_EVENT(depositPortfolio, "portfolioName", _portfolioName, "portfolioBalance", finalBalance);
    }
    
    PAYABLE void PortfolioManage::createOrder(char* _portfolioName, char* _orderId, uint16_t _orderType, char* _stockCode, uint64_t _stockPrice, uint64_t _stockAmount, uint64_t _endTime){
        uint64_t tokenBalance = getTotalBalance();
        DIPC_EMIT_EVENT(createOrder, "portfolioName", _portfolioName, "OrderInfo", "ignore", "tokenBalance", tokenBalance);
        uint64_t spent = 0;
        if(_orderType == 1){
            spent = _stockPrice * _stockAmount;
            DipcAssert((portfolioBalance.get()[_portfolioName] + tokenBalance) > spent);
        }
        struct Order order{_orderId, _orderType, _stockCode, _stockPrice, _stockAmount, _endTime, 0};
        std::string pInfo = portfolioStorge.get()[_portfolioName];
        
        
        
        if(pInfo == "") {
            DIPC_EMIT_EVENT(ErrEvent, "Current portfolio  doesn't exist: ", _portfolioName);
            return;
        }
        PortfolioInfo info;
        info.parseJson(pInfo);
        if(info.getOrder(_orderId).orderId != ""){
            DIPC_EMIT_EVENT(ErrEvent, "Current order exist: ", _orderId);
            return;
        }
        info.addOrder(order);
        pInfo = info.toJson();

        uint64_t currentBalance = portfolioBalance.get()[_portfolioName] ;
        uint64_t finalBalance = currentBalance + tokenBalance - spent;
        DipcAssert(totalToken.get() + tokenBalance > totalToken);
        
        DipcAssert(ownerTotalToken.get() < ownerTotalToken.get() + spent);
        (*portfolioStorge)[_portfolioName] = &pInfo[0];
        
        
        
        


        (*portfolioBalance)[_portfolioName] = finalBalance;
        *totalToken = totalToken.get() + finalBalance; 
        *ownerTotalToken = ownerTotalToken.get() + spent;
        DIPC_EMIT_EVENT(createOrder, "portfolioName", _portfolioName, "OrderInfo", &order.toJson()[0], "portfolioBalance", finalBalance);
    }

    
    EXPORT void PortfolioManage::dealOrder(char* _portfolioName, char* _orderId){
        u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
isOwner();
        std::string pInfo = portfolioStorge.get()[_portfolioName];
        
        
        PortfolioInfo info;
        info.parseJson(pInfo);
        

        
         Order ord = info.getOrder(_orderId);
         
         
        if(ord.orderId != "" && ord.orderStatus == 0){
            
            uint64_t timenow = dipc::timestamp();
            if(ord.endTime > timenow){
                ord.orderStatus = 1;
            }else {
                ord.orderStatus = 3;
            }
        } else {
          

            return;
        }
        

        uint64_t sellValue = 0;
        if(ord.orderType == 0){
            sellValue = ord.stockAmount * ord.stockPrice;
        }
        uint64_t currentBalance =  portfolioBalance.get()[_portfolioName];
        

        DipcAssert(currentBalance + sellValue >= currentBalance);
        DipcAssert((ownerTotalToken.get() - sellValue) <= ownerTotalToken.get());
        


        (*portfolioBalance)[_portfolioName] = currentBalance + sellValue;
        *ownerTotalToken = ownerTotalToken.get() - sellValue;
        (*portfolioStorge)[_portfolioName] = &info.toJson()[0];
        
        
        
        

        DIPC_EMIT_EVENT(dealPortfolio, "orderId", _orderId, "orderInfo", &ord.toJson()[0]);
    }
    
    EXPORT void PortfolioManage::revocationOrder(char* _portfolioName, char* _orderId){
        u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
std::string pInfo = portfolioStorge.get()[_portfolioName];
        
        
        PortfolioInfo info;
        info.parseJson(pInfo);
        Order ord = info.getOrder(_orderId);
        
        
        if(ord.orderId != "" && ord.orderStatus == 0){
            std::string callerStr = caller().toString();
            
            
            
            DipcAssert(info.getOwnerAddress() == caller().toString());
            

            uint64_t timenow = dipc::timestamp();
            if(ord.endTime > timenow){
                ord.orderStatus = 2;
            }else {
                ord.orderStatus = 3;
            }
        } else {
            return;
        }
        uint64_t lockToken = 0;
        if(ord.orderType == 1){
            lockToken = ord.stockPrice * ord.stockAmount;
        }
        uint64_t currentBalance =  portfolioBalance.get()[_portfolioName];
        
        
        
        

        DipcAssert(currentBalance + lockToken >= currentBalance);
        DipcAssert(ownerTotalToken.get() - lockToken <= ownerTotalToken.get());

        
        (*portfolioBalance)[_portfolioName] = currentBalance + lockToken;
        *ownerTotalToken = ownerTotalToken.get() - lockToken;
        (*portfolioStorge)[_portfolioName] = &info.toJson()[0];
        DIPC_EMIT_EVENT(revocationPortfolio, "orderId", _orderId, "orderInfo", &ord.toJson()[0]);
    }
    
    EXPORT void PortfolioManage::withdrawPortfolio(char* _portfolioName, uint64_t _withdrawBalance){
         u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
if(!userCanWithdraw.get()){
             return;
         }
         uint64_t currentBalance =  portfolioBalance.get()[_portfolioName];
         DipcAssert(currentBalance - _withdrawBalance < currentBalance);
         auto coinBalance = changeUint64ToU256WithChangeRate(currentBalance, changeRate.get());
         (*portfolioBalance)[_portfolioName] = currentBalance - _withdrawBalance;
         callTransfer(caller(), coinBalance);
    }
    
    EXPORT void PortfolioManage::withdrawPool(uint64_t _balance){
        u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
isOwner();
        Address ownerAddr = Address(owner.get()); 
        callTransfer(ownerAddr, _balance);
        *ownerTotalToken = ownerTotalToken.get() - _balance * changeRate.get();
        *totalToken = totalToken.get() - _balance * changeRate.get();
        DIPC_EMIT_EVENT(tokenCount, "ownerTotalToken", ownerTotalToken.get(), "totalToken", totalToken.get());
    }
    
    PAYABLE void PortfolioManage::depositPool(uint64_t _depositValue){
        isOwner();
        
        uint64_t tokenBalance = changeU256ToUint64WithChangeRate(callValue(), changeRate.get()); 
        *ownerTotalToken = ownerTotalToken.get() + tokenBalance;
        *totalToken = totalToken.get() + tokenBalance;
        DIPC_EMIT_EVENT(tokenCount, "ownerTotalToken", ownerTotalToken.get(), "totalToken", totalToken.get());
    }
     
    CONSTANT uint64_t PortfolioManage::queryTotalToken(){
        return totalToken.get();
    }

     
    CONSTANT uint64_t PortfolioManage::queryPortfolioBalance(char* _portfolioName){
        return portfolioBalance.get()[_portfolioName];
    }

    
    CONSTANT bool PortfolioManage::queryPortfolioNameIfUsed(char* _portfolioName){
        if(portfolioStorge.get()[_portfolioName] != ""){
            return true;
        } 
        return false;
    }

    
    CONSTANT uint64_t PortfolioManage::queryChangeRate(){
        return changeRate.get();
    }

2019-12-19_15:14:54.808365: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:451] log out out  Export :
     
    CONSTANT uint64_t PortfolioManage::queryTotalToken(){
        

2019-12-19_15:14:54.808386: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:457] name : queryTotalToken   pos1  0

2019-12-19_15:14:54.808400: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:469] pos2  8799   pos1  8799

2019-12-19_15:14:54.808408: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:500] pos2 after 8902   pos1  8799

2019-12-19_15:14:54.808416: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:509] finalContract  first #include "PortfolioManage.hpp"

    
    PAYABLE void PortfolioManage::init(){
        *owner = caller().toString();
        *changeRate = 10000;
        *userCanWithdraw = false;
        uint64_t tokenBalance = getTotalBalance();
        
        *ownerTotalToken = tokenBalance;
        *totalToken = ownerTotalToken.get();
        
        
        DIPC_EMIT_EVENT(initEvent, "ownerTotalToken" ,tokenBalance);
    }
    
     
    EXPORT void PortfolioManage::setChangeRate(uint64_t _changeRate){
        u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
isOwner();
        *changeRate = _changeRate;
    }
     
    EXPORT void PortfolioManage::setUserCanWithdraw(bool _canWithdraw){
        u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
isOwner();
        *userCanWithdraw = _canWithdraw;
    }

    
    PAYABLE void PortfolioManage::createPortfolio(char* _portfolioName, char* _portfolioDesc){
        if(portfolioStorge.get()[_portfolioName] != ""){
            DIPC_EMIT_EVENT(ErrEvent, "Current portfolio exist: ", _portfolioName);
            return;
        } 
        std::string callerAddr = caller().toString();
        uint64_t tokenBalance = getTotalBalance();
        
        PortfolioInfo info(_portfolioName, _portfolioDesc, &callerAddr[0]);
        std::string portfolioStr = info.toJson();
        
        
        

        (*portfolioStorge)[_portfolioName] = portfolioStr;
        DipcAssert(totalToken.get() + tokenBalance > totalToken);
        (*portfolioBalance)[_portfolioName] = tokenBalance;
        *totalToken = totalToken.get() + tokenBalance; 
        
        DIPC_EMIT_EVENT(portfolioInfo, _portfolioName, &portfolioStr[0], "portfolioBalance", tokenBalance);
    }

    
    PAYABLE void PortfolioManage::depositPortfolio(char* _portfolioName){
        uint64_t tokenBalance = getTotalBalance();
        
        uint64_t currentBalance = portfolioBalance.get()[_portfolioName];
        uint64_t finalBalance  = currentBalance + tokenBalance;
        DipcAssert(totalToken.get() + tokenBalance > totalToken);
        DipcAssert(finalBalance > currentBalance);
        (*portfolioBalance)[_portfolioName] = finalBalance;
        *totalToken = totalToken.get() + finalBalance; 
        DIPC_EMIT_EVENT(depositPortfolio, "portfolioName", _portfolioName, "portfolioBalance", finalBalance);
    }
    
    PAYABLE void PortfolioManage::createOrder(char* _portfolioName, char* _orderId, uint16_t _orderType, char* _stockCode, uint64_t _stockPrice, uint64_t _stockAmount, uint64_t _endTime){
        uint64_t tokenBalance = getTotalBalance();
        DIPC_EMIT_EVENT(createOrder, "portfolioName", _portfolioName, "OrderInfo", "ignore", "tokenBalance", tokenBalance);
        uint64_t spent = 0;
        if(_orderType == 1){
            spent = _stockPrice * _stockAmount;
            DipcAssert((portfolioBalance.get()[_portfolioName] + tokenBalance) > spent);
        }
        struct Order order{_orderId, _orderType, _stockCode, _stockPrice, _stockAmount, _endTime, 0};
        std::string pInfo = portfolioStorge.get()[_portfolioName];
        
        
        
        if(pInfo == "") {
            DIPC_EMIT_EVENT(ErrEvent, "Current portfolio  doesn't exist: ", _portfolioName);
            return;
        }
        PortfolioInfo info;
        info.parseJson(pInfo);
        if(info.getOrder(_orderId).orderId != ""){
            DIPC_EMIT_EVENT(ErrEvent, "Current order exist: ", _orderId);
            return;
        }
        info.addOrder(order);
        pInfo = info.toJson();

        uint64_t currentBalance = portfolioBalance.get()[_portfolioName] ;
        uint64_t finalBalance = currentBalance + tokenBalance - spent;
        DipcAssert(totalToken.get() + tokenBalance > totalToken);
        
        DipcAssert(ownerTotalToken.get() < ownerTotalToken.get() + spent);
        (*portfolioStorge)[_portfolioName] = &pInfo[0];
        
        
        
        


        (*portfolioBalance)[_portfolioName] = finalBalance;
        *totalToken = totalToken.get() + finalBalance; 
        *ownerTotalToken = ownerTotalToken.get() + spent;
        DIPC_EMIT_EVENT(createOrder, "portfolioName", _portfolioName, "OrderInfo", &order.toJson()[0], "portfolioBalance", finalBalance);
    }

    
    EXPORT void PortfolioManage::dealOrder(char* _portfolioName, char* _orderId){
        u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
isOwner();
        std::string pInfo = portfolioStorge.get()[_portfolioName];
        
        
        PortfolioInfo info;
        info.parseJson(pInfo);
        

        
         Order ord = info.getOrder(_orderId);
         
         
        if(ord.orderId != "" && ord.orderStatus == 0){
            
            uint64_t timenow = dipc::timestamp();
            if(ord.endTime > timenow){
                ord.orderStatus = 1;
            }else {
                ord.orderStatus = 3;
            }
        } else {
          

            return;
        }
        

        uint64_t sellValue = 0;
        if(ord.orderType == 0){
            sellValue = ord.stockAmount * ord.stockPrice;
        }
        uint64_t currentBalance =  portfolioBalance.get()[_portfolioName];
        

        DipcAssert(currentBalance + sellValue >= currentBalance);
        DipcAssert((ownerTotalToken.get() - sellValue) <= ownerTotalToken.get());
        


        (*portfolioBalance)[_portfolioName] = currentBalance + sellValue;
        *ownerTotalToken = ownerTotalToken.get() - sellValue;
        (*portfolioStorge)[_portfolioName] = &info.toJson()[0];
        
        
        
        

        DIPC_EMIT_EVENT(dealPortfolio, "orderId", _orderId, "orderInfo", &ord.toJson()[0]);
    }
    
    EXPORT void PortfolioManage::revocationOrder(char* _portfolioName, char* _orderId){
        u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
std::string pInfo = portfolioStorge.get()[_portfolioName];
        
        
        PortfolioInfo info;
        info.parseJson(pInfo);
        Order ord = info.getOrder(_orderId);
        
        
        if(ord.orderId != "" && ord.orderStatus == 0){
            std::string callerStr = caller().toString();
            
            
            
            DipcAssert(info.getOwnerAddress() == caller().toString());
            

            uint64_t timenow = dipc::timestamp();
            if(ord.endTime > timenow){
                ord.orderStatus = 2;
            }else {
                ord.orderStatus = 3;
            }
        } else {
            return;
        }
        uint64_t lockToken = 0;
        if(ord.orderType == 1){
            lockToken = ord.stockPrice * ord.stockAmount;
        }
        uint64_t currentBalance =  portfolioBalance.get()[_portfolioName];
        
        
        
        

        DipcAssert(currentBalance + lockToken >= currentBalance);
        DipcAssert(ownerTotalToken.get() - lockToken <= ownerTotalToken.get());

        
        (*portfolioBalance)[_portfolioName] = currentBalance + lockToken;
        *ownerTotalToken = ownerTotalToken.get() - lockToken;
        (*portfolioStorge)[_portfolioName] = &info.toJson()[0];
        DIPC_EMIT_EVENT(revocationPortfolio, "orderId", _orderId, "orderInfo", &ord.toJson()[0]);
    }
    
    EXPORT void PortfolioManage::withdrawPortfolio(char* _portfolioName, uint64_t _withdrawBalance){
         u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
if(!userCanWithdraw.get()){
             return;
         }
         uint64_t currentBalance =  portfolioBalance.get()[_portfolioName];
         DipcAssert(currentBalance - _withdrawBalance < currentBalance);
         auto coinBalance = changeUint64ToU256WithChangeRate(currentBalance, changeRate.get());
         (*portfolioBalance)[_portfolioName] = currentBalance - _withdrawBalance;
         callTransfer(caller(), coinBalance);
    }
    
    EXPORT void PortfolioManage::withdrawPool(uint64_t _balance){
        u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
isOwner();
        Address ownerAddr = Address(owner.get()); 
        callTransfer(ownerAddr, _balance);
        *ownerTotalToken = ownerTotalToken.get() - _balance * changeRate.get();
        *totalToken = totalToken.get() - _balance * changeRate.get();
        DIPC_EMIT_EVENT(tokenCount, "ownerTotalToken", ownerTotalToken.get(), "totalToken", totalToken.get());
    }
    
    PAYABLE void PortfolioManage::depositPool(uint64_t _depositValue){
        isOwner();
        
        uint64_t tokenBalance = changeU256ToUint64WithChangeRate(callValue(), changeRate.get()); 
        *ownerTotalToken = ownerTotalToken.get() + tokenBalance;
        *totalToken = totalToken.get() + tokenBalance;
        DIPC_EMIT_EVENT(tokenCount, "ownerTotalToken", ownerTotalToken.get(), "totalToken", totalToken.get());
    }

2019-12-19_15:14:54.808481: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:510] codetext  first #include "PortfolioManage.hpp"

    
    PAYABLE void PortfolioManage::init(){
        *owner = caller().toString();
        *changeRate = 10000;
        *userCanWithdraw = false;
        uint64_t tokenBalance = getTotalBalance();
        
        *ownerTotalToken = tokenBalance;
        *totalToken = ownerTotalToken.get();
        
        
        DIPC_EMIT_EVENT(initEvent, "ownerTotalToken" ,tokenBalance);
    }
    
     
    EXPORT void PortfolioManage::setChangeRate(uint64_t _changeRate){
        u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
isOwner();
        *changeRate = _changeRate;
    }
     
    EXPORT void PortfolioManage::setUserCanWithdraw(bool _canWithdraw){
        u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
isOwner();
        *userCanWithdraw = _canWithdraw;
    }

    
    PAYABLE void PortfolioManage::createPortfolio(char* _portfolioName, char* _portfolioDesc){
        if(portfolioStorge.get()[_portfolioName] != ""){
            DIPC_EMIT_EVENT(ErrEvent, "Current portfolio exist: ", _portfolioName);
            return;
        } 
        std::string callerAddr = caller().toString();
        uint64_t tokenBalance = getTotalBalance();
        
        PortfolioInfo info(_portfolioName, _portfolioDesc, &callerAddr[0]);
        std::string portfolioStr = info.toJson();
        
        
        

        (*portfolioStorge)[_portfolioName] = portfolioStr;
        DipcAssert(totalToken.get() + tokenBalance > totalToken);
        (*portfolioBalance)[_portfolioName] = tokenBalance;
        *totalToken = totalToken.get() + tokenBalance; 
        
        DIPC_EMIT_EVENT(portfolioInfo, _portfolioName, &portfolioStr[0], "portfolioBalance", tokenBalance);
    }

    
    PAYABLE void PortfolioManage::depositPortfolio(char* _portfolioName){
        uint64_t tokenBalance = getTotalBalance();
        
        uint64_t currentBalance = portfolioBalance.get()[_portfolioName];
        uint64_t finalBalance  = currentBalance + tokenBalance;
        DipcAssert(totalToken.get() + tokenBalance > totalToken);
        DipcAssert(finalBalance > currentBalance);
        (*portfolioBalance)[_portfolioName] = finalBalance;
        *totalToken = totalToken.get() + finalBalance; 
        DIPC_EMIT_EVENT(depositPortfolio, "portfolioName", _portfolioName, "portfolioBalance", finalBalance);
    }
    
    PAYABLE void PortfolioManage::createOrder(char* _portfolioName, char* _orderId, uint16_t _orderType, char* _stockCode, uint64_t _stockPrice, uint64_t _stockAmount, uint64_t _endTime){
        uint64_t tokenBalance = getTotalBalance();
        DIPC_EMIT_EVENT(createOrder, "portfolioName", _portfolioName, "OrderInfo", "ignore", "tokenBalance", tokenBalance);
        uint64_t spent = 0;
        if(_orderType == 1){
            spent = _stockPrice * _stockAmount;
            DipcAssert((portfolioBalance.get()[_portfolioName] + tokenBalance) > spent);
        }
        struct Order order{_orderId, _orderType, _stockCode, _stockPrice, _stockAmount, _endTime, 0};
        std::string pInfo = portfolioStorge.get()[_portfolioName];
        
        
        
        if(pInfo == "") {
            DIPC_EMIT_EVENT(ErrEvent, "Current portfolio  doesn't exist: ", _portfolioName);
            return;
        }
        PortfolioInfo info;
        info.parseJson(pInfo);
        if(info.getOrder(_orderId).orderId != ""){
            DIPC_EMIT_EVENT(ErrEvent, "Current order exist: ", _orderId);
            return;
        }
        info.addOrder(order);
        pInfo = info.toJson();

        uint64_t currentBalance = portfolioBalance.get()[_portfolioName] ;
        uint64_t finalBalance = currentBalance + tokenBalance - spent;
        DipcAssert(totalToken.get() + tokenBalance > totalToken);
        
        DipcAssert(ownerTotalToken.get() < ownerTotalToken.get() + spent);
        (*portfolioStorge)[_portfolioName] = &pInfo[0];
        
        
        
        


        (*portfolioBalance)[_portfolioName] = finalBalance;
        *totalToken = totalToken.get() + finalBalance; 
        *ownerTotalToken = ownerTotalToken.get() + spent;
        DIPC_EMIT_EVENT(createOrder, "portfolioName", _portfolioName, "OrderInfo", &order.toJson()[0], "portfolioBalance", finalBalance);
    }

    
    EXPORT void PortfolioManage::dealOrder(char* _portfolioName, char* _orderId){
        u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
isOwner();
        std::string pInfo = portfolioStorge.get()[_portfolioName];
        
        
        PortfolioInfo info;
        info.parseJson(pInfo);
        

        
         Order ord = info.getOrder(_orderId);
         
         
        if(ord.orderId != "" && ord.orderStatus == 0){
            
            uint64_t timenow = dipc::timestamp();
            if(ord.endTime > timenow){
                ord.orderStatus = 1;
            }else {
                ord.orderStatus = 3;
            }
        } else {
          

            return;
        }
        

        uint64_t sellValue = 0;
        if(ord.orderType == 0){
            sellValue = ord.stockAmount * ord.stockPrice;
        }
        uint64_t currentBalance =  portfolioBalance.get()[_portfolioName];
        

        DipcAssert(currentBalance + sellValue >= currentBalance);
        DipcAssert((ownerTotalToken.get() - sellValue) <= ownerTotalToken.get());
        


        (*portfolioBalance)[_portfolioName] = currentBalance + sellValue;
        *ownerTotalToken = ownerTotalToken.get() - sellValue;
        (*portfolioStorge)[_portfolioName] = &info.toJson()[0];
        
        
        
        

        DIPC_EMIT_EVENT(dealPortfolio, "orderId", _orderId, "orderInfo", &ord.toJson()[0]);
    }
    
    EXPORT void PortfolioManage::revocationOrder(char* _portfolioName, char* _orderId){
        u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
std::string pInfo = portfolioStorge.get()[_portfolioName];
        
        
        PortfolioInfo info;
        info.parseJson(pInfo);
        Order ord = info.getOrder(_orderId);
        
        
        if(ord.orderId != "" && ord.orderStatus == 0){
            std::string callerStr = caller().toString();
            
            
            
            DipcAssert(info.getOwnerAddress() == caller().toString());
            

            uint64_t timenow = dipc::timestamp();
            if(ord.endTime > timenow){
                ord.orderStatus = 2;
            }else {
                ord.orderStatus = 3;
            }
        } else {
            return;
        }
        uint64_t lockToken = 0;
        if(ord.orderType == 1){
            lockToken = ord.stockPrice * ord.stockAmount;
        }
        uint64_t currentBalance =  portfolioBalance.get()[_portfolioName];
        
        
        
        

        DipcAssert(currentBalance + lockToken >= currentBalance);
        DipcAssert(ownerTotalToken.get() - lockToken <= ownerTotalToken.get());

        
        (*portfolioBalance)[_portfolioName] = currentBalance + lockToken;
        *ownerTotalToken = ownerTotalToken.get() - lockToken;
        (*portfolioStorge)[_portfolioName] = &info.toJson()[0];
        DIPC_EMIT_EVENT(revocationPortfolio, "orderId", _orderId, "orderInfo", &ord.toJson()[0]);
    }
    
    EXPORT void PortfolioManage::withdrawPortfolio(char* _portfolioName, uint64_t _withdrawBalance){
         u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
if(!userCanWithdraw.get()){
             return;
         }
         uint64_t currentBalance =  portfolioBalance.get()[_portfolioName];
         DipcAssert(currentBalance - _withdrawBalance < currentBalance);
         auto coinBalance = changeUint64ToU256WithChangeRate(currentBalance, changeRate.get());
         (*portfolioBalance)[_portfolioName] = currentBalance - _withdrawBalance;
         callTransfer(caller(), coinBalance);
    }
    
    EXPORT void PortfolioManage::withdrawPool(uint64_t _balance){
        u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
isOwner();
        Address ownerAddr = Address(owner.get()); 
        callTransfer(ownerAddr, _balance);
        *ownerTotalToken = ownerTotalToken.get() - _balance * changeRate.get();
        *totalToken = totalToken.get() - _balance * changeRate.get();
        DIPC_EMIT_EVENT(tokenCount, "ownerTotalToken", ownerTotalToken.get(), "totalToken", totalToken.get());
    }
    
    PAYABLE void PortfolioManage::depositPool(uint64_t _depositValue){
        isOwner();
        
        uint64_t tokenBalance = changeU256ToUint64WithChangeRate(callValue(), changeRate.get()); 
        *ownerTotalToken = ownerTotalToken.get() + tokenBalance;
        *totalToken = totalToken.get() + tokenBalance;
        DIPC_EMIT_EVENT(tokenCount, "ownerTotalToken", ownerTotalToken.get(), "totalToken", totalToken.get());
    }
     
    CONSTANT uint64_t PortfolioManage::queryTotalToken(){
        return totalToken.get();
    }

     
    CONSTANT uint64_t PortfolioManage::queryPortfolioBalance(char* _portfolioName){
        return portfolioBalance.get()[_portfolioName];
    }

    
    CONSTANT bool PortfolioManage::queryPortfolioNameIfUsed(char* _portfolioName){
        if(portfolioStorge.get()[_portfolioName] != ""){
            return true;
        } 
        return false;
    }

    
    CONSTANT uint64_t PortfolioManage::queryChangeRate(){
        return changeRate.get();
    }

2019-12-19_15:14:54.808491: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:513] s  first 
     
    CONSTANT uint64_t PortfolioManage::queryTotalToken(){
        return totalToken.get();
    }

2019-12-19_15:14:54.808499: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:593] calledFunc temp export: 
     
    CONSTANT uint64_t PortfolioManage::queryTotalToken(){
        u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
return totalToken.get();
    }

2019-12-19_15:14:54.808507: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:599] search func : 
     
    CONSTANT uint64_t PortfolioManage::queryTotalToken(){
        u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
return totalToken.get();
    }
2019-12-19_15:14:54.808514: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:424] finalContract  this height  #include "PortfolioManage.hpp"

    
    PAYABLE void PortfolioManage::init(){
        *owner = caller().toString();
        *changeRate = 10000;
        *userCanWithdraw = false;
        uint64_t tokenBalance = getTotalBalance();
        
        *ownerTotalToken = tokenBalance;
        *totalToken = ownerTotalToken.get();
        
        
        DIPC_EMIT_EVENT(initEvent, "ownerTotalToken" ,tokenBalance);
    }
    
     
    EXPORT void PortfolioManage::setChangeRate(uint64_t _changeRate){
        u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
isOwner();
        *changeRate = _changeRate;
    }
     
    EXPORT void PortfolioManage::setUserCanWithdraw(bool _canWithdraw){
        u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
isOwner();
        *userCanWithdraw = _canWithdraw;
    }

    
    PAYABLE void PortfolioManage::createPortfolio(char* _portfolioName, char* _portfolioDesc){
        if(portfolioStorge.get()[_portfolioName] != ""){
            DIPC_EMIT_EVENT(ErrEvent, "Current portfolio exist: ", _portfolioName);
            return;
        } 
        std::string callerAddr = caller().toString();
        uint64_t tokenBalance = getTotalBalance();
        
        PortfolioInfo info(_portfolioName, _portfolioDesc, &callerAddr[0]);
        std::string portfolioStr = info.toJson();
        
        
        

        (*portfolioStorge)[_portfolioName] = portfolioStr;
        DipcAssert(totalToken.get() + tokenBalance > totalToken);
        (*portfolioBalance)[_portfolioName] = tokenBalance;
        *totalToken = totalToken.get() + tokenBalance; 
        
        DIPC_EMIT_EVENT(portfolioInfo, _portfolioName, &portfolioStr[0], "portfolioBalance", tokenBalance);
    }

    
    PAYABLE void PortfolioManage::depositPortfolio(char* _portfolioName){
        uint64_t tokenBalance = getTotalBalance();
        
        uint64_t currentBalance = portfolioBalance.get()[_portfolioName];
        uint64_t finalBalance  = currentBalance + tokenBalance;
        DipcAssert(totalToken.get() + tokenBalance > totalToken);
        DipcAssert(finalBalance > currentBalance);
        (*portfolioBalance)[_portfolioName] = finalBalance;
        *totalToken = totalToken.get() + finalBalance; 
        DIPC_EMIT_EVENT(depositPortfolio, "portfolioName", _portfolioName, "portfolioBalance", finalBalance);
    }
    
    PAYABLE void PortfolioManage::createOrder(char* _portfolioName, char* _orderId, uint16_t _orderType, char* _stockCode, uint64_t _stockPrice, uint64_t _stockAmount, uint64_t _endTime){
        uint64_t tokenBalance = getTotalBalance();
        DIPC_EMIT_EVENT(createOrder, "portfolioName", _portfolioName, "OrderInfo", "ignore", "tokenBalance", tokenBalance);
        uint64_t spent = 0;
        if(_orderType == 1){
            spent = _stockPrice * _stockAmount;
            DipcAssert((portfolioBalance.get()[_portfolioName] + tokenBalance) > spent);
        }
        struct Order order{_orderId, _orderType, _stockCode, _stockPrice, _stockAmount, _endTime, 0};
        std::string pInfo = portfolioStorge.get()[_portfolioName];
        
        
        
        if(pInfo == "") {
            DIPC_EMIT_EVENT(ErrEvent, "Current portfolio  doesn't exist: ", _portfolioName);
            return;
        }
        PortfolioInfo info;
        info.parseJson(pInfo);
        if(info.getOrder(_orderId).orderId != ""){
            DIPC_EMIT_EVENT(ErrEvent, "Current order exist: ", _orderId);
            return;
        }
        info.addOrder(order);
        pInfo = info.toJson();

        uint64_t currentBalance = portfolioBalance.get()[_portfolioName] ;
        uint64_t finalBalance = currentBalance + tokenBalance - spent;
        DipcAssert(totalToken.get() + tokenBalance > totalToken);
        
        DipcAssert(ownerTotalToken.get() < ownerTotalToken.get() + spent);
        (*portfolioStorge)[_portfolioName] = &pInfo[0];
        
        
        
        


        (*portfolioBalance)[_portfolioName] = finalBalance;
        *totalToken = totalToken.get() + finalBalance; 
        *ownerTotalToken = ownerTotalToken.get() + spent;
        DIPC_EMIT_EVENT(createOrder, "portfolioName", _portfolioName, "OrderInfo", &order.toJson()[0], "portfolioBalance", finalBalance);
    }

    
    EXPORT void PortfolioManage::dealOrder(char* _portfolioName, char* _orderId){
        u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
isOwner();
        std::string pInfo = portfolioStorge.get()[_portfolioName];
        
        
        PortfolioInfo info;
        info.parseJson(pInfo);
        

        
         Order ord = info.getOrder(_orderId);
         
         
        if(ord.orderId != "" && ord.orderStatus == 0){
            
            uint64_t timenow = dipc::timestamp();
            if(ord.endTime > timenow){
                ord.orderStatus = 1;
            }else {
                ord.orderStatus = 3;
            }
        } else {
          

            return;
        }
        

        uint64_t sellValue = 0;
        if(ord.orderType == 0){
            sellValue = ord.stockAmount * ord.stockPrice;
        }
        uint64_t currentBalance =  portfolioBalance.get()[_portfolioName];
        

        DipcAssert(currentBalance + sellValue >= currentBalance);
        DipcAssert((ownerTotalToken.get() - sellValue) <= ownerTotalToken.get());
        


        (*portfolioBalance)[_portfolioName] = currentBalance + sellValue;
        *ownerTotalToken = ownerTotalToken.get() - sellValue;
        (*portfolioStorge)[_portfolioName] = &info.toJson()[0];
        
        
        
        

        DIPC_EMIT_EVENT(dealPortfolio, "orderId", _orderId, "orderInfo", &ord.toJson()[0]);
    }
    
    EXPORT void PortfolioManage::revocationOrder(char* _portfolioName, char* _orderId){
        u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
std::string pInfo = portfolioStorge.get()[_portfolioName];
        
        
        PortfolioInfo info;
        info.parseJson(pInfo);
        Order ord = info.getOrder(_orderId);
        
        
        if(ord.orderId != "" && ord.orderStatus == 0){
            std::string callerStr = caller().toString();
            
            
            
            DipcAssert(info.getOwnerAddress() == caller().toString());
            

            uint64_t timenow = dipc::timestamp();
            if(ord.endTime > timenow){
                ord.orderStatus = 2;
            }else {
                ord.orderStatus = 3;
            }
        } else {
            return;
        }
        uint64_t lockToken = 0;
        if(ord.orderType == 1){
            lockToken = ord.stockPrice * ord.stockAmount;
        }
        uint64_t currentBalance =  portfolioBalance.get()[_portfolioName];
        
        
        
        

        DipcAssert(currentBalance + lockToken >= currentBalance);
        DipcAssert(ownerTotalToken.get() - lockToken <= ownerTotalToken.get());

        
        (*portfolioBalance)[_portfolioName] = currentBalance + lockToken;
        *ownerTotalToken = ownerTotalToken.get() - lockToken;
        (*portfolioStorge)[_portfolioName] = &info.toJson()[0];
        DIPC_EMIT_EVENT(revocationPortfolio, "orderId", _orderId, "orderInfo", &ord.toJson()[0]);
    }
    
    EXPORT void PortfolioManage::withdrawPortfolio(char* _portfolioName, uint64_t _withdrawBalance){
         u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
if(!userCanWithdraw.get()){
             return;
         }
         uint64_t currentBalance =  portfolioBalance.get()[_portfolioName];
         DipcAssert(currentBalance - _withdrawBalance < currentBalance);
         auto coinBalance = changeUint64ToU256WithChangeRate(currentBalance, changeRate.get());
         (*portfolioBalance)[_portfolioName] = currentBalance - _withdrawBalance;
         callTransfer(caller(), coinBalance);
    }
    
    EXPORT void PortfolioManage::withdrawPool(uint64_t _balance){
        u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
isOwner();
        Address ownerAddr = Address(owner.get()); 
        callTransfer(ownerAddr, _balance);
        *ownerTotalToken = ownerTotalToken.get() - _balance * changeRate.get();
        *totalToken = totalToken.get() - _balance * changeRate.get();
        DIPC_EMIT_EVENT(tokenCount, "ownerTotalToken", ownerTotalToken.get(), "totalToken", totalToken.get());
    }
    
    PAYABLE void PortfolioManage::depositPool(uint64_t _depositValue){
        isOwner();
        
        uint64_t tokenBalance = changeU256ToUint64WithChangeRate(callValue(), changeRate.get()); 
        *ownerTotalToken = ownerTotalToken.get() + tokenBalance;
        *totalToken = totalToken.get() + tokenBalance;
        DIPC_EMIT_EVENT(tokenCount, "ownerTotalToken", ownerTotalToken.get(), "totalToken", totalToken.get());
    }
     
    CONSTANT uint64_t PortfolioManage::queryTotalToken(){
        u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
return totalToken.get();
    } codetext height #include "PortfolioManage.hpp"

    
    PAYABLE void PortfolioManage::init(){
        *owner = caller().toString();
        *changeRate = 10000;
        *userCanWithdraw = false;
        uint64_t tokenBalance = getTotalBalance();
        
        *ownerTotalToken = tokenBalance;
        *totalToken = ownerTotalToken.get();
        
        
        DIPC_EMIT_EVENT(initEvent, "ownerTotalToken" ,tokenBalance);
    }
    
     
    EXPORT void PortfolioManage::setChangeRate(uint64_t _changeRate){
        u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
isOwner();
        *changeRate = _changeRate;
    }
     
    EXPORT void PortfolioManage::setUserCanWithdraw(bool _canWithdraw){
        u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
isOwner();
        *userCanWithdraw = _canWithdraw;
    }

    
    PAYABLE void PortfolioManage::createPortfolio(char* _portfolioName, char* _portfolioDesc){
        if(portfolioStorge.get()[_portfolioName] != ""){
            DIPC_EMIT_EVENT(ErrEvent, "Current portfolio exist: ", _portfolioName);
            return;
        } 
        std::string callerAddr = caller().toString();
        uint64_t tokenBalance = getTotalBalance();
        
        PortfolioInfo info(_portfolioName, _portfolioDesc, &callerAddr[0]);
        std::string portfolioStr = info.toJson();
        
        
        

        (*portfolioStorge)[_portfolioName] = portfolioStr;
        DipcAssert(totalToken.get() + tokenBalance > totalToken);
        (*portfolioBalance)[_portfolioName] = tokenBalance;
        *totalToken = totalToken.get() + tokenBalance; 
        
        DIPC_EMIT_EVENT(portfolioInfo, _portfolioName, &portfolioStr[0], "portfolioBalance", tokenBalance);
    }

    
    PAYABLE void PortfolioManage::depositPortfolio(char* _portfolioName){
        uint64_t tokenBalance = getTotalBalance();
        
        uint64_t currentBalance = portfolioBalance.get()[_portfolioName];
        uint64_t finalBalance  = currentBalance + tokenBalance;
        DipcAssert(totalToken.get() + tokenBalance > totalToken);
        DipcAssert(finalBalance > currentBalance);
        (*portfolioBalance)[_portfolioName] = finalBalance;
        *totalToken = totalToken.get() + finalBalance; 
        DIPC_EMIT_EVENT(depositPortfolio, "portfolioName", _portfolioName, "portfolioBalance", finalBalance);
    }
    
    PAYABLE void PortfolioManage::createOrder(char* _portfolioName, char* _orderId, uint16_t _orderType, char* _stockCode, uint64_t _stockPrice, uint64_t _stockAmount, uint64_t _endTime){
        uint64_t tokenBalance = getTotalBalance();
        DIPC_EMIT_EVENT(createOrder, "portfolioName", _portfolioName, "OrderInfo", "ignore", "tokenBalance", tokenBalance);
        uint64_t spent = 0;
        if(_orderType == 1){
            spent = _stockPrice * _stockAmount;
            DipcAssert((portfolioBalance.get()[_portfolioName] + tokenBalance) > spent);
        }
        struct Order order{_orderId, _orderType, _stockCode, _stockPrice, _stockAmount, _endTime, 0};
        std::string pInfo = portfolioStorge.get()[_portfolioName];
        
        
        
        if(pInfo == "") {
            DIPC_EMIT_EVENT(ErrEvent, "Current portfolio  doesn't exist: ", _portfolioName);
            return;
        }
        PortfolioInfo info;
        info.parseJson(pInfo);
        if(info.getOrder(_orderId).orderId != ""){
            DIPC_EMIT_EVENT(ErrEvent, "Current order exist: ", _orderId);
            return;
        }
        info.addOrder(order);
        pInfo = info.toJson();

        uint64_t currentBalance = portfolioBalance.get()[_portfolioName] ;
        uint64_t finalBalance = currentBalance + tokenBalance - spent;
        DipcAssert(totalToken.get() + tokenBalance > totalToken);
        
        DipcAssert(ownerTotalToken.get() < ownerTotalToken.get() + spent);
        (*portfolioStorge)[_portfolioName] = &pInfo[0];
        
        
        
        


        (*portfolioBalance)[_portfolioName] = finalBalance;
        *totalToken = totalToken.get() + finalBalance; 
        *ownerTotalToken = ownerTotalToken.get() + spent;
        DIPC_EMIT_EVENT(createOrder, "portfolioName", _portfolioName, "OrderInfo", &order.toJson()[0], "portfolioBalance", finalBalance);
    }

    
    EXPORT void PortfolioManage::dealOrder(char* _portfolioName, char* _orderId){
        u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
isOwner();
        std::string pInfo = portfolioStorge.get()[_portfolioName];
        
        
        PortfolioInfo info;
        info.parseJson(pInfo);
        

        
         Order ord = info.getOrder(_orderId);
         
         
        if(ord.orderId != "" && ord.orderStatus == 0){
            
            uint64_t timenow = dipc::timestamp();
            if(ord.endTime > timenow){
                ord.orderStatus = 1;
            }else {
                ord.orderStatus = 3;
            }
        } else {
          

            return;
        }
        

        uint64_t sellValue = 0;
        if(ord.orderType == 0){
            sellValue = ord.stockAmount * ord.stockPrice;
        }
        uint64_t currentBalance =  portfolioBalance.get()[_portfolioName];
        

        DipcAssert(currentBalance + sellValue >= currentBalance);
        DipcAssert((ownerTotalToken.get() - sellValue) <= ownerTotalToken.get());
        


        (*portfolioBalance)[_portfolioName] = currentBalance + sellValue;
        *ownerTotalToken = ownerTotalToken.get() - sellValue;
        (*portfolioStorge)[_portfolioName] = &info.toJson()[0];
        
        
        
        

        DIPC_EMIT_EVENT(dealPortfolio, "orderId", _orderId, "orderInfo", &ord.toJson()[0]);
    }
    
    EXPORT void PortfolioManage::revocationOrder(char* _portfolioName, char* _orderId){
        u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
std::string pInfo = portfolioStorge.get()[_portfolioName];
        
        
        PortfolioInfo info;
        info.parseJson(pInfo);
        Order ord = info.getOrder(_orderId);
        
        
        if(ord.orderId != "" && ord.orderStatus == 0){
            std::string callerStr = caller().toString();
            
            
            
            DipcAssert(info.getOwnerAddress() == caller().toString());
            

            uint64_t timenow = dipc::timestamp();
            if(ord.endTime > timenow){
                ord.orderStatus = 2;
            }else {
                ord.orderStatus = 3;
            }
        } else {
            return;
        }
        uint64_t lockToken = 0;
        if(ord.orderType == 1){
            lockToken = ord.stockPrice * ord.stockAmount;
        }
        uint64_t currentBalance =  portfolioBalance.get()[_portfolioName];
        
        
        
        

        DipcAssert(currentBalance + lockToken >= currentBalance);
        DipcAssert(ownerTotalToken.get() - lockToken <= ownerTotalToken.get());

        
        (*portfolioBalance)[_portfolioName] = currentBalance + lockToken;
        *ownerTotalToken = ownerTotalToken.get() - lockToken;
        (*portfolioStorge)[_portfolioName] = &info.toJson()[0];
        DIPC_EMIT_EVENT(revocationPortfolio, "orderId", _orderId, "orderInfo", &ord.toJson()[0]);
    }
    
    EXPORT void PortfolioManage::withdrawPortfolio(char* _portfolioName, uint64_t _withdrawBalance){
         u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
if(!userCanWithdraw.get()){
             return;
         }
         uint64_t currentBalance =  portfolioBalance.get()[_portfolioName];
         DipcAssert(currentBalance - _withdrawBalance < currentBalance);
         auto coinBalance = changeUint64ToU256WithChangeRate(currentBalance, changeRate.get());
         (*portfolioBalance)[_portfolioName] = currentBalance - _withdrawBalance;
         callTransfer(caller(), coinBalance);
    }
    
    EXPORT void PortfolioManage::withdrawPool(uint64_t _balance){
        u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
isOwner();
        Address ownerAddr = Address(owner.get()); 
        callTransfer(ownerAddr, _balance);
        *ownerTotalToken = ownerTotalToken.get() - _balance * changeRate.get();
        *totalToken = totalToken.get() - _balance * changeRate.get();
        DIPC_EMIT_EVENT(tokenCount, "ownerTotalToken", ownerTotalToken.get(), "totalToken", totalToken.get());
    }
    
    PAYABLE void PortfolioManage::depositPool(uint64_t _depositValue){
        isOwner();
        
        uint64_t tokenBalance = changeU256ToUint64WithChangeRate(callValue(), changeRate.get()); 
        *ownerTotalToken = ownerTotalToken.get() + tokenBalance;
        *totalToken = totalToken.get() + tokenBalance;
        DIPC_EMIT_EVENT(tokenCount, "ownerTotalToken", ownerTotalToken.get(), "totalToken", totalToken.get());
    }
     
    CONSTANT uint64_t PortfolioManage::queryTotalToken(){
        return totalToken.get();
    }

     
    CONSTANT uint64_t PortfolioManage::queryPortfolioBalance(char* _portfolioName){
        return portfolioBalance.get()[_portfolioName];
    }

    
    CONSTANT bool PortfolioManage::queryPortfolioNameIfUsed(char* _portfolioName){
        if(portfolioStorge.get()[_portfolioName] != ""){
            return true;
        } 
        return false;
    }

    
    CONSTANT uint64_t PortfolioManage::queryChangeRate(){
        return changeRate.get();
    }

2019-12-19_15:14:54.808539: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:427] searchContext  

     
    CONSTANT uint64_t PortfolioManage::queryPortfolioBalance(char* _portfolioName){
        return portfolioBalance.get()[_portfolioName];
    }

    
    CONSTANT bool PortfolioManage::queryPortfolioNameIfUsed(char* _portfolioName){
        if(portfolioStorge.get()[_portfolioName] != ""){
            return true;
        } 
        return false;
    }

    
    CONSTANT uint64_t PortfolioManage::queryChangeRate(){
        return changeRate.get();
    }

2019-12-19_15:14:54.816705: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:442] finalContract  this new  #include "PortfolioManage.hpp"

    
    PAYABLE void PortfolioManage::init(){
        *owner = caller().toString();
        *changeRate = 10000;
        *userCanWithdraw = false;
        uint64_t tokenBalance = getTotalBalance();
        
        *ownerTotalToken = tokenBalance;
        *totalToken = ownerTotalToken.get();
        
        
        DIPC_EMIT_EVENT(initEvent, "ownerTotalToken" ,tokenBalance);
    }
    
     
    EXPORT void PortfolioManage::setChangeRate(uint64_t _changeRate){
        u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
isOwner();
        *changeRate = _changeRate;
    }
     
    EXPORT void PortfolioManage::setUserCanWithdraw(bool _canWithdraw){
        u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
isOwner();
        *userCanWithdraw = _canWithdraw;
    }

    
    PAYABLE void PortfolioManage::createPortfolio(char* _portfolioName, char* _portfolioDesc){
        if(portfolioStorge.get()[_portfolioName] != ""){
            DIPC_EMIT_EVENT(ErrEvent, "Current portfolio exist: ", _portfolioName);
            return;
        } 
        std::string callerAddr = caller().toString();
        uint64_t tokenBalance = getTotalBalance();
        
        PortfolioInfo info(_portfolioName, _portfolioDesc, &callerAddr[0]);
        std::string portfolioStr = info.toJson();
        
        
        

        (*portfolioStorge)[_portfolioName] = portfolioStr;
        DipcAssert(totalToken.get() + tokenBalance > totalToken);
        (*portfolioBalance)[_portfolioName] = tokenBalance;
        *totalToken = totalToken.get() + tokenBalance; 
        
        DIPC_EMIT_EVENT(portfolioInfo, _portfolioName, &portfolioStr[0], "portfolioBalance", tokenBalance);
    }

    
    PAYABLE void PortfolioManage::depositPortfolio(char* _portfolioName){
        uint64_t tokenBalance = getTotalBalance();
        
        uint64_t currentBalance = portfolioBalance.get()[_portfolioName];
        uint64_t finalBalance  = currentBalance + tokenBalance;
        DipcAssert(totalToken.get() + tokenBalance > totalToken);
        DipcAssert(finalBalance > currentBalance);
        (*portfolioBalance)[_portfolioName] = finalBalance;
        *totalToken = totalToken.get() + finalBalance; 
        DIPC_EMIT_EVENT(depositPortfolio, "portfolioName", _portfolioName, "portfolioBalance", finalBalance);
    }
    
    PAYABLE void PortfolioManage::createOrder(char* _portfolioName, char* _orderId, uint16_t _orderType, char* _stockCode, uint64_t _stockPrice, uint64_t _stockAmount, uint64_t _endTime){
        uint64_t tokenBalance = getTotalBalance();
        DIPC_EMIT_EVENT(createOrder, "portfolioName", _portfolioName, "OrderInfo", "ignore", "tokenBalance", tokenBalance);
        uint64_t spent = 0;
        if(_orderType == 1){
            spent = _stockPrice * _stockAmount;
            DipcAssert((portfolioBalance.get()[_portfolioName] + tokenBalance) > spent);
        }
        struct Order order{_orderId, _orderType, _stockCode, _stockPrice, _stockAmount, _endTime, 0};
        std::string pInfo = portfolioStorge.get()[_portfolioName];
        
        
        
        if(pInfo == "") {
            DIPC_EMIT_EVENT(ErrEvent, "Current portfolio  doesn't exist: ", _portfolioName);
            return;
        }
        PortfolioInfo info;
        info.parseJson(pInfo);
        if(info.getOrder(_orderId).orderId != ""){
            DIPC_EMIT_EVENT(ErrEvent, "Current order exist: ", _orderId);
            return;
        }
        info.addOrder(order);
        pInfo = info.toJson();

        uint64_t currentBalance = portfolioBalance.get()[_portfolioName] ;
        uint64_t finalBalance = currentBalance + tokenBalance - spent;
        DipcAssert(totalToken.get() + tokenBalance > totalToken);
        
        DipcAssert(ownerTotalToken.get() < ownerTotalToken.get() + spent);
        (*portfolioStorge)[_portfolioName] = &pInfo[0];
        
        
        
        


        (*portfolioBalance)[_portfolioName] = finalBalance;
        *totalToken = totalToken.get() + finalBalance; 
        *ownerTotalToken = ownerTotalToken.get() + spent;
        DIPC_EMIT_EVENT(createOrder, "portfolioName", _portfolioName, "OrderInfo", &order.toJson()[0], "portfolioBalance", finalBalance);
    }

    
    EXPORT void PortfolioManage::dealOrder(char* _portfolioName, char* _orderId){
        u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
isOwner();
        std::string pInfo = portfolioStorge.get()[_portfolioName];
        
        
        PortfolioInfo info;
        info.parseJson(pInfo);
        

        
         Order ord = info.getOrder(_orderId);
         
         
        if(ord.orderId != "" && ord.orderStatus == 0){
            
            uint64_t timenow = dipc::timestamp();
            if(ord.endTime > timenow){
                ord.orderStatus = 1;
            }else {
                ord.orderStatus = 3;
            }
        } else {
          

            return;
        }
        

        uint64_t sellValue = 0;
        if(ord.orderType == 0){
            sellValue = ord.stockAmount * ord.stockPrice;
        }
        uint64_t currentBalance =  portfolioBalance.get()[_portfolioName];
        

        DipcAssert(currentBalance + sellValue >= currentBalance);
        DipcAssert((ownerTotalToken.get() - sellValue) <= ownerTotalToken.get());
        


        (*portfolioBalance)[_portfolioName] = currentBalance + sellValue;
        *ownerTotalToken = ownerTotalToken.get() - sellValue;
        (*portfolioStorge)[_portfolioName] = &info.toJson()[0];
        
        
        
        

        DIPC_EMIT_EVENT(dealPortfolio, "orderId", _orderId, "orderInfo", &ord.toJson()[0]);
    }
    
    EXPORT void PortfolioManage::revocationOrder(char* _portfolioName, char* _orderId){
        u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
std::string pInfo = portfolioStorge.get()[_portfolioName];
        
        
        PortfolioInfo info;
        info.parseJson(pInfo);
        Order ord = info.getOrder(_orderId);
        
        
        if(ord.orderId != "" && ord.orderStatus == 0){
            std::string callerStr = caller().toString();
            
            
            
            DipcAssert(info.getOwnerAddress() == caller().toString());
            

            uint64_t timenow = dipc::timestamp();
            if(ord.endTime > timenow){
                ord.orderStatus = 2;
            }else {
                ord.orderStatus = 3;
            }
        } else {
            return;
        }
        uint64_t lockToken = 0;
        if(ord.orderType == 1){
            lockToken = ord.stockPrice * ord.stockAmount;
        }
        uint64_t currentBalance =  portfolioBalance.get()[_portfolioName];
        
        
        
        

        DipcAssert(currentBalance + lockToken >= currentBalance);
        DipcAssert(ownerTotalToken.get() - lockToken <= ownerTotalToken.get());

        
        (*portfolioBalance)[_portfolioName] = currentBalance + lockToken;
        *ownerTotalToken = ownerTotalToken.get() - lockToken;
        (*portfolioStorge)[_portfolioName] = &info.toJson()[0];
        DIPC_EMIT_EVENT(revocationPortfolio, "orderId", _orderId, "orderInfo", &ord.toJson()[0]);
    }
    
    EXPORT void PortfolioManage::withdrawPortfolio(char* _portfolioName, uint64_t _withdrawBalance){
         u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
if(!userCanWithdraw.get()){
             return;
         }
         uint64_t currentBalance =  portfolioBalance.get()[_portfolioName];
         DipcAssert(currentBalance - _withdrawBalance < currentBalance);
         auto coinBalance = changeUint64ToU256WithChangeRate(currentBalance, changeRate.get());
         (*portfolioBalance)[_portfolioName] = currentBalance - _withdrawBalance;
         callTransfer(caller(), coinBalance);
    }
    
    EXPORT void PortfolioManage::withdrawPool(uint64_t _balance){
        u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
isOwner();
        Address ownerAddr = Address(owner.get()); 
        callTransfer(ownerAddr, _balance);
        *ownerTotalToken = ownerTotalToken.get() - _balance * changeRate.get();
        *totalToken = totalToken.get() - _balance * changeRate.get();
        DIPC_EMIT_EVENT(tokenCount, "ownerTotalToken", ownerTotalToken.get(), "totalToken", totalToken.get());
    }
    
    PAYABLE void PortfolioManage::depositPool(uint64_t _depositValue){
        isOwner();
        
        uint64_t tokenBalance = changeU256ToUint64WithChangeRate(callValue(), changeRate.get()); 
        *ownerTotalToken = ownerTotalToken.get() + tokenBalance;
        *totalToken = totalToken.get() + tokenBalance;
        DIPC_EMIT_EVENT(tokenCount, "ownerTotalToken", ownerTotalToken.get(), "totalToken", totalToken.get());
    }
     
    CONSTANT uint64_t PortfolioManage::queryTotalToken(){
        u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
return totalToken.get();
    } codetext new #include "PortfolioManage.hpp"

    
    PAYABLE void PortfolioManage::init(){
        *owner = caller().toString();
        *changeRate = 10000;
        *userCanWithdraw = false;
        uint64_t tokenBalance = getTotalBalance();
        
        *ownerTotalToken = tokenBalance;
        *totalToken = ownerTotalToken.get();
        
        
        DIPC_EMIT_EVENT(initEvent, "ownerTotalToken" ,tokenBalance);
    }
    
     
    EXPORT void PortfolioManage::setChangeRate(uint64_t _changeRate){
        u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
isOwner();
        *changeRate = _changeRate;
    }
     
    EXPORT void PortfolioManage::setUserCanWithdraw(bool _canWithdraw){
        u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
isOwner();
        *userCanWithdraw = _canWithdraw;
    }

    
    PAYABLE void PortfolioManage::createPortfolio(char* _portfolioName, char* _portfolioDesc){
        if(portfolioStorge.get()[_portfolioName] != ""){
            DIPC_EMIT_EVENT(ErrEvent, "Current portfolio exist: ", _portfolioName);
            return;
        } 
        std::string callerAddr = caller().toString();
        uint64_t tokenBalance = getTotalBalance();
        
        PortfolioInfo info(_portfolioName, _portfolioDesc, &callerAddr[0]);
        std::string portfolioStr = info.toJson();
        
        
        

        (*portfolioStorge)[_portfolioName] = portfolioStr;
        DipcAssert(totalToken.get() + tokenBalance > totalToken);
        (*portfolioBalance)[_portfolioName] = tokenBalance;
        *totalToken = totalToken.get() + tokenBalance; 
        
        DIPC_EMIT_EVENT(portfolioInfo, _portfolioName, &portfolioStr[0], "portfolioBalance", tokenBalance);
    }

    
    PAYABLE void PortfolioManage::depositPortfolio(char* _portfolioName){
        uint64_t tokenBalance = getTotalBalance();
        
        uint64_t currentBalance = portfolioBalance.get()[_portfolioName];
        uint64_t finalBalance  = currentBalance + tokenBalance;
        DipcAssert(totalToken.get() + tokenBalance > totalToken);
        DipcAssert(finalBalance > currentBalance);
        (*portfolioBalance)[_portfolioName] = finalBalance;
        *totalToken = totalToken.get() + finalBalance; 
        DIPC_EMIT_EVENT(depositPortfolio, "portfolioName", _portfolioName, "portfolioBalance", finalBalance);
    }
    
    PAYABLE void PortfolioManage::createOrder(char* _portfolioName, char* _orderId, uint16_t _orderType, char* _stockCode, uint64_t _stockPrice, uint64_t _stockAmount, uint64_t _endTime){
        uint64_t tokenBalance = getTotalBalance();
        DIPC_EMIT_EVENT(createOrder, "portfolioName", _portfolioName, "OrderInfo", "ignore", "tokenBalance", tokenBalance);
        uint64_t spent = 0;
        if(_orderType == 1){
            spent = _stockPrice * _stockAmount;
            DipcAssert((portfolioBalance.get()[_portfolioName] + tokenBalance) > spent);
        }
        struct Order order{_orderId, _orderType, _stockCode, _stockPrice, _stockAmount, _endTime, 0};
        std::string pInfo = portfolioStorge.get()[_portfolioName];
        
        
        
        if(pInfo == "") {
            DIPC_EMIT_EVENT(ErrEvent, "Current portfolio  doesn't exist: ", _portfolioName);
            return;
        }
        PortfolioInfo info;
        info.parseJson(pInfo);
        if(info.getOrder(_orderId).orderId != ""){
            DIPC_EMIT_EVENT(ErrEvent, "Current order exist: ", _orderId);
            return;
        }
        info.addOrder(order);
        pInfo = info.toJson();

        uint64_t currentBalance = portfolioBalance.get()[_portfolioName] ;
        uint64_t finalBalance = currentBalance + tokenBalance - spent;
        DipcAssert(totalToken.get() + tokenBalance > totalToken);
        
        DipcAssert(ownerTotalToken.get() < ownerTotalToken.get() + spent);
        (*portfolioStorge)[_portfolioName] = &pInfo[0];
        
        
        
        


        (*portfolioBalance)[_portfolioName] = finalBalance;
        *totalToken = totalToken.get() + finalBalance; 
        *ownerTotalToken = ownerTotalToken.get() + spent;
        DIPC_EMIT_EVENT(createOrder, "portfolioName", _portfolioName, "OrderInfo", &order.toJson()[0], "portfolioBalance", finalBalance);
    }

    
    EXPORT void PortfolioManage::dealOrder(char* _portfolioName, char* _orderId){
        u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
isOwner();
        std::string pInfo = portfolioStorge.get()[_portfolioName];
        
        
        PortfolioInfo info;
        info.parseJson(pInfo);
        

        
         Order ord = info.getOrder(_orderId);
         
         
        if(ord.orderId != "" && ord.orderStatus == 0){
            
            uint64_t timenow = dipc::timestamp();
            if(ord.endTime > timenow){
                ord.orderStatus = 1;
            }else {
                ord.orderStatus = 3;
            }
        } else {
          

            return;
        }
        

        uint64_t sellValue = 0;
        if(ord.orderType == 0){
            sellValue = ord.stockAmount * ord.stockPrice;
        }
        uint64_t currentBalance =  portfolioBalance.get()[_portfolioName];
        

        DipcAssert(currentBalance + sellValue >= currentBalance);
        DipcAssert((ownerTotalToken.get() - sellValue) <= ownerTotalToken.get());
        


        (*portfolioBalance)[_portfolioName] = currentBalance + sellValue;
        *ownerTotalToken = ownerTotalToken.get() - sellValue;
        (*portfolioStorge)[_portfolioName] = &info.toJson()[0];
        
        
        
        

        DIPC_EMIT_EVENT(dealPortfolio, "orderId", _orderId, "orderInfo", &ord.toJson()[0]);
    }
    
    EXPORT void PortfolioManage::revocationOrder(char* _portfolioName, char* _orderId){
        u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
std::string pInfo = portfolioStorge.get()[_portfolioName];
        
        
        PortfolioInfo info;
        info.parseJson(pInfo);
        Order ord = info.getOrder(_orderId);
        
        
        if(ord.orderId != "" && ord.orderStatus == 0){
            std::string callerStr = caller().toString();
            
            
            
            DipcAssert(info.getOwnerAddress() == caller().toString());
            

            uint64_t timenow = dipc::timestamp();
            if(ord.endTime > timenow){
                ord.orderStatus = 2;
            }else {
                ord.orderStatus = 3;
            }
        } else {
            return;
        }
        uint64_t lockToken = 0;
        if(ord.orderType == 1){
            lockToken = ord.stockPrice * ord.stockAmount;
        }
        uint64_t currentBalance =  portfolioBalance.get()[_portfolioName];
        
        
        
        

        DipcAssert(currentBalance + lockToken >= currentBalance);
        DipcAssert(ownerTotalToken.get() - lockToken <= ownerTotalToken.get());

        
        (*portfolioBalance)[_portfolioName] = currentBalance + lockToken;
        *ownerTotalToken = ownerTotalToken.get() - lockToken;
        (*portfolioStorge)[_portfolioName] = &info.toJson()[0];
        DIPC_EMIT_EVENT(revocationPortfolio, "orderId", _orderId, "orderInfo", &ord.toJson()[0]);
    }
    
    EXPORT void PortfolioManage::withdrawPortfolio(char* _portfolioName, uint64_t _withdrawBalance){
         u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
if(!userCanWithdraw.get()){
             return;
         }
         uint64_t currentBalance =  portfolioBalance.get()[_portfolioName];
         DipcAssert(currentBalance - _withdrawBalance < currentBalance);
         auto coinBalance = changeUint64ToU256WithChangeRate(currentBalance, changeRate.get());
         (*portfolioBalance)[_portfolioName] = currentBalance - _withdrawBalance;
         callTransfer(caller(), coinBalance);
    }
    
    EXPORT void PortfolioManage::withdrawPool(uint64_t _balance){
        u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
isOwner();
        Address ownerAddr = Address(owner.get()); 
        callTransfer(ownerAddr, _balance);
        *ownerTotalToken = ownerTotalToken.get() - _balance * changeRate.get();
        *totalToken = totalToken.get() - _balance * changeRate.get();
        DIPC_EMIT_EVENT(tokenCount, "ownerTotalToken", ownerTotalToken.get(), "totalToken", totalToken.get());
    }
    
    PAYABLE void PortfolioManage::depositPool(uint64_t _depositValue){
        isOwner();
        
        uint64_t tokenBalance = changeU256ToUint64WithChangeRate(callValue(), changeRate.get()); 
        *ownerTotalToken = ownerTotalToken.get() + tokenBalance;
        *totalToken = totalToken.get() + tokenBalance;
        DIPC_EMIT_EVENT(tokenCount, "ownerTotalToken", ownerTotalToken.get(), "totalToken", totalToken.get());
    }
     
    CONSTANT uint64_t PortfolioManage::queryTotalToken(){
        return totalToken.get();
    }

     
    CONSTANT uint64_t PortfolioManage::queryPortfolioBalance(char* _portfolioName){
        return portfolioBalance.get()[_portfolioName];
    }

    
    CONSTANT bool PortfolioManage::queryPortfolioNameIfUsed(char* _portfolioName){
        if(portfolioStorge.get()[_portfolioName] != ""){
            return true;
        } 
        return false;
    }

    
    CONSTANT uint64_t PortfolioManage::queryChangeRate(){
        return changeRate.get();
    }

2019-12-19_15:14:54.816745: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:604] finalContract  final content =======   : #include "PortfolioManage.hpp"

    
    PAYABLE void PortfolioManage::init(){
        *owner = caller().toString();
        *changeRate = 10000;
        *userCanWithdraw = false;
        uint64_t tokenBalance = getTotalBalance();
        
        *ownerTotalToken = tokenBalance;
        *totalToken = ownerTotalToken.get();
        
        
        DIPC_EMIT_EVENT(initEvent, "ownerTotalToken" ,tokenBalance);
    }
    
     
    EXPORT void PortfolioManage::setChangeRate(uint64_t _changeRate){
        u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
isOwner();
        *changeRate = _changeRate;
    }
     
    EXPORT void PortfolioManage::setUserCanWithdraw(bool _canWithdraw){
        u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
isOwner();
        *userCanWithdraw = _canWithdraw;
    }

    
    PAYABLE void PortfolioManage::createPortfolio(char* _portfolioName, char* _portfolioDesc){
        if(portfolioStorge.get()[_portfolioName] != ""){
            DIPC_EMIT_EVENT(ErrEvent, "Current portfolio exist: ", _portfolioName);
            return;
        } 
        std::string callerAddr = caller().toString();
        uint64_t tokenBalance = getTotalBalance();
        
        PortfolioInfo info(_portfolioName, _portfolioDesc, &callerAddr[0]);
        std::string portfolioStr = info.toJson();
        
        
        

        (*portfolioStorge)[_portfolioName] = portfolioStr;
        DipcAssert(totalToken.get() + tokenBalance > totalToken);
        (*portfolioBalance)[_portfolioName] = tokenBalance;
        *totalToken = totalToken.get() + tokenBalance; 
        
        DIPC_EMIT_EVENT(portfolioInfo, _portfolioName, &portfolioStr[0], "portfolioBalance", tokenBalance);
    }

    
    PAYABLE void PortfolioManage::depositPortfolio(char* _portfolioName){
        uint64_t tokenBalance = getTotalBalance();
        
        uint64_t currentBalance = portfolioBalance.get()[_portfolioName];
        uint64_t finalBalance  = currentBalance + tokenBalance;
        DipcAssert(totalToken.get() + tokenBalance > totalToken);
        DipcAssert(finalBalance > currentBalance);
        (*portfolioBalance)[_portfolioName] = finalBalance;
        *totalToken = totalToken.get() + finalBalance; 
        DIPC_EMIT_EVENT(depositPortfolio, "portfolioName", _portfolioName, "portfolioBalance", finalBalance);
    }
    
    PAYABLE void PortfolioManage::createOrder(char* _portfolioName, char* _orderId, uint16_t _orderType, char* _stockCode, uint64_t _stockPrice, uint64_t _stockAmount, uint64_t _endTime){
        uint64_t tokenBalance = getTotalBalance();
        DIPC_EMIT_EVENT(createOrder, "portfolioName", _portfolioName, "OrderInfo", "ignore", "tokenBalance", tokenBalance);
        uint64_t spent = 0;
        if(_orderType == 1){
            spent = _stockPrice * _stockAmount;
            DipcAssert((portfolioBalance.get()[_portfolioName] + tokenBalance) > spent);
        }
        struct Order order{_orderId, _orderType, _stockCode, _stockPrice, _stockAmount, _endTime, 0};
        std::string pInfo = portfolioStorge.get()[_portfolioName];
        
        
        
        if(pInfo == "") {
            DIPC_EMIT_EVENT(ErrEvent, "Current portfolio  doesn't exist: ", _portfolioName);
            return;
        }
        PortfolioInfo info;
        info.parseJson(pInfo);
        if(info.getOrder(_orderId).orderId != ""){
            DIPC_EMIT_EVENT(ErrEvent, "Current order exist: ", _orderId);
            return;
        }
        info.addOrder(order);
        pInfo = info.toJson();

        uint64_t currentBalance = portfolioBalance.get()[_portfolioName] ;
        uint64_t finalBalance = currentBalance + tokenBalance - spent;
        DipcAssert(totalToken.get() + tokenBalance > totalToken);
        
        DipcAssert(ownerTotalToken.get() < ownerTotalToken.get() + spent);
        (*portfolioStorge)[_portfolioName] = &pInfo[0];
        
        
        
        


        (*portfolioBalance)[_portfolioName] = finalBalance;
        *totalToken = totalToken.get() + finalBalance; 
        *ownerTotalToken = ownerTotalToken.get() + spent;
        DIPC_EMIT_EVENT(createOrder, "portfolioName", _portfolioName, "OrderInfo", &order.toJson()[0], "portfolioBalance", finalBalance);
    }

    
    EXPORT void PortfolioManage::dealOrder(char* _portfolioName, char* _orderId){
        u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
isOwner();
        std::string pInfo = portfolioStorge.get()[_portfolioName];
        
        
        PortfolioInfo info;
        info.parseJson(pInfo);
        

        
         Order ord = info.getOrder(_orderId);
         
         
        if(ord.orderId != "" && ord.orderStatus == 0){
            
            uint64_t timenow = dipc::timestamp();
            if(ord.endTime > timenow){
                ord.orderStatus = 1;
            }else {
                ord.orderStatus = 3;
            }
        } else {
          

            return;
        }
        

        uint64_t sellValue = 0;
        if(ord.orderType == 0){
            sellValue = ord.stockAmount * ord.stockPrice;
        }
        uint64_t currentBalance =  portfolioBalance.get()[_portfolioName];
        

        DipcAssert(currentBalance + sellValue >= currentBalance);
        DipcAssert((ownerTotalToken.get() - sellValue) <= ownerTotalToken.get());
        


        (*portfolioBalance)[_portfolioName] = currentBalance + sellValue;
        *ownerTotalToken = ownerTotalToken.get() - sellValue;
        (*portfolioStorge)[_portfolioName] = &info.toJson()[0];
        
        
        
        

        DIPC_EMIT_EVENT(dealPortfolio, "orderId", _orderId, "orderInfo", &ord.toJson()[0]);
    }
    
    EXPORT void PortfolioManage::revocationOrder(char* _portfolioName, char* _orderId){
        u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
std::string pInfo = portfolioStorge.get()[_portfolioName];
        
        
        PortfolioInfo info;
        info.parseJson(pInfo);
        Order ord = info.getOrder(_orderId);
        
        
        if(ord.orderId != "" && ord.orderStatus == 0){
            std::string callerStr = caller().toString();
            
            
            
            DipcAssert(info.getOwnerAddress() == caller().toString());
            

            uint64_t timenow = dipc::timestamp();
            if(ord.endTime > timenow){
                ord.orderStatus = 2;
            }else {
                ord.orderStatus = 3;
            }
        } else {
            return;
        }
        uint64_t lockToken = 0;
        if(ord.orderType == 1){
            lockToken = ord.stockPrice * ord.stockAmount;
        }
        uint64_t currentBalance =  portfolioBalance.get()[_portfolioName];
        
        
        
        

        DipcAssert(currentBalance + lockToken >= currentBalance);
        DipcAssert(ownerTotalToken.get() - lockToken <= ownerTotalToken.get());

        
        (*portfolioBalance)[_portfolioName] = currentBalance + lockToken;
        *ownerTotalToken = ownerTotalToken.get() - lockToken;
        (*portfolioStorge)[_portfolioName] = &info.toJson()[0];
        DIPC_EMIT_EVENT(revocationPortfolio, "orderId", _orderId, "orderInfo", &ord.toJson()[0]);
    }
    
    EXPORT void PortfolioManage::withdrawPortfolio(char* _portfolioName, uint64_t _withdrawBalance){
         u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
if(!userCanWithdraw.get()){
             return;
         }
         uint64_t currentBalance =  portfolioBalance.get()[_portfolioName];
         DipcAssert(currentBalance - _withdrawBalance < currentBalance);
         auto coinBalance = changeUint64ToU256WithChangeRate(currentBalance, changeRate.get());
         (*portfolioBalance)[_portfolioName] = currentBalance - _withdrawBalance;
         callTransfer(caller(), coinBalance);
    }
    
    EXPORT void PortfolioManage::withdrawPool(uint64_t _balance){
        u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
isOwner();
        Address ownerAddr = Address(owner.get()); 
        callTransfer(ownerAddr, _balance);
        *ownerTotalToken = ownerTotalToken.get() - _balance * changeRate.get();
        *totalToken = totalToken.get() - _balance * changeRate.get();
        DIPC_EMIT_EVENT(tokenCount, "ownerTotalToken", ownerTotalToken.get(), "totalToken", totalToken.get());
    }
    
    PAYABLE void PortfolioManage::depositPool(uint64_t _depositValue){
        isOwner();
        
        uint64_t tokenBalance = changeU256ToUint64WithChangeRate(callValue(), changeRate.get()); 
        *ownerTotalToken = ownerTotalToken.get() + tokenBalance;
        *totalToken = totalToken.get() + tokenBalance;
        DIPC_EMIT_EVENT(tokenCount, "ownerTotalToken", ownerTotalToken.get(), "totalToken", totalToken.get());
    }
     
    CONSTANT uint64_t PortfolioManage::queryTotalToken(){
        u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
return totalToken.get();
    }

     
    CONSTANT uint64_t PortfolioManage::queryPortfolioBalance(char* _portfolioName){
        return portfolioBalance.get()[_portfolioName];
    }

    
    CONSTANT bool PortfolioManage::queryPortfolioNameIfUsed(char* _portfolioName){
        if(portfolioStorge.get()[_portfolioName] != ""){
            return true;
        } 
        return false;
    }

    
    CONSTANT uint64_t PortfolioManage::queryChangeRate(){
        return changeRate.get();
    }

2019-12-19_15:14:54.816757: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:401] abis.ispayable :false

2019-12-19_15:14:54.816776: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:424] finalContract  this height  #include "PortfolioManage.hpp"

    
    PAYABLE void PortfolioManage::init(){
        *owner = caller().toString();
        *changeRate = 10000;
        *userCanWithdraw = false;
        uint64_t tokenBalance = getTotalBalance();
        
        *ownerTotalToken = tokenBalance;
        *totalToken = ownerTotalToken.get();
        
        
        DIPC_EMIT_EVENT(initEvent, "ownerTotalToken" ,tokenBalance);
    }
    
     
    EXPORT void PortfolioManage::setChangeRate(uint64_t _changeRate){
        u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
isOwner();
        *changeRate = _changeRate;
    }
     
    EXPORT void PortfolioManage::setUserCanWithdraw(bool _canWithdraw){
        u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
isOwner();
        *userCanWithdraw = _canWithdraw;
    }

    
    PAYABLE void PortfolioManage::createPortfolio(char* _portfolioName, char* _portfolioDesc){
        if(portfolioStorge.get()[_portfolioName] != ""){
            DIPC_EMIT_EVENT(ErrEvent, "Current portfolio exist: ", _portfolioName);
            return;
        } 
        std::string callerAddr = caller().toString();
        uint64_t tokenBalance = getTotalBalance();
        
        PortfolioInfo info(_portfolioName, _portfolioDesc, &callerAddr[0]);
        std::string portfolioStr = info.toJson();
        
        
        

        (*portfolioStorge)[_portfolioName] = portfolioStr;
        DipcAssert(totalToken.get() + tokenBalance > totalToken);
        (*portfolioBalance)[_portfolioName] = tokenBalance;
        *totalToken = totalToken.get() + tokenBalance; 
        
        DIPC_EMIT_EVENT(portfolioInfo, _portfolioName, &portfolioStr[0], "portfolioBalance", tokenBalance);
    }

    
    PAYABLE void PortfolioManage::depositPortfolio(char* _portfolioName){
        uint64_t tokenBalance = getTotalBalance();
        
        uint64_t currentBalance = portfolioBalance.get()[_portfolioName];
        uint64_t finalBalance  = currentBalance + tokenBalance;
        DipcAssert(totalToken.get() + tokenBalance > totalToken);
        DipcAssert(finalBalance > currentBalance);
        (*portfolioBalance)[_portfolioName] = finalBalance;
        *totalToken = totalToken.get() + finalBalance; 
        DIPC_EMIT_EVENT(depositPortfolio, "portfolioName", _portfolioName, "portfolioBalance", finalBalance);
    }
    
    PAYABLE void PortfolioManage::createOrder(char* _portfolioName, char* _orderId, uint16_t _orderType, char* _stockCode, uint64_t _stockPrice, uint64_t _stockAmount, uint64_t _endTime){
        uint64_t tokenBalance = getTotalBalance();
        DIPC_EMIT_EVENT(createOrder, "portfolioName", _portfolioName, "OrderInfo", "ignore", "tokenBalance", tokenBalance);
        uint64_t spent = 0;
        if(_orderType == 1){
            spent = _stockPrice * _stockAmount;
            DipcAssert((portfolioBalance.get()[_portfolioName] + tokenBalance) > spent);
        }
        struct Order order{_orderId, _orderType, _stockCode, _stockPrice, _stockAmount, _endTime, 0};
        std::string pInfo = portfolioStorge.get()[_portfolioName];
        
        
        
        if(pInfo == "") {
            DIPC_EMIT_EVENT(ErrEvent, "Current portfolio  doesn't exist: ", _portfolioName);
            return;
        }
        PortfolioInfo info;
        info.parseJson(pInfo);
        if(info.getOrder(_orderId).orderId != ""){
            DIPC_EMIT_EVENT(ErrEvent, "Current order exist: ", _orderId);
            return;
        }
        info.addOrder(order);
        pInfo = info.toJson();

        uint64_t currentBalance = portfolioBalance.get()[_portfolioName] ;
        uint64_t finalBalance = currentBalance + tokenBalance - spent;
        DipcAssert(totalToken.get() + tokenBalance > totalToken);
        
        DipcAssert(ownerTotalToken.get() < ownerTotalToken.get() + spent);
        (*portfolioStorge)[_portfolioName] = &pInfo[0];
        
        
        
        


        (*portfolioBalance)[_portfolioName] = finalBalance;
        *totalToken = totalToken.get() + finalBalance; 
        *ownerTotalToken = ownerTotalToken.get() + spent;
        DIPC_EMIT_EVENT(createOrder, "portfolioName", _portfolioName, "OrderInfo", &order.toJson()[0], "portfolioBalance", finalBalance);
    }

    
    EXPORT void PortfolioManage::dealOrder(char* _portfolioName, char* _orderId){
        u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
isOwner();
        std::string pInfo = portfolioStorge.get()[_portfolioName];
        
        
        PortfolioInfo info;
        info.parseJson(pInfo);
        

        
         Order ord = info.getOrder(_orderId);
         
         
        if(ord.orderId != "" && ord.orderStatus == 0){
            
            uint64_t timenow = dipc::timestamp();
            if(ord.endTime > timenow){
                ord.orderStatus = 1;
            }else {
                ord.orderStatus = 3;
            }
        } else {
          

            return;
        }
        

        uint64_t sellValue = 0;
        if(ord.orderType == 0){
            sellValue = ord.stockAmount * ord.stockPrice;
        }
        uint64_t currentBalance =  portfolioBalance.get()[_portfolioName];
        

        DipcAssert(currentBalance + sellValue >= currentBalance);
        DipcAssert((ownerTotalToken.get() - sellValue) <= ownerTotalToken.get());
        


        (*portfolioBalance)[_portfolioName] = currentBalance + sellValue;
        *ownerTotalToken = ownerTotalToken.get() - sellValue;
        (*portfolioStorge)[_portfolioName] = &info.toJson()[0];
        
        
        
        

        DIPC_EMIT_EVENT(dealPortfolio, "orderId", _orderId, "orderInfo", &ord.toJson()[0]);
    }
    
    EXPORT void PortfolioManage::revocationOrder(char* _portfolioName, char* _orderId){
        u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
std::string pInfo = portfolioStorge.get()[_portfolioName];
        
        
        PortfolioInfo info;
        info.parseJson(pInfo);
        Order ord = info.getOrder(_orderId);
        
        
        if(ord.orderId != "" && ord.orderStatus == 0){
            std::string callerStr = caller().toString();
            
            
            
            DipcAssert(info.getOwnerAddress() == caller().toString());
            

            uint64_t timenow = dipc::timestamp();
            if(ord.endTime > timenow){
                ord.orderStatus = 2;
            }else {
                ord.orderStatus = 3;
            }
        } else {
            return;
        }
        uint64_t lockToken = 0;
        if(ord.orderType == 1){
            lockToken = ord.stockPrice * ord.stockAmount;
        }
        uint64_t currentBalance =  portfolioBalance.get()[_portfolioName];
        
        
        
        

        DipcAssert(currentBalance + lockToken >= currentBalance);
        DipcAssert(ownerTotalToken.get() - lockToken <= ownerTotalToken.get());

        
        (*portfolioBalance)[_portfolioName] = currentBalance + lockToken;
        *ownerTotalToken = ownerTotalToken.get() - lockToken;
        (*portfolioStorge)[_portfolioName] = &info.toJson()[0];
        DIPC_EMIT_EVENT(revocationPortfolio, "orderId", _orderId, "orderInfo", &ord.toJson()[0]);
    }
    
    EXPORT void PortfolioManage::withdrawPortfolio(char* _portfolioName, uint64_t _withdrawBalance){
         u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
if(!userCanWithdraw.get()){
             return;
         }
         uint64_t currentBalance =  portfolioBalance.get()[_portfolioName];
         DipcAssert(currentBalance - _withdrawBalance < currentBalance);
         auto coinBalance = changeUint64ToU256WithChangeRate(currentBalance, changeRate.get());
         (*portfolioBalance)[_portfolioName] = currentBalance - _withdrawBalance;
         callTransfer(caller(), coinBalance);
    }
    
    EXPORT void PortfolioManage::withdrawPool(uint64_t _balance){
        u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
isOwner();
        Address ownerAddr = Address(owner.get()); 
        callTransfer(ownerAddr, _balance);
        *ownerTotalToken = ownerTotalToken.get() - _balance * changeRate.get();
        *totalToken = totalToken.get() - _balance * changeRate.get();
        DIPC_EMIT_EVENT(tokenCount, "ownerTotalToken", ownerTotalToken.get(), "totalToken", totalToken.get());
    }
    
    PAYABLE void PortfolioManage::depositPool(uint64_t _depositValue){
        isOwner();
        
        uint64_t tokenBalance = changeU256ToUint64WithChangeRate(callValue(), changeRate.get()); 
        *ownerTotalToken = ownerTotalToken.get() + tokenBalance;
        *totalToken = totalToken.get() + tokenBalance;
        DIPC_EMIT_EVENT(tokenCount, "ownerTotalToken", ownerTotalToken.get(), "totalToken", totalToken.get());
    }
     
    CONSTANT uint64_t PortfolioManage::queryTotalToken(){
        u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
return totalToken.get();
    }

     
    CONSTANT uint64_t PortfolioManage::queryPortfolioBalance(char* _portfolioName){
        return portfolioBalance.get()[_portfolioName];
    }

    
    CONSTANT bool PortfolioManage::queryPortfolioNameIfUsed(char* _portfolioName){
        if(portfolioStorge.get()[_portfolioName] != ""){
            return true;
        } 
        return false;
    }

    
    CONSTANT uint64_t PortfolioManage::queryChangeRate(){
        return changeRate.get();
    } codetext height #include "PortfolioManage.hpp"

    
    PAYABLE void PortfolioManage::init(){
        *owner = caller().toString();
        *changeRate = 10000;
        *userCanWithdraw = false;
        uint64_t tokenBalance = getTotalBalance();
        
        *ownerTotalToken = tokenBalance;
        *totalToken = ownerTotalToken.get();
        
        
        DIPC_EMIT_EVENT(initEvent, "ownerTotalToken" ,tokenBalance);
    }
    
     
    EXPORT void PortfolioManage::setChangeRate(uint64_t _changeRate){
        u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
isOwner();
        *changeRate = _changeRate;
    }
     
    EXPORT void PortfolioManage::setUserCanWithdraw(bool _canWithdraw){
        u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
isOwner();
        *userCanWithdraw = _canWithdraw;
    }

    
    PAYABLE void PortfolioManage::createPortfolio(char* _portfolioName, char* _portfolioDesc){
        if(portfolioStorge.get()[_portfolioName] != ""){
            DIPC_EMIT_EVENT(ErrEvent, "Current portfolio exist: ", _portfolioName);
            return;
        } 
        std::string callerAddr = caller().toString();
        uint64_t tokenBalance = getTotalBalance();
        
        PortfolioInfo info(_portfolioName, _portfolioDesc, &callerAddr[0]);
        std::string portfolioStr = info.toJson();
        
        
        

        (*portfolioStorge)[_portfolioName] = portfolioStr;
        DipcAssert(totalToken.get() + tokenBalance > totalToken);
        (*portfolioBalance)[_portfolioName] = tokenBalance;
        *totalToken = totalToken.get() + tokenBalance; 
        
        DIPC_EMIT_EVENT(portfolioInfo, _portfolioName, &portfolioStr[0], "portfolioBalance", tokenBalance);
    }

    
    PAYABLE void PortfolioManage::depositPortfolio(char* _portfolioName){
        uint64_t tokenBalance = getTotalBalance();
        
        uint64_t currentBalance = portfolioBalance.get()[_portfolioName];
        uint64_t finalBalance  = currentBalance + tokenBalance;
        DipcAssert(totalToken.get() + tokenBalance > totalToken);
        DipcAssert(finalBalance > currentBalance);
        (*portfolioBalance)[_portfolioName] = finalBalance;
        *totalToken = totalToken.get() + finalBalance; 
        DIPC_EMIT_EVENT(depositPortfolio, "portfolioName", _portfolioName, "portfolioBalance", finalBalance);
    }
    
    PAYABLE void PortfolioManage::createOrder(char* _portfolioName, char* _orderId, uint16_t _orderType, char* _stockCode, uint64_t _stockPrice, uint64_t _stockAmount, uint64_t _endTime){
        uint64_t tokenBalance = getTotalBalance();
        DIPC_EMIT_EVENT(createOrder, "portfolioName", _portfolioName, "OrderInfo", "ignore", "tokenBalance", tokenBalance);
        uint64_t spent = 0;
        if(_orderType == 1){
            spent = _stockPrice * _stockAmount;
            DipcAssert((portfolioBalance.get()[_portfolioName] + tokenBalance) > spent);
        }
        struct Order order{_orderId, _orderType, _stockCode, _stockPrice, _stockAmount, _endTime, 0};
        std::string pInfo = portfolioStorge.get()[_portfolioName];
        
        
        
        if(pInfo == "") {
            DIPC_EMIT_EVENT(ErrEvent, "Current portfolio  doesn't exist: ", _portfolioName);
            return;
        }
        PortfolioInfo info;
        info.parseJson(pInfo);
        if(info.getOrder(_orderId).orderId != ""){
            DIPC_EMIT_EVENT(ErrEvent, "Current order exist: ", _orderId);
            return;
        }
        info.addOrder(order);
        pInfo = info.toJson();

        uint64_t currentBalance = portfolioBalance.get()[_portfolioName] ;
        uint64_t finalBalance = currentBalance + tokenBalance - spent;
        DipcAssert(totalToken.get() + tokenBalance > totalToken);
        
        DipcAssert(ownerTotalToken.get() < ownerTotalToken.get() + spent);
        (*portfolioStorge)[_portfolioName] = &pInfo[0];
        
        
        
        


        (*portfolioBalance)[_portfolioName] = finalBalance;
        *totalToken = totalToken.get() + finalBalance; 
        *ownerTotalToken = ownerTotalToken.get() + spent;
        DIPC_EMIT_EVENT(createOrder, "portfolioName", _portfolioName, "OrderInfo", &order.toJson()[0], "portfolioBalance", finalBalance);
    }

    
    EXPORT void PortfolioManage::dealOrder(char* _portfolioName, char* _orderId){
        u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
isOwner();
        std::string pInfo = portfolioStorge.get()[_portfolioName];
        
        
        PortfolioInfo info;
        info.parseJson(pInfo);
        

        
         Order ord = info.getOrder(_orderId);
         
         
        if(ord.orderId != "" && ord.orderStatus == 0){
            
            uint64_t timenow = dipc::timestamp();
            if(ord.endTime > timenow){
                ord.orderStatus = 1;
            }else {
                ord.orderStatus = 3;
            }
        } else {
          

            return;
        }
        

        uint64_t sellValue = 0;
        if(ord.orderType == 0){
            sellValue = ord.stockAmount * ord.stockPrice;
        }
        uint64_t currentBalance =  portfolioBalance.get()[_portfolioName];
        

        DipcAssert(currentBalance + sellValue >= currentBalance);
        DipcAssert((ownerTotalToken.get() - sellValue) <= ownerTotalToken.get());
        


        (*portfolioBalance)[_portfolioName] = currentBalance + sellValue;
        *ownerTotalToken = ownerTotalToken.get() - sellValue;
        (*portfolioStorge)[_portfolioName] = &info.toJson()[0];
        
        
        
        

        DIPC_EMIT_EVENT(dealPortfolio, "orderId", _orderId, "orderInfo", &ord.toJson()[0]);
    }
    
    EXPORT void PortfolioManage::revocationOrder(char* _portfolioName, char* _orderId){
        u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
std::string pInfo = portfolioStorge.get()[_portfolioName];
        
        
        PortfolioInfo info;
        info.parseJson(pInfo);
        Order ord = info.getOrder(_orderId);
        
        
        if(ord.orderId != "" && ord.orderStatus == 0){
            std::string callerStr = caller().toString();
            
            
            
            DipcAssert(info.getOwnerAddress() == caller().toString());
            

            uint64_t timenow = dipc::timestamp();
            if(ord.endTime > timenow){
                ord.orderStatus = 2;
            }else {
                ord.orderStatus = 3;
            }
        } else {
            return;
        }
        uint64_t lockToken = 0;
        if(ord.orderType == 1){
            lockToken = ord.stockPrice * ord.stockAmount;
        }
        uint64_t currentBalance =  portfolioBalance.get()[_portfolioName];
        
        
        
        

        DipcAssert(currentBalance + lockToken >= currentBalance);
        DipcAssert(ownerTotalToken.get() - lockToken <= ownerTotalToken.get());

        
        (*portfolioBalance)[_portfolioName] = currentBalance + lockToken;
        *ownerTotalToken = ownerTotalToken.get() - lockToken;
        (*portfolioStorge)[_portfolioName] = &info.toJson()[0];
        DIPC_EMIT_EVENT(revocationPortfolio, "orderId", _orderId, "orderInfo", &ord.toJson()[0]);
    }
    
    EXPORT void PortfolioManage::withdrawPortfolio(char* _portfolioName, uint64_t _withdrawBalance){
         u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
if(!userCanWithdraw.get()){
             return;
         }
         uint64_t currentBalance =  portfolioBalance.get()[_portfolioName];
         DipcAssert(currentBalance - _withdrawBalance < currentBalance);
         auto coinBalance = changeUint64ToU256WithChangeRate(currentBalance, changeRate.get());
         (*portfolioBalance)[_portfolioName] = currentBalance - _withdrawBalance;
         callTransfer(caller(), coinBalance);
    }
    
    EXPORT void PortfolioManage::withdrawPool(uint64_t _balance){
        u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
isOwner();
        Address ownerAddr = Address(owner.get()); 
        callTransfer(ownerAddr, _balance);
        *ownerTotalToken = ownerTotalToken.get() - _balance * changeRate.get();
        *totalToken = totalToken.get() - _balance * changeRate.get();
        DIPC_EMIT_EVENT(tokenCount, "ownerTotalToken", ownerTotalToken.get(), "totalToken", totalToken.get());
    }
    
    PAYABLE void PortfolioManage::depositPool(uint64_t _depositValue){
        isOwner();
        
        uint64_t tokenBalance = changeU256ToUint64WithChangeRate(callValue(), changeRate.get()); 
        *ownerTotalToken = ownerTotalToken.get() + tokenBalance;
        *totalToken = totalToken.get() + tokenBalance;
        DIPC_EMIT_EVENT(tokenCount, "ownerTotalToken", ownerTotalToken.get(), "totalToken", totalToken.get());
    }
     
    CONSTANT uint64_t PortfolioManage::queryTotalToken(){
        u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
return totalToken.get();
    }

     
    CONSTANT uint64_t PortfolioManage::queryPortfolioBalance(char* _portfolioName){
        return portfolioBalance.get()[_portfolioName];
    }

    
    CONSTANT bool PortfolioManage::queryPortfolioNameIfUsed(char* _portfolioName){
        if(portfolioStorge.get()[_portfolioName] != ""){
            return true;
        } 
        return false;
    }

    
    CONSTANT uint64_t PortfolioManage::queryChangeRate(){
        return changeRate.get();
    }

2019-12-19_15:14:54.816829: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:427] searchContext  #include "PortfolioManage.hpp"

    
    PAYABLE void PortfolioManage::init(){
        *owner = caller().toString();
        *changeRate = 10000;
        *userCanWithdraw = false;
        uint64_t tokenBalance = getTotalBalance();
        
        *ownerTotalToken = tokenBalance;
        *totalToken = ownerTotalToken.get();
        
        
        DIPC_EMIT_EVENT(initEvent, "ownerTotalToken" ,tokenBalance);
    }
    
     
    EXPORT void PortfolioManage::setChangeRate(uint64_t _changeRate){
        u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
isOwner();
        *changeRate = _changeRate;
    }
     
    EXPORT void PortfolioManage::setUserCanWithdraw(bool _canWithdraw){
        u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
isOwner();
        *userCanWithdraw = _canWithdraw;
    }

    
    PAYABLE void PortfolioManage::createPortfolio(char* _portfolioName, char* _portfolioDesc){
        if(portfolioStorge.get()[_portfolioName] != ""){
            DIPC_EMIT_EVENT(ErrEvent, "Current portfolio exist: ", _portfolioName);
            return;
        } 
        std::string callerAddr = caller().toString();
        uint64_t tokenBalance = getTotalBalance();
        
        PortfolioInfo info(_portfolioName, _portfolioDesc, &callerAddr[0]);
        std::string portfolioStr = info.toJson();
        
        
        

        (*portfolioStorge)[_portfolioName] = portfolioStr;
        DipcAssert(totalToken.get() + tokenBalance > totalToken);
        (*portfolioBalance)[_portfolioName] = tokenBalance;
        *totalToken = totalToken.get() + tokenBalance; 
        
        DIPC_EMIT_EVENT(portfolioInfo, _portfolioName, &portfolioStr[0], "portfolioBalance", tokenBalance);
    }

    
    PAYABLE void PortfolioManage::depositPortfolio(char* _portfolioName){
        uint64_t tokenBalance = getTotalBalance();
        
        uint64_t currentBalance = portfolioBalance.get()[_portfolioName];
        uint64_t finalBalance  = currentBalance + tokenBalance;
        DipcAssert(totalToken.get() + tokenBalance > totalToken);
        DipcAssert(finalBalance > currentBalance);
        (*portfolioBalance)[_portfolioName] = finalBalance;
        *totalToken = totalToken.get() + finalBalance; 
        DIPC_EMIT_EVENT(depositPortfolio, "portfolioName", _portfolioName, "portfolioBalance", finalBalance);
    }
    
    PAYABLE void PortfolioManage::createOrder(char* _portfolioName, char* _orderId, uint16_t _orderType, char* _stockCode, uint64_t _stockPrice, uint64_t _stockAmount, uint64_t _endTime){
        uint64_t tokenBalance = getTotalBalance();
        DIPC_EMIT_EVENT(createOrder, "portfolioName", _portfolioName, "OrderInfo", "ignore", "tokenBalance", tokenBalance);
        uint64_t spent = 0;
        if(_orderType == 1){
            spent = _stockPrice * _stockAmount;
            DipcAssert((portfolioBalance.get()[_portfolioName] + tokenBalance) > spent);
        }
        struct Order order{_orderId, _orderType, _stockCode, _stockPrice, _stockAmount, _endTime, 0};
        std::string pInfo = portfolioStorge.get()[_portfolioName];
        
        
        
        if(pInfo == "") {
            DIPC_EMIT_EVENT(ErrEvent, "Current portfolio  doesn't exist: ", _portfolioName);
            return;
        }
        PortfolioInfo info;
        info.parseJson(pInfo);
        if(info.getOrder(_orderId).orderId != ""){
            DIPC_EMIT_EVENT(ErrEvent, "Current order exist: ", _orderId);
            return;
        }
        info.addOrder(order);
        pInfo = info.toJson();

        uint64_t currentBalance = portfolioBalance.get()[_portfolioName] ;
        uint64_t finalBalance = currentBalance + tokenBalance - spent;
        DipcAssert(totalToken.get() + tokenBalance > totalToken);
        
        DipcAssert(ownerTotalToken.get() < ownerTotalToken.get() + spent);
        (*portfolioStorge)[_portfolioName] = &pInfo[0];
        
        
        
        


        (*portfolioBalance)[_portfolioName] = finalBalance;
        *totalToken = totalToken.get() + finalBalance; 
        *ownerTotalToken = ownerTotalToken.get() + spent;
        DIPC_EMIT_EVENT(createOrder, "portfolioName", _portfolioName, "OrderInfo", &order.toJson()[0], "portfolioBalance", finalBalance);
    }

    
    EXPORT void PortfolioManage::dealOrder(char* _portfolioName, char* _orderId){
        u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
isOwner();
        std::string pInfo = portfolioStorge.get()[_portfolioName];
        
        
        PortfolioInfo info;
        info.parseJson(pInfo);
        

        
         Order ord = info.getOrder(_orderId);
         
         
        if(ord.orderId != "" && ord.orderStatus == 0){
            
            uint64_t timenow = dipc::timestamp();
            if(ord.endTime > timenow){
                ord.orderStatus = 1;
            }else {
                ord.orderStatus = 3;
            }
        } else {
          

            return;
        }
        

        uint64_t sellValue = 0;
        if(ord.orderType == 0){
            sellValue = ord.stockAmount * ord.stockPrice;
        }
        uint64_t currentBalance =  portfolioBalance.get()[_portfolioName];
        

        DipcAssert(currentBalance + sellValue >= currentBalance);
        DipcAssert((ownerTotalToken.get() - sellValue) <= ownerTotalToken.get());
        


        (*portfolioBalance)[_portfolioName] = currentBalance + sellValue;
        *ownerTotalToken = ownerTotalToken.get() - sellValue;
        (*portfolioStorge)[_portfolioName] = &info.toJson()[0];
        
        
        
        

        DIPC_EMIT_EVENT(dealPortfolio, "orderId", _orderId, "orderInfo", &ord.toJson()[0]);
    }
    
    EXPORT void PortfolioManage::revocationOrder(char* _portfolioName, char* _orderId){
        u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
std::string pInfo = portfolioStorge.get()[_portfolioName];
        
        
        PortfolioInfo info;
        info.parseJson(pInfo);
        Order ord = info.getOrder(_orderId);
        
        
        if(ord.orderId != "" && ord.orderStatus == 0){
            std::string callerStr = caller().toString();
            
            
            
            DipcAssert(info.getOwnerAddress() == caller().toString());
            

            uint64_t timenow = dipc::timestamp();
            if(ord.endTime > timenow){
                ord.orderStatus = 2;
            }else {
                ord.orderStatus = 3;
            }
        } else {
            return;
        }
        uint64_t lockToken = 0;
        if(ord.orderType == 1){
            lockToken = ord.stockPrice * ord.stockAmount;
        }
        uint64_t currentBalance =  portfolioBalance.get()[_portfolioName];
        
        
        
        

        DipcAssert(currentBalance + lockToken >= currentBalance);
        DipcAssert(ownerTotalToken.get() - lockToken <= ownerTotalToken.get());

        
        (*portfolioBalance)[_portfolioName] = currentBalance + lockToken;
        *ownerTotalToken = ownerTotalToken.get() - lockToken;
        (*portfolioStorge)[_portfolioName] = &info.toJson()[0];
        DIPC_EMIT_EVENT(revocationPortfolio, "orderId", _orderId, "orderInfo", &ord.toJson()[0]);
    }
    
    EXPORT void PortfolioManage::withdrawPortfolio(char* _portfolioName, uint64_t _withdrawBalance){
         u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
if(!userCanWithdraw.get()){
             return;
         }
         uint64_t currentBalance =  portfolioBalance.get()[_portfolioName];
         DipcAssert(currentBalance - _withdrawBalance < currentBalance);
         auto coinBalance = changeUint64ToU256WithChangeRate(currentBalance, changeRate.get());
         (*portfolioBalance)[_portfolioName] = currentBalance - _withdrawBalance;
         callTransfer(caller(), coinBalance);
    }
    
    EXPORT void PortfolioManage::withdrawPool(uint64_t _balance){
        u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
isOwner();
        Address ownerAddr = Address(owner.get()); 
        callTransfer(ownerAddr, _balance);
        *ownerTotalToken = ownerTotalToken.get() - _balance * changeRate.get();
        *totalToken = totalToken.get() - _balance * changeRate.get();
        DIPC_EMIT_EVENT(tokenCount, "ownerTotalToken", ownerTotalToken.get(), "totalToken", totalToken.get());
    }
    
    PAYABLE void PortfolioManage::depositPool(uint64_t _depositValue){
        isOwner();
        
        uint64_t tokenBalance = changeU256ToUint64WithChangeRate(callValue(), changeRate.get()); 
        *ownerTotalToken = ownerTotalToken.get() + tokenBalance;
        *totalToken = totalToken.get() + tokenBalance;
        DIPC_EMIT_EVENT(tokenCount, "ownerTotalToken", ownerTotalToken.get(), "totalToken", totalToken.get());
    }
     
    CONSTANT uint64_t PortfolioManage::queryTotalToken(){
        u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
return totalToken.get();
    }

     
    CONSTANT uint64_t PortfolioManage::queryPortfolioBalance(char* _portfolioName){
        return portfolioBalance.get()[_portfolioName];
    }

    
    CONSTANT bool PortfolioManage::queryPortfolioNameIfUsed(char* _portfolioName){
        if(portfolioStorge.get()[_portfolioName] != ""){
            return true;
        } 
        return false;
    }

    
    CONSTANT uint64_t PortfolioManage::queryChangeRate(){
        return changeRate.get();
    }

2019-12-19_15:14:55.039212: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:451] log out out  Export :

     
    CONSTANT uint64_t PortfolioManage::queryPortfolioBalance(char* _portfolioName){
        

2019-12-19_15:14:55.039237: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:457] name : queryPortfolioBalance   pos1  0

2019-12-19_15:14:55.039250: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:469] pos2  8961   pos1  8961

2019-12-19_15:14:55.039257: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:500] pos2 after 9113   pos1  8961

2019-12-19_15:14:55.039265: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:509] finalContract  first #include "PortfolioManage.hpp"

    
    PAYABLE void PortfolioManage::init(){
        *owner = caller().toString();
        *changeRate = 10000;
        *userCanWithdraw = false;
        uint64_t tokenBalance = getTotalBalance();
        
        *ownerTotalToken = tokenBalance;
        *totalToken = ownerTotalToken.get();
        
        
        DIPC_EMIT_EVENT(initEvent, "ownerTotalToken" ,tokenBalance);
    }
    
     
    EXPORT void PortfolioManage::setChangeRate(uint64_t _changeRate){
        u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
isOwner();
        *changeRate = _changeRate;
    }
     
    EXPORT void PortfolioManage::setUserCanWithdraw(bool _canWithdraw){
        u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
isOwner();
        *userCanWithdraw = _canWithdraw;
    }

    
    PAYABLE void PortfolioManage::createPortfolio(char* _portfolioName, char* _portfolioDesc){
        if(portfolioStorge.get()[_portfolioName] != ""){
            DIPC_EMIT_EVENT(ErrEvent, "Current portfolio exist: ", _portfolioName);
            return;
        } 
        std::string callerAddr = caller().toString();
        uint64_t tokenBalance = getTotalBalance();
        
        PortfolioInfo info(_portfolioName, _portfolioDesc, &callerAddr[0]);
        std::string portfolioStr = info.toJson();
        
        
        

        (*portfolioStorge)[_portfolioName] = portfolioStr;
        DipcAssert(totalToken.get() + tokenBalance > totalToken);
        (*portfolioBalance)[_portfolioName] = tokenBalance;
        *totalToken = totalToken.get() + tokenBalance; 
        
        DIPC_EMIT_EVENT(portfolioInfo, _portfolioName, &portfolioStr[0], "portfolioBalance", tokenBalance);
    }

    
    PAYABLE void PortfolioManage::depositPortfolio(char* _portfolioName){
        uint64_t tokenBalance = getTotalBalance();
        
        uint64_t currentBalance = portfolioBalance.get()[_portfolioName];
        uint64_t finalBalance  = currentBalance + tokenBalance;
        DipcAssert(totalToken.get() + tokenBalance > totalToken);
        DipcAssert(finalBalance > currentBalance);
        (*portfolioBalance)[_portfolioName] = finalBalance;
        *totalToken = totalToken.get() + finalBalance; 
        DIPC_EMIT_EVENT(depositPortfolio, "portfolioName", _portfolioName, "portfolioBalance", finalBalance);
    }
    
    PAYABLE void PortfolioManage::createOrder(char* _portfolioName, char* _orderId, uint16_t _orderType, char* _stockCode, uint64_t _stockPrice, uint64_t _stockAmount, uint64_t _endTime){
        uint64_t tokenBalance = getTotalBalance();
        DIPC_EMIT_EVENT(createOrder, "portfolioName", _portfolioName, "OrderInfo", "ignore", "tokenBalance", tokenBalance);
        uint64_t spent = 0;
        if(_orderType == 1){
            spent = _stockPrice * _stockAmount;
            DipcAssert((portfolioBalance.get()[_portfolioName] + tokenBalance) > spent);
        }
        struct Order order{_orderId, _orderType, _stockCode, _stockPrice, _stockAmount, _endTime, 0};
        std::string pInfo = portfolioStorge.get()[_portfolioName];
        
        
        
        if(pInfo == "") {
            DIPC_EMIT_EVENT(ErrEvent, "Current portfolio  doesn't exist: ", _portfolioName);
            return;
        }
        PortfolioInfo info;
        info.parseJson(pInfo);
        if(info.getOrder(_orderId).orderId != ""){
            DIPC_EMIT_EVENT(ErrEvent, "Current order exist: ", _orderId);
            return;
        }
        info.addOrder(order);
        pInfo = info.toJson();

        uint64_t currentBalance = portfolioBalance.get()[_portfolioName] ;
        uint64_t finalBalance = currentBalance + tokenBalance - spent;
        DipcAssert(totalToken.get() + tokenBalance > totalToken);
        
        DipcAssert(ownerTotalToken.get() < ownerTotalToken.get() + spent);
        (*portfolioStorge)[_portfolioName] = &pInfo[0];
        
        
        
        


        (*portfolioBalance)[_portfolioName] = finalBalance;
        *totalToken = totalToken.get() + finalBalance; 
        *ownerTotalToken = ownerTotalToken.get() + spent;
        DIPC_EMIT_EVENT(createOrder, "portfolioName", _portfolioName, "OrderInfo", &order.toJson()[0], "portfolioBalance", finalBalance);
    }

    
    EXPORT void PortfolioManage::dealOrder(char* _portfolioName, char* _orderId){
        u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
isOwner();
        std::string pInfo = portfolioStorge.get()[_portfolioName];
        
        
        PortfolioInfo info;
        info.parseJson(pInfo);
        

        
         Order ord = info.getOrder(_orderId);
         
         
        if(ord.orderId != "" && ord.orderStatus == 0){
            
            uint64_t timenow = dipc::timestamp();
            if(ord.endTime > timenow){
                ord.orderStatus = 1;
            }else {
                ord.orderStatus = 3;
            }
        } else {
          

            return;
        }
        

        uint64_t sellValue = 0;
        if(ord.orderType == 0){
            sellValue = ord.stockAmount * ord.stockPrice;
        }
        uint64_t currentBalance =  portfolioBalance.get()[_portfolioName];
        

        DipcAssert(currentBalance + sellValue >= currentBalance);
        DipcAssert((ownerTotalToken.get() - sellValue) <= ownerTotalToken.get());
        


        (*portfolioBalance)[_portfolioName] = currentBalance + sellValue;
        *ownerTotalToken = ownerTotalToken.get() - sellValue;
        (*portfolioStorge)[_portfolioName] = &info.toJson()[0];
        
        
        
        

        DIPC_EMIT_EVENT(dealPortfolio, "orderId", _orderId, "orderInfo", &ord.toJson()[0]);
    }
    
    EXPORT void PortfolioManage::revocationOrder(char* _portfolioName, char* _orderId){
        u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
std::string pInfo = portfolioStorge.get()[_portfolioName];
        
        
        PortfolioInfo info;
        info.parseJson(pInfo);
        Order ord = info.getOrder(_orderId);
        
        
        if(ord.orderId != "" && ord.orderStatus == 0){
            std::string callerStr = caller().toString();
            
            
            
            DipcAssert(info.getOwnerAddress() == caller().toString());
            

            uint64_t timenow = dipc::timestamp();
            if(ord.endTime > timenow){
                ord.orderStatus = 2;
            }else {
                ord.orderStatus = 3;
            }
        } else {
            return;
        }
        uint64_t lockToken = 0;
        if(ord.orderType == 1){
            lockToken = ord.stockPrice * ord.stockAmount;
        }
        uint64_t currentBalance =  portfolioBalance.get()[_portfolioName];
        
        
        
        

        DipcAssert(currentBalance + lockToken >= currentBalance);
        DipcAssert(ownerTotalToken.get() - lockToken <= ownerTotalToken.get());

        
        (*portfolioBalance)[_portfolioName] = currentBalance + lockToken;
        *ownerTotalToken = ownerTotalToken.get() - lockToken;
        (*portfolioStorge)[_portfolioName] = &info.toJson()[0];
        DIPC_EMIT_EVENT(revocationPortfolio, "orderId", _orderId, "orderInfo", &ord.toJson()[0]);
    }
    
    EXPORT void PortfolioManage::withdrawPortfolio(char* _portfolioName, uint64_t _withdrawBalance){
         u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
if(!userCanWithdraw.get()){
             return;
         }
         uint64_t currentBalance =  portfolioBalance.get()[_portfolioName];
         DipcAssert(currentBalance - _withdrawBalance < currentBalance);
         auto coinBalance = changeUint64ToU256WithChangeRate(currentBalance, changeRate.get());
         (*portfolioBalance)[_portfolioName] = currentBalance - _withdrawBalance;
         callTransfer(caller(), coinBalance);
    }
    
    EXPORT void PortfolioManage::withdrawPool(uint64_t _balance){
        u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
isOwner();
        Address ownerAddr = Address(owner.get()); 
        callTransfer(ownerAddr, _balance);
        *ownerTotalToken = ownerTotalToken.get() - _balance * changeRate.get();
        *totalToken = totalToken.get() - _balance * changeRate.get();
        DIPC_EMIT_EVENT(tokenCount, "ownerTotalToken", ownerTotalToken.get(), "totalToken", totalToken.get());
    }
    
    PAYABLE void PortfolioManage::depositPool(uint64_t _depositValue){
        isOwner();
        
        uint64_t tokenBalance = changeU256ToUint64WithChangeRate(callValue(), changeRate.get()); 
        *ownerTotalToken = ownerTotalToken.get() + tokenBalance;
        *totalToken = totalToken.get() + tokenBalance;
        DIPC_EMIT_EVENT(tokenCount, "ownerTotalToken", ownerTotalToken.get(), "totalToken", totalToken.get());
    }
     
    CONSTANT uint64_t PortfolioManage::queryTotalToken(){
        u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
return totalToken.get();
    }

2019-12-19_15:14:55.039274: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:510] codetext  first #include "PortfolioManage.hpp"

    
    PAYABLE void PortfolioManage::init(){
        *owner = caller().toString();
        *changeRate = 10000;
        *userCanWithdraw = false;
        uint64_t tokenBalance = getTotalBalance();
        
        *ownerTotalToken = tokenBalance;
        *totalToken = ownerTotalToken.get();
        
        
        DIPC_EMIT_EVENT(initEvent, "ownerTotalToken" ,tokenBalance);
    }
    
     
    EXPORT void PortfolioManage::setChangeRate(uint64_t _changeRate){
        u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
isOwner();
        *changeRate = _changeRate;
    }
     
    EXPORT void PortfolioManage::setUserCanWithdraw(bool _canWithdraw){
        u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
isOwner();
        *userCanWithdraw = _canWithdraw;
    }

    
    PAYABLE void PortfolioManage::createPortfolio(char* _portfolioName, char* _portfolioDesc){
        if(portfolioStorge.get()[_portfolioName] != ""){
            DIPC_EMIT_EVENT(ErrEvent, "Current portfolio exist: ", _portfolioName);
            return;
        } 
        std::string callerAddr = caller().toString();
        uint64_t tokenBalance = getTotalBalance();
        
        PortfolioInfo info(_portfolioName, _portfolioDesc, &callerAddr[0]);
        std::string portfolioStr = info.toJson();
        
        
        

        (*portfolioStorge)[_portfolioName] = portfolioStr;
        DipcAssert(totalToken.get() + tokenBalance > totalToken);
        (*portfolioBalance)[_portfolioName] = tokenBalance;
        *totalToken = totalToken.get() + tokenBalance; 
        
        DIPC_EMIT_EVENT(portfolioInfo, _portfolioName, &portfolioStr[0], "portfolioBalance", tokenBalance);
    }

    
    PAYABLE void PortfolioManage::depositPortfolio(char* _portfolioName){
        uint64_t tokenBalance = getTotalBalance();
        
        uint64_t currentBalance = portfolioBalance.get()[_portfolioName];
        uint64_t finalBalance  = currentBalance + tokenBalance;
        DipcAssert(totalToken.get() + tokenBalance > totalToken);
        DipcAssert(finalBalance > currentBalance);
        (*portfolioBalance)[_portfolioName] = finalBalance;
        *totalToken = totalToken.get() + finalBalance; 
        DIPC_EMIT_EVENT(depositPortfolio, "portfolioName", _portfolioName, "portfolioBalance", finalBalance);
    }
    
    PAYABLE void PortfolioManage::createOrder(char* _portfolioName, char* _orderId, uint16_t _orderType, char* _stockCode, uint64_t _stockPrice, uint64_t _stockAmount, uint64_t _endTime){
        uint64_t tokenBalance = getTotalBalance();
        DIPC_EMIT_EVENT(createOrder, "portfolioName", _portfolioName, "OrderInfo", "ignore", "tokenBalance", tokenBalance);
        uint64_t spent = 0;
        if(_orderType == 1){
            spent = _stockPrice * _stockAmount;
            DipcAssert((portfolioBalance.get()[_portfolioName] + tokenBalance) > spent);
        }
        struct Order order{_orderId, _orderType, _stockCode, _stockPrice, _stockAmount, _endTime, 0};
        std::string pInfo = portfolioStorge.get()[_portfolioName];
        
        
        
        if(pInfo == "") {
            DIPC_EMIT_EVENT(ErrEvent, "Current portfolio  doesn't exist: ", _portfolioName);
            return;
        }
        PortfolioInfo info;
        info.parseJson(pInfo);
        if(info.getOrder(_orderId).orderId != ""){
            DIPC_EMIT_EVENT(ErrEvent, "Current order exist: ", _orderId);
            return;
        }
        info.addOrder(order);
        pInfo = info.toJson();

        uint64_t currentBalance = portfolioBalance.get()[_portfolioName] ;
        uint64_t finalBalance = currentBalance + tokenBalance - spent;
        DipcAssert(totalToken.get() + tokenBalance > totalToken);
        
        DipcAssert(ownerTotalToken.get() < ownerTotalToken.get() + spent);
        (*portfolioStorge)[_portfolioName] = &pInfo[0];
        
        
        
        


        (*portfolioBalance)[_portfolioName] = finalBalance;
        *totalToken = totalToken.get() + finalBalance; 
        *ownerTotalToken = ownerTotalToken.get() + spent;
        DIPC_EMIT_EVENT(createOrder, "portfolioName", _portfolioName, "OrderInfo", &order.toJson()[0], "portfolioBalance", finalBalance);
    }

    
    EXPORT void PortfolioManage::dealOrder(char* _portfolioName, char* _orderId){
        u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
isOwner();
        std::string pInfo = portfolioStorge.get()[_portfolioName];
        
        
        PortfolioInfo info;
        info.parseJson(pInfo);
        

        
         Order ord = info.getOrder(_orderId);
         
         
        if(ord.orderId != "" && ord.orderStatus == 0){
            
            uint64_t timenow = dipc::timestamp();
            if(ord.endTime > timenow){
                ord.orderStatus = 1;
            }else {
                ord.orderStatus = 3;
            }
        } else {
          

            return;
        }
        

        uint64_t sellValue = 0;
        if(ord.orderType == 0){
            sellValue = ord.stockAmount * ord.stockPrice;
        }
        uint64_t currentBalance =  portfolioBalance.get()[_portfolioName];
        

        DipcAssert(currentBalance + sellValue >= currentBalance);
        DipcAssert((ownerTotalToken.get() - sellValue) <= ownerTotalToken.get());
        


        (*portfolioBalance)[_portfolioName] = currentBalance + sellValue;
        *ownerTotalToken = ownerTotalToken.get() - sellValue;
        (*portfolioStorge)[_portfolioName] = &info.toJson()[0];
        
        
        
        

        DIPC_EMIT_EVENT(dealPortfolio, "orderId", _orderId, "orderInfo", &ord.toJson()[0]);
    }
    
    EXPORT void PortfolioManage::revocationOrder(char* _portfolioName, char* _orderId){
        u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
std::string pInfo = portfolioStorge.get()[_portfolioName];
        
        
        PortfolioInfo info;
        info.parseJson(pInfo);
        Order ord = info.getOrder(_orderId);
        
        
        if(ord.orderId != "" && ord.orderStatus == 0){
            std::string callerStr = caller().toString();
            
            
            
            DipcAssert(info.getOwnerAddress() == caller().toString());
            

            uint64_t timenow = dipc::timestamp();
            if(ord.endTime > timenow){
                ord.orderStatus = 2;
            }else {
                ord.orderStatus = 3;
            }
        } else {
            return;
        }
        uint64_t lockToken = 0;
        if(ord.orderType == 1){
            lockToken = ord.stockPrice * ord.stockAmount;
        }
        uint64_t currentBalance =  portfolioBalance.get()[_portfolioName];
        
        
        
        

        DipcAssert(currentBalance + lockToken >= currentBalance);
        DipcAssert(ownerTotalToken.get() - lockToken <= ownerTotalToken.get());

        
        (*portfolioBalance)[_portfolioName] = currentBalance + lockToken;
        *ownerTotalToken = ownerTotalToken.get() - lockToken;
        (*portfolioStorge)[_portfolioName] = &info.toJson()[0];
        DIPC_EMIT_EVENT(revocationPortfolio, "orderId", _orderId, "orderInfo", &ord.toJson()[0]);
    }
    
    EXPORT void PortfolioManage::withdrawPortfolio(char* _portfolioName, uint64_t _withdrawBalance){
         u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
if(!userCanWithdraw.get()){
             return;
         }
         uint64_t currentBalance =  portfolioBalance.get()[_portfolioName];
         DipcAssert(currentBalance - _withdrawBalance < currentBalance);
         auto coinBalance = changeUint64ToU256WithChangeRate(currentBalance, changeRate.get());
         (*portfolioBalance)[_portfolioName] = currentBalance - _withdrawBalance;
         callTransfer(caller(), coinBalance);
    }
    
    EXPORT void PortfolioManage::withdrawPool(uint64_t _balance){
        u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
isOwner();
        Address ownerAddr = Address(owner.get()); 
        callTransfer(ownerAddr, _balance);
        *ownerTotalToken = ownerTotalToken.get() - _balance * changeRate.get();
        *totalToken = totalToken.get() - _balance * changeRate.get();
        DIPC_EMIT_EVENT(tokenCount, "ownerTotalToken", ownerTotalToken.get(), "totalToken", totalToken.get());
    }
    
    PAYABLE void PortfolioManage::depositPool(uint64_t _depositValue){
        isOwner();
        
        uint64_t tokenBalance = changeU256ToUint64WithChangeRate(callValue(), changeRate.get()); 
        *ownerTotalToken = ownerTotalToken.get() + tokenBalance;
        *totalToken = totalToken.get() + tokenBalance;
        DIPC_EMIT_EVENT(tokenCount, "ownerTotalToken", ownerTotalToken.get(), "totalToken", totalToken.get());
    }
     
    CONSTANT uint64_t PortfolioManage::queryTotalToken(){
        u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
return totalToken.get();
    }

     
    CONSTANT uint64_t PortfolioManage::queryPortfolioBalance(char* _portfolioName){
        return portfolioBalance.get()[_portfolioName];
    }

    
    CONSTANT bool PortfolioManage::queryPortfolioNameIfUsed(char* _portfolioName){
        if(portfolioStorge.get()[_portfolioName] != ""){
            return true;
        } 
        return false;
    }

    
    CONSTANT uint64_t PortfolioManage::queryChangeRate(){
        return changeRate.get();
    }

2019-12-19_15:14:55.039283: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:513] s  first 

     
    CONSTANT uint64_t PortfolioManage::queryPortfolioBalance(char* _portfolioName){
        return portfolioBalance.get()[_portfolioName];
    }

2019-12-19_15:14:55.039290: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:593] calledFunc temp export: 

     
    CONSTANT uint64_t PortfolioManage::queryPortfolioBalance(char* _portfolioName){
        u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
return portfolioBalance.get()[_portfolioName];
    }

2019-12-19_15:14:55.039298: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:599] search func : 

     
    CONSTANT uint64_t PortfolioManage::queryPortfolioBalance(char* _portfolioName){
        u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
return portfolioBalance.get()[_portfolioName];
    }
2019-12-19_15:14:55.039305: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:424] finalContract  this height  #include "PortfolioManage.hpp"

    
    PAYABLE void PortfolioManage::init(){
        *owner = caller().toString();
        *changeRate = 10000;
        *userCanWithdraw = false;
        uint64_t tokenBalance = getTotalBalance();
        
        *ownerTotalToken = tokenBalance;
        *totalToken = ownerTotalToken.get();
        
        
        DIPC_EMIT_EVENT(initEvent, "ownerTotalToken" ,tokenBalance);
    }
    
     
    EXPORT void PortfolioManage::setChangeRate(uint64_t _changeRate){
        u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
isOwner();
        *changeRate = _changeRate;
    }
     
    EXPORT void PortfolioManage::setUserCanWithdraw(bool _canWithdraw){
        u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
isOwner();
        *userCanWithdraw = _canWithdraw;
    }

    
    PAYABLE void PortfolioManage::createPortfolio(char* _portfolioName, char* _portfolioDesc){
        if(portfolioStorge.get()[_portfolioName] != ""){
            DIPC_EMIT_EVENT(ErrEvent, "Current portfolio exist: ", _portfolioName);
            return;
        } 
        std::string callerAddr = caller().toString();
        uint64_t tokenBalance = getTotalBalance();
        
        PortfolioInfo info(_portfolioName, _portfolioDesc, &callerAddr[0]);
        std::string portfolioStr = info.toJson();
        
        
        

        (*portfolioStorge)[_portfolioName] = portfolioStr;
        DipcAssert(totalToken.get() + tokenBalance > totalToken);
        (*portfolioBalance)[_portfolioName] = tokenBalance;
        *totalToken = totalToken.get() + tokenBalance; 
        
        DIPC_EMIT_EVENT(portfolioInfo, _portfolioName, &portfolioStr[0], "portfolioBalance", tokenBalance);
    }

    
    PAYABLE void PortfolioManage::depositPortfolio(char* _portfolioName){
        uint64_t tokenBalance = getTotalBalance();
        
        uint64_t currentBalance = portfolioBalance.get()[_portfolioName];
        uint64_t finalBalance  = currentBalance + tokenBalance;
        DipcAssert(totalToken.get() + tokenBalance > totalToken);
        DipcAssert(finalBalance > currentBalance);
        (*portfolioBalance)[_portfolioName] = finalBalance;
        *totalToken = totalToken.get() + finalBalance; 
        DIPC_EMIT_EVENT(depositPortfolio, "portfolioName", _portfolioName, "portfolioBalance", finalBalance);
    }
    
    PAYABLE void PortfolioManage::createOrder(char* _portfolioName, char* _orderId, uint16_t _orderType, char* _stockCode, uint64_t _stockPrice, uint64_t _stockAmount, uint64_t _endTime){
        uint64_t tokenBalance = getTotalBalance();
        DIPC_EMIT_EVENT(createOrder, "portfolioName", _portfolioName, "OrderInfo", "ignore", "tokenBalance", tokenBalance);
        uint64_t spent = 0;
        if(_orderType == 1){
            spent = _stockPrice * _stockAmount;
            DipcAssert((portfolioBalance.get()[_portfolioName] + tokenBalance) > spent);
        }
        struct Order order{_orderId, _orderType, _stockCode, _stockPrice, _stockAmount, _endTime, 0};
        std::string pInfo = portfolioStorge.get()[_portfolioName];
        
        
        
        if(pInfo == "") {
            DIPC_EMIT_EVENT(ErrEvent, "Current portfolio  doesn't exist: ", _portfolioName);
            return;
        }
        PortfolioInfo info;
        info.parseJson(pInfo);
        if(info.getOrder(_orderId).orderId != ""){
            DIPC_EMIT_EVENT(ErrEvent, "Current order exist: ", _orderId);
            return;
        }
        info.addOrder(order);
        pInfo = info.toJson();

        uint64_t currentBalance = portfolioBalance.get()[_portfolioName] ;
        uint64_t finalBalance = currentBalance + tokenBalance - spent;
        DipcAssert(totalToken.get() + tokenBalance > totalToken);
        
        DipcAssert(ownerTotalToken.get() < ownerTotalToken.get() + spent);
        (*portfolioStorge)[_portfolioName] = &pInfo[0];
        
        
        
        


        (*portfolioBalance)[_portfolioName] = finalBalance;
        *totalToken = totalToken.get() + finalBalance; 
        *ownerTotalToken = ownerTotalToken.get() + spent;
        DIPC_EMIT_EVENT(createOrder, "portfolioName", _portfolioName, "OrderInfo", &order.toJson()[0], "portfolioBalance", finalBalance);
    }

    
    EXPORT void PortfolioManage::dealOrder(char* _portfolioName, char* _orderId){
        u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
isOwner();
        std::string pInfo = portfolioStorge.get()[_portfolioName];
        
        
        PortfolioInfo info;
        info.parseJson(pInfo);
        

        
         Order ord = info.getOrder(_orderId);
         
         
        if(ord.orderId != "" && ord.orderStatus == 0){
            
            uint64_t timenow = dipc::timestamp();
            if(ord.endTime > timenow){
                ord.orderStatus = 1;
            }else {
                ord.orderStatus = 3;
            }
        } else {
          

            return;
        }
        

        uint64_t sellValue = 0;
        if(ord.orderType == 0){
            sellValue = ord.stockAmount * ord.stockPrice;
        }
        uint64_t currentBalance =  portfolioBalance.get()[_portfolioName];
        

        DipcAssert(currentBalance + sellValue >= currentBalance);
        DipcAssert((ownerTotalToken.get() - sellValue) <= ownerTotalToken.get());
        


        (*portfolioBalance)[_portfolioName] = currentBalance + sellValue;
        *ownerTotalToken = ownerTotalToken.get() - sellValue;
        (*portfolioStorge)[_portfolioName] = &info.toJson()[0];
        
        
        
        

        DIPC_EMIT_EVENT(dealPortfolio, "orderId", _orderId, "orderInfo", &ord.toJson()[0]);
    }
    
    EXPORT void PortfolioManage::revocationOrder(char* _portfolioName, char* _orderId){
        u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
std::string pInfo = portfolioStorge.get()[_portfolioName];
        
        
        PortfolioInfo info;
        info.parseJson(pInfo);
        Order ord = info.getOrder(_orderId);
        
        
        if(ord.orderId != "" && ord.orderStatus == 0){
            std::string callerStr = caller().toString();
            
            
            
            DipcAssert(info.getOwnerAddress() == caller().toString());
            

            uint64_t timenow = dipc::timestamp();
            if(ord.endTime > timenow){
                ord.orderStatus = 2;
            }else {
                ord.orderStatus = 3;
            }
        } else {
            return;
        }
        uint64_t lockToken = 0;
        if(ord.orderType == 1){
            lockToken = ord.stockPrice * ord.stockAmount;
        }
        uint64_t currentBalance =  portfolioBalance.get()[_portfolioName];
        
        
        
        

        DipcAssert(currentBalance + lockToken >= currentBalance);
        DipcAssert(ownerTotalToken.get() - lockToken <= ownerTotalToken.get());

        
        (*portfolioBalance)[_portfolioName] = currentBalance + lockToken;
        *ownerTotalToken = ownerTotalToken.get() - lockToken;
        (*portfolioStorge)[_portfolioName] = &info.toJson()[0];
        DIPC_EMIT_EVENT(revocationPortfolio, "orderId", _orderId, "orderInfo", &ord.toJson()[0]);
    }
    
    EXPORT void PortfolioManage::withdrawPortfolio(char* _portfolioName, uint64_t _withdrawBalance){
         u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
if(!userCanWithdraw.get()){
             return;
         }
         uint64_t currentBalance =  portfolioBalance.get()[_portfolioName];
         DipcAssert(currentBalance - _withdrawBalance < currentBalance);
         auto coinBalance = changeUint64ToU256WithChangeRate(currentBalance, changeRate.get());
         (*portfolioBalance)[_portfolioName] = currentBalance - _withdrawBalance;
         callTransfer(caller(), coinBalance);
    }
    
    EXPORT void PortfolioManage::withdrawPool(uint64_t _balance){
        u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
isOwner();
        Address ownerAddr = Address(owner.get()); 
        callTransfer(ownerAddr, _balance);
        *ownerTotalToken = ownerTotalToken.get() - _balance * changeRate.get();
        *totalToken = totalToken.get() - _balance * changeRate.get();
        DIPC_EMIT_EVENT(tokenCount, "ownerTotalToken", ownerTotalToken.get(), "totalToken", totalToken.get());
    }
    
    PAYABLE void PortfolioManage::depositPool(uint64_t _depositValue){
        isOwner();
        
        uint64_t tokenBalance = changeU256ToUint64WithChangeRate(callValue(), changeRate.get()); 
        *ownerTotalToken = ownerTotalToken.get() + tokenBalance;
        *totalToken = totalToken.get() + tokenBalance;
        DIPC_EMIT_EVENT(tokenCount, "ownerTotalToken", ownerTotalToken.get(), "totalToken", totalToken.get());
    }
     
    CONSTANT uint64_t PortfolioManage::queryTotalToken(){
        u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
return totalToken.get();
    }

     
    CONSTANT uint64_t PortfolioManage::queryPortfolioBalance(char* _portfolioName){
        u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
return portfolioBalance.get()[_portfolioName];
    } codetext height #include "PortfolioManage.hpp"

    
    PAYABLE void PortfolioManage::init(){
        *owner = caller().toString();
        *changeRate = 10000;
        *userCanWithdraw = false;
        uint64_t tokenBalance = getTotalBalance();
        
        *ownerTotalToken = tokenBalance;
        *totalToken = ownerTotalToken.get();
        
        
        DIPC_EMIT_EVENT(initEvent, "ownerTotalToken" ,tokenBalance);
    }
    
     
    EXPORT void PortfolioManage::setChangeRate(uint64_t _changeRate){
        u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
isOwner();
        *changeRate = _changeRate;
    }
     
    EXPORT void PortfolioManage::setUserCanWithdraw(bool _canWithdraw){
        u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
isOwner();
        *userCanWithdraw = _canWithdraw;
    }

    
    PAYABLE void PortfolioManage::createPortfolio(char* _portfolioName, char* _portfolioDesc){
        if(portfolioStorge.get()[_portfolioName] != ""){
            DIPC_EMIT_EVENT(ErrEvent, "Current portfolio exist: ", _portfolioName);
            return;
        } 
        std::string callerAddr = caller().toString();
        uint64_t tokenBalance = getTotalBalance();
        
        PortfolioInfo info(_portfolioName, _portfolioDesc, &callerAddr[0]);
        std::string portfolioStr = info.toJson();
        
        
        

        (*portfolioStorge)[_portfolioName] = portfolioStr;
        DipcAssert(totalToken.get() + tokenBalance > totalToken);
        (*portfolioBalance)[_portfolioName] = tokenBalance;
        *totalToken = totalToken.get() + tokenBalance; 
        
        DIPC_EMIT_EVENT(portfolioInfo, _portfolioName, &portfolioStr[0], "portfolioBalance", tokenBalance);
    }

    
    PAYABLE void PortfolioManage::depositPortfolio(char* _portfolioName){
        uint64_t tokenBalance = getTotalBalance();
        
        uint64_t currentBalance = portfolioBalance.get()[_portfolioName];
        uint64_t finalBalance  = currentBalance + tokenBalance;
        DipcAssert(totalToken.get() + tokenBalance > totalToken);
        DipcAssert(finalBalance > currentBalance);
        (*portfolioBalance)[_portfolioName] = finalBalance;
        *totalToken = totalToken.get() + finalBalance; 
        DIPC_EMIT_EVENT(depositPortfolio, "portfolioName", _portfolioName, "portfolioBalance", finalBalance);
    }
    
    PAYABLE void PortfolioManage::createOrder(char* _portfolioName, char* _orderId, uint16_t _orderType, char* _stockCode, uint64_t _stockPrice, uint64_t _stockAmount, uint64_t _endTime){
        uint64_t tokenBalance = getTotalBalance();
        DIPC_EMIT_EVENT(createOrder, "portfolioName", _portfolioName, "OrderInfo", "ignore", "tokenBalance", tokenBalance);
        uint64_t spent = 0;
        if(_orderType == 1){
            spent = _stockPrice * _stockAmount;
            DipcAssert((portfolioBalance.get()[_portfolioName] + tokenBalance) > spent);
        }
        struct Order order{_orderId, _orderType, _stockCode, _stockPrice, _stockAmount, _endTime, 0};
        std::string pInfo = portfolioStorge.get()[_portfolioName];
        
        
        
        if(pInfo == "") {
            DIPC_EMIT_EVENT(ErrEvent, "Current portfolio  doesn't exist: ", _portfolioName);
            return;
        }
        PortfolioInfo info;
        info.parseJson(pInfo);
        if(info.getOrder(_orderId).orderId != ""){
            DIPC_EMIT_EVENT(ErrEvent, "Current order exist: ", _orderId);
            return;
        }
        info.addOrder(order);
        pInfo = info.toJson();

        uint64_t currentBalance = portfolioBalance.get()[_portfolioName] ;
        uint64_t finalBalance = currentBalance + tokenBalance - spent;
        DipcAssert(totalToken.get() + tokenBalance > totalToken);
        
        DipcAssert(ownerTotalToken.get() < ownerTotalToken.get() + spent);
        (*portfolioStorge)[_portfolioName] = &pInfo[0];
        
        
        
        


        (*portfolioBalance)[_portfolioName] = finalBalance;
        *totalToken = totalToken.get() + finalBalance; 
        *ownerTotalToken = ownerTotalToken.get() + spent;
        DIPC_EMIT_EVENT(createOrder, "portfolioName", _portfolioName, "OrderInfo", &order.toJson()[0], "portfolioBalance", finalBalance);
    }

    
    EXPORT void PortfolioManage::dealOrder(char* _portfolioName, char* _orderId){
        u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
isOwner();
        std::string pInfo = portfolioStorge.get()[_portfolioName];
        
        
        PortfolioInfo info;
        info.parseJson(pInfo);
        

        
         Order ord = info.getOrder(_orderId);
         
         
        if(ord.orderId != "" && ord.orderStatus == 0){
            
            uint64_t timenow = dipc::timestamp();
            if(ord.endTime > timenow){
                ord.orderStatus = 1;
            }else {
                ord.orderStatus = 3;
            }
        } else {
          

            return;
        }
        

        uint64_t sellValue = 0;
        if(ord.orderType == 0){
            sellValue = ord.stockAmount * ord.stockPrice;
        }
        uint64_t currentBalance =  portfolioBalance.get()[_portfolioName];
        

        DipcAssert(currentBalance + sellValue >= currentBalance);
        DipcAssert((ownerTotalToken.get() - sellValue) <= ownerTotalToken.get());
        


        (*portfolioBalance)[_portfolioName] = currentBalance + sellValue;
        *ownerTotalToken = ownerTotalToken.get() - sellValue;
        (*portfolioStorge)[_portfolioName] = &info.toJson()[0];
        
        
        
        

        DIPC_EMIT_EVENT(dealPortfolio, "orderId", _orderId, "orderInfo", &ord.toJson()[0]);
    }
    
    EXPORT void PortfolioManage::revocationOrder(char* _portfolioName, char* _orderId){
        u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
std::string pInfo = portfolioStorge.get()[_portfolioName];
        
        
        PortfolioInfo info;
        info.parseJson(pInfo);
        Order ord = info.getOrder(_orderId);
        
        
        if(ord.orderId != "" && ord.orderStatus == 0){
            std::string callerStr = caller().toString();
            
            
            
            DipcAssert(info.getOwnerAddress() == caller().toString());
            

            uint64_t timenow = dipc::timestamp();
            if(ord.endTime > timenow){
                ord.orderStatus = 2;
            }else {
                ord.orderStatus = 3;
            }
        } else {
            return;
        }
        uint64_t lockToken = 0;
        if(ord.orderType == 1){
            lockToken = ord.stockPrice * ord.stockAmount;
        }
        uint64_t currentBalance =  portfolioBalance.get()[_portfolioName];
        
        
        
        

        DipcAssert(currentBalance + lockToken >= currentBalance);
        DipcAssert(ownerTotalToken.get() - lockToken <= ownerTotalToken.get());

        
        (*portfolioBalance)[_portfolioName] = currentBalance + lockToken;
        *ownerTotalToken = ownerTotalToken.get() - lockToken;
        (*portfolioStorge)[_portfolioName] = &info.toJson()[0];
        DIPC_EMIT_EVENT(revocationPortfolio, "orderId", _orderId, "orderInfo", &ord.toJson()[0]);
    }
    
    EXPORT void PortfolioManage::withdrawPortfolio(char* _portfolioName, uint64_t _withdrawBalance){
         u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
if(!userCanWithdraw.get()){
             return;
         }
         uint64_t currentBalance =  portfolioBalance.get()[_portfolioName];
         DipcAssert(currentBalance - _withdrawBalance < currentBalance);
         auto coinBalance = changeUint64ToU256WithChangeRate(currentBalance, changeRate.get());
         (*portfolioBalance)[_portfolioName] = currentBalance - _withdrawBalance;
         callTransfer(caller(), coinBalance);
    }
    
    EXPORT void PortfolioManage::withdrawPool(uint64_t _balance){
        u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
isOwner();
        Address ownerAddr = Address(owner.get()); 
        callTransfer(ownerAddr, _balance);
        *ownerTotalToken = ownerTotalToken.get() - _balance * changeRate.get();
        *totalToken = totalToken.get() - _balance * changeRate.get();
        DIPC_EMIT_EVENT(tokenCount, "ownerTotalToken", ownerTotalToken.get(), "totalToken", totalToken.get());
    }
    
    PAYABLE void PortfolioManage::depositPool(uint64_t _depositValue){
        isOwner();
        
        uint64_t tokenBalance = changeU256ToUint64WithChangeRate(callValue(), changeRate.get()); 
        *ownerTotalToken = ownerTotalToken.get() + tokenBalance;
        *totalToken = totalToken.get() + tokenBalance;
        DIPC_EMIT_EVENT(tokenCount, "ownerTotalToken", ownerTotalToken.get(), "totalToken", totalToken.get());
    }
     
    CONSTANT uint64_t PortfolioManage::queryTotalToken(){
        u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
return totalToken.get();
    }

     
    CONSTANT uint64_t PortfolioManage::queryPortfolioBalance(char* _portfolioName){
        return portfolioBalance.get()[_portfolioName];
    }

    
    CONSTANT bool PortfolioManage::queryPortfolioNameIfUsed(char* _portfolioName){
        if(portfolioStorge.get()[_portfolioName] != ""){
            return true;
        } 
        return false;
    }

    
    CONSTANT uint64_t PortfolioManage::queryChangeRate(){
        return changeRate.get();
    }

2019-12-19_15:14:55.039316: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:427] searchContext  

    
    CONSTANT bool PortfolioManage::queryPortfolioNameIfUsed(char* _portfolioName){
        if(portfolioStorge.get()[_portfolioName] != ""){
            return true;
        } 
        return false;
    }

    
    CONSTANT uint64_t PortfolioManage::queryChangeRate(){
        return changeRate.get();
    }

2019-12-19_15:14:55.044311: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:442] finalContract  this new  #include "PortfolioManage.hpp"

    
    PAYABLE void PortfolioManage::init(){
        *owner = caller().toString();
        *changeRate = 10000;
        *userCanWithdraw = false;
        uint64_t tokenBalance = getTotalBalance();
        
        *ownerTotalToken = tokenBalance;
        *totalToken = ownerTotalToken.get();
        
        
        DIPC_EMIT_EVENT(initEvent, "ownerTotalToken" ,tokenBalance);
    }
    
     
    EXPORT void PortfolioManage::setChangeRate(uint64_t _changeRate){
        u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
isOwner();
        *changeRate = _changeRate;
    }
     
    EXPORT void PortfolioManage::setUserCanWithdraw(bool _canWithdraw){
        u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
isOwner();
        *userCanWithdraw = _canWithdraw;
    }

    
    PAYABLE void PortfolioManage::createPortfolio(char* _portfolioName, char* _portfolioDesc){
        if(portfolioStorge.get()[_portfolioName] != ""){
            DIPC_EMIT_EVENT(ErrEvent, "Current portfolio exist: ", _portfolioName);
            return;
        } 
        std::string callerAddr = caller().toString();
        uint64_t tokenBalance = getTotalBalance();
        
        PortfolioInfo info(_portfolioName, _portfolioDesc, &callerAddr[0]);
        std::string portfolioStr = info.toJson();
        
        
        

        (*portfolioStorge)[_portfolioName] = portfolioStr;
        DipcAssert(totalToken.get() + tokenBalance > totalToken);
        (*portfolioBalance)[_portfolioName] = tokenBalance;
        *totalToken = totalToken.get() + tokenBalance; 
        
        DIPC_EMIT_EVENT(portfolioInfo, _portfolioName, &portfolioStr[0], "portfolioBalance", tokenBalance);
    }

    
    PAYABLE void PortfolioManage::depositPortfolio(char* _portfolioName){
        uint64_t tokenBalance = getTotalBalance();
        
        uint64_t currentBalance = portfolioBalance.get()[_portfolioName];
        uint64_t finalBalance  = currentBalance + tokenBalance;
        DipcAssert(totalToken.get() + tokenBalance > totalToken);
        DipcAssert(finalBalance > currentBalance);
        (*portfolioBalance)[_portfolioName] = finalBalance;
        *totalToken = totalToken.get() + finalBalance; 
        DIPC_EMIT_EVENT(depositPortfolio, "portfolioName", _portfolioName, "portfolioBalance", finalBalance);
    }
    
    PAYABLE void PortfolioManage::createOrder(char* _portfolioName, char* _orderId, uint16_t _orderType, char* _stockCode, uint64_t _stockPrice, uint64_t _stockAmount, uint64_t _endTime){
        uint64_t tokenBalance = getTotalBalance();
        DIPC_EMIT_EVENT(createOrder, "portfolioName", _portfolioName, "OrderInfo", "ignore", "tokenBalance", tokenBalance);
        uint64_t spent = 0;
        if(_orderType == 1){
            spent = _stockPrice * _stockAmount;
            DipcAssert((portfolioBalance.get()[_portfolioName] + tokenBalance) > spent);
        }
        struct Order order{_orderId, _orderType, _stockCode, _stockPrice, _stockAmount, _endTime, 0};
        std::string pInfo = portfolioStorge.get()[_portfolioName];
        
        
        
        if(pInfo == "") {
            DIPC_EMIT_EVENT(ErrEvent, "Current portfolio  doesn't exist: ", _portfolioName);
            return;
        }
        PortfolioInfo info;
        info.parseJson(pInfo);
        if(info.getOrder(_orderId).orderId != ""){
            DIPC_EMIT_EVENT(ErrEvent, "Current order exist: ", _orderId);
            return;
        }
        info.addOrder(order);
        pInfo = info.toJson();

        uint64_t currentBalance = portfolioBalance.get()[_portfolioName] ;
        uint64_t finalBalance = currentBalance + tokenBalance - spent;
        DipcAssert(totalToken.get() + tokenBalance > totalToken);
        
        DipcAssert(ownerTotalToken.get() < ownerTotalToken.get() + spent);
        (*portfolioStorge)[_portfolioName] = &pInfo[0];
        
        
        
        


        (*portfolioBalance)[_portfolioName] = finalBalance;
        *totalToken = totalToken.get() + finalBalance; 
        *ownerTotalToken = ownerTotalToken.get() + spent;
        DIPC_EMIT_EVENT(createOrder, "portfolioName", _portfolioName, "OrderInfo", &order.toJson()[0], "portfolioBalance", finalBalance);
    }

    
    EXPORT void PortfolioManage::dealOrder(char* _portfolioName, char* _orderId){
        u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
isOwner();
        std::string pInfo = portfolioStorge.get()[_portfolioName];
        
        
        PortfolioInfo info;
        info.parseJson(pInfo);
        

        
         Order ord = info.getOrder(_orderId);
         
         
        if(ord.orderId != "" && ord.orderStatus == 0){
            
            uint64_t timenow = dipc::timestamp();
            if(ord.endTime > timenow){
                ord.orderStatus = 1;
            }else {
                ord.orderStatus = 3;
            }
        } else {
          

            return;
        }
        

        uint64_t sellValue = 0;
        if(ord.orderType == 0){
            sellValue = ord.stockAmount * ord.stockPrice;
        }
        uint64_t currentBalance =  portfolioBalance.get()[_portfolioName];
        

        DipcAssert(currentBalance + sellValue >= currentBalance);
        DipcAssert((ownerTotalToken.get() - sellValue) <= ownerTotalToken.get());
        


        (*portfolioBalance)[_portfolioName] = currentBalance + sellValue;
        *ownerTotalToken = ownerTotalToken.get() - sellValue;
        (*portfolioStorge)[_portfolioName] = &info.toJson()[0];
        
        
        
        

        DIPC_EMIT_EVENT(dealPortfolio, "orderId", _orderId, "orderInfo", &ord.toJson()[0]);
    }
    
    EXPORT void PortfolioManage::revocationOrder(char* _portfolioName, char* _orderId){
        u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
std::string pInfo = portfolioStorge.get()[_portfolioName];
        
        
        PortfolioInfo info;
        info.parseJson(pInfo);
        Order ord = info.getOrder(_orderId);
        
        
        if(ord.orderId != "" && ord.orderStatus == 0){
            std::string callerStr = caller().toString();
            
            
            
            DipcAssert(info.getOwnerAddress() == caller().toString());
            

            uint64_t timenow = dipc::timestamp();
            if(ord.endTime > timenow){
                ord.orderStatus = 2;
            }else {
                ord.orderStatus = 3;
            }
        } else {
            return;
        }
        uint64_t lockToken = 0;
        if(ord.orderType == 1){
            lockToken = ord.stockPrice * ord.stockAmount;
        }
        uint64_t currentBalance =  portfolioBalance.get()[_portfolioName];
        
        
        
        

        DipcAssert(currentBalance + lockToken >= currentBalance);
        DipcAssert(ownerTotalToken.get() - lockToken <= ownerTotalToken.get());

        
        (*portfolioBalance)[_portfolioName] = currentBalance + lockToken;
        *ownerTotalToken = ownerTotalToken.get() - lockToken;
        (*portfolioStorge)[_portfolioName] = &info.toJson()[0];
        DIPC_EMIT_EVENT(revocationPortfolio, "orderId", _orderId, "orderInfo", &ord.toJson()[0]);
    }
    
    EXPORT void PortfolioManage::withdrawPortfolio(char* _portfolioName, uint64_t _withdrawBalance){
         u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
if(!userCanWithdraw.get()){
             return;
         }
         uint64_t currentBalance =  portfolioBalance.get()[_portfolioName];
         DipcAssert(currentBalance - _withdrawBalance < currentBalance);
         auto coinBalance = changeUint64ToU256WithChangeRate(currentBalance, changeRate.get());
         (*portfolioBalance)[_portfolioName] = currentBalance - _withdrawBalance;
         callTransfer(caller(), coinBalance);
    }
    
    EXPORT void PortfolioManage::withdrawPool(uint64_t _balance){
        u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
isOwner();
        Address ownerAddr = Address(owner.get()); 
        callTransfer(ownerAddr, _balance);
        *ownerTotalToken = ownerTotalToken.get() - _balance * changeRate.get();
        *totalToken = totalToken.get() - _balance * changeRate.get();
        DIPC_EMIT_EVENT(tokenCount, "ownerTotalToken", ownerTotalToken.get(), "totalToken", totalToken.get());
    }
    
    PAYABLE void PortfolioManage::depositPool(uint64_t _depositValue){
        isOwner();
        
        uint64_t tokenBalance = changeU256ToUint64WithChangeRate(callValue(), changeRate.get()); 
        *ownerTotalToken = ownerTotalToken.get() + tokenBalance;
        *totalToken = totalToken.get() + tokenBalance;
        DIPC_EMIT_EVENT(tokenCount, "ownerTotalToken", ownerTotalToken.get(), "totalToken", totalToken.get());
    }
     
    CONSTANT uint64_t PortfolioManage::queryTotalToken(){
        u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
return totalToken.get();
    }

     
    CONSTANT uint64_t PortfolioManage::queryPortfolioBalance(char* _portfolioName){
        u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
return portfolioBalance.get()[_portfolioName];
    } codetext new #include "PortfolioManage.hpp"

    
    PAYABLE void PortfolioManage::init(){
        *owner = caller().toString();
        *changeRate = 10000;
        *userCanWithdraw = false;
        uint64_t tokenBalance = getTotalBalance();
        
        *ownerTotalToken = tokenBalance;
        *totalToken = ownerTotalToken.get();
        
        
        DIPC_EMIT_EVENT(initEvent, "ownerTotalToken" ,tokenBalance);
    }
    
     
    EXPORT void PortfolioManage::setChangeRate(uint64_t _changeRate){
        u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
isOwner();
        *changeRate = _changeRate;
    }
     
    EXPORT void PortfolioManage::setUserCanWithdraw(bool _canWithdraw){
        u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
isOwner();
        *userCanWithdraw = _canWithdraw;
    }

    
    PAYABLE void PortfolioManage::createPortfolio(char* _portfolioName, char* _portfolioDesc){
        if(portfolioStorge.get()[_portfolioName] != ""){
            DIPC_EMIT_EVENT(ErrEvent, "Current portfolio exist: ", _portfolioName);
            return;
        } 
        std::string callerAddr = caller().toString();
        uint64_t tokenBalance = getTotalBalance();
        
        PortfolioInfo info(_portfolioName, _portfolioDesc, &callerAddr[0]);
        std::string portfolioStr = info.toJson();
        
        
        

        (*portfolioStorge)[_portfolioName] = portfolioStr;
        DipcAssert(totalToken.get() + tokenBalance > totalToken);
        (*portfolioBalance)[_portfolioName] = tokenBalance;
        *totalToken = totalToken.get() + tokenBalance; 
        
        DIPC_EMIT_EVENT(portfolioInfo, _portfolioName, &portfolioStr[0], "portfolioBalance", tokenBalance);
    }

    
    PAYABLE void PortfolioManage::depositPortfolio(char* _portfolioName){
        uint64_t tokenBalance = getTotalBalance();
        
        uint64_t currentBalance = portfolioBalance.get()[_portfolioName];
        uint64_t finalBalance  = currentBalance + tokenBalance;
        DipcAssert(totalToken.get() + tokenBalance > totalToken);
        DipcAssert(finalBalance > currentBalance);
        (*portfolioBalance)[_portfolioName] = finalBalance;
        *totalToken = totalToken.get() + finalBalance; 
        DIPC_EMIT_EVENT(depositPortfolio, "portfolioName", _portfolioName, "portfolioBalance", finalBalance);
    }
    
    PAYABLE void PortfolioManage::createOrder(char* _portfolioName, char* _orderId, uint16_t _orderType, char* _stockCode, uint64_t _stockPrice, uint64_t _stockAmount, uint64_t _endTime){
        uint64_t tokenBalance = getTotalBalance();
        DIPC_EMIT_EVENT(createOrder, "portfolioName", _portfolioName, "OrderInfo", "ignore", "tokenBalance", tokenBalance);
        uint64_t spent = 0;
        if(_orderType == 1){
            spent = _stockPrice * _stockAmount;
            DipcAssert((portfolioBalance.get()[_portfolioName] + tokenBalance) > spent);
        }
        struct Order order{_orderId, _orderType, _stockCode, _stockPrice, _stockAmount, _endTime, 0};
        std::string pInfo = portfolioStorge.get()[_portfolioName];
        
        
        
        if(pInfo == "") {
            DIPC_EMIT_EVENT(ErrEvent, "Current portfolio  doesn't exist: ", _portfolioName);
            return;
        }
        PortfolioInfo info;
        info.parseJson(pInfo);
        if(info.getOrder(_orderId).orderId != ""){
            DIPC_EMIT_EVENT(ErrEvent, "Current order exist: ", _orderId);
            return;
        }
        info.addOrder(order);
        pInfo = info.toJson();

        uint64_t currentBalance = portfolioBalance.get()[_portfolioName] ;
        uint64_t finalBalance = currentBalance + tokenBalance - spent;
        DipcAssert(totalToken.get() + tokenBalance > totalToken);
        
        DipcAssert(ownerTotalToken.get() < ownerTotalToken.get() + spent);
        (*portfolioStorge)[_portfolioName] = &pInfo[0];
        
        
        
        


        (*portfolioBalance)[_portfolioName] = finalBalance;
        *totalToken = totalToken.get() + finalBalance; 
        *ownerTotalToken = ownerTotalToken.get() + spent;
        DIPC_EMIT_EVENT(createOrder, "portfolioName", _portfolioName, "OrderInfo", &order.toJson()[0], "portfolioBalance", finalBalance);
    }

    
    EXPORT void PortfolioManage::dealOrder(char* _portfolioName, char* _orderId){
        u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
isOwner();
        std::string pInfo = portfolioStorge.get()[_portfolioName];
        
        
        PortfolioInfo info;
        info.parseJson(pInfo);
        

        
         Order ord = info.getOrder(_orderId);
         
         
        if(ord.orderId != "" && ord.orderStatus == 0){
            
            uint64_t timenow = dipc::timestamp();
            if(ord.endTime > timenow){
                ord.orderStatus = 1;
            }else {
                ord.orderStatus = 3;
            }
        } else {
          

            return;
        }
        

        uint64_t sellValue = 0;
        if(ord.orderType == 0){
            sellValue = ord.stockAmount * ord.stockPrice;
        }
        uint64_t currentBalance =  portfolioBalance.get()[_portfolioName];
        

        DipcAssert(currentBalance + sellValue >= currentBalance);
        DipcAssert((ownerTotalToken.get() - sellValue) <= ownerTotalToken.get());
        


        (*portfolioBalance)[_portfolioName] = currentBalance + sellValue;
        *ownerTotalToken = ownerTotalToken.get() - sellValue;
        (*portfolioStorge)[_portfolioName] = &info.toJson()[0];
        
        
        
        

        DIPC_EMIT_EVENT(dealPortfolio, "orderId", _orderId, "orderInfo", &ord.toJson()[0]);
    }
    
    EXPORT void PortfolioManage::revocationOrder(char* _portfolioName, char* _orderId){
        u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
std::string pInfo = portfolioStorge.get()[_portfolioName];
        
        
        PortfolioInfo info;
        info.parseJson(pInfo);
        Order ord = info.getOrder(_orderId);
        
        
        if(ord.orderId != "" && ord.orderStatus == 0){
            std::string callerStr = caller().toString();
            
            
            
            DipcAssert(info.getOwnerAddress() == caller().toString());
            

            uint64_t timenow = dipc::timestamp();
            if(ord.endTime > timenow){
                ord.orderStatus = 2;
            }else {
                ord.orderStatus = 3;
            }
        } else {
            return;
        }
        uint64_t lockToken = 0;
        if(ord.orderType == 1){
            lockToken = ord.stockPrice * ord.stockAmount;
        }
        uint64_t currentBalance =  portfolioBalance.get()[_portfolioName];
        
        
        
        

        DipcAssert(currentBalance + lockToken >= currentBalance);
        DipcAssert(ownerTotalToken.get() - lockToken <= ownerTotalToken.get());

        
        (*portfolioBalance)[_portfolioName] = currentBalance + lockToken;
        *ownerTotalToken = ownerTotalToken.get() - lockToken;
        (*portfolioStorge)[_portfolioName] = &info.toJson()[0];
        DIPC_EMIT_EVENT(revocationPortfolio, "orderId", _orderId, "orderInfo", &ord.toJson()[0]);
    }
    
    EXPORT void PortfolioManage::withdrawPortfolio(char* _portfolioName, uint64_t _withdrawBalance){
         u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
if(!userCanWithdraw.get()){
             return;
         }
         uint64_t currentBalance =  portfolioBalance.get()[_portfolioName];
         DipcAssert(currentBalance - _withdrawBalance < currentBalance);
         auto coinBalance = changeUint64ToU256WithChangeRate(currentBalance, changeRate.get());
         (*portfolioBalance)[_portfolioName] = currentBalance - _withdrawBalance;
         callTransfer(caller(), coinBalance);
    }
    
    EXPORT void PortfolioManage::withdrawPool(uint64_t _balance){
        u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
isOwner();
        Address ownerAddr = Address(owner.get()); 
        callTransfer(ownerAddr, _balance);
        *ownerTotalToken = ownerTotalToken.get() - _balance * changeRate.get();
        *totalToken = totalToken.get() - _balance * changeRate.get();
        DIPC_EMIT_EVENT(tokenCount, "ownerTotalToken", ownerTotalToken.get(), "totalToken", totalToken.get());
    }
    
    PAYABLE void PortfolioManage::depositPool(uint64_t _depositValue){
        isOwner();
        
        uint64_t tokenBalance = changeU256ToUint64WithChangeRate(callValue(), changeRate.get()); 
        *ownerTotalToken = ownerTotalToken.get() + tokenBalance;
        *totalToken = totalToken.get() + tokenBalance;
        DIPC_EMIT_EVENT(tokenCount, "ownerTotalToken", ownerTotalToken.get(), "totalToken", totalToken.get());
    }
     
    CONSTANT uint64_t PortfolioManage::queryTotalToken(){
        u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
return totalToken.get();
    }

     
    CONSTANT uint64_t PortfolioManage::queryPortfolioBalance(char* _portfolioName){
        return portfolioBalance.get()[_portfolioName];
    }

    
    CONSTANT bool PortfolioManage::queryPortfolioNameIfUsed(char* _portfolioName){
        if(portfolioStorge.get()[_portfolioName] != ""){
            return true;
        } 
        return false;
    }

    
    CONSTANT uint64_t PortfolioManage::queryChangeRate(){
        return changeRate.get();
    }

2019-12-19_15:14:55.044376: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:604] finalContract  final content =======   : #include "PortfolioManage.hpp"

    
    PAYABLE void PortfolioManage::init(){
        *owner = caller().toString();
        *changeRate = 10000;
        *userCanWithdraw = false;
        uint64_t tokenBalance = getTotalBalance();
        
        *ownerTotalToken = tokenBalance;
        *totalToken = ownerTotalToken.get();
        
        
        DIPC_EMIT_EVENT(initEvent, "ownerTotalToken" ,tokenBalance);
    }
    
     
    EXPORT void PortfolioManage::setChangeRate(uint64_t _changeRate){
        u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
isOwner();
        *changeRate = _changeRate;
    }
     
    EXPORT void PortfolioManage::setUserCanWithdraw(bool _canWithdraw){
        u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
isOwner();
        *userCanWithdraw = _canWithdraw;
    }

    
    PAYABLE void PortfolioManage::createPortfolio(char* _portfolioName, char* _portfolioDesc){
        if(portfolioStorge.get()[_portfolioName] != ""){
            DIPC_EMIT_EVENT(ErrEvent, "Current portfolio exist: ", _portfolioName);
            return;
        } 
        std::string callerAddr = caller().toString();
        uint64_t tokenBalance = getTotalBalance();
        
        PortfolioInfo info(_portfolioName, _portfolioDesc, &callerAddr[0]);
        std::string portfolioStr = info.toJson();
        
        
        

        (*portfolioStorge)[_portfolioName] = portfolioStr;
        DipcAssert(totalToken.get() + tokenBalance > totalToken);
        (*portfolioBalance)[_portfolioName] = tokenBalance;
        *totalToken = totalToken.get() + tokenBalance; 
        
        DIPC_EMIT_EVENT(portfolioInfo, _portfolioName, &portfolioStr[0], "portfolioBalance", tokenBalance);
    }

    
    PAYABLE void PortfolioManage::depositPortfolio(char* _portfolioName){
        uint64_t tokenBalance = getTotalBalance();
        
        uint64_t currentBalance = portfolioBalance.get()[_portfolioName];
        uint64_t finalBalance  = currentBalance + tokenBalance;
        DipcAssert(totalToken.get() + tokenBalance > totalToken);
        DipcAssert(finalBalance > currentBalance);
        (*portfolioBalance)[_portfolioName] = finalBalance;
        *totalToken = totalToken.get() + finalBalance; 
        DIPC_EMIT_EVENT(depositPortfolio, "portfolioName", _portfolioName, "portfolioBalance", finalBalance);
    }
    
    PAYABLE void PortfolioManage::createOrder(char* _portfolioName, char* _orderId, uint16_t _orderType, char* _stockCode, uint64_t _stockPrice, uint64_t _stockAmount, uint64_t _endTime){
        uint64_t tokenBalance = getTotalBalance();
        DIPC_EMIT_EVENT(createOrder, "portfolioName", _portfolioName, "OrderInfo", "ignore", "tokenBalance", tokenBalance);
        uint64_t spent = 0;
        if(_orderType == 1){
            spent = _stockPrice * _stockAmount;
            DipcAssert((portfolioBalance.get()[_portfolioName] + tokenBalance) > spent);
        }
        struct Order order{_orderId, _orderType, _stockCode, _stockPrice, _stockAmount, _endTime, 0};
        std::string pInfo = portfolioStorge.get()[_portfolioName];
        
        
        
        if(pInfo == "") {
            DIPC_EMIT_EVENT(ErrEvent, "Current portfolio  doesn't exist: ", _portfolioName);
            return;
        }
        PortfolioInfo info;
        info.parseJson(pInfo);
        if(info.getOrder(_orderId).orderId != ""){
            DIPC_EMIT_EVENT(ErrEvent, "Current order exist: ", _orderId);
            return;
        }
        info.addOrder(order);
        pInfo = info.toJson();

        uint64_t currentBalance = portfolioBalance.get()[_portfolioName] ;
        uint64_t finalBalance = currentBalance + tokenBalance - spent;
        DipcAssert(totalToken.get() + tokenBalance > totalToken);
        
        DipcAssert(ownerTotalToken.get() < ownerTotalToken.get() + spent);
        (*portfolioStorge)[_portfolioName] = &pInfo[0];
        
        
        
        


        (*portfolioBalance)[_portfolioName] = finalBalance;
        *totalToken = totalToken.get() + finalBalance; 
        *ownerTotalToken = ownerTotalToken.get() + spent;
        DIPC_EMIT_EVENT(createOrder, "portfolioName", _portfolioName, "OrderInfo", &order.toJson()[0], "portfolioBalance", finalBalance);
    }

    
    EXPORT void PortfolioManage::dealOrder(char* _portfolioName, char* _orderId){
        u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
isOwner();
        std::string pInfo = portfolioStorge.get()[_portfolioName];
        
        
        PortfolioInfo info;
        info.parseJson(pInfo);
        

        
         Order ord = info.getOrder(_orderId);
         
         
        if(ord.orderId != "" && ord.orderStatus == 0){
            
            uint64_t timenow = dipc::timestamp();
            if(ord.endTime > timenow){
                ord.orderStatus = 1;
            }else {
                ord.orderStatus = 3;
            }
        } else {
          

            return;
        }
        

        uint64_t sellValue = 0;
        if(ord.orderType == 0){
            sellValue = ord.stockAmount * ord.stockPrice;
        }
        uint64_t currentBalance =  portfolioBalance.get()[_portfolioName];
        

        DipcAssert(currentBalance + sellValue >= currentBalance);
        DipcAssert((ownerTotalToken.get() - sellValue) <= ownerTotalToken.get());
        


        (*portfolioBalance)[_portfolioName] = currentBalance + sellValue;
        *ownerTotalToken = ownerTotalToken.get() - sellValue;
        (*portfolioStorge)[_portfolioName] = &info.toJson()[0];
        
        
        
        

        DIPC_EMIT_EVENT(dealPortfolio, "orderId", _orderId, "orderInfo", &ord.toJson()[0]);
    }
    
    EXPORT void PortfolioManage::revocationOrder(char* _portfolioName, char* _orderId){
        u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
std::string pInfo = portfolioStorge.get()[_portfolioName];
        
        
        PortfolioInfo info;
        info.parseJson(pInfo);
        Order ord = info.getOrder(_orderId);
        
        
        if(ord.orderId != "" && ord.orderStatus == 0){
            std::string callerStr = caller().toString();
            
            
            
            DipcAssert(info.getOwnerAddress() == caller().toString());
            

            uint64_t timenow = dipc::timestamp();
            if(ord.endTime > timenow){
                ord.orderStatus = 2;
            }else {
                ord.orderStatus = 3;
            }
        } else {
            return;
        }
        uint64_t lockToken = 0;
        if(ord.orderType == 1){
            lockToken = ord.stockPrice * ord.stockAmount;
        }
        uint64_t currentBalance =  portfolioBalance.get()[_portfolioName];
        
        
        
        

        DipcAssert(currentBalance + lockToken >= currentBalance);
        DipcAssert(ownerTotalToken.get() - lockToken <= ownerTotalToken.get());

        
        (*portfolioBalance)[_portfolioName] = currentBalance + lockToken;
        *ownerTotalToken = ownerTotalToken.get() - lockToken;
        (*portfolioStorge)[_portfolioName] = &info.toJson()[0];
        DIPC_EMIT_EVENT(revocationPortfolio, "orderId", _orderId, "orderInfo", &ord.toJson()[0]);
    }
    
    EXPORT void PortfolioManage::withdrawPortfolio(char* _portfolioName, uint64_t _withdrawBalance){
         u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
if(!userCanWithdraw.get()){
             return;
         }
         uint64_t currentBalance =  portfolioBalance.get()[_portfolioName];
         DipcAssert(currentBalance - _withdrawBalance < currentBalance);
         auto coinBalance = changeUint64ToU256WithChangeRate(currentBalance, changeRate.get());
         (*portfolioBalance)[_portfolioName] = currentBalance - _withdrawBalance;
         callTransfer(caller(), coinBalance);
    }
    
    EXPORT void PortfolioManage::withdrawPool(uint64_t _balance){
        u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
isOwner();
        Address ownerAddr = Address(owner.get()); 
        callTransfer(ownerAddr, _balance);
        *ownerTotalToken = ownerTotalToken.get() - _balance * changeRate.get();
        *totalToken = totalToken.get() - _balance * changeRate.get();
        DIPC_EMIT_EVENT(tokenCount, "ownerTotalToken", ownerTotalToken.get(), "totalToken", totalToken.get());
    }
    
    PAYABLE void PortfolioManage::depositPool(uint64_t _depositValue){
        isOwner();
        
        uint64_t tokenBalance = changeU256ToUint64WithChangeRate(callValue(), changeRate.get()); 
        *ownerTotalToken = ownerTotalToken.get() + tokenBalance;
        *totalToken = totalToken.get() + tokenBalance;
        DIPC_EMIT_EVENT(tokenCount, "ownerTotalToken", ownerTotalToken.get(), "totalToken", totalToken.get());
    }
     
    CONSTANT uint64_t PortfolioManage::queryTotalToken(){
        u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
return totalToken.get();
    }

     
    CONSTANT uint64_t PortfolioManage::queryPortfolioBalance(char* _portfolioName){
        u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
return portfolioBalance.get()[_portfolioName];
    }

    
    CONSTANT bool PortfolioManage::queryPortfolioNameIfUsed(char* _portfolioName){
        if(portfolioStorge.get()[_portfolioName] != ""){
            return true;
        } 
        return false;
    }

    
    CONSTANT uint64_t PortfolioManage::queryChangeRate(){
        return changeRate.get();
    }

2019-12-19_15:14:55.044388: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:401] abis.ispayable :false

2019-12-19_15:14:55.044408: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:424] finalContract  this height  #include "PortfolioManage.hpp"

    
    PAYABLE void PortfolioManage::init(){
        *owner = caller().toString();
        *changeRate = 10000;
        *userCanWithdraw = false;
        uint64_t tokenBalance = getTotalBalance();
        
        *ownerTotalToken = tokenBalance;
        *totalToken = ownerTotalToken.get();
        
        
        DIPC_EMIT_EVENT(initEvent, "ownerTotalToken" ,tokenBalance);
    }
    
     
    EXPORT void PortfolioManage::setChangeRate(uint64_t _changeRate){
        u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
isOwner();
        *changeRate = _changeRate;
    }
     
    EXPORT void PortfolioManage::setUserCanWithdraw(bool _canWithdraw){
        u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
isOwner();
        *userCanWithdraw = _canWithdraw;
    }

    
    PAYABLE void PortfolioManage::createPortfolio(char* _portfolioName, char* _portfolioDesc){
        if(portfolioStorge.get()[_portfolioName] != ""){
            DIPC_EMIT_EVENT(ErrEvent, "Current portfolio exist: ", _portfolioName);
            return;
        } 
        std::string callerAddr = caller().toString();
        uint64_t tokenBalance = getTotalBalance();
        
        PortfolioInfo info(_portfolioName, _portfolioDesc, &callerAddr[0]);
        std::string portfolioStr = info.toJson();
        
        
        

        (*portfolioStorge)[_portfolioName] = portfolioStr;
        DipcAssert(totalToken.get() + tokenBalance > totalToken);
        (*portfolioBalance)[_portfolioName] = tokenBalance;
        *totalToken = totalToken.get() + tokenBalance; 
        
        DIPC_EMIT_EVENT(portfolioInfo, _portfolioName, &portfolioStr[0], "portfolioBalance", tokenBalance);
    }

    
    PAYABLE void PortfolioManage::depositPortfolio(char* _portfolioName){
        uint64_t tokenBalance = getTotalBalance();
        
        uint64_t currentBalance = portfolioBalance.get()[_portfolioName];
        uint64_t finalBalance  = currentBalance + tokenBalance;
        DipcAssert(totalToken.get() + tokenBalance > totalToken);
        DipcAssert(finalBalance > currentBalance);
        (*portfolioBalance)[_portfolioName] = finalBalance;
        *totalToken = totalToken.get() + finalBalance; 
        DIPC_EMIT_EVENT(depositPortfolio, "portfolioName", _portfolioName, "portfolioBalance", finalBalance);
    }
    
    PAYABLE void PortfolioManage::createOrder(char* _portfolioName, char* _orderId, uint16_t _orderType, char* _stockCode, uint64_t _stockPrice, uint64_t _stockAmount, uint64_t _endTime){
        uint64_t tokenBalance = getTotalBalance();
        DIPC_EMIT_EVENT(createOrder, "portfolioName", _portfolioName, "OrderInfo", "ignore", "tokenBalance", tokenBalance);
        uint64_t spent = 0;
        if(_orderType == 1){
            spent = _stockPrice * _stockAmount;
            DipcAssert((portfolioBalance.get()[_portfolioName] + tokenBalance) > spent);
        }
        struct Order order{_orderId, _orderType, _stockCode, _stockPrice, _stockAmount, _endTime, 0};
        std::string pInfo = portfolioStorge.get()[_portfolioName];
        
        
        
        if(pInfo == "") {
            DIPC_EMIT_EVENT(ErrEvent, "Current portfolio  doesn't exist: ", _portfolioName);
            return;
        }
        PortfolioInfo info;
        info.parseJson(pInfo);
        if(info.getOrder(_orderId).orderId != ""){
            DIPC_EMIT_EVENT(ErrEvent, "Current order exist: ", _orderId);
            return;
        }
        info.addOrder(order);
        pInfo = info.toJson();

        uint64_t currentBalance = portfolioBalance.get()[_portfolioName] ;
        uint64_t finalBalance = currentBalance + tokenBalance - spent;
        DipcAssert(totalToken.get() + tokenBalance > totalToken);
        
        DipcAssert(ownerTotalToken.get() < ownerTotalToken.get() + spent);
        (*portfolioStorge)[_portfolioName] = &pInfo[0];
        
        
        
        


        (*portfolioBalance)[_portfolioName] = finalBalance;
        *totalToken = totalToken.get() + finalBalance; 
        *ownerTotalToken = ownerTotalToken.get() + spent;
        DIPC_EMIT_EVENT(createOrder, "portfolioName", _portfolioName, "OrderInfo", &order.toJson()[0], "portfolioBalance", finalBalance);
    }

    
    EXPORT void PortfolioManage::dealOrder(char* _portfolioName, char* _orderId){
        u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
isOwner();
        std::string pInfo = portfolioStorge.get()[_portfolioName];
        
        
        PortfolioInfo info;
        info.parseJson(pInfo);
        

        
         Order ord = info.getOrder(_orderId);
         
         
        if(ord.orderId != "" && ord.orderStatus == 0){
            
            uint64_t timenow = dipc::timestamp();
            if(ord.endTime > timenow){
                ord.orderStatus = 1;
            }else {
                ord.orderStatus = 3;
            }
        } else {
          

            return;
        }
        

        uint64_t sellValue = 0;
        if(ord.orderType == 0){
            sellValue = ord.stockAmount * ord.stockPrice;
        }
        uint64_t currentBalance =  portfolioBalance.get()[_portfolioName];
        

        DipcAssert(currentBalance + sellValue >= currentBalance);
        DipcAssert((ownerTotalToken.get() - sellValue) <= ownerTotalToken.get());
        


        (*portfolioBalance)[_portfolioName] = currentBalance + sellValue;
        *ownerTotalToken = ownerTotalToken.get() - sellValue;
        (*portfolioStorge)[_portfolioName] = &info.toJson()[0];
        
        
        
        

        DIPC_EMIT_EVENT(dealPortfolio, "orderId", _orderId, "orderInfo", &ord.toJson()[0]);
    }
    
    EXPORT void PortfolioManage::revocationOrder(char* _portfolioName, char* _orderId){
        u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
std::string pInfo = portfolioStorge.get()[_portfolioName];
        
        
        PortfolioInfo info;
        info.parseJson(pInfo);
        Order ord = info.getOrder(_orderId);
        
        
        if(ord.orderId != "" && ord.orderStatus == 0){
            std::string callerStr = caller().toString();
            
            
            
            DipcAssert(info.getOwnerAddress() == caller().toString());
            

            uint64_t timenow = dipc::timestamp();
            if(ord.endTime > timenow){
                ord.orderStatus = 2;
            }else {
                ord.orderStatus = 3;
            }
        } else {
            return;
        }
        uint64_t lockToken = 0;
        if(ord.orderType == 1){
            lockToken = ord.stockPrice * ord.stockAmount;
        }
        uint64_t currentBalance =  portfolioBalance.get()[_portfolioName];
        
        
        
        

        DipcAssert(currentBalance + lockToken >= currentBalance);
        DipcAssert(ownerTotalToken.get() - lockToken <= ownerTotalToken.get());

        
        (*portfolioBalance)[_portfolioName] = currentBalance + lockToken;
        *ownerTotalToken = ownerTotalToken.get() - lockToken;
        (*portfolioStorge)[_portfolioName] = &info.toJson()[0];
        DIPC_EMIT_EVENT(revocationPortfolio, "orderId", _orderId, "orderInfo", &ord.toJson()[0]);
    }
    
    EXPORT void PortfolioManage::withdrawPortfolio(char* _portfolioName, uint64_t _withdrawBalance){
         u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
if(!userCanWithdraw.get()){
             return;
         }
         uint64_t currentBalance =  portfolioBalance.get()[_portfolioName];
         DipcAssert(currentBalance - _withdrawBalance < currentBalance);
         auto coinBalance = changeUint64ToU256WithChangeRate(currentBalance, changeRate.get());
         (*portfolioBalance)[_portfolioName] = currentBalance - _withdrawBalance;
         callTransfer(caller(), coinBalance);
    }
    
    EXPORT void PortfolioManage::withdrawPool(uint64_t _balance){
        u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
isOwner();
        Address ownerAddr = Address(owner.get()); 
        callTransfer(ownerAddr, _balance);
        *ownerTotalToken = ownerTotalToken.get() - _balance * changeRate.get();
        *totalToken = totalToken.get() - _balance * changeRate.get();
        DIPC_EMIT_EVENT(tokenCount, "ownerTotalToken", ownerTotalToken.get(), "totalToken", totalToken.get());
    }
    
    PAYABLE void PortfolioManage::depositPool(uint64_t _depositValue){
        isOwner();
        
        uint64_t tokenBalance = changeU256ToUint64WithChangeRate(callValue(), changeRate.get()); 
        *ownerTotalToken = ownerTotalToken.get() + tokenBalance;
        *totalToken = totalToken.get() + tokenBalance;
        DIPC_EMIT_EVENT(tokenCount, "ownerTotalToken", ownerTotalToken.get(), "totalToken", totalToken.get());
    }
     
    CONSTANT uint64_t PortfolioManage::queryTotalToken(){
        u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
return totalToken.get();
    }

     
    CONSTANT uint64_t PortfolioManage::queryPortfolioBalance(char* _portfolioName){
        u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
return portfolioBalance.get()[_portfolioName];
    }

    
    CONSTANT bool PortfolioManage::queryPortfolioNameIfUsed(char* _portfolioName){
        if(portfolioStorge.get()[_portfolioName] != ""){
            return true;
        } 
        return false;
    }

    
    CONSTANT uint64_t PortfolioManage::queryChangeRate(){
        return changeRate.get();
    } codetext height #include "PortfolioManage.hpp"

    
    PAYABLE void PortfolioManage::init(){
        *owner = caller().toString();
        *changeRate = 10000;
        *userCanWithdraw = false;
        uint64_t tokenBalance = getTotalBalance();
        
        *ownerTotalToken = tokenBalance;
        *totalToken = ownerTotalToken.get();
        
        
        DIPC_EMIT_EVENT(initEvent, "ownerTotalToken" ,tokenBalance);
    }
    
     
    EXPORT void PortfolioManage::setChangeRate(uint64_t _changeRate){
        u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
isOwner();
        *changeRate = _changeRate;
    }
     
    EXPORT void PortfolioManage::setUserCanWithdraw(bool _canWithdraw){
        u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
isOwner();
        *userCanWithdraw = _canWithdraw;
    }

    
    PAYABLE void PortfolioManage::createPortfolio(char* _portfolioName, char* _portfolioDesc){
        if(portfolioStorge.get()[_portfolioName] != ""){
            DIPC_EMIT_EVENT(ErrEvent, "Current portfolio exist: ", _portfolioName);
            return;
        } 
        std::string callerAddr = caller().toString();
        uint64_t tokenBalance = getTotalBalance();
        
        PortfolioInfo info(_portfolioName, _portfolioDesc, &callerAddr[0]);
        std::string portfolioStr = info.toJson();
        
        
        

        (*portfolioStorge)[_portfolioName] = portfolioStr;
        DipcAssert(totalToken.get() + tokenBalance > totalToken);
        (*portfolioBalance)[_portfolioName] = tokenBalance;
        *totalToken = totalToken.get() + tokenBalance; 
        
        DIPC_EMIT_EVENT(portfolioInfo, _portfolioName, &portfolioStr[0], "portfolioBalance", tokenBalance);
    }

    
    PAYABLE void PortfolioManage::depositPortfolio(char* _portfolioName){
        uint64_t tokenBalance = getTotalBalance();
        
        uint64_t currentBalance = portfolioBalance.get()[_portfolioName];
        uint64_t finalBalance  = currentBalance + tokenBalance;
        DipcAssert(totalToken.get() + tokenBalance > totalToken);
        DipcAssert(finalBalance > currentBalance);
        (*portfolioBalance)[_portfolioName] = finalBalance;
        *totalToken = totalToken.get() + finalBalance; 
        DIPC_EMIT_EVENT(depositPortfolio, "portfolioName", _portfolioName, "portfolioBalance", finalBalance);
    }
    
    PAYABLE void PortfolioManage::createOrder(char* _portfolioName, char* _orderId, uint16_t _orderType, char* _stockCode, uint64_t _stockPrice, uint64_t _stockAmount, uint64_t _endTime){
        uint64_t tokenBalance = getTotalBalance();
        DIPC_EMIT_EVENT(createOrder, "portfolioName", _portfolioName, "OrderInfo", "ignore", "tokenBalance", tokenBalance);
        uint64_t spent = 0;
        if(_orderType == 1){
            spent = _stockPrice * _stockAmount;
            DipcAssert((portfolioBalance.get()[_portfolioName] + tokenBalance) > spent);
        }
        struct Order order{_orderId, _orderType, _stockCode, _stockPrice, _stockAmount, _endTime, 0};
        std::string pInfo = portfolioStorge.get()[_portfolioName];
        
        
        
        if(pInfo == "") {
            DIPC_EMIT_EVENT(ErrEvent, "Current portfolio  doesn't exist: ", _portfolioName);
            return;
        }
        PortfolioInfo info;
        info.parseJson(pInfo);
        if(info.getOrder(_orderId).orderId != ""){
            DIPC_EMIT_EVENT(ErrEvent, "Current order exist: ", _orderId);
            return;
        }
        info.addOrder(order);
        pInfo = info.toJson();

        uint64_t currentBalance = portfolioBalance.get()[_portfolioName] ;
        uint64_t finalBalance = currentBalance + tokenBalance - spent;
        DipcAssert(totalToken.get() + tokenBalance > totalToken);
        
        DipcAssert(ownerTotalToken.get() < ownerTotalToken.get() + spent);
        (*portfolioStorge)[_portfolioName] = &pInfo[0];
        
        
        
        


        (*portfolioBalance)[_portfolioName] = finalBalance;
        *totalToken = totalToken.get() + finalBalance; 
        *ownerTotalToken = ownerTotalToken.get() + spent;
        DIPC_EMIT_EVENT(createOrder, "portfolioName", _portfolioName, "OrderInfo", &order.toJson()[0], "portfolioBalance", finalBalance);
    }

    
    EXPORT void PortfolioManage::dealOrder(char* _portfolioName, char* _orderId){
        u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
isOwner();
        std::string pInfo = portfolioStorge.get()[_portfolioName];
        
        
        PortfolioInfo info;
        info.parseJson(pInfo);
        

        
         Order ord = info.getOrder(_orderId);
         
         
        if(ord.orderId != "" && ord.orderStatus == 0){
            
            uint64_t timenow = dipc::timestamp();
            if(ord.endTime > timenow){
                ord.orderStatus = 1;
            }else {
                ord.orderStatus = 3;
            }
        } else {
          

            return;
        }
        

        uint64_t sellValue = 0;
        if(ord.orderType == 0){
            sellValue = ord.stockAmount * ord.stockPrice;
        }
        uint64_t currentBalance =  portfolioBalance.get()[_portfolioName];
        

        DipcAssert(currentBalance + sellValue >= currentBalance);
        DipcAssert((ownerTotalToken.get() - sellValue) <= ownerTotalToken.get());
        


        (*portfolioBalance)[_portfolioName] = currentBalance + sellValue;
        *ownerTotalToken = ownerTotalToken.get() - sellValue;
        (*portfolioStorge)[_portfolioName] = &info.toJson()[0];
        
        
        
        

        DIPC_EMIT_EVENT(dealPortfolio, "orderId", _orderId, "orderInfo", &ord.toJson()[0]);
    }
    
    EXPORT void PortfolioManage::revocationOrder(char* _portfolioName, char* _orderId){
        u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
std::string pInfo = portfolioStorge.get()[_portfolioName];
        
        
        PortfolioInfo info;
        info.parseJson(pInfo);
        Order ord = info.getOrder(_orderId);
        
        
        if(ord.orderId != "" && ord.orderStatus == 0){
            std::string callerStr = caller().toString();
            
            
            
            DipcAssert(info.getOwnerAddress() == caller().toString());
            

            uint64_t timenow = dipc::timestamp();
            if(ord.endTime > timenow){
                ord.orderStatus = 2;
            }else {
                ord.orderStatus = 3;
            }
        } else {
            return;
        }
        uint64_t lockToken = 0;
        if(ord.orderType == 1){
            lockToken = ord.stockPrice * ord.stockAmount;
        }
        uint64_t currentBalance =  portfolioBalance.get()[_portfolioName];
        
        
        
        

        DipcAssert(currentBalance + lockToken >= currentBalance);
        DipcAssert(ownerTotalToken.get() - lockToken <= ownerTotalToken.get());

        
        (*portfolioBalance)[_portfolioName] = currentBalance + lockToken;
        *ownerTotalToken = ownerTotalToken.get() - lockToken;
        (*portfolioStorge)[_portfolioName] = &info.toJson()[0];
        DIPC_EMIT_EVENT(revocationPortfolio, "orderId", _orderId, "orderInfo", &ord.toJson()[0]);
    }
    
    EXPORT void PortfolioManage::withdrawPortfolio(char* _portfolioName, uint64_t _withdrawBalance){
         u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
if(!userCanWithdraw.get()){
             return;
         }
         uint64_t currentBalance =  portfolioBalance.get()[_portfolioName];
         DipcAssert(currentBalance - _withdrawBalance < currentBalance);
         auto coinBalance = changeUint64ToU256WithChangeRate(currentBalance, changeRate.get());
         (*portfolioBalance)[_portfolioName] = currentBalance - _withdrawBalance;
         callTransfer(caller(), coinBalance);
    }
    
    EXPORT void PortfolioManage::withdrawPool(uint64_t _balance){
        u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
isOwner();
        Address ownerAddr = Address(owner.get()); 
        callTransfer(ownerAddr, _balance);
        *ownerTotalToken = ownerTotalToken.get() - _balance * changeRate.get();
        *totalToken = totalToken.get() - _balance * changeRate.get();
        DIPC_EMIT_EVENT(tokenCount, "ownerTotalToken", ownerTotalToken.get(), "totalToken", totalToken.get());
    }
    
    PAYABLE void PortfolioManage::depositPool(uint64_t _depositValue){
        isOwner();
        
        uint64_t tokenBalance = changeU256ToUint64WithChangeRate(callValue(), changeRate.get()); 
        *ownerTotalToken = ownerTotalToken.get() + tokenBalance;
        *totalToken = totalToken.get() + tokenBalance;
        DIPC_EMIT_EVENT(tokenCount, "ownerTotalToken", ownerTotalToken.get(), "totalToken", totalToken.get());
    }
     
    CONSTANT uint64_t PortfolioManage::queryTotalToken(){
        u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
return totalToken.get();
    }

     
    CONSTANT uint64_t PortfolioManage::queryPortfolioBalance(char* _portfolioName){
        u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
return portfolioBalance.get()[_portfolioName];
    }

    
    CONSTANT bool PortfolioManage::queryPortfolioNameIfUsed(char* _portfolioName){
        if(portfolioStorge.get()[_portfolioName] != ""){
            return true;
        } 
        return false;
    }

    
    CONSTANT uint64_t PortfolioManage::queryChangeRate(){
        return changeRate.get();
    }

2019-12-19_15:14:55.044419: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:427] searchContext  #include "PortfolioManage.hpp"

    
    PAYABLE void PortfolioManage::init(){
        *owner = caller().toString();
        *changeRate = 10000;
        *userCanWithdraw = false;
        uint64_t tokenBalance = getTotalBalance();
        
        *ownerTotalToken = tokenBalance;
        *totalToken = ownerTotalToken.get();
        
        
        DIPC_EMIT_EVENT(initEvent, "ownerTotalToken" ,tokenBalance);
    }
    
     
    EXPORT void PortfolioManage::setChangeRate(uint64_t _changeRate){
        u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
isOwner();
        *changeRate = _changeRate;
    }
     
    EXPORT void PortfolioManage::setUserCanWithdraw(bool _canWithdraw){
        u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
isOwner();
        *userCanWithdraw = _canWithdraw;
    }

    
    PAYABLE void PortfolioManage::createPortfolio(char* _portfolioName, char* _portfolioDesc){
        if(portfolioStorge.get()[_portfolioName] != ""){
            DIPC_EMIT_EVENT(ErrEvent, "Current portfolio exist: ", _portfolioName);
            return;
        } 
        std::string callerAddr = caller().toString();
        uint64_t tokenBalance = getTotalBalance();
        
        PortfolioInfo info(_portfolioName, _portfolioDesc, &callerAddr[0]);
        std::string portfolioStr = info.toJson();
        
        
        

        (*portfolioStorge)[_portfolioName] = portfolioStr;
        DipcAssert(totalToken.get() + tokenBalance > totalToken);
        (*portfolioBalance)[_portfolioName] = tokenBalance;
        *totalToken = totalToken.get() + tokenBalance; 
        
        DIPC_EMIT_EVENT(portfolioInfo, _portfolioName, &portfolioStr[0], "portfolioBalance", tokenBalance);
    }

    
    PAYABLE void PortfolioManage::depositPortfolio(char* _portfolioName){
        uint64_t tokenBalance = getTotalBalance();
        
        uint64_t currentBalance = portfolioBalance.get()[_portfolioName];
        uint64_t finalBalance  = currentBalance + tokenBalance;
        DipcAssert(totalToken.get() + tokenBalance > totalToken);
        DipcAssert(finalBalance > currentBalance);
        (*portfolioBalance)[_portfolioName] = finalBalance;
        *totalToken = totalToken.get() + finalBalance; 
        DIPC_EMIT_EVENT(depositPortfolio, "portfolioName", _portfolioName, "portfolioBalance", finalBalance);
    }
    
    PAYABLE void PortfolioManage::createOrder(char* _portfolioName, char* _orderId, uint16_t _orderType, char* _stockCode, uint64_t _stockPrice, uint64_t _stockAmount, uint64_t _endTime){
        uint64_t tokenBalance = getTotalBalance();
        DIPC_EMIT_EVENT(createOrder, "portfolioName", _portfolioName, "OrderInfo", "ignore", "tokenBalance", tokenBalance);
        uint64_t spent = 0;
        if(_orderType == 1){
            spent = _stockPrice * _stockAmount;
            DipcAssert((portfolioBalance.get()[_portfolioName] + tokenBalance) > spent);
        }
        struct Order order{_orderId, _orderType, _stockCode, _stockPrice, _stockAmount, _endTime, 0};
        std::string pInfo = portfolioStorge.get()[_portfolioName];
        
        
        
        if(pInfo == "") {
            DIPC_EMIT_EVENT(ErrEvent, "Current portfolio  doesn't exist: ", _portfolioName);
            return;
        }
        PortfolioInfo info;
        info.parseJson(pInfo);
        if(info.getOrder(_orderId).orderId != ""){
            DIPC_EMIT_EVENT(ErrEvent, "Current order exist: ", _orderId);
            return;
        }
        info.addOrder(order);
        pInfo = info.toJson();

        uint64_t currentBalance = portfolioBalance.get()[_portfolioName] ;
        uint64_t finalBalance = currentBalance + tokenBalance - spent;
        DipcAssert(totalToken.get() + tokenBalance > totalToken);
        
        DipcAssert(ownerTotalToken.get() < ownerTotalToken.get() + spent);
        (*portfolioStorge)[_portfolioName] = &pInfo[0];
        
        
        
        


        (*portfolioBalance)[_portfolioName] = finalBalance;
        *totalToken = totalToken.get() + finalBalance; 
        *ownerTotalToken = ownerTotalToken.get() + spent;
        DIPC_EMIT_EVENT(createOrder, "portfolioName", _portfolioName, "OrderInfo", &order.toJson()[0], "portfolioBalance", finalBalance);
    }

    
    EXPORT void PortfolioManage::dealOrder(char* _portfolioName, char* _orderId){
        u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
isOwner();
        std::string pInfo = portfolioStorge.get()[_portfolioName];
        
        
        PortfolioInfo info;
        info.parseJson(pInfo);
        

        
         Order ord = info.getOrder(_orderId);
         
         
        if(ord.orderId != "" && ord.orderStatus == 0){
            
            uint64_t timenow = dipc::timestamp();
            if(ord.endTime > timenow){
                ord.orderStatus = 1;
            }else {
                ord.orderStatus = 3;
            }
        } else {
          

            return;
        }
        

        uint64_t sellValue = 0;
        if(ord.orderType == 0){
            sellValue = ord.stockAmount * ord.stockPrice;
        }
        uint64_t currentBalance =  portfolioBalance.get()[_portfolioName];
        

        DipcAssert(currentBalance + sellValue >= currentBalance);
        DipcAssert((ownerTotalToken.get() - sellValue) <= ownerTotalToken.get());
        


        (*portfolioBalance)[_portfolioName] = currentBalance + sellValue;
        *ownerTotalToken = ownerTotalToken.get() - sellValue;
        (*portfolioStorge)[_portfolioName] = &info.toJson()[0];
        
        
        
        

        DIPC_EMIT_EVENT(dealPortfolio, "orderId", _orderId, "orderInfo", &ord.toJson()[0]);
    }
    
    EXPORT void PortfolioManage::revocationOrder(char* _portfolioName, char* _orderId){
        u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
std::string pInfo = portfolioStorge.get()[_portfolioName];
        
        
        PortfolioInfo info;
        info.parseJson(pInfo);
        Order ord = info.getOrder(_orderId);
        
        
        if(ord.orderId != "" && ord.orderStatus == 0){
            std::string callerStr = caller().toString();
            
            
            
            DipcAssert(info.getOwnerAddress() == caller().toString());
            

            uint64_t timenow = dipc::timestamp();
            if(ord.endTime > timenow){
                ord.orderStatus = 2;
            }else {
                ord.orderStatus = 3;
            }
        } else {
            return;
        }
        uint64_t lockToken = 0;
        if(ord.orderType == 1){
            lockToken = ord.stockPrice * ord.stockAmount;
        }
        uint64_t currentBalance =  portfolioBalance.get()[_portfolioName];
        
        
        
        

        DipcAssert(currentBalance + lockToken >= currentBalance);
        DipcAssert(ownerTotalToken.get() - lockToken <= ownerTotalToken.get());

        
        (*portfolioBalance)[_portfolioName] = currentBalance + lockToken;
        *ownerTotalToken = ownerTotalToken.get() - lockToken;
        (*portfolioStorge)[_portfolioName] = &info.toJson()[0];
        DIPC_EMIT_EVENT(revocationPortfolio, "orderId", _orderId, "orderInfo", &ord.toJson()[0]);
    }
    
    EXPORT void PortfolioManage::withdrawPortfolio(char* _portfolioName, uint64_t _withdrawBalance){
         u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
if(!userCanWithdraw.get()){
             return;
         }
         uint64_t currentBalance =  portfolioBalance.get()[_portfolioName];
         DipcAssert(currentBalance - _withdrawBalance < currentBalance);
         auto coinBalance = changeUint64ToU256WithChangeRate(currentBalance, changeRate.get());
         (*portfolioBalance)[_portfolioName] = currentBalance - _withdrawBalance;
         callTransfer(caller(), coinBalance);
    }
    
    EXPORT void PortfolioManage::withdrawPool(uint64_t _balance){
        u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
isOwner();
        Address ownerAddr = Address(owner.get()); 
        callTransfer(ownerAddr, _balance);
        *ownerTotalToken = ownerTotalToken.get() - _balance * changeRate.get();
        *totalToken = totalToken.get() - _balance * changeRate.get();
        DIPC_EMIT_EVENT(tokenCount, "ownerTotalToken", ownerTotalToken.get(), "totalToken", totalToken.get());
    }
    
    PAYABLE void PortfolioManage::depositPool(uint64_t _depositValue){
        isOwner();
        
        uint64_t tokenBalance = changeU256ToUint64WithChangeRate(callValue(), changeRate.get()); 
        *ownerTotalToken = ownerTotalToken.get() + tokenBalance;
        *totalToken = totalToken.get() + tokenBalance;
        DIPC_EMIT_EVENT(tokenCount, "ownerTotalToken", ownerTotalToken.get(), "totalToken", totalToken.get());
    }
     
    CONSTANT uint64_t PortfolioManage::queryTotalToken(){
        u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
return totalToken.get();
    }

     
    CONSTANT uint64_t PortfolioManage::queryPortfolioBalance(char* _portfolioName){
        u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
return portfolioBalance.get()[_portfolioName];
    }

    
    CONSTANT bool PortfolioManage::queryPortfolioNameIfUsed(char* _portfolioName){
        if(portfolioStorge.get()[_portfolioName] != ""){
            return true;
        } 
        return false;
    }

    
    CONSTANT uint64_t PortfolioManage::queryChangeRate(){
        return changeRate.get();
    }

2019-12-19_15:14:55.367135: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:451] log out out  Export :

    
    CONSTANT bool PortfolioManage::queryPortfolioNameIfUsed(char* _portfolioName){
        

2019-12-19_15:14:55.367159: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:457] name : queryPortfolioNameIfUsed   pos1  0

2019-12-19_15:14:55.367171: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:469] pos2  9172   pos1  9172

2019-12-19_15:14:55.367179: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:500] pos2 after 9382   pos1  9172

2019-12-19_15:14:55.367188: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:509] finalContract  first #include "PortfolioManage.hpp"

    
    PAYABLE void PortfolioManage::init(){
        *owner = caller().toString();
        *changeRate = 10000;
        *userCanWithdraw = false;
        uint64_t tokenBalance = getTotalBalance();
        
        *ownerTotalToken = tokenBalance;
        *totalToken = ownerTotalToken.get();
        
        
        DIPC_EMIT_EVENT(initEvent, "ownerTotalToken" ,tokenBalance);
    }
    
     
    EXPORT void PortfolioManage::setChangeRate(uint64_t _changeRate){
        u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
isOwner();
        *changeRate = _changeRate;
    }
     
    EXPORT void PortfolioManage::setUserCanWithdraw(bool _canWithdraw){
        u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
isOwner();
        *userCanWithdraw = _canWithdraw;
    }

    
    PAYABLE void PortfolioManage::createPortfolio(char* _portfolioName, char* _portfolioDesc){
        if(portfolioStorge.get()[_portfolioName] != ""){
            DIPC_EMIT_EVENT(ErrEvent, "Current portfolio exist: ", _portfolioName);
            return;
        } 
        std::string callerAddr = caller().toString();
        uint64_t tokenBalance = getTotalBalance();
        
        PortfolioInfo info(_portfolioName, _portfolioDesc, &callerAddr[0]);
        std::string portfolioStr = info.toJson();
        
        
        

        (*portfolioStorge)[_portfolioName] = portfolioStr;
        DipcAssert(totalToken.get() + tokenBalance > totalToken);
        (*portfolioBalance)[_portfolioName] = tokenBalance;
        *totalToken = totalToken.get() + tokenBalance; 
        
        DIPC_EMIT_EVENT(portfolioInfo, _portfolioName, &portfolioStr[0], "portfolioBalance", tokenBalance);
    }

    
    PAYABLE void PortfolioManage::depositPortfolio(char* _portfolioName){
        uint64_t tokenBalance = getTotalBalance();
        
        uint64_t currentBalance = portfolioBalance.get()[_portfolioName];
        uint64_t finalBalance  = currentBalance + tokenBalance;
        DipcAssert(totalToken.get() + tokenBalance > totalToken);
        DipcAssert(finalBalance > currentBalance);
        (*portfolioBalance)[_portfolioName] = finalBalance;
        *totalToken = totalToken.get() + finalBalance; 
        DIPC_EMIT_EVENT(depositPortfolio, "portfolioName", _portfolioName, "portfolioBalance", finalBalance);
    }
    
    PAYABLE void PortfolioManage::createOrder(char* _portfolioName, char* _orderId, uint16_t _orderType, char* _stockCode, uint64_t _stockPrice, uint64_t _stockAmount, uint64_t _endTime){
        uint64_t tokenBalance = getTotalBalance();
        DIPC_EMIT_EVENT(createOrder, "portfolioName", _portfolioName, "OrderInfo", "ignore", "tokenBalance", tokenBalance);
        uint64_t spent = 0;
        if(_orderType == 1){
            spent = _stockPrice * _stockAmount;
            DipcAssert((portfolioBalance.get()[_portfolioName] + tokenBalance) > spent);
        }
        struct Order order{_orderId, _orderType, _stockCode, _stockPrice, _stockAmount, _endTime, 0};
        std::string pInfo = portfolioStorge.get()[_portfolioName];
        
        
        
        if(pInfo == "") {
            DIPC_EMIT_EVENT(ErrEvent, "Current portfolio  doesn't exist: ", _portfolioName);
            return;
        }
        PortfolioInfo info;
        info.parseJson(pInfo);
        if(info.getOrder(_orderId).orderId != ""){
            DIPC_EMIT_EVENT(ErrEvent, "Current order exist: ", _orderId);
            return;
        }
        info.addOrder(order);
        pInfo = info.toJson();

        uint64_t currentBalance = portfolioBalance.get()[_portfolioName] ;
        uint64_t finalBalance = currentBalance + tokenBalance - spent;
        DipcAssert(totalToken.get() + tokenBalance > totalToken);
        
        DipcAssert(ownerTotalToken.get() < ownerTotalToken.get() + spent);
        (*portfolioStorge)[_portfolioName] = &pInfo[0];
        
        
        
        


        (*portfolioBalance)[_portfolioName] = finalBalance;
        *totalToken = totalToken.get() + finalBalance; 
        *ownerTotalToken = ownerTotalToken.get() + spent;
        DIPC_EMIT_EVENT(createOrder, "portfolioName", _portfolioName, "OrderInfo", &order.toJson()[0], "portfolioBalance", finalBalance);
    }

    
    EXPORT void PortfolioManage::dealOrder(char* _portfolioName, char* _orderId){
        u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
isOwner();
        std::string pInfo = portfolioStorge.get()[_portfolioName];
        
        
        PortfolioInfo info;
        info.parseJson(pInfo);
        

        
         Order ord = info.getOrder(_orderId);
         
         
        if(ord.orderId != "" && ord.orderStatus == 0){
            
            uint64_t timenow = dipc::timestamp();
            if(ord.endTime > timenow){
                ord.orderStatus = 1;
            }else {
                ord.orderStatus = 3;
            }
        } else {
          

            return;
        }
        

        uint64_t sellValue = 0;
        if(ord.orderType == 0){
            sellValue = ord.stockAmount * ord.stockPrice;
        }
        uint64_t currentBalance =  portfolioBalance.get()[_portfolioName];
        

        DipcAssert(currentBalance + sellValue >= currentBalance);
        DipcAssert((ownerTotalToken.get() - sellValue) <= ownerTotalToken.get());
        


        (*portfolioBalance)[_portfolioName] = currentBalance + sellValue;
        *ownerTotalToken = ownerTotalToken.get() - sellValue;
        (*portfolioStorge)[_portfolioName] = &info.toJson()[0];
        
        
        
        

        DIPC_EMIT_EVENT(dealPortfolio, "orderId", _orderId, "orderInfo", &ord.toJson()[0]);
    }
    
    EXPORT void PortfolioManage::revocationOrder(char* _portfolioName, char* _orderId){
        u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
std::string pInfo = portfolioStorge.get()[_portfolioName];
        
        
        PortfolioInfo info;
        info.parseJson(pInfo);
        Order ord = info.getOrder(_orderId);
        
        
        if(ord.orderId != "" && ord.orderStatus == 0){
            std::string callerStr = caller().toString();
            
            
            
            DipcAssert(info.getOwnerAddress() == caller().toString());
            

            uint64_t timenow = dipc::timestamp();
            if(ord.endTime > timenow){
                ord.orderStatus = 2;
            }else {
                ord.orderStatus = 3;
            }
        } else {
            return;
        }
        uint64_t lockToken = 0;
        if(ord.orderType == 1){
            lockToken = ord.stockPrice * ord.stockAmount;
        }
        uint64_t currentBalance =  portfolioBalance.get()[_portfolioName];
        
        
        
        

        DipcAssert(currentBalance + lockToken >= currentBalance);
        DipcAssert(ownerTotalToken.get() - lockToken <= ownerTotalToken.get());

        
        (*portfolioBalance)[_portfolioName] = currentBalance + lockToken;
        *ownerTotalToken = ownerTotalToken.get() - lockToken;
        (*portfolioStorge)[_portfolioName] = &info.toJson()[0];
        DIPC_EMIT_EVENT(revocationPortfolio, "orderId", _orderId, "orderInfo", &ord.toJson()[0]);
    }
    
    EXPORT void PortfolioManage::withdrawPortfolio(char* _portfolioName, uint64_t _withdrawBalance){
         u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
if(!userCanWithdraw.get()){
             return;
         }
         uint64_t currentBalance =  portfolioBalance.get()[_portfolioName];
         DipcAssert(currentBalance - _withdrawBalance < currentBalance);
         auto coinBalance = changeUint64ToU256WithChangeRate(currentBalance, changeRate.get());
         (*portfolioBalance)[_portfolioName] = currentBalance - _withdrawBalance;
         callTransfer(caller(), coinBalance);
    }
    
    EXPORT void PortfolioManage::withdrawPool(uint64_t _balance){
        u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
isOwner();
        Address ownerAddr = Address(owner.get()); 
        callTransfer(ownerAddr, _balance);
        *ownerTotalToken = ownerTotalToken.get() - _balance * changeRate.get();
        *totalToken = totalToken.get() - _balance * changeRate.get();
        DIPC_EMIT_EVENT(tokenCount, "ownerTotalToken", ownerTotalToken.get(), "totalToken", totalToken.get());
    }
    
    PAYABLE void PortfolioManage::depositPool(uint64_t _depositValue){
        isOwner();
        
        uint64_t tokenBalance = changeU256ToUint64WithChangeRate(callValue(), changeRate.get()); 
        *ownerTotalToken = ownerTotalToken.get() + tokenBalance;
        *totalToken = totalToken.get() + tokenBalance;
        DIPC_EMIT_EVENT(tokenCount, "ownerTotalToken", ownerTotalToken.get(), "totalToken", totalToken.get());
    }
     
    CONSTANT uint64_t PortfolioManage::queryTotalToken(){
        u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
return totalToken.get();
    }

     
    CONSTANT uint64_t PortfolioManage::queryPortfolioBalance(char* _portfolioName){
        u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
return portfolioBalance.get()[_portfolioName];
    }

2019-12-19_15:14:55.367291: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:510] codetext  first #include "PortfolioManage.hpp"

    
    PAYABLE void PortfolioManage::init(){
        *owner = caller().toString();
        *changeRate = 10000;
        *userCanWithdraw = false;
        uint64_t tokenBalance = getTotalBalance();
        
        *ownerTotalToken = tokenBalance;
        *totalToken = ownerTotalToken.get();
        
        
        DIPC_EMIT_EVENT(initEvent, "ownerTotalToken" ,tokenBalance);
    }
    
     
    EXPORT void PortfolioManage::setChangeRate(uint64_t _changeRate){
        u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
isOwner();
        *changeRate = _changeRate;
    }
     
    EXPORT void PortfolioManage::setUserCanWithdraw(bool _canWithdraw){
        u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
isOwner();
        *userCanWithdraw = _canWithdraw;
    }

    
    PAYABLE void PortfolioManage::createPortfolio(char* _portfolioName, char* _portfolioDesc){
        if(portfolioStorge.get()[_portfolioName] != ""){
            DIPC_EMIT_EVENT(ErrEvent, "Current portfolio exist: ", _portfolioName);
            return;
        } 
        std::string callerAddr = caller().toString();
        uint64_t tokenBalance = getTotalBalance();
        
        PortfolioInfo info(_portfolioName, _portfolioDesc, &callerAddr[0]);
        std::string portfolioStr = info.toJson();
        
        
        

        (*portfolioStorge)[_portfolioName] = portfolioStr;
        DipcAssert(totalToken.get() + tokenBalance > totalToken);
        (*portfolioBalance)[_portfolioName] = tokenBalance;
        *totalToken = totalToken.get() + tokenBalance; 
        
        DIPC_EMIT_EVENT(portfolioInfo, _portfolioName, &portfolioStr[0], "portfolioBalance", tokenBalance);
    }

    
    PAYABLE void PortfolioManage::depositPortfolio(char* _portfolioName){
        uint64_t tokenBalance = getTotalBalance();
        
        uint64_t currentBalance = portfolioBalance.get()[_portfolioName];
        uint64_t finalBalance  = currentBalance + tokenBalance;
        DipcAssert(totalToken.get() + tokenBalance > totalToken);
        DipcAssert(finalBalance > currentBalance);
        (*portfolioBalance)[_portfolioName] = finalBalance;
        *totalToken = totalToken.get() + finalBalance; 
        DIPC_EMIT_EVENT(depositPortfolio, "portfolioName", _portfolioName, "portfolioBalance", finalBalance);
    }
    
    PAYABLE void PortfolioManage::createOrder(char* _portfolioName, char* _orderId, uint16_t _orderType, char* _stockCode, uint64_t _stockPrice, uint64_t _stockAmount, uint64_t _endTime){
        uint64_t tokenBalance = getTotalBalance();
        DIPC_EMIT_EVENT(createOrder, "portfolioName", _portfolioName, "OrderInfo", "ignore", "tokenBalance", tokenBalance);
        uint64_t spent = 0;
        if(_orderType == 1){
            spent = _stockPrice * _stockAmount;
            DipcAssert((portfolioBalance.get()[_portfolioName] + tokenBalance) > spent);
        }
        struct Order order{_orderId, _orderType, _stockCode, _stockPrice, _stockAmount, _endTime, 0};
        std::string pInfo = portfolioStorge.get()[_portfolioName];
        
        
        
        if(pInfo == "") {
            DIPC_EMIT_EVENT(ErrEvent, "Current portfolio  doesn't exist: ", _portfolioName);
            return;
        }
        PortfolioInfo info;
        info.parseJson(pInfo);
        if(info.getOrder(_orderId).orderId != ""){
            DIPC_EMIT_EVENT(ErrEvent, "Current order exist: ", _orderId);
            return;
        }
        info.addOrder(order);
        pInfo = info.toJson();

        uint64_t currentBalance = portfolioBalance.get()[_portfolioName] ;
        uint64_t finalBalance = currentBalance + tokenBalance - spent;
        DipcAssert(totalToken.get() + tokenBalance > totalToken);
        
        DipcAssert(ownerTotalToken.get() < ownerTotalToken.get() + spent);
        (*portfolioStorge)[_portfolioName] = &pInfo[0];
        
        
        
        


        (*portfolioBalance)[_portfolioName] = finalBalance;
        *totalToken = totalToken.get() + finalBalance; 
        *ownerTotalToken = ownerTotalToken.get() + spent;
        DIPC_EMIT_EVENT(createOrder, "portfolioName", _portfolioName, "OrderInfo", &order.toJson()[0], "portfolioBalance", finalBalance);
    }

    
    EXPORT void PortfolioManage::dealOrder(char* _portfolioName, char* _orderId){
        u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
isOwner();
        std::string pInfo = portfolioStorge.get()[_portfolioName];
        
        
        PortfolioInfo info;
        info.parseJson(pInfo);
        

        
         Order ord = info.getOrder(_orderId);
         
         
        if(ord.orderId != "" && ord.orderStatus == 0){
            
            uint64_t timenow = dipc::timestamp();
            if(ord.endTime > timenow){
                ord.orderStatus = 1;
            }else {
                ord.orderStatus = 3;
            }
        } else {
          

            return;
        }
        

        uint64_t sellValue = 0;
        if(ord.orderType == 0){
            sellValue = ord.stockAmount * ord.stockPrice;
        }
        uint64_t currentBalance =  portfolioBalance.get()[_portfolioName];
        

        DipcAssert(currentBalance + sellValue >= currentBalance);
        DipcAssert((ownerTotalToken.get() - sellValue) <= ownerTotalToken.get());
        


        (*portfolioBalance)[_portfolioName] = currentBalance + sellValue;
        *ownerTotalToken = ownerTotalToken.get() - sellValue;
        (*portfolioStorge)[_portfolioName] = &info.toJson()[0];
        
        
        
        

        DIPC_EMIT_EVENT(dealPortfolio, "orderId", _orderId, "orderInfo", &ord.toJson()[0]);
    }
    
    EXPORT void PortfolioManage::revocationOrder(char* _portfolioName, char* _orderId){
        u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
std::string pInfo = portfolioStorge.get()[_portfolioName];
        
        
        PortfolioInfo info;
        info.parseJson(pInfo);
        Order ord = info.getOrder(_orderId);
        
        
        if(ord.orderId != "" && ord.orderStatus == 0){
            std::string callerStr = caller().toString();
            
            
            
            DipcAssert(info.getOwnerAddress() == caller().toString());
            

            uint64_t timenow = dipc::timestamp();
            if(ord.endTime > timenow){
                ord.orderStatus = 2;
            }else {
                ord.orderStatus = 3;
            }
        } else {
            return;
        }
        uint64_t lockToken = 0;
        if(ord.orderType == 1){
            lockToken = ord.stockPrice * ord.stockAmount;
        }
        uint64_t currentBalance =  portfolioBalance.get()[_portfolioName];
        
        
        
        

        DipcAssert(currentBalance + lockToken >= currentBalance);
        DipcAssert(ownerTotalToken.get() - lockToken <= ownerTotalToken.get());

        
        (*portfolioBalance)[_portfolioName] = currentBalance + lockToken;
        *ownerTotalToken = ownerTotalToken.get() - lockToken;
        (*portfolioStorge)[_portfolioName] = &info.toJson()[0];
        DIPC_EMIT_EVENT(revocationPortfolio, "orderId", _orderId, "orderInfo", &ord.toJson()[0]);
    }
    
    EXPORT void PortfolioManage::withdrawPortfolio(char* _portfolioName, uint64_t _withdrawBalance){
         u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
if(!userCanWithdraw.get()){
             return;
         }
         uint64_t currentBalance =  portfolioBalance.get()[_portfolioName];
         DipcAssert(currentBalance - _withdrawBalance < currentBalance);
         auto coinBalance = changeUint64ToU256WithChangeRate(currentBalance, changeRate.get());
         (*portfolioBalance)[_portfolioName] = currentBalance - _withdrawBalance;
         callTransfer(caller(), coinBalance);
    }
    
    EXPORT void PortfolioManage::withdrawPool(uint64_t _balance){
        u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
isOwner();
        Address ownerAddr = Address(owner.get()); 
        callTransfer(ownerAddr, _balance);
        *ownerTotalToken = ownerTotalToken.get() - _balance * changeRate.get();
        *totalToken = totalToken.get() - _balance * changeRate.get();
        DIPC_EMIT_EVENT(tokenCount, "ownerTotalToken", ownerTotalToken.get(), "totalToken", totalToken.get());
    }
    
    PAYABLE void PortfolioManage::depositPool(uint64_t _depositValue){
        isOwner();
        
        uint64_t tokenBalance = changeU256ToUint64WithChangeRate(callValue(), changeRate.get()); 
        *ownerTotalToken = ownerTotalToken.get() + tokenBalance;
        *totalToken = totalToken.get() + tokenBalance;
        DIPC_EMIT_EVENT(tokenCount, "ownerTotalToken", ownerTotalToken.get(), "totalToken", totalToken.get());
    }
     
    CONSTANT uint64_t PortfolioManage::queryTotalToken(){
        u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
return totalToken.get();
    }

     
    CONSTANT uint64_t PortfolioManage::queryPortfolioBalance(char* _portfolioName){
        u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
return portfolioBalance.get()[_portfolioName];
    }

    
    CONSTANT bool PortfolioManage::queryPortfolioNameIfUsed(char* _portfolioName){
        if(portfolioStorge.get()[_portfolioName] != ""){
            return true;
        } 
        return false;
    }

    
    CONSTANT uint64_t PortfolioManage::queryChangeRate(){
        return changeRate.get();
    }

2019-12-19_15:14:55.367301: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:513] s  first 

    
    CONSTANT bool PortfolioManage::queryPortfolioNameIfUsed(char* _portfolioName){
        if(portfolioStorge.get()[_portfolioName] != ""){
            return true;
        } 
        return false;
    }

2019-12-19_15:14:55.367309: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:593] calledFunc temp export: 

    
    CONSTANT bool PortfolioManage::queryPortfolioNameIfUsed(char* _portfolioName){
        u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
if(portfolioStorge.get()[_portfolioName] != ""){
            return true;
        } 
        return false;
    }

2019-12-19_15:14:55.367317: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:599] search func : 

    
    CONSTANT bool PortfolioManage::queryPortfolioNameIfUsed(char* _portfolioName){
        u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
if(portfolioStorge.get()[_portfolioName] != ""){
            return true;
        } 
        return false;
    }
2019-12-19_15:14:55.367338: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:424] finalContract  this height  #include "PortfolioManage.hpp"

    
    PAYABLE void PortfolioManage::init(){
        *owner = caller().toString();
        *changeRate = 10000;
        *userCanWithdraw = false;
        uint64_t tokenBalance = getTotalBalance();
        
        *ownerTotalToken = tokenBalance;
        *totalToken = ownerTotalToken.get();
        
        
        DIPC_EMIT_EVENT(initEvent, "ownerTotalToken" ,tokenBalance);
    }
    
     
    EXPORT void PortfolioManage::setChangeRate(uint64_t _changeRate){
        u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
isOwner();
        *changeRate = _changeRate;
    }
     
    EXPORT void PortfolioManage::setUserCanWithdraw(bool _canWithdraw){
        u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
isOwner();
        *userCanWithdraw = _canWithdraw;
    }

    
    PAYABLE void PortfolioManage::createPortfolio(char* _portfolioName, char* _portfolioDesc){
        if(portfolioStorge.get()[_portfolioName] != ""){
            DIPC_EMIT_EVENT(ErrEvent, "Current portfolio exist: ", _portfolioName);
            return;
        } 
        std::string callerAddr = caller().toString();
        uint64_t tokenBalance = getTotalBalance();
        
        PortfolioInfo info(_portfolioName, _portfolioDesc, &callerAddr[0]);
        std::string portfolioStr = info.toJson();
        
        
        

        (*portfolioStorge)[_portfolioName] = portfolioStr;
        DipcAssert(totalToken.get() + tokenBalance > totalToken);
        (*portfolioBalance)[_portfolioName] = tokenBalance;
        *totalToken = totalToken.get() + tokenBalance; 
        
        DIPC_EMIT_EVENT(portfolioInfo, _portfolioName, &portfolioStr[0], "portfolioBalance", tokenBalance);
    }

    
    PAYABLE void PortfolioManage::depositPortfolio(char* _portfolioName){
        uint64_t tokenBalance = getTotalBalance();
        
        uint64_t currentBalance = portfolioBalance.get()[_portfolioName];
        uint64_t finalBalance  = currentBalance + tokenBalance;
        DipcAssert(totalToken.get() + tokenBalance > totalToken);
        DipcAssert(finalBalance > currentBalance);
        (*portfolioBalance)[_portfolioName] = finalBalance;
        *totalToken = totalToken.get() + finalBalance; 
        DIPC_EMIT_EVENT(depositPortfolio, "portfolioName", _portfolioName, "portfolioBalance", finalBalance);
    }
    
    PAYABLE void PortfolioManage::createOrder(char* _portfolioName, char* _orderId, uint16_t _orderType, char* _stockCode, uint64_t _stockPrice, uint64_t _stockAmount, uint64_t _endTime){
        uint64_t tokenBalance = getTotalBalance();
        DIPC_EMIT_EVENT(createOrder, "portfolioName", _portfolioName, "OrderInfo", "ignore", "tokenBalance", tokenBalance);
        uint64_t spent = 0;
        if(_orderType == 1){
            spent = _stockPrice * _stockAmount;
            DipcAssert((portfolioBalance.get()[_portfolioName] + tokenBalance) > spent);
        }
        struct Order order{_orderId, _orderType, _stockCode, _stockPrice, _stockAmount, _endTime, 0};
        std::string pInfo = portfolioStorge.get()[_portfolioName];
        
        
        
        if(pInfo == "") {
            DIPC_EMIT_EVENT(ErrEvent, "Current portfolio  doesn't exist: ", _portfolioName);
            return;
        }
        PortfolioInfo info;
        info.parseJson(pInfo);
        if(info.getOrder(_orderId).orderId != ""){
            DIPC_EMIT_EVENT(ErrEvent, "Current order exist: ", _orderId);
            return;
        }
        info.addOrder(order);
        pInfo = info.toJson();

        uint64_t currentBalance = portfolioBalance.get()[_portfolioName] ;
        uint64_t finalBalance = currentBalance + tokenBalance - spent;
        DipcAssert(totalToken.get() + tokenBalance > totalToken);
        
        DipcAssert(ownerTotalToken.get() < ownerTotalToken.get() + spent);
        (*portfolioStorge)[_portfolioName] = &pInfo[0];
        
        
        
        


        (*portfolioBalance)[_portfolioName] = finalBalance;
        *totalToken = totalToken.get() + finalBalance; 
        *ownerTotalToken = ownerTotalToken.get() + spent;
        DIPC_EMIT_EVENT(createOrder, "portfolioName", _portfolioName, "OrderInfo", &order.toJson()[0], "portfolioBalance", finalBalance);
    }

    
    EXPORT void PortfolioManage::dealOrder(char* _portfolioName, char* _orderId){
        u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
isOwner();
        std::string pInfo = portfolioStorge.get()[_portfolioName];
        
        
        PortfolioInfo info;
        info.parseJson(pInfo);
        

        
         Order ord = info.getOrder(_orderId);
         
         
        if(ord.orderId != "" && ord.orderStatus == 0){
            
            uint64_t timenow = dipc::timestamp();
            if(ord.endTime > timenow){
                ord.orderStatus = 1;
            }else {
                ord.orderStatus = 3;
            }
        } else {
          

            return;
        }
        

        uint64_t sellValue = 0;
        if(ord.orderType == 0){
            sellValue = ord.stockAmount * ord.stockPrice;
        }
        uint64_t currentBalance =  portfolioBalance.get()[_portfolioName];
        

        DipcAssert(currentBalance + sellValue >= currentBalance);
        DipcAssert((ownerTotalToken.get() - sellValue) <= ownerTotalToken.get());
        


        (*portfolioBalance)[_portfolioName] = currentBalance + sellValue;
        *ownerTotalToken = ownerTotalToken.get() - sellValue;
        (*portfolioStorge)[_portfolioName] = &info.toJson()[0];
        
        
        
        

        DIPC_EMIT_EVENT(dealPortfolio, "orderId", _orderId, "orderInfo", &ord.toJson()[0]);
    }
    
    EXPORT void PortfolioManage::revocationOrder(char* _portfolioName, char* _orderId){
        u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
std::string pInfo = portfolioStorge.get()[_portfolioName];
        
        
        PortfolioInfo info;
        info.parseJson(pInfo);
        Order ord = info.getOrder(_orderId);
        
        
        if(ord.orderId != "" && ord.orderStatus == 0){
            std::string callerStr = caller().toString();
            
            
            
            DipcAssert(info.getOwnerAddress() == caller().toString());
            

            uint64_t timenow = dipc::timestamp();
            if(ord.endTime > timenow){
                ord.orderStatus = 2;
            }else {
                ord.orderStatus = 3;
            }
        } else {
            return;
        }
        uint64_t lockToken = 0;
        if(ord.orderType == 1){
            lockToken = ord.stockPrice * ord.stockAmount;
        }
        uint64_t currentBalance =  portfolioBalance.get()[_portfolioName];
        
        
        
        

        DipcAssert(currentBalance + lockToken >= currentBalance);
        DipcAssert(ownerTotalToken.get() - lockToken <= ownerTotalToken.get());

        
        (*portfolioBalance)[_portfolioName] = currentBalance + lockToken;
        *ownerTotalToken = ownerTotalToken.get() - lockToken;
        (*portfolioStorge)[_portfolioName] = &info.toJson()[0];
        DIPC_EMIT_EVENT(revocationPortfolio, "orderId", _orderId, "orderInfo", &ord.toJson()[0]);
    }
    
    EXPORT void PortfolioManage::withdrawPortfolio(char* _portfolioName, uint64_t _withdrawBalance){
         u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
if(!userCanWithdraw.get()){
             return;
         }
         uint64_t currentBalance =  portfolioBalance.get()[_portfolioName];
         DipcAssert(currentBalance - _withdrawBalance < currentBalance);
         auto coinBalance = changeUint64ToU256WithChangeRate(currentBalance, changeRate.get());
         (*portfolioBalance)[_portfolioName] = currentBalance - _withdrawBalance;
         callTransfer(caller(), coinBalance);
    }
    
    EXPORT void PortfolioManage::withdrawPool(uint64_t _balance){
        u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
isOwner();
        Address ownerAddr = Address(owner.get()); 
        callTransfer(ownerAddr, _balance);
        *ownerTotalToken = ownerTotalToken.get() - _balance * changeRate.get();
        *totalToken = totalToken.get() - _balance * changeRate.get();
        DIPC_EMIT_EVENT(tokenCount, "ownerTotalToken", ownerTotalToken.get(), "totalToken", totalToken.get());
    }
    
    PAYABLE void PortfolioManage::depositPool(uint64_t _depositValue){
        isOwner();
        
        uint64_t tokenBalance = changeU256ToUint64WithChangeRate(callValue(), changeRate.get()); 
        *ownerTotalToken = ownerTotalToken.get() + tokenBalance;
        *totalToken = totalToken.get() + tokenBalance;
        DIPC_EMIT_EVENT(tokenCount, "ownerTotalToken", ownerTotalToken.get(), "totalToken", totalToken.get());
    }
     
    CONSTANT uint64_t PortfolioManage::queryTotalToken(){
        u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
return totalToken.get();
    }

     
    CONSTANT uint64_t PortfolioManage::queryPortfolioBalance(char* _portfolioName){
        u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
return portfolioBalance.get()[_portfolioName];
    }

    
    CONSTANT bool PortfolioManage::queryPortfolioNameIfUsed(char* _portfolioName){
        u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
if(portfolioStorge.get()[_portfolioName] != ""){
            return true;
        } 
        return false;
    } codetext height #include "PortfolioManage.hpp"

    
    PAYABLE void PortfolioManage::init(){
        *owner = caller().toString();
        *changeRate = 10000;
        *userCanWithdraw = false;
        uint64_t tokenBalance = getTotalBalance();
        
        *ownerTotalToken = tokenBalance;
        *totalToken = ownerTotalToken.get();
        
        
        DIPC_EMIT_EVENT(initEvent, "ownerTotalToken" ,tokenBalance);
    }
    
     
    EXPORT void PortfolioManage::setChangeRate(uint64_t _changeRate){
        u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
isOwner();
        *changeRate = _changeRate;
    }
     
    EXPORT void PortfolioManage::setUserCanWithdraw(bool _canWithdraw){
        u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
isOwner();
        *userCanWithdraw = _canWithdraw;
    }

    
    PAYABLE void PortfolioManage::createPortfolio(char* _portfolioName, char* _portfolioDesc){
        if(portfolioStorge.get()[_portfolioName] != ""){
            DIPC_EMIT_EVENT(ErrEvent, "Current portfolio exist: ", _portfolioName);
            return;
        } 
        std::string callerAddr = caller().toString();
        uint64_t tokenBalance = getTotalBalance();
        
        PortfolioInfo info(_portfolioName, _portfolioDesc, &callerAddr[0]);
        std::string portfolioStr = info.toJson();
        
        
        

        (*portfolioStorge)[_portfolioName] = portfolioStr;
        DipcAssert(totalToken.get() + tokenBalance > totalToken);
        (*portfolioBalance)[_portfolioName] = tokenBalance;
        *totalToken = totalToken.get() + tokenBalance; 
        
        DIPC_EMIT_EVENT(portfolioInfo, _portfolioName, &portfolioStr[0], "portfolioBalance", tokenBalance);
    }

    
    PAYABLE void PortfolioManage::depositPortfolio(char* _portfolioName){
        uint64_t tokenBalance = getTotalBalance();
        
        uint64_t currentBalance = portfolioBalance.get()[_portfolioName];
        uint64_t finalBalance  = currentBalance + tokenBalance;
        DipcAssert(totalToken.get() + tokenBalance > totalToken);
        DipcAssert(finalBalance > currentBalance);
        (*portfolioBalance)[_portfolioName] = finalBalance;
        *totalToken = totalToken.get() + finalBalance; 
        DIPC_EMIT_EVENT(depositPortfolio, "portfolioName", _portfolioName, "portfolioBalance", finalBalance);
    }
    
    PAYABLE void PortfolioManage::createOrder(char* _portfolioName, char* _orderId, uint16_t _orderType, char* _stockCode, uint64_t _stockPrice, uint64_t _stockAmount, uint64_t _endTime){
        uint64_t tokenBalance = getTotalBalance();
        DIPC_EMIT_EVENT(createOrder, "portfolioName", _portfolioName, "OrderInfo", "ignore", "tokenBalance", tokenBalance);
        uint64_t spent = 0;
        if(_orderType == 1){
            spent = _stockPrice * _stockAmount;
            DipcAssert((portfolioBalance.get()[_portfolioName] + tokenBalance) > spent);
        }
        struct Order order{_orderId, _orderType, _stockCode, _stockPrice, _stockAmount, _endTime, 0};
        std::string pInfo = portfolioStorge.get()[_portfolioName];
        
        
        
        if(pInfo == "") {
            DIPC_EMIT_EVENT(ErrEvent, "Current portfolio  doesn't exist: ", _portfolioName);
            return;
        }
        PortfolioInfo info;
        info.parseJson(pInfo);
        if(info.getOrder(_orderId).orderId != ""){
            DIPC_EMIT_EVENT(ErrEvent, "Current order exist: ", _orderId);
            return;
        }
        info.addOrder(order);
        pInfo = info.toJson();

        uint64_t currentBalance = portfolioBalance.get()[_portfolioName] ;
        uint64_t finalBalance = currentBalance + tokenBalance - spent;
        DipcAssert(totalToken.get() + tokenBalance > totalToken);
        
        DipcAssert(ownerTotalToken.get() < ownerTotalToken.get() + spent);
        (*portfolioStorge)[_portfolioName] = &pInfo[0];
        
        
        
        


        (*portfolioBalance)[_portfolioName] = finalBalance;
        *totalToken = totalToken.get() + finalBalance; 
        *ownerTotalToken = ownerTotalToken.get() + spent;
        DIPC_EMIT_EVENT(createOrder, "portfolioName", _portfolioName, "OrderInfo", &order.toJson()[0], "portfolioBalance", finalBalance);
    }

    
    EXPORT void PortfolioManage::dealOrder(char* _portfolioName, char* _orderId){
        u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
isOwner();
        std::string pInfo = portfolioStorge.get()[_portfolioName];
        
        
        PortfolioInfo info;
        info.parseJson(pInfo);
        

        
         Order ord = info.getOrder(_orderId);
         
         
        if(ord.orderId != "" && ord.orderStatus == 0){
            
            uint64_t timenow = dipc::timestamp();
            if(ord.endTime > timenow){
                ord.orderStatus = 1;
            }else {
                ord.orderStatus = 3;
            }
        } else {
          

            return;
        }
        

        uint64_t sellValue = 0;
        if(ord.orderType == 0){
            sellValue = ord.stockAmount * ord.stockPrice;
        }
        uint64_t currentBalance =  portfolioBalance.get()[_portfolioName];
        

        DipcAssert(currentBalance + sellValue >= currentBalance);
        DipcAssert((ownerTotalToken.get() - sellValue) <= ownerTotalToken.get());
        


        (*portfolioBalance)[_portfolioName] = currentBalance + sellValue;
        *ownerTotalToken = ownerTotalToken.get() - sellValue;
        (*portfolioStorge)[_portfolioName] = &info.toJson()[0];
        
        
        
        

        DIPC_EMIT_EVENT(dealPortfolio, "orderId", _orderId, "orderInfo", &ord.toJson()[0]);
    }
    
    EXPORT void PortfolioManage::revocationOrder(char* _portfolioName, char* _orderId){
        u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
std::string pInfo = portfolioStorge.get()[_portfolioName];
        
        
        PortfolioInfo info;
        info.parseJson(pInfo);
        Order ord = info.getOrder(_orderId);
        
        
        if(ord.orderId != "" && ord.orderStatus == 0){
            std::string callerStr = caller().toString();
            
            
            
            DipcAssert(info.getOwnerAddress() == caller().toString());
            

            uint64_t timenow = dipc::timestamp();
            if(ord.endTime > timenow){
                ord.orderStatus = 2;
            }else {
                ord.orderStatus = 3;
            }
        } else {
            return;
        }
        uint64_t lockToken = 0;
        if(ord.orderType == 1){
            lockToken = ord.stockPrice * ord.stockAmount;
        }
        uint64_t currentBalance =  portfolioBalance.get()[_portfolioName];
        
        
        
        

        DipcAssert(currentBalance + lockToken >= currentBalance);
        DipcAssert(ownerTotalToken.get() - lockToken <= ownerTotalToken.get());

        
        (*portfolioBalance)[_portfolioName] = currentBalance + lockToken;
        *ownerTotalToken = ownerTotalToken.get() - lockToken;
        (*portfolioStorge)[_portfolioName] = &info.toJson()[0];
        DIPC_EMIT_EVENT(revocationPortfolio, "orderId", _orderId, "orderInfo", &ord.toJson()[0]);
    }
    
    EXPORT void PortfolioManage::withdrawPortfolio(char* _portfolioName, uint64_t _withdrawBalance){
         u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
if(!userCanWithdraw.get()){
             return;
         }
         uint64_t currentBalance =  portfolioBalance.get()[_portfolioName];
         DipcAssert(currentBalance - _withdrawBalance < currentBalance);
         auto coinBalance = changeUint64ToU256WithChangeRate(currentBalance, changeRate.get());
         (*portfolioBalance)[_portfolioName] = currentBalance - _withdrawBalance;
         callTransfer(caller(), coinBalance);
    }
    
    EXPORT void PortfolioManage::withdrawPool(uint64_t _balance){
        u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
isOwner();
        Address ownerAddr = Address(owner.get()); 
        callTransfer(ownerAddr, _balance);
        *ownerTotalToken = ownerTotalToken.get() - _balance * changeRate.get();
        *totalToken = totalToken.get() - _balance * changeRate.get();
        DIPC_EMIT_EVENT(tokenCount, "ownerTotalToken", ownerTotalToken.get(), "totalToken", totalToken.get());
    }
    
    PAYABLE void PortfolioManage::depositPool(uint64_t _depositValue){
        isOwner();
        
        uint64_t tokenBalance = changeU256ToUint64WithChangeRate(callValue(), changeRate.get()); 
        *ownerTotalToken = ownerTotalToken.get() + tokenBalance;
        *totalToken = totalToken.get() + tokenBalance;
        DIPC_EMIT_EVENT(tokenCount, "ownerTotalToken", ownerTotalToken.get(), "totalToken", totalToken.get());
    }
     
    CONSTANT uint64_t PortfolioManage::queryTotalToken(){
        u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
return totalToken.get();
    }

     
    CONSTANT uint64_t PortfolioManage::queryPortfolioBalance(char* _portfolioName){
        u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
return portfolioBalance.get()[_portfolioName];
    }

    
    CONSTANT bool PortfolioManage::queryPortfolioNameIfUsed(char* _portfolioName){
        if(portfolioStorge.get()[_portfolioName] != ""){
            return true;
        } 
        return false;
    }

    
    CONSTANT uint64_t PortfolioManage::queryChangeRate(){
        return changeRate.get();
    }

2019-12-19_15:14:55.367351: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:427] searchContext  

    
    CONSTANT uint64_t PortfolioManage::queryChangeRate(){
        return changeRate.get();
    }

2019-12-19_15:14:55.369402: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:442] finalContract  this new  #include "PortfolioManage.hpp"

    
    PAYABLE void PortfolioManage::init(){
        *owner = caller().toString();
        *changeRate = 10000;
        *userCanWithdraw = false;
        uint64_t tokenBalance = getTotalBalance();
        
        *ownerTotalToken = tokenBalance;
        *totalToken = ownerTotalToken.get();
        
        
        DIPC_EMIT_EVENT(initEvent, "ownerTotalToken" ,tokenBalance);
    }
    
     
    EXPORT void PortfolioManage::setChangeRate(uint64_t _changeRate){
        u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
isOwner();
        *changeRate = _changeRate;
    }
     
    EXPORT void PortfolioManage::setUserCanWithdraw(bool _canWithdraw){
        u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
isOwner();
        *userCanWithdraw = _canWithdraw;
    }

    
    PAYABLE void PortfolioManage::createPortfolio(char* _portfolioName, char* _portfolioDesc){
        if(portfolioStorge.get()[_portfolioName] != ""){
            DIPC_EMIT_EVENT(ErrEvent, "Current portfolio exist: ", _portfolioName);
            return;
        } 
        std::string callerAddr = caller().toString();
        uint64_t tokenBalance = getTotalBalance();
        
        PortfolioInfo info(_portfolioName, _portfolioDesc, &callerAddr[0]);
        std::string portfolioStr = info.toJson();
        
        
        

        (*portfolioStorge)[_portfolioName] = portfolioStr;
        DipcAssert(totalToken.get() + tokenBalance > totalToken);
        (*portfolioBalance)[_portfolioName] = tokenBalance;
        *totalToken = totalToken.get() + tokenBalance; 
        
        DIPC_EMIT_EVENT(portfolioInfo, _portfolioName, &portfolioStr[0], "portfolioBalance", tokenBalance);
    }

    
    PAYABLE void PortfolioManage::depositPortfolio(char* _portfolioName){
        uint64_t tokenBalance = getTotalBalance();
        
        uint64_t currentBalance = portfolioBalance.get()[_portfolioName];
        uint64_t finalBalance  = currentBalance + tokenBalance;
        DipcAssert(totalToken.get() + tokenBalance > totalToken);
        DipcAssert(finalBalance > currentBalance);
        (*portfolioBalance)[_portfolioName] = finalBalance;
        *totalToken = totalToken.get() + finalBalance; 
        DIPC_EMIT_EVENT(depositPortfolio, "portfolioName", _portfolioName, "portfolioBalance", finalBalance);
    }
    
    PAYABLE void PortfolioManage::createOrder(char* _portfolioName, char* _orderId, uint16_t _orderType, char* _stockCode, uint64_t _stockPrice, uint64_t _stockAmount, uint64_t _endTime){
        uint64_t tokenBalance = getTotalBalance();
        DIPC_EMIT_EVENT(createOrder, "portfolioName", _portfolioName, "OrderInfo", "ignore", "tokenBalance", tokenBalance);
        uint64_t spent = 0;
        if(_orderType == 1){
            spent = _stockPrice * _stockAmount;
            DipcAssert((portfolioBalance.get()[_portfolioName] + tokenBalance) > spent);
        }
        struct Order order{_orderId, _orderType, _stockCode, _stockPrice, _stockAmount, _endTime, 0};
        std::string pInfo = portfolioStorge.get()[_portfolioName];
        
        
        
        if(pInfo == "") {
            DIPC_EMIT_EVENT(ErrEvent, "Current portfolio  doesn't exist: ", _portfolioName);
            return;
        }
        PortfolioInfo info;
        info.parseJson(pInfo);
        if(info.getOrder(_orderId).orderId != ""){
            DIPC_EMIT_EVENT(ErrEvent, "Current order exist: ", _orderId);
            return;
        }
        info.addOrder(order);
        pInfo = info.toJson();

        uint64_t currentBalance = portfolioBalance.get()[_portfolioName] ;
        uint64_t finalBalance = currentBalance + tokenBalance - spent;
        DipcAssert(totalToken.get() + tokenBalance > totalToken);
        
        DipcAssert(ownerTotalToken.get() < ownerTotalToken.get() + spent);
        (*portfolioStorge)[_portfolioName] = &pInfo[0];
        
        
        
        


        (*portfolioBalance)[_portfolioName] = finalBalance;
        *totalToken = totalToken.get() + finalBalance; 
        *ownerTotalToken = ownerTotalToken.get() + spent;
        DIPC_EMIT_EVENT(createOrder, "portfolioName", _portfolioName, "OrderInfo", &order.toJson()[0], "portfolioBalance", finalBalance);
    }

    
    EXPORT void PortfolioManage::dealOrder(char* _portfolioName, char* _orderId){
        u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
isOwner();
        std::string pInfo = portfolioStorge.get()[_portfolioName];
        
        
        PortfolioInfo info;
        info.parseJson(pInfo);
        

        
         Order ord = info.getOrder(_orderId);
         
         
        if(ord.orderId != "" && ord.orderStatus == 0){
            
            uint64_t timenow = dipc::timestamp();
            if(ord.endTime > timenow){
                ord.orderStatus = 1;
            }else {
                ord.orderStatus = 3;
            }
        } else {
          

            return;
        }
        

        uint64_t sellValue = 0;
        if(ord.orderType == 0){
            sellValue = ord.stockAmount * ord.stockPrice;
        }
        uint64_t currentBalance =  portfolioBalance.get()[_portfolioName];
        

        DipcAssert(currentBalance + sellValue >= currentBalance);
        DipcAssert((ownerTotalToken.get() - sellValue) <= ownerTotalToken.get());
        


        (*portfolioBalance)[_portfolioName] = currentBalance + sellValue;
        *ownerTotalToken = ownerTotalToken.get() - sellValue;
        (*portfolioStorge)[_portfolioName] = &info.toJson()[0];
        
        
        
        

        DIPC_EMIT_EVENT(dealPortfolio, "orderId", _orderId, "orderInfo", &ord.toJson()[0]);
    }
    
    EXPORT void PortfolioManage::revocationOrder(char* _portfolioName, char* _orderId){
        u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
std::string pInfo = portfolioStorge.get()[_portfolioName];
        
        
        PortfolioInfo info;
        info.parseJson(pInfo);
        Order ord = info.getOrder(_orderId);
        
        
        if(ord.orderId != "" && ord.orderStatus == 0){
            std::string callerStr = caller().toString();
            
            
            
            DipcAssert(info.getOwnerAddress() == caller().toString());
            

            uint64_t timenow = dipc::timestamp();
            if(ord.endTime > timenow){
                ord.orderStatus = 2;
            }else {
                ord.orderStatus = 3;
            }
        } else {
            return;
        }
        uint64_t lockToken = 0;
        if(ord.orderType == 1){
            lockToken = ord.stockPrice * ord.stockAmount;
        }
        uint64_t currentBalance =  portfolioBalance.get()[_portfolioName];
        
        
        
        

        DipcAssert(currentBalance + lockToken >= currentBalance);
        DipcAssert(ownerTotalToken.get() - lockToken <= ownerTotalToken.get());

        
        (*portfolioBalance)[_portfolioName] = currentBalance + lockToken;
        *ownerTotalToken = ownerTotalToken.get() - lockToken;
        (*portfolioStorge)[_portfolioName] = &info.toJson()[0];
        DIPC_EMIT_EVENT(revocationPortfolio, "orderId", _orderId, "orderInfo", &ord.toJson()[0]);
    }
    
    EXPORT void PortfolioManage::withdrawPortfolio(char* _portfolioName, uint64_t _withdrawBalance){
         u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
if(!userCanWithdraw.get()){
             return;
         }
         uint64_t currentBalance =  portfolioBalance.get()[_portfolioName];
         DipcAssert(currentBalance - _withdrawBalance < currentBalance);
         auto coinBalance = changeUint64ToU256WithChangeRate(currentBalance, changeRate.get());
         (*portfolioBalance)[_portfolioName] = currentBalance - _withdrawBalance;
         callTransfer(caller(), coinBalance);
    }
    
    EXPORT void PortfolioManage::withdrawPool(uint64_t _balance){
        u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
isOwner();
        Address ownerAddr = Address(owner.get()); 
        callTransfer(ownerAddr, _balance);
        *ownerTotalToken = ownerTotalToken.get() - _balance * changeRate.get();
        *totalToken = totalToken.get() - _balance * changeRate.get();
        DIPC_EMIT_EVENT(tokenCount, "ownerTotalToken", ownerTotalToken.get(), "totalToken", totalToken.get());
    }
    
    PAYABLE void PortfolioManage::depositPool(uint64_t _depositValue){
        isOwner();
        
        uint64_t tokenBalance = changeU256ToUint64WithChangeRate(callValue(), changeRate.get()); 
        *ownerTotalToken = ownerTotalToken.get() + tokenBalance;
        *totalToken = totalToken.get() + tokenBalance;
        DIPC_EMIT_EVENT(tokenCount, "ownerTotalToken", ownerTotalToken.get(), "totalToken", totalToken.get());
    }
     
    CONSTANT uint64_t PortfolioManage::queryTotalToken(){
        u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
return totalToken.get();
    }

     
    CONSTANT uint64_t PortfolioManage::queryPortfolioBalance(char* _portfolioName){
        u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
return portfolioBalance.get()[_portfolioName];
    }

    
    CONSTANT bool PortfolioManage::queryPortfolioNameIfUsed(char* _portfolioName){
        u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
if(portfolioStorge.get()[_portfolioName] != ""){
            return true;
        } 
        return false;
    } codetext new #include "PortfolioManage.hpp"

    
    PAYABLE void PortfolioManage::init(){
        *owner = caller().toString();
        *changeRate = 10000;
        *userCanWithdraw = false;
        uint64_t tokenBalance = getTotalBalance();
        
        *ownerTotalToken = tokenBalance;
        *totalToken = ownerTotalToken.get();
        
        
        DIPC_EMIT_EVENT(initEvent, "ownerTotalToken" ,tokenBalance);
    }
    
     
    EXPORT void PortfolioManage::setChangeRate(uint64_t _changeRate){
        u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
isOwner();
        *changeRate = _changeRate;
    }
     
    EXPORT void PortfolioManage::setUserCanWithdraw(bool _canWithdraw){
        u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
isOwner();
        *userCanWithdraw = _canWithdraw;
    }

    
    PAYABLE void PortfolioManage::createPortfolio(char* _portfolioName, char* _portfolioDesc){
        if(portfolioStorge.get()[_portfolioName] != ""){
            DIPC_EMIT_EVENT(ErrEvent, "Current portfolio exist: ", _portfolioName);
            return;
        } 
        std::string callerAddr = caller().toString();
        uint64_t tokenBalance = getTotalBalance();
        
        PortfolioInfo info(_portfolioName, _portfolioDesc, &callerAddr[0]);
        std::string portfolioStr = info.toJson();
        
        
        

        (*portfolioStorge)[_portfolioName] = portfolioStr;
        DipcAssert(totalToken.get() + tokenBalance > totalToken);
        (*portfolioBalance)[_portfolioName] = tokenBalance;
        *totalToken = totalToken.get() + tokenBalance; 
        
        DIPC_EMIT_EVENT(portfolioInfo, _portfolioName, &portfolioStr[0], "portfolioBalance", tokenBalance);
    }

    
    PAYABLE void PortfolioManage::depositPortfolio(char* _portfolioName){
        uint64_t tokenBalance = getTotalBalance();
        
        uint64_t currentBalance = portfolioBalance.get()[_portfolioName];
        uint64_t finalBalance  = currentBalance + tokenBalance;
        DipcAssert(totalToken.get() + tokenBalance > totalToken);
        DipcAssert(finalBalance > currentBalance);
        (*portfolioBalance)[_portfolioName] = finalBalance;
        *totalToken = totalToken.get() + finalBalance; 
        DIPC_EMIT_EVENT(depositPortfolio, "portfolioName", _portfolioName, "portfolioBalance", finalBalance);
    }
    
    PAYABLE void PortfolioManage::createOrder(char* _portfolioName, char* _orderId, uint16_t _orderType, char* _stockCode, uint64_t _stockPrice, uint64_t _stockAmount, uint64_t _endTime){
        uint64_t tokenBalance = getTotalBalance();
        DIPC_EMIT_EVENT(createOrder, "portfolioName", _portfolioName, "OrderInfo", "ignore", "tokenBalance", tokenBalance);
        uint64_t spent = 0;
        if(_orderType == 1){
            spent = _stockPrice * _stockAmount;
            DipcAssert((portfolioBalance.get()[_portfolioName] + tokenBalance) > spent);
        }
        struct Order order{_orderId, _orderType, _stockCode, _stockPrice, _stockAmount, _endTime, 0};
        std::string pInfo = portfolioStorge.get()[_portfolioName];
        
        
        
        if(pInfo == "") {
            DIPC_EMIT_EVENT(ErrEvent, "Current portfolio  doesn't exist: ", _portfolioName);
            return;
        }
        PortfolioInfo info;
        info.parseJson(pInfo);
        if(info.getOrder(_orderId).orderId != ""){
            DIPC_EMIT_EVENT(ErrEvent, "Current order exist: ", _orderId);
            return;
        }
        info.addOrder(order);
        pInfo = info.toJson();

        uint64_t currentBalance = portfolioBalance.get()[_portfolioName] ;
        uint64_t finalBalance = currentBalance + tokenBalance - spent;
        DipcAssert(totalToken.get() + tokenBalance > totalToken);
        
        DipcAssert(ownerTotalToken.get() < ownerTotalToken.get() + spent);
        (*portfolioStorge)[_portfolioName] = &pInfo[0];
        
        
        
        


        (*portfolioBalance)[_portfolioName] = finalBalance;
        *totalToken = totalToken.get() + finalBalance; 
        *ownerTotalToken = ownerTotalToken.get() + spent;
        DIPC_EMIT_EVENT(createOrder, "portfolioName", _portfolioName, "OrderInfo", &order.toJson()[0], "portfolioBalance", finalBalance);
    }

    
    EXPORT void PortfolioManage::dealOrder(char* _portfolioName, char* _orderId){
        u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
isOwner();
        std::string pInfo = portfolioStorge.get()[_portfolioName];
        
        
        PortfolioInfo info;
        info.parseJson(pInfo);
        

        
         Order ord = info.getOrder(_orderId);
         
         
        if(ord.orderId != "" && ord.orderStatus == 0){
            
            uint64_t timenow = dipc::timestamp();
            if(ord.endTime > timenow){
                ord.orderStatus = 1;
            }else {
                ord.orderStatus = 3;
            }
        } else {
          

            return;
        }
        

        uint64_t sellValue = 0;
        if(ord.orderType == 0){
            sellValue = ord.stockAmount * ord.stockPrice;
        }
        uint64_t currentBalance =  portfolioBalance.get()[_portfolioName];
        

        DipcAssert(currentBalance + sellValue >= currentBalance);
        DipcAssert((ownerTotalToken.get() - sellValue) <= ownerTotalToken.get());
        


        (*portfolioBalance)[_portfolioName] = currentBalance + sellValue;
        *ownerTotalToken = ownerTotalToken.get() - sellValue;
        (*portfolioStorge)[_portfolioName] = &info.toJson()[0];
        
        
        
        

        DIPC_EMIT_EVENT(dealPortfolio, "orderId", _orderId, "orderInfo", &ord.toJson()[0]);
    }
    
    EXPORT void PortfolioManage::revocationOrder(char* _portfolioName, char* _orderId){
        u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
std::string pInfo = portfolioStorge.get()[_portfolioName];
        
        
        PortfolioInfo info;
        info.parseJson(pInfo);
        Order ord = info.getOrder(_orderId);
        
        
        if(ord.orderId != "" && ord.orderStatus == 0){
            std::string callerStr = caller().toString();
            
            
            
            DipcAssert(info.getOwnerAddress() == caller().toString());
            

            uint64_t timenow = dipc::timestamp();
            if(ord.endTime > timenow){
                ord.orderStatus = 2;
            }else {
                ord.orderStatus = 3;
            }
        } else {
            return;
        }
        uint64_t lockToken = 0;
        if(ord.orderType == 1){
            lockToken = ord.stockPrice * ord.stockAmount;
        }
        uint64_t currentBalance =  portfolioBalance.get()[_portfolioName];
        
        
        
        

        DipcAssert(currentBalance + lockToken >= currentBalance);
        DipcAssert(ownerTotalToken.get() - lockToken <= ownerTotalToken.get());

        
        (*portfolioBalance)[_portfolioName] = currentBalance + lockToken;
        *ownerTotalToken = ownerTotalToken.get() - lockToken;
        (*portfolioStorge)[_portfolioName] = &info.toJson()[0];
        DIPC_EMIT_EVENT(revocationPortfolio, "orderId", _orderId, "orderInfo", &ord.toJson()[0]);
    }
    
    EXPORT void PortfolioManage::withdrawPortfolio(char* _portfolioName, uint64_t _withdrawBalance){
         u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
if(!userCanWithdraw.get()){
             return;
         }
         uint64_t currentBalance =  portfolioBalance.get()[_portfolioName];
         DipcAssert(currentBalance - _withdrawBalance < currentBalance);
         auto coinBalance = changeUint64ToU256WithChangeRate(currentBalance, changeRate.get());
         (*portfolioBalance)[_portfolioName] = currentBalance - _withdrawBalance;
         callTransfer(caller(), coinBalance);
    }
    
    EXPORT void PortfolioManage::withdrawPool(uint64_t _balance){
        u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
isOwner();
        Address ownerAddr = Address(owner.get()); 
        callTransfer(ownerAddr, _balance);
        *ownerTotalToken = ownerTotalToken.get() - _balance * changeRate.get();
        *totalToken = totalToken.get() - _balance * changeRate.get();
        DIPC_EMIT_EVENT(tokenCount, "ownerTotalToken", ownerTotalToken.get(), "totalToken", totalToken.get());
    }
    
    PAYABLE void PortfolioManage::depositPool(uint64_t _depositValue){
        isOwner();
        
        uint64_t tokenBalance = changeU256ToUint64WithChangeRate(callValue(), changeRate.get()); 
        *ownerTotalToken = ownerTotalToken.get() + tokenBalance;
        *totalToken = totalToken.get() + tokenBalance;
        DIPC_EMIT_EVENT(tokenCount, "ownerTotalToken", ownerTotalToken.get(), "totalToken", totalToken.get());
    }
     
    CONSTANT uint64_t PortfolioManage::queryTotalToken(){
        u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
return totalToken.get();
    }

     
    CONSTANT uint64_t PortfolioManage::queryPortfolioBalance(char* _portfolioName){
        u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
return portfolioBalance.get()[_portfolioName];
    }

    
    CONSTANT bool PortfolioManage::queryPortfolioNameIfUsed(char* _portfolioName){
        if(portfolioStorge.get()[_portfolioName] != ""){
            return true;
        } 
        return false;
    }

    
    CONSTANT uint64_t PortfolioManage::queryChangeRate(){
        return changeRate.get();
    }

2019-12-19_15:14:55.369427: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:604] finalContract  final content =======   : #include "PortfolioManage.hpp"

    
    PAYABLE void PortfolioManage::init(){
        *owner = caller().toString();
        *changeRate = 10000;
        *userCanWithdraw = false;
        uint64_t tokenBalance = getTotalBalance();
        
        *ownerTotalToken = tokenBalance;
        *totalToken = ownerTotalToken.get();
        
        
        DIPC_EMIT_EVENT(initEvent, "ownerTotalToken" ,tokenBalance);
    }
    
     
    EXPORT void PortfolioManage::setChangeRate(uint64_t _changeRate){
        u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
isOwner();
        *changeRate = _changeRate;
    }
     
    EXPORT void PortfolioManage::setUserCanWithdraw(bool _canWithdraw){
        u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
isOwner();
        *userCanWithdraw = _canWithdraw;
    }

    
    PAYABLE void PortfolioManage::createPortfolio(char* _portfolioName, char* _portfolioDesc){
        if(portfolioStorge.get()[_portfolioName] != ""){
            DIPC_EMIT_EVENT(ErrEvent, "Current portfolio exist: ", _portfolioName);
            return;
        } 
        std::string callerAddr = caller().toString();
        uint64_t tokenBalance = getTotalBalance();
        
        PortfolioInfo info(_portfolioName, _portfolioDesc, &callerAddr[0]);
        std::string portfolioStr = info.toJson();
        
        
        

        (*portfolioStorge)[_portfolioName] = portfolioStr;
        DipcAssert(totalToken.get() + tokenBalance > totalToken);
        (*portfolioBalance)[_portfolioName] = tokenBalance;
        *totalToken = totalToken.get() + tokenBalance; 
        
        DIPC_EMIT_EVENT(portfolioInfo, _portfolioName, &portfolioStr[0], "portfolioBalance", tokenBalance);
    }

    
    PAYABLE void PortfolioManage::depositPortfolio(char* _portfolioName){
        uint64_t tokenBalance = getTotalBalance();
        
        uint64_t currentBalance = portfolioBalance.get()[_portfolioName];
        uint64_t finalBalance  = currentBalance + tokenBalance;
        DipcAssert(totalToken.get() + tokenBalance > totalToken);
        DipcAssert(finalBalance > currentBalance);
        (*portfolioBalance)[_portfolioName] = finalBalance;
        *totalToken = totalToken.get() + finalBalance; 
        DIPC_EMIT_EVENT(depositPortfolio, "portfolioName", _portfolioName, "portfolioBalance", finalBalance);
    }
    
    PAYABLE void PortfolioManage::createOrder(char* _portfolioName, char* _orderId, uint16_t _orderType, char* _stockCode, uint64_t _stockPrice, uint64_t _stockAmount, uint64_t _endTime){
        uint64_t tokenBalance = getTotalBalance();
        DIPC_EMIT_EVENT(createOrder, "portfolioName", _portfolioName, "OrderInfo", "ignore", "tokenBalance", tokenBalance);
        uint64_t spent = 0;
        if(_orderType == 1){
            spent = _stockPrice * _stockAmount;
            DipcAssert((portfolioBalance.get()[_portfolioName] + tokenBalance) > spent);
        }
        struct Order order{_orderId, _orderType, _stockCode, _stockPrice, _stockAmount, _endTime, 0};
        std::string pInfo = portfolioStorge.get()[_portfolioName];
        
        
        
        if(pInfo == "") {
            DIPC_EMIT_EVENT(ErrEvent, "Current portfolio  doesn't exist: ", _portfolioName);
            return;
        }
        PortfolioInfo info;
        info.parseJson(pInfo);
        if(info.getOrder(_orderId).orderId != ""){
            DIPC_EMIT_EVENT(ErrEvent, "Current order exist: ", _orderId);
            return;
        }
        info.addOrder(order);
        pInfo = info.toJson();

        uint64_t currentBalance = portfolioBalance.get()[_portfolioName] ;
        uint64_t finalBalance = currentBalance + tokenBalance - spent;
        DipcAssert(totalToken.get() + tokenBalance > totalToken);
        
        DipcAssert(ownerTotalToken.get() < ownerTotalToken.get() + spent);
        (*portfolioStorge)[_portfolioName] = &pInfo[0];
        
        
        
        


        (*portfolioBalance)[_portfolioName] = finalBalance;
        *totalToken = totalToken.get() + finalBalance; 
        *ownerTotalToken = ownerTotalToken.get() + spent;
        DIPC_EMIT_EVENT(createOrder, "portfolioName", _portfolioName, "OrderInfo", &order.toJson()[0], "portfolioBalance", finalBalance);
    }

    
    EXPORT void PortfolioManage::dealOrder(char* _portfolioName, char* _orderId){
        u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
isOwner();
        std::string pInfo = portfolioStorge.get()[_portfolioName];
        
        
        PortfolioInfo info;
        info.parseJson(pInfo);
        

        
         Order ord = info.getOrder(_orderId);
         
         
        if(ord.orderId != "" && ord.orderStatus == 0){
            
            uint64_t timenow = dipc::timestamp();
            if(ord.endTime > timenow){
                ord.orderStatus = 1;
            }else {
                ord.orderStatus = 3;
            }
        } else {
          

            return;
        }
        

        uint64_t sellValue = 0;
        if(ord.orderType == 0){
            sellValue = ord.stockAmount * ord.stockPrice;
        }
        uint64_t currentBalance =  portfolioBalance.get()[_portfolioName];
        

        DipcAssert(currentBalance + sellValue >= currentBalance);
        DipcAssert((ownerTotalToken.get() - sellValue) <= ownerTotalToken.get());
        


        (*portfolioBalance)[_portfolioName] = currentBalance + sellValue;
        *ownerTotalToken = ownerTotalToken.get() - sellValue;
        (*portfolioStorge)[_portfolioName] = &info.toJson()[0];
        
        
        
        

        DIPC_EMIT_EVENT(dealPortfolio, "orderId", _orderId, "orderInfo", &ord.toJson()[0]);
    }
    
    EXPORT void PortfolioManage::revocationOrder(char* _portfolioName, char* _orderId){
        u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
std::string pInfo = portfolioStorge.get()[_portfolioName];
        
        
        PortfolioInfo info;
        info.parseJson(pInfo);
        Order ord = info.getOrder(_orderId);
        
        
        if(ord.orderId != "" && ord.orderStatus == 0){
            std::string callerStr = caller().toString();
            
            
            
            DipcAssert(info.getOwnerAddress() == caller().toString());
            

            uint64_t timenow = dipc::timestamp();
            if(ord.endTime > timenow){
                ord.orderStatus = 2;
            }else {
                ord.orderStatus = 3;
            }
        } else {
            return;
        }
        uint64_t lockToken = 0;
        if(ord.orderType == 1){
            lockToken = ord.stockPrice * ord.stockAmount;
        }
        uint64_t currentBalance =  portfolioBalance.get()[_portfolioName];
        
        
        
        

        DipcAssert(currentBalance + lockToken >= currentBalance);
        DipcAssert(ownerTotalToken.get() - lockToken <= ownerTotalToken.get());

        
        (*portfolioBalance)[_portfolioName] = currentBalance + lockToken;
        *ownerTotalToken = ownerTotalToken.get() - lockToken;
        (*portfolioStorge)[_portfolioName] = &info.toJson()[0];
        DIPC_EMIT_EVENT(revocationPortfolio, "orderId", _orderId, "orderInfo", &ord.toJson()[0]);
    }
    
    EXPORT void PortfolioManage::withdrawPortfolio(char* _portfolioName, uint64_t _withdrawBalance){
         u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
if(!userCanWithdraw.get()){
             return;
         }
         uint64_t currentBalance =  portfolioBalance.get()[_portfolioName];
         DipcAssert(currentBalance - _withdrawBalance < currentBalance);
         auto coinBalance = changeUint64ToU256WithChangeRate(currentBalance, changeRate.get());
         (*portfolioBalance)[_portfolioName] = currentBalance - _withdrawBalance;
         callTransfer(caller(), coinBalance);
    }
    
    EXPORT void PortfolioManage::withdrawPool(uint64_t _balance){
        u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
isOwner();
        Address ownerAddr = Address(owner.get()); 
        callTransfer(ownerAddr, _balance);
        *ownerTotalToken = ownerTotalToken.get() - _balance * changeRate.get();
        *totalToken = totalToken.get() - _balance * changeRate.get();
        DIPC_EMIT_EVENT(tokenCount, "ownerTotalToken", ownerTotalToken.get(), "totalToken", totalToken.get());
    }
    
    PAYABLE void PortfolioManage::depositPool(uint64_t _depositValue){
        isOwner();
        
        uint64_t tokenBalance = changeU256ToUint64WithChangeRate(callValue(), changeRate.get()); 
        *ownerTotalToken = ownerTotalToken.get() + tokenBalance;
        *totalToken = totalToken.get() + tokenBalance;
        DIPC_EMIT_EVENT(tokenCount, "ownerTotalToken", ownerTotalToken.get(), "totalToken", totalToken.get());
    }
     
    CONSTANT uint64_t PortfolioManage::queryTotalToken(){
        u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
return totalToken.get();
    }

     
    CONSTANT uint64_t PortfolioManage::queryPortfolioBalance(char* _portfolioName){
        u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
return portfolioBalance.get()[_portfolioName];
    }

    
    CONSTANT bool PortfolioManage::queryPortfolioNameIfUsed(char* _portfolioName){
        u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
if(portfolioStorge.get()[_portfolioName] != ""){
            return true;
        } 
        return false;
    }

    
    CONSTANT uint64_t PortfolioManage::queryChangeRate(){
        return changeRate.get();
    }

2019-12-19_15:14:55.369437: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:401] abis.ispayable :false

2019-12-19_15:14:55.369455: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:424] finalContract  this height  #include "PortfolioManage.hpp"

    
    PAYABLE void PortfolioManage::init(){
        *owner = caller().toString();
        *changeRate = 10000;
        *userCanWithdraw = false;
        uint64_t tokenBalance = getTotalBalance();
        
        *ownerTotalToken = tokenBalance;
        *totalToken = ownerTotalToken.get();
        
        
        DIPC_EMIT_EVENT(initEvent, "ownerTotalToken" ,tokenBalance);
    }
    
     
    EXPORT void PortfolioManage::setChangeRate(uint64_t _changeRate){
        u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
isOwner();
        *changeRate = _changeRate;
    }
     
    EXPORT void PortfolioManage::setUserCanWithdraw(bool _canWithdraw){
        u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
isOwner();
        *userCanWithdraw = _canWithdraw;
    }

    
    PAYABLE void PortfolioManage::createPortfolio(char* _portfolioName, char* _portfolioDesc){
        if(portfolioStorge.get()[_portfolioName] != ""){
            DIPC_EMIT_EVENT(ErrEvent, "Current portfolio exist: ", _portfolioName);
            return;
        } 
        std::string callerAddr = caller().toString();
        uint64_t tokenBalance = getTotalBalance();
        
        PortfolioInfo info(_portfolioName, _portfolioDesc, &callerAddr[0]);
        std::string portfolioStr = info.toJson();
        
        
        

        (*portfolioStorge)[_portfolioName] = portfolioStr;
        DipcAssert(totalToken.get() + tokenBalance > totalToken);
        (*portfolioBalance)[_portfolioName] = tokenBalance;
        *totalToken = totalToken.get() + tokenBalance; 
        
        DIPC_EMIT_EVENT(portfolioInfo, _portfolioName, &portfolioStr[0], "portfolioBalance", tokenBalance);
    }

    
    PAYABLE void PortfolioManage::depositPortfolio(char* _portfolioName){
        uint64_t tokenBalance = getTotalBalance();
        
        uint64_t currentBalance = portfolioBalance.get()[_portfolioName];
        uint64_t finalBalance  = currentBalance + tokenBalance;
        DipcAssert(totalToken.get() + tokenBalance > totalToken);
        DipcAssert(finalBalance > currentBalance);
        (*portfolioBalance)[_portfolioName] = finalBalance;
        *totalToken = totalToken.get() + finalBalance; 
        DIPC_EMIT_EVENT(depositPortfolio, "portfolioName", _portfolioName, "portfolioBalance", finalBalance);
    }
    
    PAYABLE void PortfolioManage::createOrder(char* _portfolioName, char* _orderId, uint16_t _orderType, char* _stockCode, uint64_t _stockPrice, uint64_t _stockAmount, uint64_t _endTime){
        uint64_t tokenBalance = getTotalBalance();
        DIPC_EMIT_EVENT(createOrder, "portfolioName", _portfolioName, "OrderInfo", "ignore", "tokenBalance", tokenBalance);
        uint64_t spent = 0;
        if(_orderType == 1){
            spent = _stockPrice * _stockAmount;
            DipcAssert((portfolioBalance.get()[_portfolioName] + tokenBalance) > spent);
        }
        struct Order order{_orderId, _orderType, _stockCode, _stockPrice, _stockAmount, _endTime, 0};
        std::string pInfo = portfolioStorge.get()[_portfolioName];
        
        
        
        if(pInfo == "") {
            DIPC_EMIT_EVENT(ErrEvent, "Current portfolio  doesn't exist: ", _portfolioName);
            return;
        }
        PortfolioInfo info;
        info.parseJson(pInfo);
        if(info.getOrder(_orderId).orderId != ""){
            DIPC_EMIT_EVENT(ErrEvent, "Current order exist: ", _orderId);
            return;
        }
        info.addOrder(order);
        pInfo = info.toJson();

        uint64_t currentBalance = portfolioBalance.get()[_portfolioName] ;
        uint64_t finalBalance = currentBalance + tokenBalance - spent;
        DipcAssert(totalToken.get() + tokenBalance > totalToken);
        
        DipcAssert(ownerTotalToken.get() < ownerTotalToken.get() + spent);
        (*portfolioStorge)[_portfolioName] = &pInfo[0];
        
        
        
        


        (*portfolioBalance)[_portfolioName] = finalBalance;
        *totalToken = totalToken.get() + finalBalance; 
        *ownerTotalToken = ownerTotalToken.get() + spent;
        DIPC_EMIT_EVENT(createOrder, "portfolioName", _portfolioName, "OrderInfo", &order.toJson()[0], "portfolioBalance", finalBalance);
    }

    
    EXPORT void PortfolioManage::dealOrder(char* _portfolioName, char* _orderId){
        u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
isOwner();
        std::string pInfo = portfolioStorge.get()[_portfolioName];
        
        
        PortfolioInfo info;
        info.parseJson(pInfo);
        

        
         Order ord = info.getOrder(_orderId);
         
         
        if(ord.orderId != "" && ord.orderStatus == 0){
            
            uint64_t timenow = dipc::timestamp();
            if(ord.endTime > timenow){
                ord.orderStatus = 1;
            }else {
                ord.orderStatus = 3;
            }
        } else {
          

            return;
        }
        

        uint64_t sellValue = 0;
        if(ord.orderType == 0){
            sellValue = ord.stockAmount * ord.stockPrice;
        }
        uint64_t currentBalance =  portfolioBalance.get()[_portfolioName];
        

        DipcAssert(currentBalance + sellValue >= currentBalance);
        DipcAssert((ownerTotalToken.get() - sellValue) <= ownerTotalToken.get());
        


        (*portfolioBalance)[_portfolioName] = currentBalance + sellValue;
        *ownerTotalToken = ownerTotalToken.get() - sellValue;
        (*portfolioStorge)[_portfolioName] = &info.toJson()[0];
        
        
        
        

        DIPC_EMIT_EVENT(dealPortfolio, "orderId", _orderId, "orderInfo", &ord.toJson()[0]);
    }
    
    EXPORT void PortfolioManage::revocationOrder(char* _portfolioName, char* _orderId){
        u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
std::string pInfo = portfolioStorge.get()[_portfolioName];
        
        
        PortfolioInfo info;
        info.parseJson(pInfo);
        Order ord = info.getOrder(_orderId);
        
        
        if(ord.orderId != "" && ord.orderStatus == 0){
            std::string callerStr = caller().toString();
            
            
            
            DipcAssert(info.getOwnerAddress() == caller().toString());
            

            uint64_t timenow = dipc::timestamp();
            if(ord.endTime > timenow){
                ord.orderStatus = 2;
            }else {
                ord.orderStatus = 3;
            }
        } else {
            return;
        }
        uint64_t lockToken = 0;
        if(ord.orderType == 1){
            lockToken = ord.stockPrice * ord.stockAmount;
        }
        uint64_t currentBalance =  portfolioBalance.get()[_portfolioName];
        
        
        
        

        DipcAssert(currentBalance + lockToken >= currentBalance);
        DipcAssert(ownerTotalToken.get() - lockToken <= ownerTotalToken.get());

        
        (*portfolioBalance)[_portfolioName] = currentBalance + lockToken;
        *ownerTotalToken = ownerTotalToken.get() - lockToken;
        (*portfolioStorge)[_portfolioName] = &info.toJson()[0];
        DIPC_EMIT_EVENT(revocationPortfolio, "orderId", _orderId, "orderInfo", &ord.toJson()[0]);
    }
    
    EXPORT void PortfolioManage::withdrawPortfolio(char* _portfolioName, uint64_t _withdrawBalance){
         u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
if(!userCanWithdraw.get()){
             return;
         }
         uint64_t currentBalance =  portfolioBalance.get()[_portfolioName];
         DipcAssert(currentBalance - _withdrawBalance < currentBalance);
         auto coinBalance = changeUint64ToU256WithChangeRate(currentBalance, changeRate.get());
         (*portfolioBalance)[_portfolioName] = currentBalance - _withdrawBalance;
         callTransfer(caller(), coinBalance);
    }
    
    EXPORT void PortfolioManage::withdrawPool(uint64_t _balance){
        u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
isOwner();
        Address ownerAddr = Address(owner.get()); 
        callTransfer(ownerAddr, _balance);
        *ownerTotalToken = ownerTotalToken.get() - _balance * changeRate.get();
        *totalToken = totalToken.get() - _balance * changeRate.get();
        DIPC_EMIT_EVENT(tokenCount, "ownerTotalToken", ownerTotalToken.get(), "totalToken", totalToken.get());
    }
    
    PAYABLE void PortfolioManage::depositPool(uint64_t _depositValue){
        isOwner();
        
        uint64_t tokenBalance = changeU256ToUint64WithChangeRate(callValue(), changeRate.get()); 
        *ownerTotalToken = ownerTotalToken.get() + tokenBalance;
        *totalToken = totalToken.get() + tokenBalance;
        DIPC_EMIT_EVENT(tokenCount, "ownerTotalToken", ownerTotalToken.get(), "totalToken", totalToken.get());
    }
     
    CONSTANT uint64_t PortfolioManage::queryTotalToken(){
        u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
return totalToken.get();
    }

     
    CONSTANT uint64_t PortfolioManage::queryPortfolioBalance(char* _portfolioName){
        u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
return portfolioBalance.get()[_portfolioName];
    }

    
    CONSTANT bool PortfolioManage::queryPortfolioNameIfUsed(char* _portfolioName){
        u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
if(portfolioStorge.get()[_portfolioName] != ""){
            return true;
        } 
        return false;
    }

    
    CONSTANT uint64_t PortfolioManage::queryChangeRate(){
        return changeRate.get();
    } codetext height #include "PortfolioManage.hpp"

    
    PAYABLE void PortfolioManage::init(){
        *owner = caller().toString();
        *changeRate = 10000;
        *userCanWithdraw = false;
        uint64_t tokenBalance = getTotalBalance();
        
        *ownerTotalToken = tokenBalance;
        *totalToken = ownerTotalToken.get();
        
        
        DIPC_EMIT_EVENT(initEvent, "ownerTotalToken" ,tokenBalance);
    }
    
     
    EXPORT void PortfolioManage::setChangeRate(uint64_t _changeRate){
        u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
isOwner();
        *changeRate = _changeRate;
    }
     
    EXPORT void PortfolioManage::setUserCanWithdraw(bool _canWithdraw){
        u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
isOwner();
        *userCanWithdraw = _canWithdraw;
    }

    
    PAYABLE void PortfolioManage::createPortfolio(char* _portfolioName, char* _portfolioDesc){
        if(portfolioStorge.get()[_portfolioName] != ""){
            DIPC_EMIT_EVENT(ErrEvent, "Current portfolio exist: ", _portfolioName);
            return;
        } 
        std::string callerAddr = caller().toString();
        uint64_t tokenBalance = getTotalBalance();
        
        PortfolioInfo info(_portfolioName, _portfolioDesc, &callerAddr[0]);
        std::string portfolioStr = info.toJson();
        
        
        

        (*portfolioStorge)[_portfolioName] = portfolioStr;
        DipcAssert(totalToken.get() + tokenBalance > totalToken);
        (*portfolioBalance)[_portfolioName] = tokenBalance;
        *totalToken = totalToken.get() + tokenBalance; 
        
        DIPC_EMIT_EVENT(portfolioInfo, _portfolioName, &portfolioStr[0], "portfolioBalance", tokenBalance);
    }

    
    PAYABLE void PortfolioManage::depositPortfolio(char* _portfolioName){
        uint64_t tokenBalance = getTotalBalance();
        
        uint64_t currentBalance = portfolioBalance.get()[_portfolioName];
        uint64_t finalBalance  = currentBalance + tokenBalance;
        DipcAssert(totalToken.get() + tokenBalance > totalToken);
        DipcAssert(finalBalance > currentBalance);
        (*portfolioBalance)[_portfolioName] = finalBalance;
        *totalToken = totalToken.get() + finalBalance; 
        DIPC_EMIT_EVENT(depositPortfolio, "portfolioName", _portfolioName, "portfolioBalance", finalBalance);
    }
    
    PAYABLE void PortfolioManage::createOrder(char* _portfolioName, char* _orderId, uint16_t _orderType, char* _stockCode, uint64_t _stockPrice, uint64_t _stockAmount, uint64_t _endTime){
        uint64_t tokenBalance = getTotalBalance();
        DIPC_EMIT_EVENT(createOrder, "portfolioName", _portfolioName, "OrderInfo", "ignore", "tokenBalance", tokenBalance);
        uint64_t spent = 0;
        if(_orderType == 1){
            spent = _stockPrice * _stockAmount;
            DipcAssert((portfolioBalance.get()[_portfolioName] + tokenBalance) > spent);
        }
        struct Order order{_orderId, _orderType, _stockCode, _stockPrice, _stockAmount, _endTime, 0};
        std::string pInfo = portfolioStorge.get()[_portfolioName];
        
        
        
        if(pInfo == "") {
            DIPC_EMIT_EVENT(ErrEvent, "Current portfolio  doesn't exist: ", _portfolioName);
            return;
        }
        PortfolioInfo info;
        info.parseJson(pInfo);
        if(info.getOrder(_orderId).orderId != ""){
            DIPC_EMIT_EVENT(ErrEvent, "Current order exist: ", _orderId);
            return;
        }
        info.addOrder(order);
        pInfo = info.toJson();

        uint64_t currentBalance = portfolioBalance.get()[_portfolioName] ;
        uint64_t finalBalance = currentBalance + tokenBalance - spent;
        DipcAssert(totalToken.get() + tokenBalance > totalToken);
        
        DipcAssert(ownerTotalToken.get() < ownerTotalToken.get() + spent);
        (*portfolioStorge)[_portfolioName] = &pInfo[0];
        
        
        
        


        (*portfolioBalance)[_portfolioName] = finalBalance;
        *totalToken = totalToken.get() + finalBalance; 
        *ownerTotalToken = ownerTotalToken.get() + spent;
        DIPC_EMIT_EVENT(createOrder, "portfolioName", _portfolioName, "OrderInfo", &order.toJson()[0], "portfolioBalance", finalBalance);
    }

    
    EXPORT void PortfolioManage::dealOrder(char* _portfolioName, char* _orderId){
        u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
isOwner();
        std::string pInfo = portfolioStorge.get()[_portfolioName];
        
        
        PortfolioInfo info;
        info.parseJson(pInfo);
        

        
         Order ord = info.getOrder(_orderId);
         
         
        if(ord.orderId != "" && ord.orderStatus == 0){
            
            uint64_t timenow = dipc::timestamp();
            if(ord.endTime > timenow){
                ord.orderStatus = 1;
            }else {
                ord.orderStatus = 3;
            }
        } else {
          

            return;
        }
        

        uint64_t sellValue = 0;
        if(ord.orderType == 0){
            sellValue = ord.stockAmount * ord.stockPrice;
        }
        uint64_t currentBalance =  portfolioBalance.get()[_portfolioName];
        

        DipcAssert(currentBalance + sellValue >= currentBalance);
        DipcAssert((ownerTotalToken.get() - sellValue) <= ownerTotalToken.get());
        


        (*portfolioBalance)[_portfolioName] = currentBalance + sellValue;
        *ownerTotalToken = ownerTotalToken.get() - sellValue;
        (*portfolioStorge)[_portfolioName] = &info.toJson()[0];
        
        
        
        

        DIPC_EMIT_EVENT(dealPortfolio, "orderId", _orderId, "orderInfo", &ord.toJson()[0]);
    }
    
    EXPORT void PortfolioManage::revocationOrder(char* _portfolioName, char* _orderId){
        u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
std::string pInfo = portfolioStorge.get()[_portfolioName];
        
        
        PortfolioInfo info;
        info.parseJson(pInfo);
        Order ord = info.getOrder(_orderId);
        
        
        if(ord.orderId != "" && ord.orderStatus == 0){
            std::string callerStr = caller().toString();
            
            
            
            DipcAssert(info.getOwnerAddress() == caller().toString());
            

            uint64_t timenow = dipc::timestamp();
            if(ord.endTime > timenow){
                ord.orderStatus = 2;
            }else {
                ord.orderStatus = 3;
            }
        } else {
            return;
        }
        uint64_t lockToken = 0;
        if(ord.orderType == 1){
            lockToken = ord.stockPrice * ord.stockAmount;
        }
        uint64_t currentBalance =  portfolioBalance.get()[_portfolioName];
        
        
        
        

        DipcAssert(currentBalance + lockToken >= currentBalance);
        DipcAssert(ownerTotalToken.get() - lockToken <= ownerTotalToken.get());

        
        (*portfolioBalance)[_portfolioName] = currentBalance + lockToken;
        *ownerTotalToken = ownerTotalToken.get() - lockToken;
        (*portfolioStorge)[_portfolioName] = &info.toJson()[0];
        DIPC_EMIT_EVENT(revocationPortfolio, "orderId", _orderId, "orderInfo", &ord.toJson()[0]);
    }
    
    EXPORT void PortfolioManage::withdrawPortfolio(char* _portfolioName, uint64_t _withdrawBalance){
         u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
if(!userCanWithdraw.get()){
             return;
         }
         uint64_t currentBalance =  portfolioBalance.get()[_portfolioName];
         DipcAssert(currentBalance - _withdrawBalance < currentBalance);
         auto coinBalance = changeUint64ToU256WithChangeRate(currentBalance, changeRate.get());
         (*portfolioBalance)[_portfolioName] = currentBalance - _withdrawBalance;
         callTransfer(caller(), coinBalance);
    }
    
    EXPORT void PortfolioManage::withdrawPool(uint64_t _balance){
        u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
isOwner();
        Address ownerAddr = Address(owner.get()); 
        callTransfer(ownerAddr, _balance);
        *ownerTotalToken = ownerTotalToken.get() - _balance * changeRate.get();
        *totalToken = totalToken.get() - _balance * changeRate.get();
        DIPC_EMIT_EVENT(tokenCount, "ownerTotalToken", ownerTotalToken.get(), "totalToken", totalToken.get());
    }
    
    PAYABLE void PortfolioManage::depositPool(uint64_t _depositValue){
        isOwner();
        
        uint64_t tokenBalance = changeU256ToUint64WithChangeRate(callValue(), changeRate.get()); 
        *ownerTotalToken = ownerTotalToken.get() + tokenBalance;
        *totalToken = totalToken.get() + tokenBalance;
        DIPC_EMIT_EVENT(tokenCount, "ownerTotalToken", ownerTotalToken.get(), "totalToken", totalToken.get());
    }
     
    CONSTANT uint64_t PortfolioManage::queryTotalToken(){
        u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
return totalToken.get();
    }

     
    CONSTANT uint64_t PortfolioManage::queryPortfolioBalance(char* _portfolioName){
        u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
return portfolioBalance.get()[_portfolioName];
    }

    
    CONSTANT bool PortfolioManage::queryPortfolioNameIfUsed(char* _portfolioName){
        u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
if(portfolioStorge.get()[_portfolioName] != ""){
            return true;
        } 
        return false;
    }

    
    CONSTANT uint64_t PortfolioManage::queryChangeRate(){
        return changeRate.get();
    }

2019-12-19_15:14:55.369501: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:427] searchContext  #include "PortfolioManage.hpp"

    
    PAYABLE void PortfolioManage::init(){
        *owner = caller().toString();
        *changeRate = 10000;
        *userCanWithdraw = false;
        uint64_t tokenBalance = getTotalBalance();
        
        *ownerTotalToken = tokenBalance;
        *totalToken = ownerTotalToken.get();
        
        
        DIPC_EMIT_EVENT(initEvent, "ownerTotalToken" ,tokenBalance);
    }
    
     
    EXPORT void PortfolioManage::setChangeRate(uint64_t _changeRate){
        u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
isOwner();
        *changeRate = _changeRate;
    }
     
    EXPORT void PortfolioManage::setUserCanWithdraw(bool _canWithdraw){
        u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
isOwner();
        *userCanWithdraw = _canWithdraw;
    }

    
    PAYABLE void PortfolioManage::createPortfolio(char* _portfolioName, char* _portfolioDesc){
        if(portfolioStorge.get()[_portfolioName] != ""){
            DIPC_EMIT_EVENT(ErrEvent, "Current portfolio exist: ", _portfolioName);
            return;
        } 
        std::string callerAddr = caller().toString();
        uint64_t tokenBalance = getTotalBalance();
        
        PortfolioInfo info(_portfolioName, _portfolioDesc, &callerAddr[0]);
        std::string portfolioStr = info.toJson();
        
        
        

        (*portfolioStorge)[_portfolioName] = portfolioStr;
        DipcAssert(totalToken.get() + tokenBalance > totalToken);
        (*portfolioBalance)[_portfolioName] = tokenBalance;
        *totalToken = totalToken.get() + tokenBalance; 
        
        DIPC_EMIT_EVENT(portfolioInfo, _portfolioName, &portfolioStr[0], "portfolioBalance", tokenBalance);
    }

    
    PAYABLE void PortfolioManage::depositPortfolio(char* _portfolioName){
        uint64_t tokenBalance = getTotalBalance();
        
        uint64_t currentBalance = portfolioBalance.get()[_portfolioName];
        uint64_t finalBalance  = currentBalance + tokenBalance;
        DipcAssert(totalToken.get() + tokenBalance > totalToken);
        DipcAssert(finalBalance > currentBalance);
        (*portfolioBalance)[_portfolioName] = finalBalance;
        *totalToken = totalToken.get() + finalBalance; 
        DIPC_EMIT_EVENT(depositPortfolio, "portfolioName", _portfolioName, "portfolioBalance", finalBalance);
    }
    
    PAYABLE void PortfolioManage::createOrder(char* _portfolioName, char* _orderId, uint16_t _orderType, char* _stockCode, uint64_t _stockPrice, uint64_t _stockAmount, uint64_t _endTime){
        uint64_t tokenBalance = getTotalBalance();
        DIPC_EMIT_EVENT(createOrder, "portfolioName", _portfolioName, "OrderInfo", "ignore", "tokenBalance", tokenBalance);
        uint64_t spent = 0;
        if(_orderType == 1){
            spent = _stockPrice * _stockAmount;
            DipcAssert((portfolioBalance.get()[_portfolioName] + tokenBalance) > spent);
        }
        struct Order order{_orderId, _orderType, _stockCode, _stockPrice, _stockAmount, _endTime, 0};
        std::string pInfo = portfolioStorge.get()[_portfolioName];
        
        
        
        if(pInfo == "") {
            DIPC_EMIT_EVENT(ErrEvent, "Current portfolio  doesn't exist: ", _portfolioName);
            return;
        }
        PortfolioInfo info;
        info.parseJson(pInfo);
        if(info.getOrder(_orderId).orderId != ""){
            DIPC_EMIT_EVENT(ErrEvent, "Current order exist: ", _orderId);
            return;
        }
        info.addOrder(order);
        pInfo = info.toJson();

        uint64_t currentBalance = portfolioBalance.get()[_portfolioName] ;
        uint64_t finalBalance = currentBalance + tokenBalance - spent;
        DipcAssert(totalToken.get() + tokenBalance > totalToken);
        
        DipcAssert(ownerTotalToken.get() < ownerTotalToken.get() + spent);
        (*portfolioStorge)[_portfolioName] = &pInfo[0];
        
        
        
        


        (*portfolioBalance)[_portfolioName] = finalBalance;
        *totalToken = totalToken.get() + finalBalance; 
        *ownerTotalToken = ownerTotalToken.get() + spent;
        DIPC_EMIT_EVENT(createOrder, "portfolioName", _portfolioName, "OrderInfo", &order.toJson()[0], "portfolioBalance", finalBalance);
    }

    
    EXPORT void PortfolioManage::dealOrder(char* _portfolioName, char* _orderId){
        u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
isOwner();
        std::string pInfo = portfolioStorge.get()[_portfolioName];
        
        
        PortfolioInfo info;
        info.parseJson(pInfo);
        

        
         Order ord = info.getOrder(_orderId);
         
         
        if(ord.orderId != "" && ord.orderStatus == 0){
            
            uint64_t timenow = dipc::timestamp();
            if(ord.endTime > timenow){
                ord.orderStatus = 1;
            }else {
                ord.orderStatus = 3;
            }
        } else {
          

            return;
        }
        

        uint64_t sellValue = 0;
        if(ord.orderType == 0){
            sellValue = ord.stockAmount * ord.stockPrice;
        }
        uint64_t currentBalance =  portfolioBalance.get()[_portfolioName];
        

        DipcAssert(currentBalance + sellValue >= currentBalance);
        DipcAssert((ownerTotalToken.get() - sellValue) <= ownerTotalToken.get());
        


        (*portfolioBalance)[_portfolioName] = currentBalance + sellValue;
        *ownerTotalToken = ownerTotalToken.get() - sellValue;
        (*portfolioStorge)[_portfolioName] = &info.toJson()[0];
        
        
        
        

        DIPC_EMIT_EVENT(dealPortfolio, "orderId", _orderId, "orderInfo", &ord.toJson()[0]);
    }
    
    EXPORT void PortfolioManage::revocationOrder(char* _portfolioName, char* _orderId){
        u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
std::string pInfo = portfolioStorge.get()[_portfolioName];
        
        
        PortfolioInfo info;
        info.parseJson(pInfo);
        Order ord = info.getOrder(_orderId);
        
        
        if(ord.orderId != "" && ord.orderStatus == 0){
            std::string callerStr = caller().toString();
            
            
            
            DipcAssert(info.getOwnerAddress() == caller().toString());
            

            uint64_t timenow = dipc::timestamp();
            if(ord.endTime > timenow){
                ord.orderStatus = 2;
            }else {
                ord.orderStatus = 3;
            }
        } else {
            return;
        }
        uint64_t lockToken = 0;
        if(ord.orderType == 1){
            lockToken = ord.stockPrice * ord.stockAmount;
        }
        uint64_t currentBalance =  portfolioBalance.get()[_portfolioName];
        
        
        
        

        DipcAssert(currentBalance + lockToken >= currentBalance);
        DipcAssert(ownerTotalToken.get() - lockToken <= ownerTotalToken.get());

        
        (*portfolioBalance)[_portfolioName] = currentBalance + lockToken;
        *ownerTotalToken = ownerTotalToken.get() - lockToken;
        (*portfolioStorge)[_portfolioName] = &info.toJson()[0];
        DIPC_EMIT_EVENT(revocationPortfolio, "orderId", _orderId, "orderInfo", &ord.toJson()[0]);
    }
    
    EXPORT void PortfolioManage::withdrawPortfolio(char* _portfolioName, uint64_t _withdrawBalance){
         u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
if(!userCanWithdraw.get()){
             return;
         }
         uint64_t currentBalance =  portfolioBalance.get()[_portfolioName];
         DipcAssert(currentBalance - _withdrawBalance < currentBalance);
         auto coinBalance = changeUint64ToU256WithChangeRate(currentBalance, changeRate.get());
         (*portfolioBalance)[_portfolioName] = currentBalance - _withdrawBalance;
         callTransfer(caller(), coinBalance);
    }
    
    EXPORT void PortfolioManage::withdrawPool(uint64_t _balance){
        u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
isOwner();
        Address ownerAddr = Address(owner.get()); 
        callTransfer(ownerAddr, _balance);
        *ownerTotalToken = ownerTotalToken.get() - _balance * changeRate.get();
        *totalToken = totalToken.get() - _balance * changeRate.get();
        DIPC_EMIT_EVENT(tokenCount, "ownerTotalToken", ownerTotalToken.get(), "totalToken", totalToken.get());
    }
    
    PAYABLE void PortfolioManage::depositPool(uint64_t _depositValue){
        isOwner();
        
        uint64_t tokenBalance = changeU256ToUint64WithChangeRate(callValue(), changeRate.get()); 
        *ownerTotalToken = ownerTotalToken.get() + tokenBalance;
        *totalToken = totalToken.get() + tokenBalance;
        DIPC_EMIT_EVENT(tokenCount, "ownerTotalToken", ownerTotalToken.get(), "totalToken", totalToken.get());
    }
     
    CONSTANT uint64_t PortfolioManage::queryTotalToken(){
        u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
return totalToken.get();
    }

     
    CONSTANT uint64_t PortfolioManage::queryPortfolioBalance(char* _portfolioName){
        u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
return portfolioBalance.get()[_portfolioName];
    }

    
    CONSTANT bool PortfolioManage::queryPortfolioNameIfUsed(char* _portfolioName){
        u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
if(portfolioStorge.get()[_portfolioName] != ""){
            return true;
        } 
        return false;
    }

    
    CONSTANT uint64_t PortfolioManage::queryChangeRate(){
        return changeRate.get();
    }

2019-12-19_15:14:55.611828: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:451] log out out  Export :

    
    CONSTANT uint64_t PortfolioManage::queryChangeRate(){
        

2019-12-19_15:14:55.611848: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:457] name : queryChangeRate   pos1  0

2019-12-19_15:14:55.611861: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:469] pos2  9441   pos1  9441

2019-12-19_15:14:55.611868: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:500] pos2 after 9544   pos1  9441

2019-12-19_15:14:55.611876: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:509] finalContract  first #include "PortfolioManage.hpp"

    
    PAYABLE void PortfolioManage::init(){
        *owner = caller().toString();
        *changeRate = 10000;
        *userCanWithdraw = false;
        uint64_t tokenBalance = getTotalBalance();
        
        *ownerTotalToken = tokenBalance;
        *totalToken = ownerTotalToken.get();
        
        
        DIPC_EMIT_EVENT(initEvent, "ownerTotalToken" ,tokenBalance);
    }
    
     
    EXPORT void PortfolioManage::setChangeRate(uint64_t _changeRate){
        u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
isOwner();
        *changeRate = _changeRate;
    }
     
    EXPORT void PortfolioManage::setUserCanWithdraw(bool _canWithdraw){
        u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
isOwner();
        *userCanWithdraw = _canWithdraw;
    }

    
    PAYABLE void PortfolioManage::createPortfolio(char* _portfolioName, char* _portfolioDesc){
        if(portfolioStorge.get()[_portfolioName] != ""){
            DIPC_EMIT_EVENT(ErrEvent, "Current portfolio exist: ", _portfolioName);
            return;
        } 
        std::string callerAddr = caller().toString();
        uint64_t tokenBalance = getTotalBalance();
        
        PortfolioInfo info(_portfolioName, _portfolioDesc, &callerAddr[0]);
        std::string portfolioStr = info.toJson();
        
        
        

        (*portfolioStorge)[_portfolioName] = portfolioStr;
        DipcAssert(totalToken.get() + tokenBalance > totalToken);
        (*portfolioBalance)[_portfolioName] = tokenBalance;
        *totalToken = totalToken.get() + tokenBalance; 
        
        DIPC_EMIT_EVENT(portfolioInfo, _portfolioName, &portfolioStr[0], "portfolioBalance", tokenBalance);
    }

    
    PAYABLE void PortfolioManage::depositPortfolio(char* _portfolioName){
        uint64_t tokenBalance = getTotalBalance();
        
        uint64_t currentBalance = portfolioBalance.get()[_portfolioName];
        uint64_t finalBalance  = currentBalance + tokenBalance;
        DipcAssert(totalToken.get() + tokenBalance > totalToken);
        DipcAssert(finalBalance > currentBalance);
        (*portfolioBalance)[_portfolioName] = finalBalance;
        *totalToken = totalToken.get() + finalBalance; 
        DIPC_EMIT_EVENT(depositPortfolio, "portfolioName", _portfolioName, "portfolioBalance", finalBalance);
    }
    
    PAYABLE void PortfolioManage::createOrder(char* _portfolioName, char* _orderId, uint16_t _orderType, char* _stockCode, uint64_t _stockPrice, uint64_t _stockAmount, uint64_t _endTime){
        uint64_t tokenBalance = getTotalBalance();
        DIPC_EMIT_EVENT(createOrder, "portfolioName", _portfolioName, "OrderInfo", "ignore", "tokenBalance", tokenBalance);
        uint64_t spent = 0;
        if(_orderType == 1){
            spent = _stockPrice * _stockAmount;
            DipcAssert((portfolioBalance.get()[_portfolioName] + tokenBalance) > spent);
        }
        struct Order order{_orderId, _orderType, _stockCode, _stockPrice, _stockAmount, _endTime, 0};
        std::string pInfo = portfolioStorge.get()[_portfolioName];
        
        
        
        if(pInfo == "") {
            DIPC_EMIT_EVENT(ErrEvent, "Current portfolio  doesn't exist: ", _portfolioName);
            return;
        }
        PortfolioInfo info;
        info.parseJson(pInfo);
        if(info.getOrder(_orderId).orderId != ""){
            DIPC_EMIT_EVENT(ErrEvent, "Current order exist: ", _orderId);
            return;
        }
        info.addOrder(order);
        pInfo = info.toJson();

        uint64_t currentBalance = portfolioBalance.get()[_portfolioName] ;
        uint64_t finalBalance = currentBalance + tokenBalance - spent;
        DipcAssert(totalToken.get() + tokenBalance > totalToken);
        
        DipcAssert(ownerTotalToken.get() < ownerTotalToken.get() + spent);
        (*portfolioStorge)[_portfolioName] = &pInfo[0];
        
        
        
        


        (*portfolioBalance)[_portfolioName] = finalBalance;
        *totalToken = totalToken.get() + finalBalance; 
        *ownerTotalToken = ownerTotalToken.get() + spent;
        DIPC_EMIT_EVENT(createOrder, "portfolioName", _portfolioName, "OrderInfo", &order.toJson()[0], "portfolioBalance", finalBalance);
    }

    
    EXPORT void PortfolioManage::dealOrder(char* _portfolioName, char* _orderId){
        u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
isOwner();
        std::string pInfo = portfolioStorge.get()[_portfolioName];
        
        
        PortfolioInfo info;
        info.parseJson(pInfo);
        

        
         Order ord = info.getOrder(_orderId);
         
         
        if(ord.orderId != "" && ord.orderStatus == 0){
            
            uint64_t timenow = dipc::timestamp();
            if(ord.endTime > timenow){
                ord.orderStatus = 1;
            }else {
                ord.orderStatus = 3;
            }
        } else {
          

            return;
        }
        

        uint64_t sellValue = 0;
        if(ord.orderType == 0){
            sellValue = ord.stockAmount * ord.stockPrice;
        }
        uint64_t currentBalance =  portfolioBalance.get()[_portfolioName];
        

        DipcAssert(currentBalance + sellValue >= currentBalance);
        DipcAssert((ownerTotalToken.get() - sellValue) <= ownerTotalToken.get());
        


        (*portfolioBalance)[_portfolioName] = currentBalance + sellValue;
        *ownerTotalToken = ownerTotalToken.get() - sellValue;
        (*portfolioStorge)[_portfolioName] = &info.toJson()[0];
        
        
        
        

        DIPC_EMIT_EVENT(dealPortfolio, "orderId", _orderId, "orderInfo", &ord.toJson()[0]);
    }
    
    EXPORT void PortfolioManage::revocationOrder(char* _portfolioName, char* _orderId){
        u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
std::string pInfo = portfolioStorge.get()[_portfolioName];
        
        
        PortfolioInfo info;
        info.parseJson(pInfo);
        Order ord = info.getOrder(_orderId);
        
        
        if(ord.orderId != "" && ord.orderStatus == 0){
            std::string callerStr = caller().toString();
            
            
            
            DipcAssert(info.getOwnerAddress() == caller().toString());
            

            uint64_t timenow = dipc::timestamp();
            if(ord.endTime > timenow){
                ord.orderStatus = 2;
            }else {
                ord.orderStatus = 3;
            }
        } else {
            return;
        }
        uint64_t lockToken = 0;
        if(ord.orderType == 1){
            lockToken = ord.stockPrice * ord.stockAmount;
        }
        uint64_t currentBalance =  portfolioBalance.get()[_portfolioName];
        
        
        
        

        DipcAssert(currentBalance + lockToken >= currentBalance);
        DipcAssert(ownerTotalToken.get() - lockToken <= ownerTotalToken.get());

        
        (*portfolioBalance)[_portfolioName] = currentBalance + lockToken;
        *ownerTotalToken = ownerTotalToken.get() - lockToken;
        (*portfolioStorge)[_portfolioName] = &info.toJson()[0];
        DIPC_EMIT_EVENT(revocationPortfolio, "orderId", _orderId, "orderInfo", &ord.toJson()[0]);
    }
    
    EXPORT void PortfolioManage::withdrawPortfolio(char* _portfolioName, uint64_t _withdrawBalance){
         u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
if(!userCanWithdraw.get()){
             return;
         }
         uint64_t currentBalance =  portfolioBalance.get()[_portfolioName];
         DipcAssert(currentBalance - _withdrawBalance < currentBalance);
         auto coinBalance = changeUint64ToU256WithChangeRate(currentBalance, changeRate.get());
         (*portfolioBalance)[_portfolioName] = currentBalance - _withdrawBalance;
         callTransfer(caller(), coinBalance);
    }
    
    EXPORT void PortfolioManage::withdrawPool(uint64_t _balance){
        u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
isOwner();
        Address ownerAddr = Address(owner.get()); 
        callTransfer(ownerAddr, _balance);
        *ownerTotalToken = ownerTotalToken.get() - _balance * changeRate.get();
        *totalToken = totalToken.get() - _balance * changeRate.get();
        DIPC_EMIT_EVENT(tokenCount, "ownerTotalToken", ownerTotalToken.get(), "totalToken", totalToken.get());
    }
    
    PAYABLE void PortfolioManage::depositPool(uint64_t _depositValue){
        isOwner();
        
        uint64_t tokenBalance = changeU256ToUint64WithChangeRate(callValue(), changeRate.get()); 
        *ownerTotalToken = ownerTotalToken.get() + tokenBalance;
        *totalToken = totalToken.get() + tokenBalance;
        DIPC_EMIT_EVENT(tokenCount, "ownerTotalToken", ownerTotalToken.get(), "totalToken", totalToken.get());
    }
     
    CONSTANT uint64_t PortfolioManage::queryTotalToken(){
        u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
return totalToken.get();
    }

     
    CONSTANT uint64_t PortfolioManage::queryPortfolioBalance(char* _portfolioName){
        u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
return portfolioBalance.get()[_portfolioName];
    }

    
    CONSTANT bool PortfolioManage::queryPortfolioNameIfUsed(char* _portfolioName){
        u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
if(portfolioStorge.get()[_portfolioName] != ""){
            return true;
        } 
        return false;
    }

2019-12-19_15:14:55.611886: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:510] codetext  first #include "PortfolioManage.hpp"

    
    PAYABLE void PortfolioManage::init(){
        *owner = caller().toString();
        *changeRate = 10000;
        *userCanWithdraw = false;
        uint64_t tokenBalance = getTotalBalance();
        
        *ownerTotalToken = tokenBalance;
        *totalToken = ownerTotalToken.get();
        
        
        DIPC_EMIT_EVENT(initEvent, "ownerTotalToken" ,tokenBalance);
    }
    
     
    EXPORT void PortfolioManage::setChangeRate(uint64_t _changeRate){
        u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
isOwner();
        *changeRate = _changeRate;
    }
     
    EXPORT void PortfolioManage::setUserCanWithdraw(bool _canWithdraw){
        u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
isOwner();
        *userCanWithdraw = _canWithdraw;
    }

    
    PAYABLE void PortfolioManage::createPortfolio(char* _portfolioName, char* _portfolioDesc){
        if(portfolioStorge.get()[_portfolioName] != ""){
            DIPC_EMIT_EVENT(ErrEvent, "Current portfolio exist: ", _portfolioName);
            return;
        } 
        std::string callerAddr = caller().toString();
        uint64_t tokenBalance = getTotalBalance();
        
        PortfolioInfo info(_portfolioName, _portfolioDesc, &callerAddr[0]);
        std::string portfolioStr = info.toJson();
        
        
        

        (*portfolioStorge)[_portfolioName] = portfolioStr;
        DipcAssert(totalToken.get() + tokenBalance > totalToken);
        (*portfolioBalance)[_portfolioName] = tokenBalance;
        *totalToken = totalToken.get() + tokenBalance; 
        
        DIPC_EMIT_EVENT(portfolioInfo, _portfolioName, &portfolioStr[0], "portfolioBalance", tokenBalance);
    }

    
    PAYABLE void PortfolioManage::depositPortfolio(char* _portfolioName){
        uint64_t tokenBalance = getTotalBalance();
        
        uint64_t currentBalance = portfolioBalance.get()[_portfolioName];
        uint64_t finalBalance  = currentBalance + tokenBalance;
        DipcAssert(totalToken.get() + tokenBalance > totalToken);
        DipcAssert(finalBalance > currentBalance);
        (*portfolioBalance)[_portfolioName] = finalBalance;
        *totalToken = totalToken.get() + finalBalance; 
        DIPC_EMIT_EVENT(depositPortfolio, "portfolioName", _portfolioName, "portfolioBalance", finalBalance);
    }
    
    PAYABLE void PortfolioManage::createOrder(char* _portfolioName, char* _orderId, uint16_t _orderType, char* _stockCode, uint64_t _stockPrice, uint64_t _stockAmount, uint64_t _endTime){
        uint64_t tokenBalance = getTotalBalance();
        DIPC_EMIT_EVENT(createOrder, "portfolioName", _portfolioName, "OrderInfo", "ignore", "tokenBalance", tokenBalance);
        uint64_t spent = 0;
        if(_orderType == 1){
            spent = _stockPrice * _stockAmount;
            DipcAssert((portfolioBalance.get()[_portfolioName] + tokenBalance) > spent);
        }
        struct Order order{_orderId, _orderType, _stockCode, _stockPrice, _stockAmount, _endTime, 0};
        std::string pInfo = portfolioStorge.get()[_portfolioName];
        
        
        
        if(pInfo == "") {
            DIPC_EMIT_EVENT(ErrEvent, "Current portfolio  doesn't exist: ", _portfolioName);
            return;
        }
        PortfolioInfo info;
        info.parseJson(pInfo);
        if(info.getOrder(_orderId).orderId != ""){
            DIPC_EMIT_EVENT(ErrEvent, "Current order exist: ", _orderId);
            return;
        }
        info.addOrder(order);
        pInfo = info.toJson();

        uint64_t currentBalance = portfolioBalance.get()[_portfolioName] ;
        uint64_t finalBalance = currentBalance + tokenBalance - spent;
        DipcAssert(totalToken.get() + tokenBalance > totalToken);
        
        DipcAssert(ownerTotalToken.get() < ownerTotalToken.get() + spent);
        (*portfolioStorge)[_portfolioName] = &pInfo[0];
        
        
        
        


        (*portfolioBalance)[_portfolioName] = finalBalance;
        *totalToken = totalToken.get() + finalBalance; 
        *ownerTotalToken = ownerTotalToken.get() + spent;
        DIPC_EMIT_EVENT(createOrder, "portfolioName", _portfolioName, "OrderInfo", &order.toJson()[0], "portfolioBalance", finalBalance);
    }

    
    EXPORT void PortfolioManage::dealOrder(char* _portfolioName, char* _orderId){
        u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
isOwner();
        std::string pInfo = portfolioStorge.get()[_portfolioName];
        
        
        PortfolioInfo info;
        info.parseJson(pInfo);
        

        
         Order ord = info.getOrder(_orderId);
         
         
        if(ord.orderId != "" && ord.orderStatus == 0){
            
            uint64_t timenow = dipc::timestamp();
            if(ord.endTime > timenow){
                ord.orderStatus = 1;
            }else {
                ord.orderStatus = 3;
            }
        } else {
          

            return;
        }
        

        uint64_t sellValue = 0;
        if(ord.orderType == 0){
            sellValue = ord.stockAmount * ord.stockPrice;
        }
        uint64_t currentBalance =  portfolioBalance.get()[_portfolioName];
        

        DipcAssert(currentBalance + sellValue >= currentBalance);
        DipcAssert((ownerTotalToken.get() - sellValue) <= ownerTotalToken.get());
        


        (*portfolioBalance)[_portfolioName] = currentBalance + sellValue;
        *ownerTotalToken = ownerTotalToken.get() - sellValue;
        (*portfolioStorge)[_portfolioName] = &info.toJson()[0];
        
        
        
        

        DIPC_EMIT_EVENT(dealPortfolio, "orderId", _orderId, "orderInfo", &ord.toJson()[0]);
    }
    
    EXPORT void PortfolioManage::revocationOrder(char* _portfolioName, char* _orderId){
        u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
std::string pInfo = portfolioStorge.get()[_portfolioName];
        
        
        PortfolioInfo info;
        info.parseJson(pInfo);
        Order ord = info.getOrder(_orderId);
        
        
        if(ord.orderId != "" && ord.orderStatus == 0){
            std::string callerStr = caller().toString();
            
            
            
            DipcAssert(info.getOwnerAddress() == caller().toString());
            

            uint64_t timenow = dipc::timestamp();
            if(ord.endTime > timenow){
                ord.orderStatus = 2;
            }else {
                ord.orderStatus = 3;
            }
        } else {
            return;
        }
        uint64_t lockToken = 0;
        if(ord.orderType == 1){
            lockToken = ord.stockPrice * ord.stockAmount;
        }
        uint64_t currentBalance =  portfolioBalance.get()[_portfolioName];
        
        
        
        

        DipcAssert(currentBalance + lockToken >= currentBalance);
        DipcAssert(ownerTotalToken.get() - lockToken <= ownerTotalToken.get());

        
        (*portfolioBalance)[_portfolioName] = currentBalance + lockToken;
        *ownerTotalToken = ownerTotalToken.get() - lockToken;
        (*portfolioStorge)[_portfolioName] = &info.toJson()[0];
        DIPC_EMIT_EVENT(revocationPortfolio, "orderId", _orderId, "orderInfo", &ord.toJson()[0]);
    }
    
    EXPORT void PortfolioManage::withdrawPortfolio(char* _portfolioName, uint64_t _withdrawBalance){
         u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
if(!userCanWithdraw.get()){
             return;
         }
         uint64_t currentBalance =  portfolioBalance.get()[_portfolioName];
         DipcAssert(currentBalance - _withdrawBalance < currentBalance);
         auto coinBalance = changeUint64ToU256WithChangeRate(currentBalance, changeRate.get());
         (*portfolioBalance)[_portfolioName] = currentBalance - _withdrawBalance;
         callTransfer(caller(), coinBalance);
    }
    
    EXPORT void PortfolioManage::withdrawPool(uint64_t _balance){
        u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
isOwner();
        Address ownerAddr = Address(owner.get()); 
        callTransfer(ownerAddr, _balance);
        *ownerTotalToken = ownerTotalToken.get() - _balance * changeRate.get();
        *totalToken = totalToken.get() - _balance * changeRate.get();
        DIPC_EMIT_EVENT(tokenCount, "ownerTotalToken", ownerTotalToken.get(), "totalToken", totalToken.get());
    }
    
    PAYABLE void PortfolioManage::depositPool(uint64_t _depositValue){
        isOwner();
        
        uint64_t tokenBalance = changeU256ToUint64WithChangeRate(callValue(), changeRate.get()); 
        *ownerTotalToken = ownerTotalToken.get() + tokenBalance;
        *totalToken = totalToken.get() + tokenBalance;
        DIPC_EMIT_EVENT(tokenCount, "ownerTotalToken", ownerTotalToken.get(), "totalToken", totalToken.get());
    }
     
    CONSTANT uint64_t PortfolioManage::queryTotalToken(){
        u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
return totalToken.get();
    }

     
    CONSTANT uint64_t PortfolioManage::queryPortfolioBalance(char* _portfolioName){
        u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
return portfolioBalance.get()[_portfolioName];
    }

    
    CONSTANT bool PortfolioManage::queryPortfolioNameIfUsed(char* _portfolioName){
        u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
if(portfolioStorge.get()[_portfolioName] != ""){
            return true;
        } 
        return false;
    }

    
    CONSTANT uint64_t PortfolioManage::queryChangeRate(){
        return changeRate.get();
    }

2019-12-19_15:14:55.611894: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:513] s  first 

    
    CONSTANT uint64_t PortfolioManage::queryChangeRate(){
        return changeRate.get();
    }

2019-12-19_15:14:55.611902: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:593] calledFunc temp export: 

    
    CONSTANT uint64_t PortfolioManage::queryChangeRate(){
        u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
return changeRate.get();
    }

2019-12-19_15:14:55.611909: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:599] search func : 

    
    CONSTANT uint64_t PortfolioManage::queryChangeRate(){
        u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
return changeRate.get();
    }
2019-12-19_15:14:55.611916: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:424] finalContract  this height  #include "PortfolioManage.hpp"

    
    PAYABLE void PortfolioManage::init(){
        *owner = caller().toString();
        *changeRate = 10000;
        *userCanWithdraw = false;
        uint64_t tokenBalance = getTotalBalance();
        
        *ownerTotalToken = tokenBalance;
        *totalToken = ownerTotalToken.get();
        
        
        DIPC_EMIT_EVENT(initEvent, "ownerTotalToken" ,tokenBalance);
    }
    
     
    EXPORT void PortfolioManage::setChangeRate(uint64_t _changeRate){
        u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
isOwner();
        *changeRate = _changeRate;
    }
     
    EXPORT void PortfolioManage::setUserCanWithdraw(bool _canWithdraw){
        u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
isOwner();
        *userCanWithdraw = _canWithdraw;
    }

    
    PAYABLE void PortfolioManage::createPortfolio(char* _portfolioName, char* _portfolioDesc){
        if(portfolioStorge.get()[_portfolioName] != ""){
            DIPC_EMIT_EVENT(ErrEvent, "Current portfolio exist: ", _portfolioName);
            return;
        } 
        std::string callerAddr = caller().toString();
        uint64_t tokenBalance = getTotalBalance();
        
        PortfolioInfo info(_portfolioName, _portfolioDesc, &callerAddr[0]);
        std::string portfolioStr = info.toJson();
        
        
        

        (*portfolioStorge)[_portfolioName] = portfolioStr;
        DipcAssert(totalToken.get() + tokenBalance > totalToken);
        (*portfolioBalance)[_portfolioName] = tokenBalance;
        *totalToken = totalToken.get() + tokenBalance; 
        
        DIPC_EMIT_EVENT(portfolioInfo, _portfolioName, &portfolioStr[0], "portfolioBalance", tokenBalance);
    }

    
    PAYABLE void PortfolioManage::depositPortfolio(char* _portfolioName){
        uint64_t tokenBalance = getTotalBalance();
        
        uint64_t currentBalance = portfolioBalance.get()[_portfolioName];
        uint64_t finalBalance  = currentBalance + tokenBalance;
        DipcAssert(totalToken.get() + tokenBalance > totalToken);
        DipcAssert(finalBalance > currentBalance);
        (*portfolioBalance)[_portfolioName] = finalBalance;
        *totalToken = totalToken.get() + finalBalance; 
        DIPC_EMIT_EVENT(depositPortfolio, "portfolioName", _portfolioName, "portfolioBalance", finalBalance);
    }
    
    PAYABLE void PortfolioManage::createOrder(char* _portfolioName, char* _orderId, uint16_t _orderType, char* _stockCode, uint64_t _stockPrice, uint64_t _stockAmount, uint64_t _endTime){
        uint64_t tokenBalance = getTotalBalance();
        DIPC_EMIT_EVENT(createOrder, "portfolioName", _portfolioName, "OrderInfo", "ignore", "tokenBalance", tokenBalance);
        uint64_t spent = 0;
        if(_orderType == 1){
            spent = _stockPrice * _stockAmount;
            DipcAssert((portfolioBalance.get()[_portfolioName] + tokenBalance) > spent);
        }
        struct Order order{_orderId, _orderType, _stockCode, _stockPrice, _stockAmount, _endTime, 0};
        std::string pInfo = portfolioStorge.get()[_portfolioName];
        
        
        
        if(pInfo == "") {
            DIPC_EMIT_EVENT(ErrEvent, "Current portfolio  doesn't exist: ", _portfolioName);
            return;
        }
        PortfolioInfo info;
        info.parseJson(pInfo);
        if(info.getOrder(_orderId).orderId != ""){
            DIPC_EMIT_EVENT(ErrEvent, "Current order exist: ", _orderId);
            return;
        }
        info.addOrder(order);
        pInfo = info.toJson();

        uint64_t currentBalance = portfolioBalance.get()[_portfolioName] ;
        uint64_t finalBalance = currentBalance + tokenBalance - spent;
        DipcAssert(totalToken.get() + tokenBalance > totalToken);
        
        DipcAssert(ownerTotalToken.get() < ownerTotalToken.get() + spent);
        (*portfolioStorge)[_portfolioName] = &pInfo[0];
        
        
        
        


        (*portfolioBalance)[_portfolioName] = finalBalance;
        *totalToken = totalToken.get() + finalBalance; 
        *ownerTotalToken = ownerTotalToken.get() + spent;
        DIPC_EMIT_EVENT(createOrder, "portfolioName", _portfolioName, "OrderInfo", &order.toJson()[0], "portfolioBalance", finalBalance);
    }

    
    EXPORT void PortfolioManage::dealOrder(char* _portfolioName, char* _orderId){
        u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
isOwner();
        std::string pInfo = portfolioStorge.get()[_portfolioName];
        
        
        PortfolioInfo info;
        info.parseJson(pInfo);
        

        
         Order ord = info.getOrder(_orderId);
         
         
        if(ord.orderId != "" && ord.orderStatus == 0){
            
            uint64_t timenow = dipc::timestamp();
            if(ord.endTime > timenow){
                ord.orderStatus = 1;
            }else {
                ord.orderStatus = 3;
            }
        } else {
          

            return;
        }
        

        uint64_t sellValue = 0;
        if(ord.orderType == 0){
            sellValue = ord.stockAmount * ord.stockPrice;
        }
        uint64_t currentBalance =  portfolioBalance.get()[_portfolioName];
        

        DipcAssert(currentBalance + sellValue >= currentBalance);
        DipcAssert((ownerTotalToken.get() - sellValue) <= ownerTotalToken.get());
        


        (*portfolioBalance)[_portfolioName] = currentBalance + sellValue;
        *ownerTotalToken = ownerTotalToken.get() - sellValue;
        (*portfolioStorge)[_portfolioName] = &info.toJson()[0];
        
        
        
        

        DIPC_EMIT_EVENT(dealPortfolio, "orderId", _orderId, "orderInfo", &ord.toJson()[0]);
    }
    
    EXPORT void PortfolioManage::revocationOrder(char* _portfolioName, char* _orderId){
        u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
std::string pInfo = portfolioStorge.get()[_portfolioName];
        
        
        PortfolioInfo info;
        info.parseJson(pInfo);
        Order ord = info.getOrder(_orderId);
        
        
        if(ord.orderId != "" && ord.orderStatus == 0){
            std::string callerStr = caller().toString();
            
            
            
            DipcAssert(info.getOwnerAddress() == caller().toString());
            

            uint64_t timenow = dipc::timestamp();
            if(ord.endTime > timenow){
                ord.orderStatus = 2;
            }else {
                ord.orderStatus = 3;
            }
        } else {
            return;
        }
        uint64_t lockToken = 0;
        if(ord.orderType == 1){
            lockToken = ord.stockPrice * ord.stockAmount;
        }
        uint64_t currentBalance =  portfolioBalance.get()[_portfolioName];
        
        
        
        

        DipcAssert(currentBalance + lockToken >= currentBalance);
        DipcAssert(ownerTotalToken.get() - lockToken <= ownerTotalToken.get());

        
        (*portfolioBalance)[_portfolioName] = currentBalance + lockToken;
        *ownerTotalToken = ownerTotalToken.get() - lockToken;
        (*portfolioStorge)[_portfolioName] = &info.toJson()[0];
        DIPC_EMIT_EVENT(revocationPortfolio, "orderId", _orderId, "orderInfo", &ord.toJson()[0]);
    }
    
    EXPORT void PortfolioManage::withdrawPortfolio(char* _portfolioName, uint64_t _withdrawBalance){
         u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
if(!userCanWithdraw.get()){
             return;
         }
         uint64_t currentBalance =  portfolioBalance.get()[_portfolioName];
         DipcAssert(currentBalance - _withdrawBalance < currentBalance);
         auto coinBalance = changeUint64ToU256WithChangeRate(currentBalance, changeRate.get());
         (*portfolioBalance)[_portfolioName] = currentBalance - _withdrawBalance;
         callTransfer(caller(), coinBalance);
    }
    
    EXPORT void PortfolioManage::withdrawPool(uint64_t _balance){
        u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
isOwner();
        Address ownerAddr = Address(owner.get()); 
        callTransfer(ownerAddr, _balance);
        *ownerTotalToken = ownerTotalToken.get() - _balance * changeRate.get();
        *totalToken = totalToken.get() - _balance * changeRate.get();
        DIPC_EMIT_EVENT(tokenCount, "ownerTotalToken", ownerTotalToken.get(), "totalToken", totalToken.get());
    }
    
    PAYABLE void PortfolioManage::depositPool(uint64_t _depositValue){
        isOwner();
        
        uint64_t tokenBalance = changeU256ToUint64WithChangeRate(callValue(), changeRate.get()); 
        *ownerTotalToken = ownerTotalToken.get() + tokenBalance;
        *totalToken = totalToken.get() + tokenBalance;
        DIPC_EMIT_EVENT(tokenCount, "ownerTotalToken", ownerTotalToken.get(), "totalToken", totalToken.get());
    }
     
    CONSTANT uint64_t PortfolioManage::queryTotalToken(){
        u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
return totalToken.get();
    }

     
    CONSTANT uint64_t PortfolioManage::queryPortfolioBalance(char* _portfolioName){
        u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
return portfolioBalance.get()[_portfolioName];
    }

    
    CONSTANT bool PortfolioManage::queryPortfolioNameIfUsed(char* _portfolioName){
        u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
if(portfolioStorge.get()[_portfolioName] != ""){
            return true;
        } 
        return false;
    }

    
    CONSTANT uint64_t PortfolioManage::queryChangeRate(){
        u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
return changeRate.get();
    } codetext height #include "PortfolioManage.hpp"

    
    PAYABLE void PortfolioManage::init(){
        *owner = caller().toString();
        *changeRate = 10000;
        *userCanWithdraw = false;
        uint64_t tokenBalance = getTotalBalance();
        
        *ownerTotalToken = tokenBalance;
        *totalToken = ownerTotalToken.get();
        
        
        DIPC_EMIT_EVENT(initEvent, "ownerTotalToken" ,tokenBalance);
    }
    
     
    EXPORT void PortfolioManage::setChangeRate(uint64_t _changeRate){
        u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
isOwner();
        *changeRate = _changeRate;
    }
     
    EXPORT void PortfolioManage::setUserCanWithdraw(bool _canWithdraw){
        u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
isOwner();
        *userCanWithdraw = _canWithdraw;
    }

    
    PAYABLE void PortfolioManage::createPortfolio(char* _portfolioName, char* _portfolioDesc){
        if(portfolioStorge.get()[_portfolioName] != ""){
            DIPC_EMIT_EVENT(ErrEvent, "Current portfolio exist: ", _portfolioName);
            return;
        } 
        std::string callerAddr = caller().toString();
        uint64_t tokenBalance = getTotalBalance();
        
        PortfolioInfo info(_portfolioName, _portfolioDesc, &callerAddr[0]);
        std::string portfolioStr = info.toJson();
        
        
        

        (*portfolioStorge)[_portfolioName] = portfolioStr;
        DipcAssert(totalToken.get() + tokenBalance > totalToken);
        (*portfolioBalance)[_portfolioName] = tokenBalance;
        *totalToken = totalToken.get() + tokenBalance; 
        
        DIPC_EMIT_EVENT(portfolioInfo, _portfolioName, &portfolioStr[0], "portfolioBalance", tokenBalance);
    }

    
    PAYABLE void PortfolioManage::depositPortfolio(char* _portfolioName){
        uint64_t tokenBalance = getTotalBalance();
        
        uint64_t currentBalance = portfolioBalance.get()[_portfolioName];
        uint64_t finalBalance  = currentBalance + tokenBalance;
        DipcAssert(totalToken.get() + tokenBalance > totalToken);
        DipcAssert(finalBalance > currentBalance);
        (*portfolioBalance)[_portfolioName] = finalBalance;
        *totalToken = totalToken.get() + finalBalance; 
        DIPC_EMIT_EVENT(depositPortfolio, "portfolioName", _portfolioName, "portfolioBalance", finalBalance);
    }
    
    PAYABLE void PortfolioManage::createOrder(char* _portfolioName, char* _orderId, uint16_t _orderType, char* _stockCode, uint64_t _stockPrice, uint64_t _stockAmount, uint64_t _endTime){
        uint64_t tokenBalance = getTotalBalance();
        DIPC_EMIT_EVENT(createOrder, "portfolioName", _portfolioName, "OrderInfo", "ignore", "tokenBalance", tokenBalance);
        uint64_t spent = 0;
        if(_orderType == 1){
            spent = _stockPrice * _stockAmount;
            DipcAssert((portfolioBalance.get()[_portfolioName] + tokenBalance) > spent);
        }
        struct Order order{_orderId, _orderType, _stockCode, _stockPrice, _stockAmount, _endTime, 0};
        std::string pInfo = portfolioStorge.get()[_portfolioName];
        
        
        
        if(pInfo == "") {
            DIPC_EMIT_EVENT(ErrEvent, "Current portfolio  doesn't exist: ", _portfolioName);
            return;
        }
        PortfolioInfo info;
        info.parseJson(pInfo);
        if(info.getOrder(_orderId).orderId != ""){
            DIPC_EMIT_EVENT(ErrEvent, "Current order exist: ", _orderId);
            return;
        }
        info.addOrder(order);
        pInfo = info.toJson();

        uint64_t currentBalance = portfolioBalance.get()[_portfolioName] ;
        uint64_t finalBalance = currentBalance + tokenBalance - spent;
        DipcAssert(totalToken.get() + tokenBalance > totalToken);
        
        DipcAssert(ownerTotalToken.get() < ownerTotalToken.get() + spent);
        (*portfolioStorge)[_portfolioName] = &pInfo[0];
        
        
        
        


        (*portfolioBalance)[_portfolioName] = finalBalance;
        *totalToken = totalToken.get() + finalBalance; 
        *ownerTotalToken = ownerTotalToken.get() + spent;
        DIPC_EMIT_EVENT(createOrder, "portfolioName", _portfolioName, "OrderInfo", &order.toJson()[0], "portfolioBalance", finalBalance);
    }

    
    EXPORT void PortfolioManage::dealOrder(char* _portfolioName, char* _orderId){
        u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
isOwner();
        std::string pInfo = portfolioStorge.get()[_portfolioName];
        
        
        PortfolioInfo info;
        info.parseJson(pInfo);
        

        
         Order ord = info.getOrder(_orderId);
         
         
        if(ord.orderId != "" && ord.orderStatus == 0){
            
            uint64_t timenow = dipc::timestamp();
            if(ord.endTime > timenow){
                ord.orderStatus = 1;
            }else {
                ord.orderStatus = 3;
            }
        } else {
          

            return;
        }
        

        uint64_t sellValue = 0;
        if(ord.orderType == 0){
            sellValue = ord.stockAmount * ord.stockPrice;
        }
        uint64_t currentBalance =  portfolioBalance.get()[_portfolioName];
        

        DipcAssert(currentBalance + sellValue >= currentBalance);
        DipcAssert((ownerTotalToken.get() - sellValue) <= ownerTotalToken.get());
        


        (*portfolioBalance)[_portfolioName] = currentBalance + sellValue;
        *ownerTotalToken = ownerTotalToken.get() - sellValue;
        (*portfolioStorge)[_portfolioName] = &info.toJson()[0];
        
        
        
        

        DIPC_EMIT_EVENT(dealPortfolio, "orderId", _orderId, "orderInfo", &ord.toJson()[0]);
    }
    
    EXPORT void PortfolioManage::revocationOrder(char* _portfolioName, char* _orderId){
        u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
std::string pInfo = portfolioStorge.get()[_portfolioName];
        
        
        PortfolioInfo info;
        info.parseJson(pInfo);
        Order ord = info.getOrder(_orderId);
        
        
        if(ord.orderId != "" && ord.orderStatus == 0){
            std::string callerStr = caller().toString();
            
            
            
            DipcAssert(info.getOwnerAddress() == caller().toString());
            

            uint64_t timenow = dipc::timestamp();
            if(ord.endTime > timenow){
                ord.orderStatus = 2;
            }else {
                ord.orderStatus = 3;
            }
        } else {
            return;
        }
        uint64_t lockToken = 0;
        if(ord.orderType == 1){
            lockToken = ord.stockPrice * ord.stockAmount;
        }
        uint64_t currentBalance =  portfolioBalance.get()[_portfolioName];
        
        
        
        

        DipcAssert(currentBalance + lockToken >= currentBalance);
        DipcAssert(ownerTotalToken.get() - lockToken <= ownerTotalToken.get());

        
        (*portfolioBalance)[_portfolioName] = currentBalance + lockToken;
        *ownerTotalToken = ownerTotalToken.get() - lockToken;
        (*portfolioStorge)[_portfolioName] = &info.toJson()[0];
        DIPC_EMIT_EVENT(revocationPortfolio, "orderId", _orderId, "orderInfo", &ord.toJson()[0]);
    }
    
    EXPORT void PortfolioManage::withdrawPortfolio(char* _portfolioName, uint64_t _withdrawBalance){
         u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
if(!userCanWithdraw.get()){
             return;
         }
         uint64_t currentBalance =  portfolioBalance.get()[_portfolioName];
         DipcAssert(currentBalance - _withdrawBalance < currentBalance);
         auto coinBalance = changeUint64ToU256WithChangeRate(currentBalance, changeRate.get());
         (*portfolioBalance)[_portfolioName] = currentBalance - _withdrawBalance;
         callTransfer(caller(), coinBalance);
    }
    
    EXPORT void PortfolioManage::withdrawPool(uint64_t _balance){
        u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
isOwner();
        Address ownerAddr = Address(owner.get()); 
        callTransfer(ownerAddr, _balance);
        *ownerTotalToken = ownerTotalToken.get() - _balance * changeRate.get();
        *totalToken = totalToken.get() - _balance * changeRate.get();
        DIPC_EMIT_EVENT(tokenCount, "ownerTotalToken", ownerTotalToken.get(), "totalToken", totalToken.get());
    }
    
    PAYABLE void PortfolioManage::depositPool(uint64_t _depositValue){
        isOwner();
        
        uint64_t tokenBalance = changeU256ToUint64WithChangeRate(callValue(), changeRate.get()); 
        *ownerTotalToken = ownerTotalToken.get() + tokenBalance;
        *totalToken = totalToken.get() + tokenBalance;
        DIPC_EMIT_EVENT(tokenCount, "ownerTotalToken", ownerTotalToken.get(), "totalToken", totalToken.get());
    }
     
    CONSTANT uint64_t PortfolioManage::queryTotalToken(){
        u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
return totalToken.get();
    }

     
    CONSTANT uint64_t PortfolioManage::queryPortfolioBalance(char* _portfolioName){
        u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
return portfolioBalance.get()[_portfolioName];
    }

    
    CONSTANT bool PortfolioManage::queryPortfolioNameIfUsed(char* _portfolioName){
        u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
if(portfolioStorge.get()[_portfolioName] != ""){
            return true;
        } 
        return false;
    }

    
    CONSTANT uint64_t PortfolioManage::queryChangeRate(){
        return changeRate.get();
    }

2019-12-19_15:14:55.611926: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:427] searchContext  

2019-12-19_15:14:55.611935: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:442] finalContract  this new  #include "PortfolioManage.hpp"

    
    PAYABLE void PortfolioManage::init(){
        *owner = caller().toString();
        *changeRate = 10000;
        *userCanWithdraw = false;
        uint64_t tokenBalance = getTotalBalance();
        
        *ownerTotalToken = tokenBalance;
        *totalToken = ownerTotalToken.get();
        
        
        DIPC_EMIT_EVENT(initEvent, "ownerTotalToken" ,tokenBalance);
    }
    
     
    EXPORT void PortfolioManage::setChangeRate(uint64_t _changeRate){
        u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
isOwner();
        *changeRate = _changeRate;
    }
     
    EXPORT void PortfolioManage::setUserCanWithdraw(bool _canWithdraw){
        u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
isOwner();
        *userCanWithdraw = _canWithdraw;
    }

    
    PAYABLE void PortfolioManage::createPortfolio(char* _portfolioName, char* _portfolioDesc){
        if(portfolioStorge.get()[_portfolioName] != ""){
            DIPC_EMIT_EVENT(ErrEvent, "Current portfolio exist: ", _portfolioName);
            return;
        } 
        std::string callerAddr = caller().toString();
        uint64_t tokenBalance = getTotalBalance();
        
        PortfolioInfo info(_portfolioName, _portfolioDesc, &callerAddr[0]);
        std::string portfolioStr = info.toJson();
        
        
        

        (*portfolioStorge)[_portfolioName] = portfolioStr;
        DipcAssert(totalToken.get() + tokenBalance > totalToken);
        (*portfolioBalance)[_portfolioName] = tokenBalance;
        *totalToken = totalToken.get() + tokenBalance; 
        
        DIPC_EMIT_EVENT(portfolioInfo, _portfolioName, &portfolioStr[0], "portfolioBalance", tokenBalance);
    }

    
    PAYABLE void PortfolioManage::depositPortfolio(char* _portfolioName){
        uint64_t tokenBalance = getTotalBalance();
        
        uint64_t currentBalance = portfolioBalance.get()[_portfolioName];
        uint64_t finalBalance  = currentBalance + tokenBalance;
        DipcAssert(totalToken.get() + tokenBalance > totalToken);
        DipcAssert(finalBalance > currentBalance);
        (*portfolioBalance)[_portfolioName] = finalBalance;
        *totalToken = totalToken.get() + finalBalance; 
        DIPC_EMIT_EVENT(depositPortfolio, "portfolioName", _portfolioName, "portfolioBalance", finalBalance);
    }
    
    PAYABLE void PortfolioManage::createOrder(char* _portfolioName, char* _orderId, uint16_t _orderType, char* _stockCode, uint64_t _stockPrice, uint64_t _stockAmount, uint64_t _endTime){
        uint64_t tokenBalance = getTotalBalance();
        DIPC_EMIT_EVENT(createOrder, "portfolioName", _portfolioName, "OrderInfo", "ignore", "tokenBalance", tokenBalance);
        uint64_t spent = 0;
        if(_orderType == 1){
            spent = _stockPrice * _stockAmount;
            DipcAssert((portfolioBalance.get()[_portfolioName] + tokenBalance) > spent);
        }
        struct Order order{_orderId, _orderType, _stockCode, _stockPrice, _stockAmount, _endTime, 0};
        std::string pInfo = portfolioStorge.get()[_portfolioName];
        
        
        
        if(pInfo == "") {
            DIPC_EMIT_EVENT(ErrEvent, "Current portfolio  doesn't exist: ", _portfolioName);
            return;
        }
        PortfolioInfo info;
        info.parseJson(pInfo);
        if(info.getOrder(_orderId).orderId != ""){
            DIPC_EMIT_EVENT(ErrEvent, "Current order exist: ", _orderId);
            return;
        }
        info.addOrder(order);
        pInfo = info.toJson();

        uint64_t currentBalance = portfolioBalance.get()[_portfolioName] ;
        uint64_t finalBalance = currentBalance + tokenBalance - spent;
        DipcAssert(totalToken.get() + tokenBalance > totalToken);
        
        DipcAssert(ownerTotalToken.get() < ownerTotalToken.get() + spent);
        (*portfolioStorge)[_portfolioName] = &pInfo[0];
        
        
        
        


        (*portfolioBalance)[_portfolioName] = finalBalance;
        *totalToken = totalToken.get() + finalBalance; 
        *ownerTotalToken = ownerTotalToken.get() + spent;
        DIPC_EMIT_EVENT(createOrder, "portfolioName", _portfolioName, "OrderInfo", &order.toJson()[0], "portfolioBalance", finalBalance);
    }

    
    EXPORT void PortfolioManage::dealOrder(char* _portfolioName, char* _orderId){
        u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
isOwner();
        std::string pInfo = portfolioStorge.get()[_portfolioName];
        
        
        PortfolioInfo info;
        info.parseJson(pInfo);
        

        
         Order ord = info.getOrder(_orderId);
         
         
        if(ord.orderId != "" && ord.orderStatus == 0){
            
            uint64_t timenow = dipc::timestamp();
            if(ord.endTime > timenow){
                ord.orderStatus = 1;
            }else {
                ord.orderStatus = 3;
            }
        } else {
          

            return;
        }
        

        uint64_t sellValue = 0;
        if(ord.orderType == 0){
            sellValue = ord.stockAmount * ord.stockPrice;
        }
        uint64_t currentBalance =  portfolioBalance.get()[_portfolioName];
        

        DipcAssert(currentBalance + sellValue >= currentBalance);
        DipcAssert((ownerTotalToken.get() - sellValue) <= ownerTotalToken.get());
        


        (*portfolioBalance)[_portfolioName] = currentBalance + sellValue;
        *ownerTotalToken = ownerTotalToken.get() - sellValue;
        (*portfolioStorge)[_portfolioName] = &info.toJson()[0];
        
        
        
        

        DIPC_EMIT_EVENT(dealPortfolio, "orderId", _orderId, "orderInfo", &ord.toJson()[0]);
    }
    
    EXPORT void PortfolioManage::revocationOrder(char* _portfolioName, char* _orderId){
        u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
std::string pInfo = portfolioStorge.get()[_portfolioName];
        
        
        PortfolioInfo info;
        info.parseJson(pInfo);
        Order ord = info.getOrder(_orderId);
        
        
        if(ord.orderId != "" && ord.orderStatus == 0){
            std::string callerStr = caller().toString();
            
            
            
            DipcAssert(info.getOwnerAddress() == caller().toString());
            

            uint64_t timenow = dipc::timestamp();
            if(ord.endTime > timenow){
                ord.orderStatus = 2;
            }else {
                ord.orderStatus = 3;
            }
        } else {
            return;
        }
        uint64_t lockToken = 0;
        if(ord.orderType == 1){
            lockToken = ord.stockPrice * ord.stockAmount;
        }
        uint64_t currentBalance =  portfolioBalance.get()[_portfolioName];
        
        
        
        

        DipcAssert(currentBalance + lockToken >= currentBalance);
        DipcAssert(ownerTotalToken.get() - lockToken <= ownerTotalToken.get());

        
        (*portfolioBalance)[_portfolioName] = currentBalance + lockToken;
        *ownerTotalToken = ownerTotalToken.get() - lockToken;
        (*portfolioStorge)[_portfolioName] = &info.toJson()[0];
        DIPC_EMIT_EVENT(revocationPortfolio, "orderId", _orderId, "orderInfo", &ord.toJson()[0]);
    }
    
    EXPORT void PortfolioManage::withdrawPortfolio(char* _portfolioName, uint64_t _withdrawBalance){
         u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
if(!userCanWithdraw.get()){
             return;
         }
         uint64_t currentBalance =  portfolioBalance.get()[_portfolioName];
         DipcAssert(currentBalance - _withdrawBalance < currentBalance);
         auto coinBalance = changeUint64ToU256WithChangeRate(currentBalance, changeRate.get());
         (*portfolioBalance)[_portfolioName] = currentBalance - _withdrawBalance;
         callTransfer(caller(), coinBalance);
    }
    
    EXPORT void PortfolioManage::withdrawPool(uint64_t _balance){
        u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
isOwner();
        Address ownerAddr = Address(owner.get()); 
        callTransfer(ownerAddr, _balance);
        *ownerTotalToken = ownerTotalToken.get() - _balance * changeRate.get();
        *totalToken = totalToken.get() - _balance * changeRate.get();
        DIPC_EMIT_EVENT(tokenCount, "ownerTotalToken", ownerTotalToken.get(), "totalToken", totalToken.get());
    }
    
    PAYABLE void PortfolioManage::depositPool(uint64_t _depositValue){
        isOwner();
        
        uint64_t tokenBalance = changeU256ToUint64WithChangeRate(callValue(), changeRate.get()); 
        *ownerTotalToken = ownerTotalToken.get() + tokenBalance;
        *totalToken = totalToken.get() + tokenBalance;
        DIPC_EMIT_EVENT(tokenCount, "ownerTotalToken", ownerTotalToken.get(), "totalToken", totalToken.get());
    }
     
    CONSTANT uint64_t PortfolioManage::queryTotalToken(){
        u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
return totalToken.get();
    }

     
    CONSTANT uint64_t PortfolioManage::queryPortfolioBalance(char* _portfolioName){
        u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
return portfolioBalance.get()[_portfolioName];
    }

    
    CONSTANT bool PortfolioManage::queryPortfolioNameIfUsed(char* _portfolioName){
        u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
if(portfolioStorge.get()[_portfolioName] != ""){
            return true;
        } 
        return false;
    }

    
    CONSTANT uint64_t PortfolioManage::queryChangeRate(){
        u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
return changeRate.get();
    } codetext new #include "PortfolioManage.hpp"

    
    PAYABLE void PortfolioManage::init(){
        *owner = caller().toString();
        *changeRate = 10000;
        *userCanWithdraw = false;
        uint64_t tokenBalance = getTotalBalance();
        
        *ownerTotalToken = tokenBalance;
        *totalToken = ownerTotalToken.get();
        
        
        DIPC_EMIT_EVENT(initEvent, "ownerTotalToken" ,tokenBalance);
    }
    
     
    EXPORT void PortfolioManage::setChangeRate(uint64_t _changeRate){
        u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
isOwner();
        *changeRate = _changeRate;
    }
     
    EXPORT void PortfolioManage::setUserCanWithdraw(bool _canWithdraw){
        u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
isOwner();
        *userCanWithdraw = _canWithdraw;
    }

    
    PAYABLE void PortfolioManage::createPortfolio(char* _portfolioName, char* _portfolioDesc){
        if(portfolioStorge.get()[_portfolioName] != ""){
            DIPC_EMIT_EVENT(ErrEvent, "Current portfolio exist: ", _portfolioName);
            return;
        } 
        std::string callerAddr = caller().toString();
        uint64_t tokenBalance = getTotalBalance();
        
        PortfolioInfo info(_portfolioName, _portfolioDesc, &callerAddr[0]);
        std::string portfolioStr = info.toJson();
        
        
        

        (*portfolioStorge)[_portfolioName] = portfolioStr;
        DipcAssert(totalToken.get() + tokenBalance > totalToken);
        (*portfolioBalance)[_portfolioName] = tokenBalance;
        *totalToken = totalToken.get() + tokenBalance; 
        
        DIPC_EMIT_EVENT(portfolioInfo, _portfolioName, &portfolioStr[0], "portfolioBalance", tokenBalance);
    }

    
    PAYABLE void PortfolioManage::depositPortfolio(char* _portfolioName){
        uint64_t tokenBalance = getTotalBalance();
        
        uint64_t currentBalance = portfolioBalance.get()[_portfolioName];
        uint64_t finalBalance  = currentBalance + tokenBalance;
        DipcAssert(totalToken.get() + tokenBalance > totalToken);
        DipcAssert(finalBalance > currentBalance);
        (*portfolioBalance)[_portfolioName] = finalBalance;
        *totalToken = totalToken.get() + finalBalance; 
        DIPC_EMIT_EVENT(depositPortfolio, "portfolioName", _portfolioName, "portfolioBalance", finalBalance);
    }
    
    PAYABLE void PortfolioManage::createOrder(char* _portfolioName, char* _orderId, uint16_t _orderType, char* _stockCode, uint64_t _stockPrice, uint64_t _stockAmount, uint64_t _endTime){
        uint64_t tokenBalance = getTotalBalance();
        DIPC_EMIT_EVENT(createOrder, "portfolioName", _portfolioName, "OrderInfo", "ignore", "tokenBalance", tokenBalance);
        uint64_t spent = 0;
        if(_orderType == 1){
            spent = _stockPrice * _stockAmount;
            DipcAssert((portfolioBalance.get()[_portfolioName] + tokenBalance) > spent);
        }
        struct Order order{_orderId, _orderType, _stockCode, _stockPrice, _stockAmount, _endTime, 0};
        std::string pInfo = portfolioStorge.get()[_portfolioName];
        
        
        
        if(pInfo == "") {
            DIPC_EMIT_EVENT(ErrEvent, "Current portfolio  doesn't exist: ", _portfolioName);
            return;
        }
        PortfolioInfo info;
        info.parseJson(pInfo);
        if(info.getOrder(_orderId).orderId != ""){
            DIPC_EMIT_EVENT(ErrEvent, "Current order exist: ", _orderId);
            return;
        }
        info.addOrder(order);
        pInfo = info.toJson();

        uint64_t currentBalance = portfolioBalance.get()[_portfolioName] ;
        uint64_t finalBalance = currentBalance + tokenBalance - spent;
        DipcAssert(totalToken.get() + tokenBalance > totalToken);
        
        DipcAssert(ownerTotalToken.get() < ownerTotalToken.get() + spent);
        (*portfolioStorge)[_portfolioName] = &pInfo[0];
        
        
        
        


        (*portfolioBalance)[_portfolioName] = finalBalance;
        *totalToken = totalToken.get() + finalBalance; 
        *ownerTotalToken = ownerTotalToken.get() + spent;
        DIPC_EMIT_EVENT(createOrder, "portfolioName", _portfolioName, "OrderInfo", &order.toJson()[0], "portfolioBalance", finalBalance);
    }

    
    EXPORT void PortfolioManage::dealOrder(char* _portfolioName, char* _orderId){
        u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
isOwner();
        std::string pInfo = portfolioStorge.get()[_portfolioName];
        
        
        PortfolioInfo info;
        info.parseJson(pInfo);
        

        
         Order ord = info.getOrder(_orderId);
         
         
        if(ord.orderId != "" && ord.orderStatus == 0){
            
            uint64_t timenow = dipc::timestamp();
            if(ord.endTime > timenow){
                ord.orderStatus = 1;
            }else {
                ord.orderStatus = 3;
            }
        } else {
          

            return;
        }
        

        uint64_t sellValue = 0;
        if(ord.orderType == 0){
            sellValue = ord.stockAmount * ord.stockPrice;
        }
        uint64_t currentBalance =  portfolioBalance.get()[_portfolioName];
        

        DipcAssert(currentBalance + sellValue >= currentBalance);
        DipcAssert((ownerTotalToken.get() - sellValue) <= ownerTotalToken.get());
        


        (*portfolioBalance)[_portfolioName] = currentBalance + sellValue;
        *ownerTotalToken = ownerTotalToken.get() - sellValue;
        (*portfolioStorge)[_portfolioName] = &info.toJson()[0];
        
        
        
        

        DIPC_EMIT_EVENT(dealPortfolio, "orderId", _orderId, "orderInfo", &ord.toJson()[0]);
    }
    
    EXPORT void PortfolioManage::revocationOrder(char* _portfolioName, char* _orderId){
        u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
std::string pInfo = portfolioStorge.get()[_portfolioName];
        
        
        PortfolioInfo info;
        info.parseJson(pInfo);
        Order ord = info.getOrder(_orderId);
        
        
        if(ord.orderId != "" && ord.orderStatus == 0){
            std::string callerStr = caller().toString();
            
            
            
            DipcAssert(info.getOwnerAddress() == caller().toString());
            

            uint64_t timenow = dipc::timestamp();
            if(ord.endTime > timenow){
                ord.orderStatus = 2;
            }else {
                ord.orderStatus = 3;
            }
        } else {
            return;
        }
        uint64_t lockToken = 0;
        if(ord.orderType == 1){
            lockToken = ord.stockPrice * ord.stockAmount;
        }
        uint64_t currentBalance =  portfolioBalance.get()[_portfolioName];
        
        
        
        

        DipcAssert(currentBalance + lockToken >= currentBalance);
        DipcAssert(ownerTotalToken.get() - lockToken <= ownerTotalToken.get());

        
        (*portfolioBalance)[_portfolioName] = currentBalance + lockToken;
        *ownerTotalToken = ownerTotalToken.get() - lockToken;
        (*portfolioStorge)[_portfolioName] = &info.toJson()[0];
        DIPC_EMIT_EVENT(revocationPortfolio, "orderId", _orderId, "orderInfo", &ord.toJson()[0]);
    }
    
    EXPORT void PortfolioManage::withdrawPortfolio(char* _portfolioName, uint64_t _withdrawBalance){
         u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
if(!userCanWithdraw.get()){
             return;
         }
         uint64_t currentBalance =  portfolioBalance.get()[_portfolioName];
         DipcAssert(currentBalance - _withdrawBalance < currentBalance);
         auto coinBalance = changeUint64ToU256WithChangeRate(currentBalance, changeRate.get());
         (*portfolioBalance)[_portfolioName] = currentBalance - _withdrawBalance;
         callTransfer(caller(), coinBalance);
    }
    
    EXPORT void PortfolioManage::withdrawPool(uint64_t _balance){
        u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
isOwner();
        Address ownerAddr = Address(owner.get()); 
        callTransfer(ownerAddr, _balance);
        *ownerTotalToken = ownerTotalToken.get() - _balance * changeRate.get();
        *totalToken = totalToken.get() - _balance * changeRate.get();
        DIPC_EMIT_EVENT(tokenCount, "ownerTotalToken", ownerTotalToken.get(), "totalToken", totalToken.get());
    }
    
    PAYABLE void PortfolioManage::depositPool(uint64_t _depositValue){
        isOwner();
        
        uint64_t tokenBalance = changeU256ToUint64WithChangeRate(callValue(), changeRate.get()); 
        *ownerTotalToken = ownerTotalToken.get() + tokenBalance;
        *totalToken = totalToken.get() + tokenBalance;
        DIPC_EMIT_EVENT(tokenCount, "ownerTotalToken", ownerTotalToken.get(), "totalToken", totalToken.get());
    }
     
    CONSTANT uint64_t PortfolioManage::queryTotalToken(){
        u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
return totalToken.get();
    }

     
    CONSTANT uint64_t PortfolioManage::queryPortfolioBalance(char* _portfolioName){
        u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
return portfolioBalance.get()[_portfolioName];
    }

    
    CONSTANT bool PortfolioManage::queryPortfolioNameIfUsed(char* _portfolioName){
        u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
if(portfolioStorge.get()[_portfolioName] != ""){
            return true;
        } 
        return false;
    }

    
    CONSTANT uint64_t PortfolioManage::queryChangeRate(){
        return changeRate.get();
    }

2019-12-19_15:14:55.611978: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:604] finalContract  final content =======   : #include "PortfolioManage.hpp"

    
    PAYABLE void PortfolioManage::init(){
        *owner = caller().toString();
        *changeRate = 10000;
        *userCanWithdraw = false;
        uint64_t tokenBalance = getTotalBalance();
        
        *ownerTotalToken = tokenBalance;
        *totalToken = ownerTotalToken.get();
        
        
        DIPC_EMIT_EVENT(initEvent, "ownerTotalToken" ,tokenBalance);
    }
    
     
    EXPORT void PortfolioManage::setChangeRate(uint64_t _changeRate){
        u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
isOwner();
        *changeRate = _changeRate;
    }
     
    EXPORT void PortfolioManage::setUserCanWithdraw(bool _canWithdraw){
        u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
isOwner();
        *userCanWithdraw = _canWithdraw;
    }

    
    PAYABLE void PortfolioManage::createPortfolio(char* _portfolioName, char* _portfolioDesc){
        if(portfolioStorge.get()[_portfolioName] != ""){
            DIPC_EMIT_EVENT(ErrEvent, "Current portfolio exist: ", _portfolioName);
            return;
        } 
        std::string callerAddr = caller().toString();
        uint64_t tokenBalance = getTotalBalance();
        
        PortfolioInfo info(_portfolioName, _portfolioDesc, &callerAddr[0]);
        std::string portfolioStr = info.toJson();
        
        
        

        (*portfolioStorge)[_portfolioName] = portfolioStr;
        DipcAssert(totalToken.get() + tokenBalance > totalToken);
        (*portfolioBalance)[_portfolioName] = tokenBalance;
        *totalToken = totalToken.get() + tokenBalance; 
        
        DIPC_EMIT_EVENT(portfolioInfo, _portfolioName, &portfolioStr[0], "portfolioBalance", tokenBalance);
    }

    
    PAYABLE void PortfolioManage::depositPortfolio(char* _portfolioName){
        uint64_t tokenBalance = getTotalBalance();
        
        uint64_t currentBalance = portfolioBalance.get()[_portfolioName];
        uint64_t finalBalance  = currentBalance + tokenBalance;
        DipcAssert(totalToken.get() + tokenBalance > totalToken);
        DipcAssert(finalBalance > currentBalance);
        (*portfolioBalance)[_portfolioName] = finalBalance;
        *totalToken = totalToken.get() + finalBalance; 
        DIPC_EMIT_EVENT(depositPortfolio, "portfolioName", _portfolioName, "portfolioBalance", finalBalance);
    }
    
    PAYABLE void PortfolioManage::createOrder(char* _portfolioName, char* _orderId, uint16_t _orderType, char* _stockCode, uint64_t _stockPrice, uint64_t _stockAmount, uint64_t _endTime){
        uint64_t tokenBalance = getTotalBalance();
        DIPC_EMIT_EVENT(createOrder, "portfolioName", _portfolioName, "OrderInfo", "ignore", "tokenBalance", tokenBalance);
        uint64_t spent = 0;
        if(_orderType == 1){
            spent = _stockPrice * _stockAmount;
            DipcAssert((portfolioBalance.get()[_portfolioName] + tokenBalance) > spent);
        }
        struct Order order{_orderId, _orderType, _stockCode, _stockPrice, _stockAmount, _endTime, 0};
        std::string pInfo = portfolioStorge.get()[_portfolioName];
        
        
        
        if(pInfo == "") {
            DIPC_EMIT_EVENT(ErrEvent, "Current portfolio  doesn't exist: ", _portfolioName);
            return;
        }
        PortfolioInfo info;
        info.parseJson(pInfo);
        if(info.getOrder(_orderId).orderId != ""){
            DIPC_EMIT_EVENT(ErrEvent, "Current order exist: ", _orderId);
            return;
        }
        info.addOrder(order);
        pInfo = info.toJson();

        uint64_t currentBalance = portfolioBalance.get()[_portfolioName] ;
        uint64_t finalBalance = currentBalance + tokenBalance - spent;
        DipcAssert(totalToken.get() + tokenBalance > totalToken);
        
        DipcAssert(ownerTotalToken.get() < ownerTotalToken.get() + spent);
        (*portfolioStorge)[_portfolioName] = &pInfo[0];
        
        
        
        


        (*portfolioBalance)[_portfolioName] = finalBalance;
        *totalToken = totalToken.get() + finalBalance; 
        *ownerTotalToken = ownerTotalToken.get() + spent;
        DIPC_EMIT_EVENT(createOrder, "portfolioName", _portfolioName, "OrderInfo", &order.toJson()[0], "portfolioBalance", finalBalance);
    }

    
    EXPORT void PortfolioManage::dealOrder(char* _portfolioName, char* _orderId){
        u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
isOwner();
        std::string pInfo = portfolioStorge.get()[_portfolioName];
        
        
        PortfolioInfo info;
        info.parseJson(pInfo);
        

        
         Order ord = info.getOrder(_orderId);
         
         
        if(ord.orderId != "" && ord.orderStatus == 0){
            
            uint64_t timenow = dipc::timestamp();
            if(ord.endTime > timenow){
                ord.orderStatus = 1;
            }else {
                ord.orderStatus = 3;
            }
        } else {
          

            return;
        }
        

        uint64_t sellValue = 0;
        if(ord.orderType == 0){
            sellValue = ord.stockAmount * ord.stockPrice;
        }
        uint64_t currentBalance =  portfolioBalance.get()[_portfolioName];
        

        DipcAssert(currentBalance + sellValue >= currentBalance);
        DipcAssert((ownerTotalToken.get() - sellValue) <= ownerTotalToken.get());
        


        (*portfolioBalance)[_portfolioName] = currentBalance + sellValue;
        *ownerTotalToken = ownerTotalToken.get() - sellValue;
        (*portfolioStorge)[_portfolioName] = &info.toJson()[0];
        
        
        
        

        DIPC_EMIT_EVENT(dealPortfolio, "orderId", _orderId, "orderInfo", &ord.toJson()[0]);
    }
    
    EXPORT void PortfolioManage::revocationOrder(char* _portfolioName, char* _orderId){
        u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
std::string pInfo = portfolioStorge.get()[_portfolioName];
        
        
        PortfolioInfo info;
        info.parseJson(pInfo);
        Order ord = info.getOrder(_orderId);
        
        
        if(ord.orderId != "" && ord.orderStatus == 0){
            std::string callerStr = caller().toString();
            
            
            
            DipcAssert(info.getOwnerAddress() == caller().toString());
            

            uint64_t timenow = dipc::timestamp();
            if(ord.endTime > timenow){
                ord.orderStatus = 2;
            }else {
                ord.orderStatus = 3;
            }
        } else {
            return;
        }
        uint64_t lockToken = 0;
        if(ord.orderType == 1){
            lockToken = ord.stockPrice * ord.stockAmount;
        }
        uint64_t currentBalance =  portfolioBalance.get()[_portfolioName];
        
        
        
        

        DipcAssert(currentBalance + lockToken >= currentBalance);
        DipcAssert(ownerTotalToken.get() - lockToken <= ownerTotalToken.get());

        
        (*portfolioBalance)[_portfolioName] = currentBalance + lockToken;
        *ownerTotalToken = ownerTotalToken.get() - lockToken;
        (*portfolioStorge)[_portfolioName] = &info.toJson()[0];
        DIPC_EMIT_EVENT(revocationPortfolio, "orderId", _orderId, "orderInfo", &ord.toJson()[0]);
    }
    
    EXPORT void PortfolioManage::withdrawPortfolio(char* _portfolioName, uint64_t _withdrawBalance){
         u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
if(!userCanWithdraw.get()){
             return;
         }
         uint64_t currentBalance =  portfolioBalance.get()[_portfolioName];
         DipcAssert(currentBalance - _withdrawBalance < currentBalance);
         auto coinBalance = changeUint64ToU256WithChangeRate(currentBalance, changeRate.get());
         (*portfolioBalance)[_portfolioName] = currentBalance - _withdrawBalance;
         callTransfer(caller(), coinBalance);
    }
    
    EXPORT void PortfolioManage::withdrawPool(uint64_t _balance){
        u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
isOwner();
        Address ownerAddr = Address(owner.get()); 
        callTransfer(ownerAddr, _balance);
        *ownerTotalToken = ownerTotalToken.get() - _balance * changeRate.get();
        *totalToken = totalToken.get() - _balance * changeRate.get();
        DIPC_EMIT_EVENT(tokenCount, "ownerTotalToken", ownerTotalToken.get(), "totalToken", totalToken.get());
    }
    
    PAYABLE void PortfolioManage::depositPool(uint64_t _depositValue){
        isOwner();
        
        uint64_t tokenBalance = changeU256ToUint64WithChangeRate(callValue(), changeRate.get()); 
        *ownerTotalToken = ownerTotalToken.get() + tokenBalance;
        *totalToken = totalToken.get() + tokenBalance;
        DIPC_EMIT_EVENT(tokenCount, "ownerTotalToken", ownerTotalToken.get(), "totalToken", totalToken.get());
    }
     
    CONSTANT uint64_t PortfolioManage::queryTotalToken(){
        u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
return totalToken.get();
    }

     
    CONSTANT uint64_t PortfolioManage::queryPortfolioBalance(char* _portfolioName){
        u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
return portfolioBalance.get()[_portfolioName];
    }

    
    CONSTANT bool PortfolioManage::queryPortfolioNameIfUsed(char* _portfolioName){
        u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
if(portfolioStorge.get()[_portfolioName] != ""){
            return true;
        } 
        return false;
    }

    
    CONSTANT uint64_t PortfolioManage::queryChangeRate(){
        u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
return changeRate.get();
    }

2019-12-19_15:14:55.612005: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:613] finalContract  final content  last =======   : #include "PortfolioManage.hpp"

    
    PAYABLE void PortfolioManage::init(){
        *owner = caller().toString();
        *changeRate = 10000;
        *userCanWithdraw = false;
        uint64_t tokenBalance = getTotalBalance();
        
        *ownerTotalToken = tokenBalance;
        *totalToken = ownerTotalToken.get();
        
        
        DIPC_EMIT_EVENT(initEvent, "ownerTotalToken" ,tokenBalance);
    }
    
     
    EXPORT void PortfolioManage::setChangeRate(uint64_t _changeRate){
        u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
isOwner();
        *changeRate = _changeRate;
    }
     
    EXPORT void PortfolioManage::setUserCanWithdraw(bool _canWithdraw){
        u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
isOwner();
        *userCanWithdraw = _canWithdraw;
    }

    
    PAYABLE void PortfolioManage::createPortfolio(char* _portfolioName, char* _portfolioDesc){
        if(portfolioStorge.get()[_portfolioName] != ""){
            DIPC_EMIT_EVENT(ErrEvent, "Current portfolio exist: ", _portfolioName);
            return;
        } 
        std::string callerAddr = caller().toString();
        uint64_t tokenBalance = getTotalBalance();
        
        PortfolioInfo info(_portfolioName, _portfolioDesc, &callerAddr[0]);
        std::string portfolioStr = info.toJson();
        
        
        

        (*portfolioStorge)[_portfolioName] = portfolioStr;
        DipcAssert(totalToken.get() + tokenBalance > totalToken);
        (*portfolioBalance)[_portfolioName] = tokenBalance;
        *totalToken = totalToken.get() + tokenBalance; 
        
        DIPC_EMIT_EVENT(portfolioInfo, _portfolioName, &portfolioStr[0], "portfolioBalance", tokenBalance);
    }

    
    PAYABLE void PortfolioManage::depositPortfolio(char* _portfolioName){
        uint64_t tokenBalance = getTotalBalance();
        
        uint64_t currentBalance = portfolioBalance.get()[_portfolioName];
        uint64_t finalBalance  = currentBalance + tokenBalance;
        DipcAssert(totalToken.get() + tokenBalance > totalToken);
        DipcAssert(finalBalance > currentBalance);
        (*portfolioBalance)[_portfolioName] = finalBalance;
        *totalToken = totalToken.get() + finalBalance; 
        DIPC_EMIT_EVENT(depositPortfolio, "portfolioName", _portfolioName, "portfolioBalance", finalBalance);
    }
    
    PAYABLE void PortfolioManage::createOrder(char* _portfolioName, char* _orderId, uint16_t _orderType, char* _stockCode, uint64_t _stockPrice, uint64_t _stockAmount, uint64_t _endTime){
        uint64_t tokenBalance = getTotalBalance();
        DIPC_EMIT_EVENT(createOrder, "portfolioName", _portfolioName, "OrderInfo", "ignore", "tokenBalance", tokenBalance);
        uint64_t spent = 0;
        if(_orderType == 1){
            spent = _stockPrice * _stockAmount;
            DipcAssert((portfolioBalance.get()[_portfolioName] + tokenBalance) > spent);
        }
        struct Order order{_orderId, _orderType, _stockCode, _stockPrice, _stockAmount, _endTime, 0};
        std::string pInfo = portfolioStorge.get()[_portfolioName];
        
        
        
        if(pInfo == "") {
            DIPC_EMIT_EVENT(ErrEvent, "Current portfolio  doesn't exist: ", _portfolioName);
            return;
        }
        PortfolioInfo info;
        info.parseJson(pInfo);
        if(info.getOrder(_orderId).orderId != ""){
            DIPC_EMIT_EVENT(ErrEvent, "Current order exist: ", _orderId);
            return;
        }
        info.addOrder(order);
        pInfo = info.toJson();

        uint64_t currentBalance = portfolioBalance.get()[_portfolioName] ;
        uint64_t finalBalance = currentBalance + tokenBalance - spent;
        DipcAssert(totalToken.get() + tokenBalance > totalToken);
        
        DipcAssert(ownerTotalToken.get() < ownerTotalToken.get() + spent);
        (*portfolioStorge)[_portfolioName] = &pInfo[0];
        
        
        
        


        (*portfolioBalance)[_portfolioName] = finalBalance;
        *totalToken = totalToken.get() + finalBalance; 
        *ownerTotalToken = ownerTotalToken.get() + spent;
        DIPC_EMIT_EVENT(createOrder, "portfolioName", _portfolioName, "OrderInfo", &order.toJson()[0], "portfolioBalance", finalBalance);
    }

    
    EXPORT void PortfolioManage::dealOrder(char* _portfolioName, char* _orderId){
        u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
isOwner();
        std::string pInfo = portfolioStorge.get()[_portfolioName];
        
        
        PortfolioInfo info;
        info.parseJson(pInfo);
        

        
         Order ord = info.getOrder(_orderId);
         
         
        if(ord.orderId != "" && ord.orderStatus == 0){
            
            uint64_t timenow = dipc::timestamp();
            if(ord.endTime > timenow){
                ord.orderStatus = 1;
            }else {
                ord.orderStatus = 3;
            }
        } else {
          

            return;
        }
        

        uint64_t sellValue = 0;
        if(ord.orderType == 0){
            sellValue = ord.stockAmount * ord.stockPrice;
        }
        uint64_t currentBalance =  portfolioBalance.get()[_portfolioName];
        

        DipcAssert(currentBalance + sellValue >= currentBalance);
        DipcAssert((ownerTotalToken.get() - sellValue) <= ownerTotalToken.get());
        


        (*portfolioBalance)[_portfolioName] = currentBalance + sellValue;
        *ownerTotalToken = ownerTotalToken.get() - sellValue;
        (*portfolioStorge)[_portfolioName] = &info.toJson()[0];
        
        
        
        

        DIPC_EMIT_EVENT(dealPortfolio, "orderId", _orderId, "orderInfo", &ord.toJson()[0]);
    }
    
    EXPORT void PortfolioManage::revocationOrder(char* _portfolioName, char* _orderId){
        u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
std::string pInfo = portfolioStorge.get()[_portfolioName];
        
        
        PortfolioInfo info;
        info.parseJson(pInfo);
        Order ord = info.getOrder(_orderId);
        
        
        if(ord.orderId != "" && ord.orderStatus == 0){
            std::string callerStr = caller().toString();
            
            
            
            DipcAssert(info.getOwnerAddress() == caller().toString());
            

            uint64_t timenow = dipc::timestamp();
            if(ord.endTime > timenow){
                ord.orderStatus = 2;
            }else {
                ord.orderStatus = 3;
            }
        } else {
            return;
        }
        uint64_t lockToken = 0;
        if(ord.orderType == 1){
            lockToken = ord.stockPrice * ord.stockAmount;
        }
        uint64_t currentBalance =  portfolioBalance.get()[_portfolioName];
        
        
        
        

        DipcAssert(currentBalance + lockToken >= currentBalance);
        DipcAssert(ownerTotalToken.get() - lockToken <= ownerTotalToken.get());

        
        (*portfolioBalance)[_portfolioName] = currentBalance + lockToken;
        *ownerTotalToken = ownerTotalToken.get() - lockToken;
        (*portfolioStorge)[_portfolioName] = &info.toJson()[0];
        DIPC_EMIT_EVENT(revocationPortfolio, "orderId", _orderId, "orderInfo", &ord.toJson()[0]);
    }
    
    EXPORT void PortfolioManage::withdrawPortfolio(char* _portfolioName, uint64_t _withdrawBalance){
         u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
if(!userCanWithdraw.get()){
             return;
         }
         uint64_t currentBalance =  portfolioBalance.get()[_portfolioName];
         DipcAssert(currentBalance - _withdrawBalance < currentBalance);
         auto coinBalance = changeUint64ToU256WithChangeRate(currentBalance, changeRate.get());
         (*portfolioBalance)[_portfolioName] = currentBalance - _withdrawBalance;
         callTransfer(caller(), coinBalance);
    }
    
    EXPORT void PortfolioManage::withdrawPool(uint64_t _balance){
        u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
isOwner();
        Address ownerAddr = Address(owner.get()); 
        callTransfer(ownerAddr, _balance);
        *ownerTotalToken = ownerTotalToken.get() - _balance * changeRate.get();
        *totalToken = totalToken.get() - _balance * changeRate.get();
        DIPC_EMIT_EVENT(tokenCount, "ownerTotalToken", ownerTotalToken.get(), "totalToken", totalToken.get());
    }
    
    PAYABLE void PortfolioManage::depositPool(uint64_t _depositValue){
        isOwner();
        
        uint64_t tokenBalance = changeU256ToUint64WithChangeRate(callValue(), changeRate.get()); 
        *ownerTotalToken = ownerTotalToken.get() + tokenBalance;
        *totalToken = totalToken.get() + tokenBalance;
        DIPC_EMIT_EVENT(tokenCount, "ownerTotalToken", ownerTotalToken.get(), "totalToken", totalToken.get());
    }
     
    CONSTANT uint64_t PortfolioManage::queryTotalToken(){
        u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
return totalToken.get();
    }

     
    CONSTANT uint64_t PortfolioManage::queryPortfolioBalance(char* _portfolioName){
        u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
return portfolioBalance.get()[_portfolioName];
    }

    
    CONSTANT bool PortfolioManage::queryPortfolioNameIfUsed(char* _portfolioName){
        u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
if(portfolioStorge.get()[_portfolioName] != ""){
            return true;
        } 
        return false;
    }

    
    CONSTANT uint64_t PortfolioManage::queryChangeRate(){
        u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
return changeRate.get();
    }

2019-12-19_15:14:55.612018: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:882] removedComments end  =======::#include "PortfolioManage.hpp"

    
    PAYABLE void PortfolioManage::init(){
        *owner = caller().toString();
        *changeRate = 10000;
        *userCanWithdraw = false;
        uint64_t tokenBalance = getTotalBalance();
        
        *ownerTotalToken = tokenBalance;
        *totalToken = ownerTotalToken.get();
        
        
        DIPC_EMIT_EVENT(initEvent, "ownerTotalToken" ,tokenBalance);
    }
    
     
    EXPORT void PortfolioManage::setChangeRate(uint64_t _changeRate){
        u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
isOwner();
        *changeRate = _changeRate;
    }
     
    EXPORT void PortfolioManage::setUserCanWithdraw(bool _canWithdraw){
        u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
isOwner();
        *userCanWithdraw = _canWithdraw;
    }

    
    PAYABLE void PortfolioManage::createPortfolio(char* _portfolioName, char* _portfolioDesc){
        if(portfolioStorge.get()[_portfolioName] != ""){
            DIPC_EMIT_EVENT(ErrEvent, "Current portfolio exist: ", _portfolioName);
            return;
        } 
        std::string callerAddr = caller().toString();
        uint64_t tokenBalance = getTotalBalance();
        
        PortfolioInfo info(_portfolioName, _portfolioDesc, &callerAddr[0]);
        std::string portfolioStr = info.toJson();
        
        
        

        (*portfolioStorge)[_portfolioName] = portfolioStr;
        DipcAssert(totalToken.get() + tokenBalance > totalToken);
        (*portfolioBalance)[_portfolioName] = tokenBalance;
        *totalToken = totalToken.get() + tokenBalance; 
        
        DIPC_EMIT_EVENT(portfolioInfo, _portfolioName, &portfolioStr[0], "portfolioBalance", tokenBalance);
    }

    
    PAYABLE void PortfolioManage::depositPortfolio(char* _portfolioName){
        uint64_t tokenBalance = getTotalBalance();
        
        uint64_t currentBalance = portfolioBalance.get()[_portfolioName];
        uint64_t finalBalance  = currentBalance + tokenBalance;
        DipcAssert(totalToken.get() + tokenBalance > totalToken);
        DipcAssert(finalBalance > currentBalance);
        (*portfolioBalance)[_portfolioName] = finalBalance;
        *totalToken = totalToken.get() + finalBalance; 
        DIPC_EMIT_EVENT(depositPortfolio, "portfolioName", _portfolioName, "portfolioBalance", finalBalance);
    }
    
    PAYABLE void PortfolioManage::createOrder(char* _portfolioName, char* _orderId, uint16_t _orderType, char* _stockCode, uint64_t _stockPrice, uint64_t _stockAmount, uint64_t _endTime){
        uint64_t tokenBalance = getTotalBalance();
        DIPC_EMIT_EVENT(createOrder, "portfolioName", _portfolioName, "OrderInfo", "ignore", "tokenBalance", tokenBalance);
        uint64_t spent = 0;
        if(_orderType == 1){
            spent = _stockPrice * _stockAmount;
            DipcAssert((portfolioBalance.get()[_portfolioName] + tokenBalance) > spent);
        }
        struct Order order{_orderId, _orderType, _stockCode, _stockPrice, _stockAmount, _endTime, 0};
        std::string pInfo = portfolioStorge.get()[_portfolioName];
        
        
        
        if(pInfo == "") {
            DIPC_EMIT_EVENT(ErrEvent, "Current portfolio  doesn't exist: ", _portfolioName);
            return;
        }
        PortfolioInfo info;
        info.parseJson(pInfo);
        if(info.getOrder(_orderId).orderId != ""){
            DIPC_EMIT_EVENT(ErrEvent, "Current order exist: ", _orderId);
            return;
        }
        info.addOrder(order);
        pInfo = info.toJson();

        uint64_t currentBalance = portfolioBalance.get()[_portfolioName] ;
        uint64_t finalBalance = currentBalance + tokenBalance - spent;
        DipcAssert(totalToken.get() + tokenBalance > totalToken);
        
        DipcAssert(ownerTotalToken.get() < ownerTotalToken.get() + spent);
        (*portfolioStorge)[_portfolioName] = &pInfo[0];
        
        
        
        


        (*portfolioBalance)[_portfolioName] = finalBalance;
        *totalToken = totalToken.get() + finalBalance; 
        *ownerTotalToken = ownerTotalToken.get() + spent;
        DIPC_EMIT_EVENT(createOrder, "portfolioName", _portfolioName, "OrderInfo", &order.toJson()[0], "portfolioBalance", finalBalance);
    }

    
    EXPORT void PortfolioManage::dealOrder(char* _portfolioName, char* _orderId){
        u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
isOwner();
        std::string pInfo = portfolioStorge.get()[_portfolioName];
        
        
        PortfolioInfo info;
        info.parseJson(pInfo);
        

        
         Order ord = info.getOrder(_orderId);
         
         
        if(ord.orderId != "" && ord.orderStatus == 0){
            
            uint64_t timenow = dipc::timestamp();
            if(ord.endTime > timenow){
                ord.orderStatus = 1;
            }else {
                ord.orderStatus = 3;
            }
        } else {
          

            return;
        }
        

        uint64_t sellValue = 0;
        if(ord.orderType == 0){
            sellValue = ord.stockAmount * ord.stockPrice;
        }
        uint64_t currentBalance =  portfolioBalance.get()[_portfolioName];
        

        DipcAssert(currentBalance + sellValue >= currentBalance);
        DipcAssert((ownerTotalToken.get() - sellValue) <= ownerTotalToken.get());
        


        (*portfolioBalance)[_portfolioName] = currentBalance + sellValue;
        *ownerTotalToken = ownerTotalToken.get() - sellValue;
        (*portfolioStorge)[_portfolioName] = &info.toJson()[0];
        
        
        
        

        DIPC_EMIT_EVENT(dealPortfolio, "orderId", _orderId, "orderInfo", &ord.toJson()[0]);
    }
    
    EXPORT void PortfolioManage::revocationOrder(char* _portfolioName, char* _orderId){
        u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
std::string pInfo = portfolioStorge.get()[_portfolioName];
        
        
        PortfolioInfo info;
        info.parseJson(pInfo);
        Order ord = info.getOrder(_orderId);
        
        
        if(ord.orderId != "" && ord.orderStatus == 0){
            std::string callerStr = caller().toString();
            
            
            
            DipcAssert(info.getOwnerAddress() == caller().toString());
            

            uint64_t timenow = dipc::timestamp();
            if(ord.endTime > timenow){
                ord.orderStatus = 2;
            }else {
                ord.orderStatus = 3;
            }
        } else {
            return;
        }
        uint64_t lockToken = 0;
        if(ord.orderType == 1){
            lockToken = ord.stockPrice * ord.stockAmount;
        }
        uint64_t currentBalance =  portfolioBalance.get()[_portfolioName];
        
        
        
        

        DipcAssert(currentBalance + lockToken >= currentBalance);
        DipcAssert(ownerTotalToken.get() - lockToken <= ownerTotalToken.get());

        
        (*portfolioBalance)[_portfolioName] = currentBalance + lockToken;
        *ownerTotalToken = ownerTotalToken.get() - lockToken;
        (*portfolioStorge)[_portfolioName] = &info.toJson()[0];
        DIPC_EMIT_EVENT(revocationPortfolio, "orderId", _orderId, "orderInfo", &ord.toJson()[0]);
    }
    
    EXPORT void PortfolioManage::withdrawPortfolio(char* _portfolioName, uint64_t _withdrawBalance){
         u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
if(!userCanWithdraw.get()){
             return;
         }
         uint64_t currentBalance =  portfolioBalance.get()[_portfolioName];
         DipcAssert(currentBalance - _withdrawBalance < currentBalance);
         auto coinBalance = changeUint64ToU256WithChangeRate(currentBalance, changeRate.get());
         (*portfolioBalance)[_portfolioName] = currentBalance - _withdrawBalance;
         callTransfer(caller(), coinBalance);
    }
    
    EXPORT void PortfolioManage::withdrawPool(uint64_t _balance){
        u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
isOwner();
        Address ownerAddr = Address(owner.get()); 
        callTransfer(ownerAddr, _balance);
        *ownerTotalToken = ownerTotalToken.get() - _balance * changeRate.get();
        *totalToken = totalToken.get() - _balance * changeRate.get();
        DIPC_EMIT_EVENT(tokenCount, "ownerTotalToken", ownerTotalToken.get(), "totalToken", totalToken.get());
    }
    
    PAYABLE void PortfolioManage::depositPool(uint64_t _depositValue){
        isOwner();
        
        uint64_t tokenBalance = changeU256ToUint64WithChangeRate(callValue(), changeRate.get()); 
        *ownerTotalToken = ownerTotalToken.get() + tokenBalance;
        *totalToken = totalToken.get() + tokenBalance;
        DIPC_EMIT_EVENT(tokenCount, "ownerTotalToken", ownerTotalToken.get(), "totalToken", totalToken.get());
    }
     
    CONSTANT uint64_t PortfolioManage::queryTotalToken(){
        u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
return totalToken.get();
    }

     
    CONSTANT uint64_t PortfolioManage::queryPortfolioBalance(char* _portfolioName){
        u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
return portfolioBalance.get()[_portfolioName];
    }

    
    CONSTANT bool PortfolioManage::queryPortfolioNameIfUsed(char* _portfolioName){
        u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
if(portfolioStorge.get()[_portfolioName] != ""){
            return true;
        } 
        return false;
    }

    
    CONSTANT uint64_t PortfolioManage::queryChangeRate(){
        u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
return changeRate.get();
    }

2019-12-19_15:14:55.612027: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:886] str ============
2019-12-19_15:14:55.612033: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:887] str ============class\s*PortfolioManage\s*\{
2019-12-19_15:14:55.612047: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:892] findClass end  =======::

2019-12-19_15:14:55.612053: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:895] claSma end  =======::

2019-12-19_15:14:55.615402: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:619] CompareHeaderAndImplFileMacro  start 

2019-12-19_15:14:55.615425: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:650] get codeText content #include "PortfolioManage.hpp"

    
    PAYABLE void PortfolioManage::init(){
        *owner = caller().toString();
        *changeRate = 10000;
        *userCanWithdraw = false;
        uint64_t tokenBalance = getTotalBalance();
        
        *ownerTotalToken = tokenBalance;
        *totalToken = ownerTotalToken.get();
        
        
        DIPC_EMIT_EVENT(initEvent, "ownerTotalToken" ,tokenBalance);
    }
    
     
    EXPORT void PortfolioManage::setChangeRate(uint64_t _changeRate){
        u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
isOwner();
        *changeRate = _changeRate;
    }
     
    EXPORT void PortfolioManage::setUserCanWithdraw(bool _canWithdraw){
        u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
isOwner();
        *userCanWithdraw = _canWithdraw;
    }

    
    PAYABLE void PortfolioManage::createPortfolio(char* _portfolioName, char* _portfolioDesc){
        if(portfolioStorge.get()[_portfolioName] != ""){
            DIPC_EMIT_EVENT(ErrEvent, "Current portfolio exist: ", _portfolioName);
            return;
        } 
        std::string callerAddr = caller().toString();
        uint64_t tokenBalance = getTotalBalance();
        
        PortfolioInfo info(_portfolioName, _portfolioDesc, &callerAddr[0]);
        std::string portfolioStr = info.toJson();
        
        
        

        (*portfolioStorge)[_portfolioName] = portfolioStr;
        DipcAssert(totalToken.get() + tokenBalance > totalToken);
        (*portfolioBalance)[_portfolioName] = tokenBalance;
        *totalToken = totalToken.get() + tokenBalance; 
        
        DIPC_EMIT_EVENT(portfolioInfo, _portfolioName, &portfolioStr[0], "portfolioBalance", tokenBalance);
    }

    
    PAYABLE void PortfolioManage::depositPortfolio(char* _portfolioName){
        uint64_t tokenBalance = getTotalBalance();
        
        uint64_t currentBalance = portfolioBalance.get()[_portfolioName];
        uint64_t finalBalance  = currentBalance + tokenBalance;
        DipcAssert(totalToken.get() + tokenBalance > totalToken);
        DipcAssert(finalBalance > currentBalance);
        (*portfolioBalance)[_portfolioName] = finalBalance;
        *totalToken = totalToken.get() + finalBalance; 
        DIPC_EMIT_EVENT(depositPortfolio, "portfolioName", _portfolioName, "portfolioBalance", finalBalance);
    }
    
    PAYABLE void PortfolioManage::createOrder(char* _portfolioName, char* _orderId, uint16_t _orderType, char* _stockCode, uint64_t _stockPrice, uint64_t _stockAmount, uint64_t _endTime){
        uint64_t tokenBalance = getTotalBalance();
        DIPC_EMIT_EVENT(createOrder, "portfolioName", _portfolioName, "OrderInfo", "ignore", "tokenBalance", tokenBalance);
        uint64_t spent = 0;
        if(_orderType == 1){
            spent = _stockPrice * _stockAmount;
            DipcAssert((portfolioBalance.get()[_portfolioName] + tokenBalance) > spent);
        }
        struct Order order{_orderId, _orderType, _stockCode, _stockPrice, _stockAmount, _endTime, 0};
        std::string pInfo = portfolioStorge.get()[_portfolioName];
        
        
        
        if(pInfo == "") {
            DIPC_EMIT_EVENT(ErrEvent, "Current portfolio  doesn't exist: ", _portfolioName);
            return;
        }
        PortfolioInfo info;
        info.parseJson(pInfo);
        if(info.getOrder(_orderId).orderId != ""){
            DIPC_EMIT_EVENT(ErrEvent, "Current order exist: ", _orderId);
            return;
        }
        info.addOrder(order);
        pInfo = info.toJson();

        uint64_t currentBalance = portfolioBalance.get()[_portfolioName] ;
        uint64_t finalBalance = currentBalance + tokenBalance - spent;
        DipcAssert(totalToken.get() + tokenBalance > totalToken);
        
        DipcAssert(ownerTotalToken.get() < ownerTotalToken.get() + spent);
        (*portfolioStorge)[_portfolioName] = &pInfo[0];
        
        
        
        


        (*portfolioBalance)[_portfolioName] = finalBalance;
        *totalToken = totalToken.get() + finalBalance; 
        *ownerTotalToken = ownerTotalToken.get() + spent;
        DIPC_EMIT_EVENT(createOrder, "portfolioName", _portfolioName, "OrderInfo", &order.toJson()[0], "portfolioBalance", finalBalance);
    }

    
    EXPORT void PortfolioManage::dealOrder(char* _portfolioName, char* _orderId){
        u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
isOwner();
        std::string pInfo = portfolioStorge.get()[_portfolioName];
        
        
        PortfolioInfo info;
        info.parseJson(pInfo);
        

        
         Order ord = info.getOrder(_orderId);
         
         
        if(ord.orderId != "" && ord.orderStatus == 0){
            
            uint64_t timenow = dipc::timestamp();
            if(ord.endTime > timenow){
                ord.orderStatus = 1;
            }else {
                ord.orderStatus = 3;
            }
        } else {
          

            return;
        }
        

        uint64_t sellValue = 0;
        if(ord.orderType == 0){
            sellValue = ord.stockAmount * ord.stockPrice;
        }
        uint64_t currentBalance =  portfolioBalance.get()[_portfolioName];
        

        DipcAssert(currentBalance + sellValue >= currentBalance);
        DipcAssert((ownerTotalToken.get() - sellValue) <= ownerTotalToken.get());
        


        (*portfolioBalance)[_portfolioName] = currentBalance + sellValue;
        *ownerTotalToken = ownerTotalToken.get() - sellValue;
        (*portfolioStorge)[_portfolioName] = &info.toJson()[0];
        
        
        
        

        DIPC_EMIT_EVENT(dealPortfolio, "orderId", _orderId, "orderInfo", &ord.toJson()[0]);
    }
    
    EXPORT void PortfolioManage::revocationOrder(char* _portfolioName, char* _orderId){
        u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
std::string pInfo = portfolioStorge.get()[_portfolioName];
        
        
        PortfolioInfo info;
        info.parseJson(pInfo);
        Order ord = info.getOrder(_orderId);
        
        
        if(ord.orderId != "" && ord.orderStatus == 0){
            std::string callerStr = caller().toString();
            
            
            
            DipcAssert(info.getOwnerAddress() == caller().toString());
            

            uint64_t timenow = dipc::timestamp();
            if(ord.endTime > timenow){
                ord.orderStatus = 2;
            }else {
                ord.orderStatus = 3;
            }
        } else {
            return;
        }
        uint64_t lockToken = 0;
        if(ord.orderType == 1){
            lockToken = ord.stockPrice * ord.stockAmount;
        }
        uint64_t currentBalance =  portfolioBalance.get()[_portfolioName];
        
        
        
        

        DipcAssert(currentBalance + lockToken >= currentBalance);
        DipcAssert(ownerTotalToken.get() - lockToken <= ownerTotalToken.get());

        
        (*portfolioBalance)[_portfolioName] = currentBalance + lockToken;
        *ownerTotalToken = ownerTotalToken.get() - lockToken;
        (*portfolioStorge)[_portfolioName] = &info.toJson()[0];
        DIPC_EMIT_EVENT(revocationPortfolio, "orderId", _orderId, "orderInfo", &ord.toJson()[0]);
    }
    
    EXPORT void PortfolioManage::withdrawPortfolio(char* _portfolioName, uint64_t _withdrawBalance){
         u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
if(!userCanWithdraw.get()){
             return;
         }
         uint64_t currentBalance =  portfolioBalance.get()[_portfolioName];
         DipcAssert(currentBalance - _withdrawBalance < currentBalance);
         auto coinBalance = changeUint64ToU256WithChangeRate(currentBalance, changeRate.get());
         (*portfolioBalance)[_portfolioName] = currentBalance - _withdrawBalance;
         callTransfer(caller(), coinBalance);
    }
    
    EXPORT void PortfolioManage::withdrawPool(uint64_t _balance){
        u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
isOwner();
        Address ownerAddr = Address(owner.get()); 
        callTransfer(ownerAddr, _balance);
        *ownerTotalToken = ownerTotalToken.get() - _balance * changeRate.get();
        *totalToken = totalToken.get() - _balance * changeRate.get();
        DIPC_EMIT_EVENT(tokenCount, "ownerTotalToken", ownerTotalToken.get(), "totalToken", totalToken.get());
    }
    
    PAYABLE void PortfolioManage::depositPool(uint64_t _depositValue){
        isOwner();
        
        uint64_t tokenBalance = changeU256ToUint64WithChangeRate(callValue(), changeRate.get()); 
        *ownerTotalToken = ownerTotalToken.get() + tokenBalance;
        *totalToken = totalToken.get() + tokenBalance;
        DIPC_EMIT_EVENT(tokenCount, "ownerTotalToken", ownerTotalToken.get(), "totalToken", totalToken.get());
    }
     
    CONSTANT uint64_t PortfolioManage::queryTotalToken(){
        u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
return totalToken.get();
    }

     
    CONSTANT uint64_t PortfolioManage::queryPortfolioBalance(char* _portfolioName){
        u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
return portfolioBalance.get()[_portfolioName];
    }

    
    CONSTANT bool PortfolioManage::queryPortfolioNameIfUsed(char* _portfolioName){
        u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
if(portfolioStorge.get()[_portfolioName] != ""){
            return true;
        } 
        return false;
    }

    
    CONSTANT uint64_t PortfolioManage::queryChangeRate(){
        u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
return changeRate.get();
    }

2019-12-19_15:14:55.615437: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:656] searchStr \s*PAYABLE\s*void\s*PortfolioManage::init code_text #include "PortfolioManage.hpp"

    
    PAYABLE void PortfolioManage::init(){
        *owner = caller().toString();
        *changeRate = 10000;
        *userCanWithdraw = false;
        uint64_t tokenBalance = getTotalBalance();
        
        *ownerTotalToken = tokenBalance;
        *totalToken = ownerTotalToken.get();
        
        
        DIPC_EMIT_EVENT(initEvent, "ownerTotalToken" ,tokenBalance);
    }
    
     
    EXPORT void PortfolioManage::setChangeRate(uint64_t _changeRate){
        u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
isOwner();
        *changeRate = _changeRate;
    }
     
    EXPORT void PortfolioManage::setUserCanWithdraw(bool _canWithdraw){
        u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
isOwner();
        *userCanWithdraw = _canWithdraw;
    }

    
    PAYABLE void PortfolioManage::createPortfolio(char* _portfolioName, char* _portfolioDesc){
        if(portfolioStorge.get()[_portfolioName] != ""){
            DIPC_EMIT_EVENT(ErrEvent, "Current portfolio exist: ", _portfolioName);
            return;
        } 
        std::string callerAddr = caller().toString();
        uint64_t tokenBalance = getTotalBalance();
        
        PortfolioInfo info(_portfolioName, _portfolioDesc, &callerAddr[0]);
        std::string portfolioStr = info.toJson();
        
        
        

        (*portfolioStorge)[_portfolioName] = portfolioStr;
        DipcAssert(totalToken.get() + tokenBalance > totalToken);
        (*portfolioBalance)[_portfolioName] = tokenBalance;
        *totalToken = totalToken.get() + tokenBalance; 
        
        DIPC_EMIT_EVENT(portfolioInfo, _portfolioName, &portfolioStr[0], "portfolioBalance", tokenBalance);
    }

    
    PAYABLE void PortfolioManage::depositPortfolio(char* _portfolioName){
        uint64_t tokenBalance = getTotalBalance();
        
        uint64_t currentBalance = portfolioBalance.get()[_portfolioName];
        uint64_t finalBalance  = currentBalance + tokenBalance;
        DipcAssert(totalToken.get() + tokenBalance > totalToken);
        DipcAssert(finalBalance > currentBalance);
        (*portfolioBalance)[_portfolioName] = finalBalance;
        *totalToken = totalToken.get() + finalBalance; 
        DIPC_EMIT_EVENT(depositPortfolio, "portfolioName", _portfolioName, "portfolioBalance", finalBalance);
    }
    
    PAYABLE void PortfolioManage::createOrder(char* _portfolioName, char* _orderId, uint16_t _orderType, char* _stockCode, uint64_t _stockPrice, uint64_t _stockAmount, uint64_t _endTime){
        uint64_t tokenBalance = getTotalBalance();
        DIPC_EMIT_EVENT(createOrder, "portfolioName", _portfolioName, "OrderInfo", "ignore", "tokenBalance", tokenBalance);
        uint64_t spent = 0;
        if(_orderType == 1){
            spent = _stockPrice * _stockAmount;
            DipcAssert((portfolioBalance.get()[_portfolioName] + tokenBalance) > spent);
        }
        struct Order order{_orderId, _orderType, _stockCode, _stockPrice, _stockAmount, _endTime, 0};
        std::string pInfo = portfolioStorge.get()[_portfolioName];
        
        
        
        if(pInfo == "") {
            DIPC_EMIT_EVENT(ErrEvent, "Current portfolio  doesn't exist: ", _portfolioName);
            return;
        }
        PortfolioInfo info;
        info.parseJson(pInfo);
        if(info.getOrder(_orderId).orderId != ""){
            DIPC_EMIT_EVENT(ErrEvent, "Current order exist: ", _orderId);
            return;
        }
        info.addOrder(order);
        pInfo = info.toJson();

        uint64_t currentBalance = portfolioBalance.get()[_portfolioName] ;
        uint64_t finalBalance = currentBalance + tokenBalance - spent;
        DipcAssert(totalToken.get() + tokenBalance > totalToken);
        
        DipcAssert(ownerTotalToken.get() < ownerTotalToken.get() + spent);
        (*portfolioStorge)[_portfolioName] = &pInfo[0];
        
        
        
        


        (*portfolioBalance)[_portfolioName] = finalBalance;
        *totalToken = totalToken.get() + finalBalance; 
        *ownerTotalToken = ownerTotalToken.get() + spent;
        DIPC_EMIT_EVENT(createOrder, "portfolioName", _portfolioName, "OrderInfo", &order.toJson()[0], "portfolioBalance", finalBalance);
    }

    
    EXPORT void PortfolioManage::dealOrder(char* _portfolioName, char* _orderId){
        u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
isOwner();
        std::string pInfo = portfolioStorge.get()[_portfolioName];
        
        
        PortfolioInfo info;
        info.parseJson(pInfo);
        

        
         Order ord = info.getOrder(_orderId);
         
         
        if(ord.orderId != "" && ord.orderStatus == 0){
            
            uint64_t timenow = dipc::timestamp();
            if(ord.endTime > timenow){
                ord.orderStatus = 1;
            }else {
                ord.orderStatus = 3;
            }
        } else {
          

            return;
        }
        

        uint64_t sellValue = 0;
        if(ord.orderType == 0){
            sellValue = ord.stockAmount * ord.stockPrice;
        }
        uint64_t currentBalance =  portfolioBalance.get()[_portfolioName];
        

        DipcAssert(currentBalance + sellValue >= currentBalance);
        DipcAssert((ownerTotalToken.get() - sellValue) <= ownerTotalToken.get());
        


        (*portfolioBalance)[_portfolioName] = currentBalance + sellValue;
        *ownerTotalToken = ownerTotalToken.get() - sellValue;
        (*portfolioStorge)[_portfolioName] = &info.toJson()[0];
        
        
        
        

        DIPC_EMIT_EVENT(dealPortfolio, "orderId", _orderId, "orderInfo", &ord.toJson()[0]);
    }
    
    EXPORT void PortfolioManage::revocationOrder(char* _portfolioName, char* _orderId){
        u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
std::string pInfo = portfolioStorge.get()[_portfolioName];
        
        
        PortfolioInfo info;
        info.parseJson(pInfo);
        Order ord = info.getOrder(_orderId);
        
        
        if(ord.orderId != "" && ord.orderStatus == 0){
            std::string callerStr = caller().toString();
            
            
            
            DipcAssert(info.getOwnerAddress() == caller().toString());
            

            uint64_t timenow = dipc::timestamp();
            if(ord.endTime > timenow){
                ord.orderStatus = 2;
            }else {
                ord.orderStatus = 3;
            }
        } else {
            return;
        }
        uint64_t lockToken = 0;
        if(ord.orderType == 1){
            lockToken = ord.stockPrice * ord.stockAmount;
        }
        uint64_t currentBalance =  portfolioBalance.get()[_portfolioName];
        
        
        
        

        DipcAssert(currentBalance + lockToken >= currentBalance);
        DipcAssert(ownerTotalToken.get() - lockToken <= ownerTotalToken.get());

        
        (*portfolioBalance)[_portfolioName] = currentBalance + lockToken;
        *ownerTotalToken = ownerTotalToken.get() - lockToken;
        (*portfolioStorge)[_portfolioName] = &info.toJson()[0];
        DIPC_EMIT_EVENT(revocationPortfolio, "orderId", _orderId, "orderInfo", &ord.toJson()[0]);
    }
    
    EXPORT void PortfolioManage::withdrawPortfolio(char* _portfolioName, uint64_t _withdrawBalance){
         u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
if(!userCanWithdraw.get()){
             return;
         }
         uint64_t currentBalance =  portfolioBalance.get()[_portfolioName];
         DipcAssert(currentBalance - _withdrawBalance < currentBalance);
         auto coinBalance = changeUint64ToU256WithChangeRate(currentBalance, changeRate.get());
         (*portfolioBalance)[_portfolioName] = currentBalance - _withdrawBalance;
         callTransfer(caller(), coinBalance);
    }
    
    EXPORT void PortfolioManage::withdrawPool(uint64_t _balance){
        u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
isOwner();
        Address ownerAddr = Address(owner.get()); 
        callTransfer(ownerAddr, _balance);
        *ownerTotalToken = ownerTotalToken.get() - _balance * changeRate.get();
        *totalToken = totalToken.get() - _balance * changeRate.get();
        DIPC_EMIT_EVENT(tokenCount, "ownerTotalToken", ownerTotalToken.get(), "totalToken", totalToken.get());
    }
    
    PAYABLE void PortfolioManage::depositPool(uint64_t _depositValue){
        isOwner();
        
        uint64_t tokenBalance = changeU256ToUint64WithChangeRate(callValue(), changeRate.get()); 
        *ownerTotalToken = ownerTotalToken.get() + tokenBalance;
        *totalToken = totalToken.get() + tokenBalance;
        DIPC_EMIT_EVENT(tokenCount, "ownerTotalToken", ownerTotalToken.get(), "totalToken", totalToken.get());
    }
     
    CONSTANT uint64_t PortfolioManage::queryTotalToken(){
        u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
return totalToken.get();
    }

     
    CONSTANT uint64_t PortfolioManage::queryPortfolioBalance(char* _portfolioName){
        u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
return portfolioBalance.get()[_portfolioName];
    }

    
    CONSTANT bool PortfolioManage::queryPortfolioNameIfUsed(char* _portfolioName){
        u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
if(portfolioStorge.get()[_portfolioName] != ""){
            return true;
        } 
        return false;
    }

    
    CONSTANT uint64_t PortfolioManage::queryChangeRate(){
        u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
return changeRate.get();
    }

2019-12-19_15:14:55.615486: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:657] searchStr \s*PAYABLE\s*void\s*PortfolioManage::init

2019-12-19_15:14:55.615528: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:656] searchStr \s*EXPORT\s*void\s*PortfolioManage::setChangeRate code_text #include "PortfolioManage.hpp"

    
    PAYABLE void PortfolioManage::init(){
        *owner = caller().toString();
        *changeRate = 10000;
        *userCanWithdraw = false;
        uint64_t tokenBalance = getTotalBalance();
        
        *ownerTotalToken = tokenBalance;
        *totalToken = ownerTotalToken.get();
        
        
        DIPC_EMIT_EVENT(initEvent, "ownerTotalToken" ,tokenBalance);
    }
    
     
    EXPORT void PortfolioManage::setChangeRate(uint64_t _changeRate){
        u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
isOwner();
        *changeRate = _changeRate;
    }
     
    EXPORT void PortfolioManage::setUserCanWithdraw(bool _canWithdraw){
        u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
isOwner();
        *userCanWithdraw = _canWithdraw;
    }

    
    PAYABLE void PortfolioManage::createPortfolio(char* _portfolioName, char* _portfolioDesc){
        if(portfolioStorge.get()[_portfolioName] != ""){
            DIPC_EMIT_EVENT(ErrEvent, "Current portfolio exist: ", _portfolioName);
            return;
        } 
        std::string callerAddr = caller().toString();
        uint64_t tokenBalance = getTotalBalance();
        
        PortfolioInfo info(_portfolioName, _portfolioDesc, &callerAddr[0]);
        std::string portfolioStr = info.toJson();
        
        
        

        (*portfolioStorge)[_portfolioName] = portfolioStr;
        DipcAssert(totalToken.get() + tokenBalance > totalToken);
        (*portfolioBalance)[_portfolioName] = tokenBalance;
        *totalToken = totalToken.get() + tokenBalance; 
        
        DIPC_EMIT_EVENT(portfolioInfo, _portfolioName, &portfolioStr[0], "portfolioBalance", tokenBalance);
    }

    
    PAYABLE void PortfolioManage::depositPortfolio(char* _portfolioName){
        uint64_t tokenBalance = getTotalBalance();
        
        uint64_t currentBalance = portfolioBalance.get()[_portfolioName];
        uint64_t finalBalance  = currentBalance + tokenBalance;
        DipcAssert(totalToken.get() + tokenBalance > totalToken);
        DipcAssert(finalBalance > currentBalance);
        (*portfolioBalance)[_portfolioName] = finalBalance;
        *totalToken = totalToken.get() + finalBalance; 
        DIPC_EMIT_EVENT(depositPortfolio, "portfolioName", _portfolioName, "portfolioBalance", finalBalance);
    }
    
    PAYABLE void PortfolioManage::createOrder(char* _portfolioName, char* _orderId, uint16_t _orderType, char* _stockCode, uint64_t _stockPrice, uint64_t _stockAmount, uint64_t _endTime){
        uint64_t tokenBalance = getTotalBalance();
        DIPC_EMIT_EVENT(createOrder, "portfolioName", _portfolioName, "OrderInfo", "ignore", "tokenBalance", tokenBalance);
        uint64_t spent = 0;
        if(_orderType == 1){
            spent = _stockPrice * _stockAmount;
            DipcAssert((portfolioBalance.get()[_portfolioName] + tokenBalance) > spent);
        }
        struct Order order{_orderId, _orderType, _stockCode, _stockPrice, _stockAmount, _endTime, 0};
        std::string pInfo = portfolioStorge.get()[_portfolioName];
        
        
        
        if(pInfo == "") {
            DIPC_EMIT_EVENT(ErrEvent, "Current portfolio  doesn't exist: ", _portfolioName);
            return;
        }
        PortfolioInfo info;
        info.parseJson(pInfo);
        if(info.getOrder(_orderId).orderId != ""){
            DIPC_EMIT_EVENT(ErrEvent, "Current order exist: ", _orderId);
            return;
        }
        info.addOrder(order);
        pInfo = info.toJson();

        uint64_t currentBalance = portfolioBalance.get()[_portfolioName] ;
        uint64_t finalBalance = currentBalance + tokenBalance - spent;
        DipcAssert(totalToken.get() + tokenBalance > totalToken);
        
        DipcAssert(ownerTotalToken.get() < ownerTotalToken.get() + spent);
        (*portfolioStorge)[_portfolioName] = &pInfo[0];
        
        
        
        


        (*portfolioBalance)[_portfolioName] = finalBalance;
        *totalToken = totalToken.get() + finalBalance; 
        *ownerTotalToken = ownerTotalToken.get() + spent;
        DIPC_EMIT_EVENT(createOrder, "portfolioName", _portfolioName, "OrderInfo", &order.toJson()[0], "portfolioBalance", finalBalance);
    }

    
    EXPORT void PortfolioManage::dealOrder(char* _portfolioName, char* _orderId){
        u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
isOwner();
        std::string pInfo = portfolioStorge.get()[_portfolioName];
        
        
        PortfolioInfo info;
        info.parseJson(pInfo);
        

        
         Order ord = info.getOrder(_orderId);
         
         
        if(ord.orderId != "" && ord.orderStatus == 0){
            
            uint64_t timenow = dipc::timestamp();
            if(ord.endTime > timenow){
                ord.orderStatus = 1;
            }else {
                ord.orderStatus = 3;
            }
        } else {
          

            return;
        }
        

        uint64_t sellValue = 0;
        if(ord.orderType == 0){
            sellValue = ord.stockAmount * ord.stockPrice;
        }
        uint64_t currentBalance =  portfolioBalance.get()[_portfolioName];
        

        DipcAssert(currentBalance + sellValue >= currentBalance);
        DipcAssert((ownerTotalToken.get() - sellValue) <= ownerTotalToken.get());
        


        (*portfolioBalance)[_portfolioName] = currentBalance + sellValue;
        *ownerTotalToken = ownerTotalToken.get() - sellValue;
        (*portfolioStorge)[_portfolioName] = &info.toJson()[0];
        
        
        
        

        DIPC_EMIT_EVENT(dealPortfolio, "orderId", _orderId, "orderInfo", &ord.toJson()[0]);
    }
    
    EXPORT void PortfolioManage::revocationOrder(char* _portfolioName, char* _orderId){
        u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
std::string pInfo = portfolioStorge.get()[_portfolioName];
        
        
        PortfolioInfo info;
        info.parseJson(pInfo);
        Order ord = info.getOrder(_orderId);
        
        
        if(ord.orderId != "" && ord.orderStatus == 0){
            std::string callerStr = caller().toString();
            
            
            
            DipcAssert(info.getOwnerAddress() == caller().toString());
            

            uint64_t timenow = dipc::timestamp();
            if(ord.endTime > timenow){
                ord.orderStatus = 2;
            }else {
                ord.orderStatus = 3;
            }
        } else {
            return;
        }
        uint64_t lockToken = 0;
        if(ord.orderType == 1){
            lockToken = ord.stockPrice * ord.stockAmount;
        }
        uint64_t currentBalance =  portfolioBalance.get()[_portfolioName];
        
        
        
        

        DipcAssert(currentBalance + lockToken >= currentBalance);
        DipcAssert(ownerTotalToken.get() - lockToken <= ownerTotalToken.get());

        
        (*portfolioBalance)[_portfolioName] = currentBalance + lockToken;
        *ownerTotalToken = ownerTotalToken.get() - lockToken;
        (*portfolioStorge)[_portfolioName] = &info.toJson()[0];
        DIPC_EMIT_EVENT(revocationPortfolio, "orderId", _orderId, "orderInfo", &ord.toJson()[0]);
    }
    
    EXPORT void PortfolioManage::withdrawPortfolio(char* _portfolioName, uint64_t _withdrawBalance){
         u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
if(!userCanWithdraw.get()){
             return;
         }
         uint64_t currentBalance =  portfolioBalance.get()[_portfolioName];
         DipcAssert(currentBalance - _withdrawBalance < currentBalance);
         auto coinBalance = changeUint64ToU256WithChangeRate(currentBalance, changeRate.get());
         (*portfolioBalance)[_portfolioName] = currentBalance - _withdrawBalance;
         callTransfer(caller(), coinBalance);
    }
    
    EXPORT void PortfolioManage::withdrawPool(uint64_t _balance){
        u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
isOwner();
        Address ownerAddr = Address(owner.get()); 
        callTransfer(ownerAddr, _balance);
        *ownerTotalToken = ownerTotalToken.get() - _balance * changeRate.get();
        *totalToken = totalToken.get() - _balance * changeRate.get();
        DIPC_EMIT_EVENT(tokenCount, "ownerTotalToken", ownerTotalToken.get(), "totalToken", totalToken.get());
    }
    
    PAYABLE void PortfolioManage::depositPool(uint64_t _depositValue){
        isOwner();
        
        uint64_t tokenBalance = changeU256ToUint64WithChangeRate(callValue(), changeRate.get()); 
        *ownerTotalToken = ownerTotalToken.get() + tokenBalance;
        *totalToken = totalToken.get() + tokenBalance;
        DIPC_EMIT_EVENT(tokenCount, "ownerTotalToken", ownerTotalToken.get(), "totalToken", totalToken.get());
    }
     
    CONSTANT uint64_t PortfolioManage::queryTotalToken(){
        u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
return totalToken.get();
    }

     
    CONSTANT uint64_t PortfolioManage::queryPortfolioBalance(char* _portfolioName){
        u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
return portfolioBalance.get()[_portfolioName];
    }

    
    CONSTANT bool PortfolioManage::queryPortfolioNameIfUsed(char* _portfolioName){
        u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
if(portfolioStorge.get()[_portfolioName] != ""){
            return true;
        } 
        return false;
    }

    
    CONSTANT uint64_t PortfolioManage::queryChangeRate(){
        u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
return changeRate.get();
    }

2019-12-19_15:14:55.615537: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:657] searchStr \s*EXPORT\s*void\s*PortfolioManage::setChangeRate

2019-12-19_15:14:55.615924: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:656] searchStr \s*EXPORT\s*void\s*PortfolioManage::setUserCanWithdraw code_text #include "PortfolioManage.hpp"

    
    PAYABLE void PortfolioManage::init(){
        *owner = caller().toString();
        *changeRate = 10000;
        *userCanWithdraw = false;
        uint64_t tokenBalance = getTotalBalance();
        
        *ownerTotalToken = tokenBalance;
        *totalToken = ownerTotalToken.get();
        
        
        DIPC_EMIT_EVENT(initEvent, "ownerTotalToken" ,tokenBalance);
    }
    
     
    EXPORT void PortfolioManage::setChangeRate(uint64_t _changeRate){
        u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
isOwner();
        *changeRate = _changeRate;
    }
     
    EXPORT void PortfolioManage::setUserCanWithdraw(bool _canWithdraw){
        u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
isOwner();
        *userCanWithdraw = _canWithdraw;
    }

    
    PAYABLE void PortfolioManage::createPortfolio(char* _portfolioName, char* _portfolioDesc){
        if(portfolioStorge.get()[_portfolioName] != ""){
            DIPC_EMIT_EVENT(ErrEvent, "Current portfolio exist: ", _portfolioName);
            return;
        } 
        std::string callerAddr = caller().toString();
        uint64_t tokenBalance = getTotalBalance();
        
        PortfolioInfo info(_portfolioName, _portfolioDesc, &callerAddr[0]);
        std::string portfolioStr = info.toJson();
        
        
        

        (*portfolioStorge)[_portfolioName] = portfolioStr;
        DipcAssert(totalToken.get() + tokenBalance > totalToken);
        (*portfolioBalance)[_portfolioName] = tokenBalance;
        *totalToken = totalToken.get() + tokenBalance; 
        
        DIPC_EMIT_EVENT(portfolioInfo, _portfolioName, &portfolioStr[0], "portfolioBalance", tokenBalance);
    }

    
    PAYABLE void PortfolioManage::depositPortfolio(char* _portfolioName){
        uint64_t tokenBalance = getTotalBalance();
        
        uint64_t currentBalance = portfolioBalance.get()[_portfolioName];
        uint64_t finalBalance  = currentBalance + tokenBalance;
        DipcAssert(totalToken.get() + tokenBalance > totalToken);
        DipcAssert(finalBalance > currentBalance);
        (*portfolioBalance)[_portfolioName] = finalBalance;
        *totalToken = totalToken.get() + finalBalance; 
        DIPC_EMIT_EVENT(depositPortfolio, "portfolioName", _portfolioName, "portfolioBalance", finalBalance);
    }
    
    PAYABLE void PortfolioManage::createOrder(char* _portfolioName, char* _orderId, uint16_t _orderType, char* _stockCode, uint64_t _stockPrice, uint64_t _stockAmount, uint64_t _endTime){
        uint64_t tokenBalance = getTotalBalance();
        DIPC_EMIT_EVENT(createOrder, "portfolioName", _portfolioName, "OrderInfo", "ignore", "tokenBalance", tokenBalance);
        uint64_t spent = 0;
        if(_orderType == 1){
            spent = _stockPrice * _stockAmount;
            DipcAssert((portfolioBalance.get()[_portfolioName] + tokenBalance) > spent);
        }
        struct Order order{_orderId, _orderType, _stockCode, _stockPrice, _stockAmount, _endTime, 0};
        std::string pInfo = portfolioStorge.get()[_portfolioName];
        
        
        
        if(pInfo == "") {
            DIPC_EMIT_EVENT(ErrEvent, "Current portfolio  doesn't exist: ", _portfolioName);
            return;
        }
        PortfolioInfo info;
        info.parseJson(pInfo);
        if(info.getOrder(_orderId).orderId != ""){
            DIPC_EMIT_EVENT(ErrEvent, "Current order exist: ", _orderId);
            return;
        }
        info.addOrder(order);
        pInfo = info.toJson();

        uint64_t currentBalance = portfolioBalance.get()[_portfolioName] ;
        uint64_t finalBalance = currentBalance + tokenBalance - spent;
        DipcAssert(totalToken.get() + tokenBalance > totalToken);
        
        DipcAssert(ownerTotalToken.get() < ownerTotalToken.get() + spent);
        (*portfolioStorge)[_portfolioName] = &pInfo[0];
        
        
        
        


        (*portfolioBalance)[_portfolioName] = finalBalance;
        *totalToken = totalToken.get() + finalBalance; 
        *ownerTotalToken = ownerTotalToken.get() + spent;
        DIPC_EMIT_EVENT(createOrder, "portfolioName", _portfolioName, "OrderInfo", &order.toJson()[0], "portfolioBalance", finalBalance);
    }

    
    EXPORT void PortfolioManage::dealOrder(char* _portfolioName, char* _orderId){
        u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
isOwner();
        std::string pInfo = portfolioStorge.get()[_portfolioName];
        
        
        PortfolioInfo info;
        info.parseJson(pInfo);
        

        
         Order ord = info.getOrder(_orderId);
         
         
        if(ord.orderId != "" && ord.orderStatus == 0){
            
            uint64_t timenow = dipc::timestamp();
            if(ord.endTime > timenow){
                ord.orderStatus = 1;
            }else {
                ord.orderStatus = 3;
            }
        } else {
          

            return;
        }
        

        uint64_t sellValue = 0;
        if(ord.orderType == 0){
            sellValue = ord.stockAmount * ord.stockPrice;
        }
        uint64_t currentBalance =  portfolioBalance.get()[_portfolioName];
        

        DipcAssert(currentBalance + sellValue >= currentBalance);
        DipcAssert((ownerTotalToken.get() - sellValue) <= ownerTotalToken.get());
        


        (*portfolioBalance)[_portfolioName] = currentBalance + sellValue;
        *ownerTotalToken = ownerTotalToken.get() - sellValue;
        (*portfolioStorge)[_portfolioName] = &info.toJson()[0];
        
        
        
        

        DIPC_EMIT_EVENT(dealPortfolio, "orderId", _orderId, "orderInfo", &ord.toJson()[0]);
    }
    
    EXPORT void PortfolioManage::revocationOrder(char* _portfolioName, char* _orderId){
        u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
std::string pInfo = portfolioStorge.get()[_portfolioName];
        
        
        PortfolioInfo info;
        info.parseJson(pInfo);
        Order ord = info.getOrder(_orderId);
        
        
        if(ord.orderId != "" && ord.orderStatus == 0){
            std::string callerStr = caller().toString();
            
            
            
            DipcAssert(info.getOwnerAddress() == caller().toString());
            

            uint64_t timenow = dipc::timestamp();
            if(ord.endTime > timenow){
                ord.orderStatus = 2;
            }else {
                ord.orderStatus = 3;
            }
        } else {
            return;
        }
        uint64_t lockToken = 0;
        if(ord.orderType == 1){
            lockToken = ord.stockPrice * ord.stockAmount;
        }
        uint64_t currentBalance =  portfolioBalance.get()[_portfolioName];
        
        
        
        

        DipcAssert(currentBalance + lockToken >= currentBalance);
        DipcAssert(ownerTotalToken.get() - lockToken <= ownerTotalToken.get());

        
        (*portfolioBalance)[_portfolioName] = currentBalance + lockToken;
        *ownerTotalToken = ownerTotalToken.get() - lockToken;
        (*portfolioStorge)[_portfolioName] = &info.toJson()[0];
        DIPC_EMIT_EVENT(revocationPortfolio, "orderId", _orderId, "orderInfo", &ord.toJson()[0]);
    }
    
    EXPORT void PortfolioManage::withdrawPortfolio(char* _portfolioName, uint64_t _withdrawBalance){
         u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
if(!userCanWithdraw.get()){
             return;
         }
         uint64_t currentBalance =  portfolioBalance.get()[_portfolioName];
         DipcAssert(currentBalance - _withdrawBalance < currentBalance);
         auto coinBalance = changeUint64ToU256WithChangeRate(currentBalance, changeRate.get());
         (*portfolioBalance)[_portfolioName] = currentBalance - _withdrawBalance;
         callTransfer(caller(), coinBalance);
    }
    
    EXPORT void PortfolioManage::withdrawPool(uint64_t _balance){
        u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
isOwner();
        Address ownerAddr = Address(owner.get()); 
        callTransfer(ownerAddr, _balance);
        *ownerTotalToken = ownerTotalToken.get() - _balance * changeRate.get();
        *totalToken = totalToken.get() - _balance * changeRate.get();
        DIPC_EMIT_EVENT(tokenCount, "ownerTotalToken", ownerTotalToken.get(), "totalToken", totalToken.get());
    }
    
    PAYABLE void PortfolioManage::depositPool(uint64_t _depositValue){
        isOwner();
        
        uint64_t tokenBalance = changeU256ToUint64WithChangeRate(callValue(), changeRate.get()); 
        *ownerTotalToken = ownerTotalToken.get() + tokenBalance;
        *totalToken = totalToken.get() + tokenBalance;
        DIPC_EMIT_EVENT(tokenCount, "ownerTotalToken", ownerTotalToken.get(), "totalToken", totalToken.get());
    }
     
    CONSTANT uint64_t PortfolioManage::queryTotalToken(){
        u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
return totalToken.get();
    }

     
    CONSTANT uint64_t PortfolioManage::queryPortfolioBalance(char* _portfolioName){
        u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
return portfolioBalance.get()[_portfolioName];
    }

    
    CONSTANT bool PortfolioManage::queryPortfolioNameIfUsed(char* _portfolioName){
        u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
if(portfolioStorge.get()[_portfolioName] != ""){
            return true;
        } 
        return false;
    }

    
    CONSTANT uint64_t PortfolioManage::queryChangeRate(){
        u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
return changeRate.get();
    }

2019-12-19_15:14:55.615933: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:657] searchStr \s*EXPORT\s*void\s*PortfolioManage::setUserCanWithdraw

2019-12-19_15:14:55.616522: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:656] searchStr \s*PAYABLE\s*void\s*PortfolioManage::createPortfolio code_text #include "PortfolioManage.hpp"

    
    PAYABLE void PortfolioManage::init(){
        *owner = caller().toString();
        *changeRate = 10000;
        *userCanWithdraw = false;
        uint64_t tokenBalance = getTotalBalance();
        
        *ownerTotalToken = tokenBalance;
        *totalToken = ownerTotalToken.get();
        
        
        DIPC_EMIT_EVENT(initEvent, "ownerTotalToken" ,tokenBalance);
    }
    
     
    EXPORT void PortfolioManage::setChangeRate(uint64_t _changeRate){
        u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
isOwner();
        *changeRate = _changeRate;
    }
     
    EXPORT void PortfolioManage::setUserCanWithdraw(bool _canWithdraw){
        u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
isOwner();
        *userCanWithdraw = _canWithdraw;
    }

    
    PAYABLE void PortfolioManage::createPortfolio(char* _portfolioName, char* _portfolioDesc){
        if(portfolioStorge.get()[_portfolioName] != ""){
            DIPC_EMIT_EVENT(ErrEvent, "Current portfolio exist: ", _portfolioName);
            return;
        } 
        std::string callerAddr = caller().toString();
        uint64_t tokenBalance = getTotalBalance();
        
        PortfolioInfo info(_portfolioName, _portfolioDesc, &callerAddr[0]);
        std::string portfolioStr = info.toJson();
        
        
        

        (*portfolioStorge)[_portfolioName] = portfolioStr;
        DipcAssert(totalToken.get() + tokenBalance > totalToken);
        (*portfolioBalance)[_portfolioName] = tokenBalance;
        *totalToken = totalToken.get() + tokenBalance; 
        
        DIPC_EMIT_EVENT(portfolioInfo, _portfolioName, &portfolioStr[0], "portfolioBalance", tokenBalance);
    }

    
    PAYABLE void PortfolioManage::depositPortfolio(char* _portfolioName){
        uint64_t tokenBalance = getTotalBalance();
        
        uint64_t currentBalance = portfolioBalance.get()[_portfolioName];
        uint64_t finalBalance  = currentBalance + tokenBalance;
        DipcAssert(totalToken.get() + tokenBalance > totalToken);
        DipcAssert(finalBalance > currentBalance);
        (*portfolioBalance)[_portfolioName] = finalBalance;
        *totalToken = totalToken.get() + finalBalance; 
        DIPC_EMIT_EVENT(depositPortfolio, "portfolioName", _portfolioName, "portfolioBalance", finalBalance);
    }
    
    PAYABLE void PortfolioManage::createOrder(char* _portfolioName, char* _orderId, uint16_t _orderType, char* _stockCode, uint64_t _stockPrice, uint64_t _stockAmount, uint64_t _endTime){
        uint64_t tokenBalance = getTotalBalance();
        DIPC_EMIT_EVENT(createOrder, "portfolioName", _portfolioName, "OrderInfo", "ignore", "tokenBalance", tokenBalance);
        uint64_t spent = 0;
        if(_orderType == 1){
            spent = _stockPrice * _stockAmount;
            DipcAssert((portfolioBalance.get()[_portfolioName] + tokenBalance) > spent);
        }
        struct Order order{_orderId, _orderType, _stockCode, _stockPrice, _stockAmount, _endTime, 0};
        std::string pInfo = portfolioStorge.get()[_portfolioName];
        
        
        
        if(pInfo == "") {
            DIPC_EMIT_EVENT(ErrEvent, "Current portfolio  doesn't exist: ", _portfolioName);
            return;
        }
        PortfolioInfo info;
        info.parseJson(pInfo);
        if(info.getOrder(_orderId).orderId != ""){
            DIPC_EMIT_EVENT(ErrEvent, "Current order exist: ", _orderId);
            return;
        }
        info.addOrder(order);
        pInfo = info.toJson();

        uint64_t currentBalance = portfolioBalance.get()[_portfolioName] ;
        uint64_t finalBalance = currentBalance + tokenBalance - spent;
        DipcAssert(totalToken.get() + tokenBalance > totalToken);
        
        DipcAssert(ownerTotalToken.get() < ownerTotalToken.get() + spent);
        (*portfolioStorge)[_portfolioName] = &pInfo[0];
        
        
        
        


        (*portfolioBalance)[_portfolioName] = finalBalance;
        *totalToken = totalToken.get() + finalBalance; 
        *ownerTotalToken = ownerTotalToken.get() + spent;
        DIPC_EMIT_EVENT(createOrder, "portfolioName", _portfolioName, "OrderInfo", &order.toJson()[0], "portfolioBalance", finalBalance);
    }

    
    EXPORT void PortfolioManage::dealOrder(char* _portfolioName, char* _orderId){
        u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
isOwner();
        std::string pInfo = portfolioStorge.get()[_portfolioName];
        
        
        PortfolioInfo info;
        info.parseJson(pInfo);
        

        
         Order ord = info.getOrder(_orderId);
         
         
        if(ord.orderId != "" && ord.orderStatus == 0){
            
            uint64_t timenow = dipc::timestamp();
            if(ord.endTime > timenow){
                ord.orderStatus = 1;
            }else {
                ord.orderStatus = 3;
            }
        } else {
          

            return;
        }
        

        uint64_t sellValue = 0;
        if(ord.orderType == 0){
            sellValue = ord.stockAmount * ord.stockPrice;
        }
        uint64_t currentBalance =  portfolioBalance.get()[_portfolioName];
        

        DipcAssert(currentBalance + sellValue >= currentBalance);
        DipcAssert((ownerTotalToken.get() - sellValue) <= ownerTotalToken.get());
        


        (*portfolioBalance)[_portfolioName] = currentBalance + sellValue;
        *ownerTotalToken = ownerTotalToken.get() - sellValue;
        (*portfolioStorge)[_portfolioName] = &info.toJson()[0];
        
        
        
        

        DIPC_EMIT_EVENT(dealPortfolio, "orderId", _orderId, "orderInfo", &ord.toJson()[0]);
    }
    
    EXPORT void PortfolioManage::revocationOrder(char* _portfolioName, char* _orderId){
        u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
std::string pInfo = portfolioStorge.get()[_portfolioName];
        
        
        PortfolioInfo info;
        info.parseJson(pInfo);
        Order ord = info.getOrder(_orderId);
        
        
        if(ord.orderId != "" && ord.orderStatus == 0){
            std::string callerStr = caller().toString();
            
            
            
            DipcAssert(info.getOwnerAddress() == caller().toString());
            

            uint64_t timenow = dipc::timestamp();
            if(ord.endTime > timenow){
                ord.orderStatus = 2;
            }else {
                ord.orderStatus = 3;
            }
        } else {
            return;
        }
        uint64_t lockToken = 0;
        if(ord.orderType == 1){
            lockToken = ord.stockPrice * ord.stockAmount;
        }
        uint64_t currentBalance =  portfolioBalance.get()[_portfolioName];
        
        
        
        

        DipcAssert(currentBalance + lockToken >= currentBalance);
        DipcAssert(ownerTotalToken.get() - lockToken <= ownerTotalToken.get());

        
        (*portfolioBalance)[_portfolioName] = currentBalance + lockToken;
        *ownerTotalToken = ownerTotalToken.get() - lockToken;
        (*portfolioStorge)[_portfolioName] = &info.toJson()[0];
        DIPC_EMIT_EVENT(revocationPortfolio, "orderId", _orderId, "orderInfo", &ord.toJson()[0]);
    }
    
    EXPORT void PortfolioManage::withdrawPortfolio(char* _portfolioName, uint64_t _withdrawBalance){
         u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
if(!userCanWithdraw.get()){
             return;
         }
         uint64_t currentBalance =  portfolioBalance.get()[_portfolioName];
         DipcAssert(currentBalance - _withdrawBalance < currentBalance);
         auto coinBalance = changeUint64ToU256WithChangeRate(currentBalance, changeRate.get());
         (*portfolioBalance)[_portfolioName] = currentBalance - _withdrawBalance;
         callTransfer(caller(), coinBalance);
    }
    
    EXPORT void PortfolioManage::withdrawPool(uint64_t _balance){
        u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
isOwner();
        Address ownerAddr = Address(owner.get()); 
        callTransfer(ownerAddr, _balance);
        *ownerTotalToken = ownerTotalToken.get() - _balance * changeRate.get();
        *totalToken = totalToken.get() - _balance * changeRate.get();
        DIPC_EMIT_EVENT(tokenCount, "ownerTotalToken", ownerTotalToken.get(), "totalToken", totalToken.get());
    }
    
    PAYABLE void PortfolioManage::depositPool(uint64_t _depositValue){
        isOwner();
        
        uint64_t tokenBalance = changeU256ToUint64WithChangeRate(callValue(), changeRate.get()); 
        *ownerTotalToken = ownerTotalToken.get() + tokenBalance;
        *totalToken = totalToken.get() + tokenBalance;
        DIPC_EMIT_EVENT(tokenCount, "ownerTotalToken", ownerTotalToken.get(), "totalToken", totalToken.get());
    }
     
    CONSTANT uint64_t PortfolioManage::queryTotalToken(){
        u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
return totalToken.get();
    }

     
    CONSTANT uint64_t PortfolioManage::queryPortfolioBalance(char* _portfolioName){
        u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
return portfolioBalance.get()[_portfolioName];
    }

    
    CONSTANT bool PortfolioManage::queryPortfolioNameIfUsed(char* _portfolioName){
        u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
if(portfolioStorge.get()[_portfolioName] != ""){
            return true;
        } 
        return false;
    }

    
    CONSTANT uint64_t PortfolioManage::queryChangeRate(){
        u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
return changeRate.get();
    }

2019-12-19_15:14:55.616536: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:657] searchStr \s*PAYABLE\s*void\s*PortfolioManage::createPortfolio

2019-12-19_15:14:55.617558: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:656] searchStr \s*PAYABLE\s*void\s*PortfolioManage::depositPortfolio code_text #include "PortfolioManage.hpp"

    
    PAYABLE void PortfolioManage::init(){
        *owner = caller().toString();
        *changeRate = 10000;
        *userCanWithdraw = false;
        uint64_t tokenBalance = getTotalBalance();
        
        *ownerTotalToken = tokenBalance;
        *totalToken = ownerTotalToken.get();
        
        
        DIPC_EMIT_EVENT(initEvent, "ownerTotalToken" ,tokenBalance);
    }
    
     
    EXPORT void PortfolioManage::setChangeRate(uint64_t _changeRate){
        u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
isOwner();
        *changeRate = _changeRate;
    }
     
    EXPORT void PortfolioManage::setUserCanWithdraw(bool _canWithdraw){
        u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
isOwner();
        *userCanWithdraw = _canWithdraw;
    }

    
    PAYABLE void PortfolioManage::createPortfolio(char* _portfolioName, char* _portfolioDesc){
        if(portfolioStorge.get()[_portfolioName] != ""){
            DIPC_EMIT_EVENT(ErrEvent, "Current portfolio exist: ", _portfolioName);
            return;
        } 
        std::string callerAddr = caller().toString();
        uint64_t tokenBalance = getTotalBalance();
        
        PortfolioInfo info(_portfolioName, _portfolioDesc, &callerAddr[0]);
        std::string portfolioStr = info.toJson();
        
        
        

        (*portfolioStorge)[_portfolioName] = portfolioStr;
        DipcAssert(totalToken.get() + tokenBalance > totalToken);
        (*portfolioBalance)[_portfolioName] = tokenBalance;
        *totalToken = totalToken.get() + tokenBalance; 
        
        DIPC_EMIT_EVENT(portfolioInfo, _portfolioName, &portfolioStr[0], "portfolioBalance", tokenBalance);
    }

    
    PAYABLE void PortfolioManage::depositPortfolio(char* _portfolioName){
        uint64_t tokenBalance = getTotalBalance();
        
        uint64_t currentBalance = portfolioBalance.get()[_portfolioName];
        uint64_t finalBalance  = currentBalance + tokenBalance;
        DipcAssert(totalToken.get() + tokenBalance > totalToken);
        DipcAssert(finalBalance > currentBalance);
        (*portfolioBalance)[_portfolioName] = finalBalance;
        *totalToken = totalToken.get() + finalBalance; 
        DIPC_EMIT_EVENT(depositPortfolio, "portfolioName", _portfolioName, "portfolioBalance", finalBalance);
    }
    
    PAYABLE void PortfolioManage::createOrder(char* _portfolioName, char* _orderId, uint16_t _orderType, char* _stockCode, uint64_t _stockPrice, uint64_t _stockAmount, uint64_t _endTime){
        uint64_t tokenBalance = getTotalBalance();
        DIPC_EMIT_EVENT(createOrder, "portfolioName", _portfolioName, "OrderInfo", "ignore", "tokenBalance", tokenBalance);
        uint64_t spent = 0;
        if(_orderType == 1){
            spent = _stockPrice * _stockAmount;
            DipcAssert((portfolioBalance.get()[_portfolioName] + tokenBalance) > spent);
        }
        struct Order order{_orderId, _orderType, _stockCode, _stockPrice, _stockAmount, _endTime, 0};
        std::string pInfo = portfolioStorge.get()[_portfolioName];
        
        
        
        if(pInfo == "") {
            DIPC_EMIT_EVENT(ErrEvent, "Current portfolio  doesn't exist: ", _portfolioName);
            return;
        }
        PortfolioInfo info;
        info.parseJson(pInfo);
        if(info.getOrder(_orderId).orderId != ""){
            DIPC_EMIT_EVENT(ErrEvent, "Current order exist: ", _orderId);
            return;
        }
        info.addOrder(order);
        pInfo = info.toJson();

        uint64_t currentBalance = portfolioBalance.get()[_portfolioName] ;
        uint64_t finalBalance = currentBalance + tokenBalance - spent;
        DipcAssert(totalToken.get() + tokenBalance > totalToken);
        
        DipcAssert(ownerTotalToken.get() < ownerTotalToken.get() + spent);
        (*portfolioStorge)[_portfolioName] = &pInfo[0];
        
        
        
        


        (*portfolioBalance)[_portfolioName] = finalBalance;
        *totalToken = totalToken.get() + finalBalance; 
        *ownerTotalToken = ownerTotalToken.get() + spent;
        DIPC_EMIT_EVENT(createOrder, "portfolioName", _portfolioName, "OrderInfo", &order.toJson()[0], "portfolioBalance", finalBalance);
    }

    
    EXPORT void PortfolioManage::dealOrder(char* _portfolioName, char* _orderId){
        u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
isOwner();
        std::string pInfo = portfolioStorge.get()[_portfolioName];
        
        
        PortfolioInfo info;
        info.parseJson(pInfo);
        

        
         Order ord = info.getOrder(_orderId);
         
         
        if(ord.orderId != "" && ord.orderStatus == 0){
            
            uint64_t timenow = dipc::timestamp();
            if(ord.endTime > timenow){
                ord.orderStatus = 1;
            }else {
                ord.orderStatus = 3;
            }
        } else {
          

            return;
        }
        

        uint64_t sellValue = 0;
        if(ord.orderType == 0){
            sellValue = ord.stockAmount * ord.stockPrice;
        }
        uint64_t currentBalance =  portfolioBalance.get()[_portfolioName];
        

        DipcAssert(currentBalance + sellValue >= currentBalance);
        DipcAssert((ownerTotalToken.get() - sellValue) <= ownerTotalToken.get());
        


        (*portfolioBalance)[_portfolioName] = currentBalance + sellValue;
        *ownerTotalToken = ownerTotalToken.get() - sellValue;
        (*portfolioStorge)[_portfolioName] = &info.toJson()[0];
        
        
        
        

        DIPC_EMIT_EVENT(dealPortfolio, "orderId", _orderId, "orderInfo", &ord.toJson()[0]);
    }
    
    EXPORT void PortfolioManage::revocationOrder(char* _portfolioName, char* _orderId){
        u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
std::string pInfo = portfolioStorge.get()[_portfolioName];
        
        
        PortfolioInfo info;
        info.parseJson(pInfo);
        Order ord = info.getOrder(_orderId);
        
        
        if(ord.orderId != "" && ord.orderStatus == 0){
            std::string callerStr = caller().toString();
            
            
            
            DipcAssert(info.getOwnerAddress() == caller().toString());
            

            uint64_t timenow = dipc::timestamp();
            if(ord.endTime > timenow){
                ord.orderStatus = 2;
            }else {
                ord.orderStatus = 3;
            }
        } else {
            return;
        }
        uint64_t lockToken = 0;
        if(ord.orderType == 1){
            lockToken = ord.stockPrice * ord.stockAmount;
        }
        uint64_t currentBalance =  portfolioBalance.get()[_portfolioName];
        
        
        
        

        DipcAssert(currentBalance + lockToken >= currentBalance);
        DipcAssert(ownerTotalToken.get() - lockToken <= ownerTotalToken.get());

        
        (*portfolioBalance)[_portfolioName] = currentBalance + lockToken;
        *ownerTotalToken = ownerTotalToken.get() - lockToken;
        (*portfolioStorge)[_portfolioName] = &info.toJson()[0];
        DIPC_EMIT_EVENT(revocationPortfolio, "orderId", _orderId, "orderInfo", &ord.toJson()[0]);
    }
    
    EXPORT void PortfolioManage::withdrawPortfolio(char* _portfolioName, uint64_t _withdrawBalance){
         u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
if(!userCanWithdraw.get()){
             return;
         }
         uint64_t currentBalance =  portfolioBalance.get()[_portfolioName];
         DipcAssert(currentBalance - _withdrawBalance < currentBalance);
         auto coinBalance = changeUint64ToU256WithChangeRate(currentBalance, changeRate.get());
         (*portfolioBalance)[_portfolioName] = currentBalance - _withdrawBalance;
         callTransfer(caller(), coinBalance);
    }
    
    EXPORT void PortfolioManage::withdrawPool(uint64_t _balance){
        u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
isOwner();
        Address ownerAddr = Address(owner.get()); 
        callTransfer(ownerAddr, _balance);
        *ownerTotalToken = ownerTotalToken.get() - _balance * changeRate.get();
        *totalToken = totalToken.get() - _balance * changeRate.get();
        DIPC_EMIT_EVENT(tokenCount, "ownerTotalToken", ownerTotalToken.get(), "totalToken", totalToken.get());
    }
    
    PAYABLE void PortfolioManage::depositPool(uint64_t _depositValue){
        isOwner();
        
        uint64_t tokenBalance = changeU256ToUint64WithChangeRate(callValue(), changeRate.get()); 
        *ownerTotalToken = ownerTotalToken.get() + tokenBalance;
        *totalToken = totalToken.get() + tokenBalance;
        DIPC_EMIT_EVENT(tokenCount, "ownerTotalToken", ownerTotalToken.get(), "totalToken", totalToken.get());
    }
     
    CONSTANT uint64_t PortfolioManage::queryTotalToken(){
        u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
return totalToken.get();
    }

     
    CONSTANT uint64_t PortfolioManage::queryPortfolioBalance(char* _portfolioName){
        u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
return portfolioBalance.get()[_portfolioName];
    }

    
    CONSTANT bool PortfolioManage::queryPortfolioNameIfUsed(char* _portfolioName){
        u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
if(portfolioStorge.get()[_portfolioName] != ""){
            return true;
        } 
        return false;
    }

    
    CONSTANT uint64_t PortfolioManage::queryChangeRate(){
        u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
return changeRate.get();
    }

2019-12-19_15:14:55.617578: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:657] searchStr \s*PAYABLE\s*void\s*PortfolioManage::depositPortfolio

2019-12-19_15:14:55.619591: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:656] searchStr \s*PAYABLE\s*void\s*PortfolioManage::createOrder code_text #include "PortfolioManage.hpp"

    
    PAYABLE void PortfolioManage::init(){
        *owner = caller().toString();
        *changeRate = 10000;
        *userCanWithdraw = false;
        uint64_t tokenBalance = getTotalBalance();
        
        *ownerTotalToken = tokenBalance;
        *totalToken = ownerTotalToken.get();
        
        
        DIPC_EMIT_EVENT(initEvent, "ownerTotalToken" ,tokenBalance);
    }
    
     
    EXPORT void PortfolioManage::setChangeRate(uint64_t _changeRate){
        u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
isOwner();
        *changeRate = _changeRate;
    }
     
    EXPORT void PortfolioManage::setUserCanWithdraw(bool _canWithdraw){
        u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
isOwner();
        *userCanWithdraw = _canWithdraw;
    }

    
    PAYABLE void PortfolioManage::createPortfolio(char* _portfolioName, char* _portfolioDesc){
        if(portfolioStorge.get()[_portfolioName] != ""){
            DIPC_EMIT_EVENT(ErrEvent, "Current portfolio exist: ", _portfolioName);
            return;
        } 
        std::string callerAddr = caller().toString();
        uint64_t tokenBalance = getTotalBalance();
        
        PortfolioInfo info(_portfolioName, _portfolioDesc, &callerAddr[0]);
        std::string portfolioStr = info.toJson();
        
        
        

        (*portfolioStorge)[_portfolioName] = portfolioStr;
        DipcAssert(totalToken.get() + tokenBalance > totalToken);
        (*portfolioBalance)[_portfolioName] = tokenBalance;
        *totalToken = totalToken.get() + tokenBalance; 
        
        DIPC_EMIT_EVENT(portfolioInfo, _portfolioName, &portfolioStr[0], "portfolioBalance", tokenBalance);
    }

    
    PAYABLE void PortfolioManage::depositPortfolio(char* _portfolioName){
        uint64_t tokenBalance = getTotalBalance();
        
        uint64_t currentBalance = portfolioBalance.get()[_portfolioName];
        uint64_t finalBalance  = currentBalance + tokenBalance;
        DipcAssert(totalToken.get() + tokenBalance > totalToken);
        DipcAssert(finalBalance > currentBalance);
        (*portfolioBalance)[_portfolioName] = finalBalance;
        *totalToken = totalToken.get() + finalBalance; 
        DIPC_EMIT_EVENT(depositPortfolio, "portfolioName", _portfolioName, "portfolioBalance", finalBalance);
    }
    
    PAYABLE void PortfolioManage::createOrder(char* _portfolioName, char* _orderId, uint16_t _orderType, char* _stockCode, uint64_t _stockPrice, uint64_t _stockAmount, uint64_t _endTime){
        uint64_t tokenBalance = getTotalBalance();
        DIPC_EMIT_EVENT(createOrder, "portfolioName", _portfolioName, "OrderInfo", "ignore", "tokenBalance", tokenBalance);
        uint64_t spent = 0;
        if(_orderType == 1){
            spent = _stockPrice * _stockAmount;
            DipcAssert((portfolioBalance.get()[_portfolioName] + tokenBalance) > spent);
        }
        struct Order order{_orderId, _orderType, _stockCode, _stockPrice, _stockAmount, _endTime, 0};
        std::string pInfo = portfolioStorge.get()[_portfolioName];
        
        
        
        if(pInfo == "") {
            DIPC_EMIT_EVENT(ErrEvent, "Current portfolio  doesn't exist: ", _portfolioName);
            return;
        }
        PortfolioInfo info;
        info.parseJson(pInfo);
        if(info.getOrder(_orderId).orderId != ""){
            DIPC_EMIT_EVENT(ErrEvent, "Current order exist: ", _orderId);
            return;
        }
        info.addOrder(order);
        pInfo = info.toJson();

        uint64_t currentBalance = portfolioBalance.get()[_portfolioName] ;
        uint64_t finalBalance = currentBalance + tokenBalance - spent;
        DipcAssert(totalToken.get() + tokenBalance > totalToken);
        
        DipcAssert(ownerTotalToken.get() < ownerTotalToken.get() + spent);
        (*portfolioStorge)[_portfolioName] = &pInfo[0];
        
        
        
        


        (*portfolioBalance)[_portfolioName] = finalBalance;
        *totalToken = totalToken.get() + finalBalance; 
        *ownerTotalToken = ownerTotalToken.get() + spent;
        DIPC_EMIT_EVENT(createOrder, "portfolioName", _portfolioName, "OrderInfo", &order.toJson()[0], "portfolioBalance", finalBalance);
    }

    
    EXPORT void PortfolioManage::dealOrder(char* _portfolioName, char* _orderId){
        u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
isOwner();
        std::string pInfo = portfolioStorge.get()[_portfolioName];
        
        
        PortfolioInfo info;
        info.parseJson(pInfo);
        

        
         Order ord = info.getOrder(_orderId);
         
         
        if(ord.orderId != "" && ord.orderStatus == 0){
            
            uint64_t timenow = dipc::timestamp();
            if(ord.endTime > timenow){
                ord.orderStatus = 1;
            }else {
                ord.orderStatus = 3;
            }
        } else {
          

            return;
        }
        

        uint64_t sellValue = 0;
        if(ord.orderType == 0){
            sellValue = ord.stockAmount * ord.stockPrice;
        }
        uint64_t currentBalance =  portfolioBalance.get()[_portfolioName];
        

        DipcAssert(currentBalance + sellValue >= currentBalance);
        DipcAssert((ownerTotalToken.get() - sellValue) <= ownerTotalToken.get());
        


        (*portfolioBalance)[_portfolioName] = currentBalance + sellValue;
        *ownerTotalToken = ownerTotalToken.get() - sellValue;
        (*portfolioStorge)[_portfolioName] = &info.toJson()[0];
        
        
        
        

        DIPC_EMIT_EVENT(dealPortfolio, "orderId", _orderId, "orderInfo", &ord.toJson()[0]);
    }
    
    EXPORT void PortfolioManage::revocationOrder(char* _portfolioName, char* _orderId){
        u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
std::string pInfo = portfolioStorge.get()[_portfolioName];
        
        
        PortfolioInfo info;
        info.parseJson(pInfo);
        Order ord = info.getOrder(_orderId);
        
        
        if(ord.orderId != "" && ord.orderStatus == 0){
            std::string callerStr = caller().toString();
            
            
            
            DipcAssert(info.getOwnerAddress() == caller().toString());
            

            uint64_t timenow = dipc::timestamp();
            if(ord.endTime > timenow){
                ord.orderStatus = 2;
            }else {
                ord.orderStatus = 3;
            }
        } else {
            return;
        }
        uint64_t lockToken = 0;
        if(ord.orderType == 1){
            lockToken = ord.stockPrice * ord.stockAmount;
        }
        uint64_t currentBalance =  portfolioBalance.get()[_portfolioName];
        
        
        
        

        DipcAssert(currentBalance + lockToken >= currentBalance);
        DipcAssert(ownerTotalToken.get() - lockToken <= ownerTotalToken.get());

        
        (*portfolioBalance)[_portfolioName] = currentBalance + lockToken;
        *ownerTotalToken = ownerTotalToken.get() - lockToken;
        (*portfolioStorge)[_portfolioName] = &info.toJson()[0];
        DIPC_EMIT_EVENT(revocationPortfolio, "orderId", _orderId, "orderInfo", &ord.toJson()[0]);
    }
    
    EXPORT void PortfolioManage::withdrawPortfolio(char* _portfolioName, uint64_t _withdrawBalance){
         u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
if(!userCanWithdraw.get()){
             return;
         }
         uint64_t currentBalance =  portfolioBalance.get()[_portfolioName];
         DipcAssert(currentBalance - _withdrawBalance < currentBalance);
         auto coinBalance = changeUint64ToU256WithChangeRate(currentBalance, changeRate.get());
         (*portfolioBalance)[_portfolioName] = currentBalance - _withdrawBalance;
         callTransfer(caller(), coinBalance);
    }
    
    EXPORT void PortfolioManage::withdrawPool(uint64_t _balance){
        u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
isOwner();
        Address ownerAddr = Address(owner.get()); 
        callTransfer(ownerAddr, _balance);
        *ownerTotalToken = ownerTotalToken.get() - _balance * changeRate.get();
        *totalToken = totalToken.get() - _balance * changeRate.get();
        DIPC_EMIT_EVENT(tokenCount, "ownerTotalToken", ownerTotalToken.get(), "totalToken", totalToken.get());
    }
    
    PAYABLE void PortfolioManage::depositPool(uint64_t _depositValue){
        isOwner();
        
        uint64_t tokenBalance = changeU256ToUint64WithChangeRate(callValue(), changeRate.get()); 
        *ownerTotalToken = ownerTotalToken.get() + tokenBalance;
        *totalToken = totalToken.get() + tokenBalance;
        DIPC_EMIT_EVENT(tokenCount, "ownerTotalToken", ownerTotalToken.get(), "totalToken", totalToken.get());
    }
     
    CONSTANT uint64_t PortfolioManage::queryTotalToken(){
        u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
return totalToken.get();
    }

     
    CONSTANT uint64_t PortfolioManage::queryPortfolioBalance(char* _portfolioName){
        u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
return portfolioBalance.get()[_portfolioName];
    }

    
    CONSTANT bool PortfolioManage::queryPortfolioNameIfUsed(char* _portfolioName){
        u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
if(portfolioStorge.get()[_portfolioName] != ""){
            return true;
        } 
        return false;
    }

    
    CONSTANT uint64_t PortfolioManage::queryChangeRate(){
        u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
return changeRate.get();
    }

2019-12-19_15:14:55.619617: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:657] searchStr \s*PAYABLE\s*void\s*PortfolioManage::createOrder

2019-12-19_15:14:55.622647: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:656] searchStr \s*EXPORT\s*void\s*PortfolioManage::dealOrder code_text #include "PortfolioManage.hpp"

    
    PAYABLE void PortfolioManage::init(){
        *owner = caller().toString();
        *changeRate = 10000;
        *userCanWithdraw = false;
        uint64_t tokenBalance = getTotalBalance();
        
        *ownerTotalToken = tokenBalance;
        *totalToken = ownerTotalToken.get();
        
        
        DIPC_EMIT_EVENT(initEvent, "ownerTotalToken" ,tokenBalance);
    }
    
     
    EXPORT void PortfolioManage::setChangeRate(uint64_t _changeRate){
        u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
isOwner();
        *changeRate = _changeRate;
    }
     
    EXPORT void PortfolioManage::setUserCanWithdraw(bool _canWithdraw){
        u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
isOwner();
        *userCanWithdraw = _canWithdraw;
    }

    
    PAYABLE void PortfolioManage::createPortfolio(char* _portfolioName, char* _portfolioDesc){
        if(portfolioStorge.get()[_portfolioName] != ""){
            DIPC_EMIT_EVENT(ErrEvent, "Current portfolio exist: ", _portfolioName);
            return;
        } 
        std::string callerAddr = caller().toString();
        uint64_t tokenBalance = getTotalBalance();
        
        PortfolioInfo info(_portfolioName, _portfolioDesc, &callerAddr[0]);
        std::string portfolioStr = info.toJson();
        
        
        

        (*portfolioStorge)[_portfolioName] = portfolioStr;
        DipcAssert(totalToken.get() + tokenBalance > totalToken);
        (*portfolioBalance)[_portfolioName] = tokenBalance;
        *totalToken = totalToken.get() + tokenBalance; 
        
        DIPC_EMIT_EVENT(portfolioInfo, _portfolioName, &portfolioStr[0], "portfolioBalance", tokenBalance);
    }

    
    PAYABLE void PortfolioManage::depositPortfolio(char* _portfolioName){
        uint64_t tokenBalance = getTotalBalance();
        
        uint64_t currentBalance = portfolioBalance.get()[_portfolioName];
        uint64_t finalBalance  = currentBalance + tokenBalance;
        DipcAssert(totalToken.get() + tokenBalance > totalToken);
        DipcAssert(finalBalance > currentBalance);
        (*portfolioBalance)[_portfolioName] = finalBalance;
        *totalToken = totalToken.get() + finalBalance; 
        DIPC_EMIT_EVENT(depositPortfolio, "portfolioName", _portfolioName, "portfolioBalance", finalBalance);
    }
    
    PAYABLE void PortfolioManage::createOrder(char* _portfolioName, char* _orderId, uint16_t _orderType, char* _stockCode, uint64_t _stockPrice, uint64_t _stockAmount, uint64_t _endTime){
        uint64_t tokenBalance = getTotalBalance();
        DIPC_EMIT_EVENT(createOrder, "portfolioName", _portfolioName, "OrderInfo", "ignore", "tokenBalance", tokenBalance);
        uint64_t spent = 0;
        if(_orderType == 1){
            spent = _stockPrice * _stockAmount;
            DipcAssert((portfolioBalance.get()[_portfolioName] + tokenBalance) > spent);
        }
        struct Order order{_orderId, _orderType, _stockCode, _stockPrice, _stockAmount, _endTime, 0};
        std::string pInfo = portfolioStorge.get()[_portfolioName];
        
        
        
        if(pInfo == "") {
            DIPC_EMIT_EVENT(ErrEvent, "Current portfolio  doesn't exist: ", _portfolioName);
            return;
        }
        PortfolioInfo info;
        info.parseJson(pInfo);
        if(info.getOrder(_orderId).orderId != ""){
            DIPC_EMIT_EVENT(ErrEvent, "Current order exist: ", _orderId);
            return;
        }
        info.addOrder(order);
        pInfo = info.toJson();

        uint64_t currentBalance = portfolioBalance.get()[_portfolioName] ;
        uint64_t finalBalance = currentBalance + tokenBalance - spent;
        DipcAssert(totalToken.get() + tokenBalance > totalToken);
        
        DipcAssert(ownerTotalToken.get() < ownerTotalToken.get() + spent);
        (*portfolioStorge)[_portfolioName] = &pInfo[0];
        
        
        
        


        (*portfolioBalance)[_portfolioName] = finalBalance;
        *totalToken = totalToken.get() + finalBalance; 
        *ownerTotalToken = ownerTotalToken.get() + spent;
        DIPC_EMIT_EVENT(createOrder, "portfolioName", _portfolioName, "OrderInfo", &order.toJson()[0], "portfolioBalance", finalBalance);
    }

    
    EXPORT void PortfolioManage::dealOrder(char* _portfolioName, char* _orderId){
        u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
isOwner();
        std::string pInfo = portfolioStorge.get()[_portfolioName];
        
        
        PortfolioInfo info;
        info.parseJson(pInfo);
        

        
         Order ord = info.getOrder(_orderId);
         
         
        if(ord.orderId != "" && ord.orderStatus == 0){
            
            uint64_t timenow = dipc::timestamp();
            if(ord.endTime > timenow){
                ord.orderStatus = 1;
            }else {
                ord.orderStatus = 3;
            }
        } else {
          

            return;
        }
        

        uint64_t sellValue = 0;
        if(ord.orderType == 0){
            sellValue = ord.stockAmount * ord.stockPrice;
        }
        uint64_t currentBalance =  portfolioBalance.get()[_portfolioName];
        

        DipcAssert(currentBalance + sellValue >= currentBalance);
        DipcAssert((ownerTotalToken.get() - sellValue) <= ownerTotalToken.get());
        


        (*portfolioBalance)[_portfolioName] = currentBalance + sellValue;
        *ownerTotalToken = ownerTotalToken.get() - sellValue;
        (*portfolioStorge)[_portfolioName] = &info.toJson()[0];
        
        
        
        

        DIPC_EMIT_EVENT(dealPortfolio, "orderId", _orderId, "orderInfo", &ord.toJson()[0]);
    }
    
    EXPORT void PortfolioManage::revocationOrder(char* _portfolioName, char* _orderId){
        u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
std::string pInfo = portfolioStorge.get()[_portfolioName];
        
        
        PortfolioInfo info;
        info.parseJson(pInfo);
        Order ord = info.getOrder(_orderId);
        
        
        if(ord.orderId != "" && ord.orderStatus == 0){
            std::string callerStr = caller().toString();
            
            
            
            DipcAssert(info.getOwnerAddress() == caller().toString());
            

            uint64_t timenow = dipc::timestamp();
            if(ord.endTime > timenow){
                ord.orderStatus = 2;
            }else {
                ord.orderStatus = 3;
            }
        } else {
            return;
        }
        uint64_t lockToken = 0;
        if(ord.orderType == 1){
            lockToken = ord.stockPrice * ord.stockAmount;
        }
        uint64_t currentBalance =  portfolioBalance.get()[_portfolioName];
        
        
        
        

        DipcAssert(currentBalance + lockToken >= currentBalance);
        DipcAssert(ownerTotalToken.get() - lockToken <= ownerTotalToken.get());

        
        (*portfolioBalance)[_portfolioName] = currentBalance + lockToken;
        *ownerTotalToken = ownerTotalToken.get() - lockToken;
        (*portfolioStorge)[_portfolioName] = &info.toJson()[0];
        DIPC_EMIT_EVENT(revocationPortfolio, "orderId", _orderId, "orderInfo", &ord.toJson()[0]);
    }
    
    EXPORT void PortfolioManage::withdrawPortfolio(char* _portfolioName, uint64_t _withdrawBalance){
         u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
if(!userCanWithdraw.get()){
             return;
         }
         uint64_t currentBalance =  portfolioBalance.get()[_portfolioName];
         DipcAssert(currentBalance - _withdrawBalance < currentBalance);
         auto coinBalance = changeUint64ToU256WithChangeRate(currentBalance, changeRate.get());
         (*portfolioBalance)[_portfolioName] = currentBalance - _withdrawBalance;
         callTransfer(caller(), coinBalance);
    }
    
    EXPORT void PortfolioManage::withdrawPool(uint64_t _balance){
        u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
isOwner();
        Address ownerAddr = Address(owner.get()); 
        callTransfer(ownerAddr, _balance);
        *ownerTotalToken = ownerTotalToken.get() - _balance * changeRate.get();
        *totalToken = totalToken.get() - _balance * changeRate.get();
        DIPC_EMIT_EVENT(tokenCount, "ownerTotalToken", ownerTotalToken.get(), "totalToken", totalToken.get());
    }
    
    PAYABLE void PortfolioManage::depositPool(uint64_t _depositValue){
        isOwner();
        
        uint64_t tokenBalance = changeU256ToUint64WithChangeRate(callValue(), changeRate.get()); 
        *ownerTotalToken = ownerTotalToken.get() + tokenBalance;
        *totalToken = totalToken.get() + tokenBalance;
        DIPC_EMIT_EVENT(tokenCount, "ownerTotalToken", ownerTotalToken.get(), "totalToken", totalToken.get());
    }
     
    CONSTANT uint64_t PortfolioManage::queryTotalToken(){
        u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
return totalToken.get();
    }

     
    CONSTANT uint64_t PortfolioManage::queryPortfolioBalance(char* _portfolioName){
        u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
return portfolioBalance.get()[_portfolioName];
    }

    
    CONSTANT bool PortfolioManage::queryPortfolioNameIfUsed(char* _portfolioName){
        u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
if(portfolioStorge.get()[_portfolioName] != ""){
            return true;
        } 
        return false;
    }

    
    CONSTANT uint64_t PortfolioManage::queryChangeRate(){
        u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
return changeRate.get();
    }

2019-12-19_15:14:55.622666: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:657] searchStr \s*EXPORT\s*void\s*PortfolioManage::dealOrder

2019-12-19_15:14:55.626331: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:656] searchStr \s*EXPORT\s*void\s*PortfolioManage::revocationOrder code_text #include "PortfolioManage.hpp"

    
    PAYABLE void PortfolioManage::init(){
        *owner = caller().toString();
        *changeRate = 10000;
        *userCanWithdraw = false;
        uint64_t tokenBalance = getTotalBalance();
        
        *ownerTotalToken = tokenBalance;
        *totalToken = ownerTotalToken.get();
        
        
        DIPC_EMIT_EVENT(initEvent, "ownerTotalToken" ,tokenBalance);
    }
    
     
    EXPORT void PortfolioManage::setChangeRate(uint64_t _changeRate){
        u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
isOwner();
        *changeRate = _changeRate;
    }
     
    EXPORT void PortfolioManage::setUserCanWithdraw(bool _canWithdraw){
        u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
isOwner();
        *userCanWithdraw = _canWithdraw;
    }

    
    PAYABLE void PortfolioManage::createPortfolio(char* _portfolioName, char* _portfolioDesc){
        if(portfolioStorge.get()[_portfolioName] != ""){
            DIPC_EMIT_EVENT(ErrEvent, "Current portfolio exist: ", _portfolioName);
            return;
        } 
        std::string callerAddr = caller().toString();
        uint64_t tokenBalance = getTotalBalance();
        
        PortfolioInfo info(_portfolioName, _portfolioDesc, &callerAddr[0]);
        std::string portfolioStr = info.toJson();
        
        
        

        (*portfolioStorge)[_portfolioName] = portfolioStr;
        DipcAssert(totalToken.get() + tokenBalance > totalToken);
        (*portfolioBalance)[_portfolioName] = tokenBalance;
        *totalToken = totalToken.get() + tokenBalance; 
        
        DIPC_EMIT_EVENT(portfolioInfo, _portfolioName, &portfolioStr[0], "portfolioBalance", tokenBalance);
    }

    
    PAYABLE void PortfolioManage::depositPortfolio(char* _portfolioName){
        uint64_t tokenBalance = getTotalBalance();
        
        uint64_t currentBalance = portfolioBalance.get()[_portfolioName];
        uint64_t finalBalance  = currentBalance + tokenBalance;
        DipcAssert(totalToken.get() + tokenBalance > totalToken);
        DipcAssert(finalBalance > currentBalance);
        (*portfolioBalance)[_portfolioName] = finalBalance;
        *totalToken = totalToken.get() + finalBalance; 
        DIPC_EMIT_EVENT(depositPortfolio, "portfolioName", _portfolioName, "portfolioBalance", finalBalance);
    }
    
    PAYABLE void PortfolioManage::createOrder(char* _portfolioName, char* _orderId, uint16_t _orderType, char* _stockCode, uint64_t _stockPrice, uint64_t _stockAmount, uint64_t _endTime){
        uint64_t tokenBalance = getTotalBalance();
        DIPC_EMIT_EVENT(createOrder, "portfolioName", _portfolioName, "OrderInfo", "ignore", "tokenBalance", tokenBalance);
        uint64_t spent = 0;
        if(_orderType == 1){
            spent = _stockPrice * _stockAmount;
            DipcAssert((portfolioBalance.get()[_portfolioName] + tokenBalance) > spent);
        }
        struct Order order{_orderId, _orderType, _stockCode, _stockPrice, _stockAmount, _endTime, 0};
        std::string pInfo = portfolioStorge.get()[_portfolioName];
        
        
        
        if(pInfo == "") {
            DIPC_EMIT_EVENT(ErrEvent, "Current portfolio  doesn't exist: ", _portfolioName);
            return;
        }
        PortfolioInfo info;
        info.parseJson(pInfo);
        if(info.getOrder(_orderId).orderId != ""){
            DIPC_EMIT_EVENT(ErrEvent, "Current order exist: ", _orderId);
            return;
        }
        info.addOrder(order);
        pInfo = info.toJson();

        uint64_t currentBalance = portfolioBalance.get()[_portfolioName] ;
        uint64_t finalBalance = currentBalance + tokenBalance - spent;
        DipcAssert(totalToken.get() + tokenBalance > totalToken);
        
        DipcAssert(ownerTotalToken.get() < ownerTotalToken.get() + spent);
        (*portfolioStorge)[_portfolioName] = &pInfo[0];
        
        
        
        


        (*portfolioBalance)[_portfolioName] = finalBalance;
        *totalToken = totalToken.get() + finalBalance; 
        *ownerTotalToken = ownerTotalToken.get() + spent;
        DIPC_EMIT_EVENT(createOrder, "portfolioName", _portfolioName, "OrderInfo", &order.toJson()[0], "portfolioBalance", finalBalance);
    }

    
    EXPORT void PortfolioManage::dealOrder(char* _portfolioName, char* _orderId){
        u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
isOwner();
        std::string pInfo = portfolioStorge.get()[_portfolioName];
        
        
        PortfolioInfo info;
        info.parseJson(pInfo);
        

        
         Order ord = info.getOrder(_orderId);
         
         
        if(ord.orderId != "" && ord.orderStatus == 0){
            
            uint64_t timenow = dipc::timestamp();
            if(ord.endTime > timenow){
                ord.orderStatus = 1;
            }else {
                ord.orderStatus = 3;
            }
        } else {
          

            return;
        }
        

        uint64_t sellValue = 0;
        if(ord.orderType == 0){
            sellValue = ord.stockAmount * ord.stockPrice;
        }
        uint64_t currentBalance =  portfolioBalance.get()[_portfolioName];
        

        DipcAssert(currentBalance + sellValue >= currentBalance);
        DipcAssert((ownerTotalToken.get() - sellValue) <= ownerTotalToken.get());
        


        (*portfolioBalance)[_portfolioName] = currentBalance + sellValue;
        *ownerTotalToken = ownerTotalToken.get() - sellValue;
        (*portfolioStorge)[_portfolioName] = &info.toJson()[0];
        
        
        
        

        DIPC_EMIT_EVENT(dealPortfolio, "orderId", _orderId, "orderInfo", &ord.toJson()[0]);
    }
    
    EXPORT void PortfolioManage::revocationOrder(char* _portfolioName, char* _orderId){
        u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
std::string pInfo = portfolioStorge.get()[_portfolioName];
        
        
        PortfolioInfo info;
        info.parseJson(pInfo);
        Order ord = info.getOrder(_orderId);
        
        
        if(ord.orderId != "" && ord.orderStatus == 0){
            std::string callerStr = caller().toString();
            
            
            
            DipcAssert(info.getOwnerAddress() == caller().toString());
            

            uint64_t timenow = dipc::timestamp();
            if(ord.endTime > timenow){
                ord.orderStatus = 2;
            }else {
                ord.orderStatus = 3;
            }
        } else {
            return;
        }
        uint64_t lockToken = 0;
        if(ord.orderType == 1){
            lockToken = ord.stockPrice * ord.stockAmount;
        }
        uint64_t currentBalance =  portfolioBalance.get()[_portfolioName];
        
        
        
        

        DipcAssert(currentBalance + lockToken >= currentBalance);
        DipcAssert(ownerTotalToken.get() - lockToken <= ownerTotalToken.get());

        
        (*portfolioBalance)[_portfolioName] = currentBalance + lockToken;
        *ownerTotalToken = ownerTotalToken.get() - lockToken;
        (*portfolioStorge)[_portfolioName] = &info.toJson()[0];
        DIPC_EMIT_EVENT(revocationPortfolio, "orderId", _orderId, "orderInfo", &ord.toJson()[0]);
    }
    
    EXPORT void PortfolioManage::withdrawPortfolio(char* _portfolioName, uint64_t _withdrawBalance){
         u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
if(!userCanWithdraw.get()){
             return;
         }
         uint64_t currentBalance =  portfolioBalance.get()[_portfolioName];
         DipcAssert(currentBalance - _withdrawBalance < currentBalance);
         auto coinBalance = changeUint64ToU256WithChangeRate(currentBalance, changeRate.get());
         (*portfolioBalance)[_portfolioName] = currentBalance - _withdrawBalance;
         callTransfer(caller(), coinBalance);
    }
    
    EXPORT void PortfolioManage::withdrawPool(uint64_t _balance){
        u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
isOwner();
        Address ownerAddr = Address(owner.get()); 
        callTransfer(ownerAddr, _balance);
        *ownerTotalToken = ownerTotalToken.get() - _balance * changeRate.get();
        *totalToken = totalToken.get() - _balance * changeRate.get();
        DIPC_EMIT_EVENT(tokenCount, "ownerTotalToken", ownerTotalToken.get(), "totalToken", totalToken.get());
    }
    
    PAYABLE void PortfolioManage::depositPool(uint64_t _depositValue){
        isOwner();
        
        uint64_t tokenBalance = changeU256ToUint64WithChangeRate(callValue(), changeRate.get()); 
        *ownerTotalToken = ownerTotalToken.get() + tokenBalance;
        *totalToken = totalToken.get() + tokenBalance;
        DIPC_EMIT_EVENT(tokenCount, "ownerTotalToken", ownerTotalToken.get(), "totalToken", totalToken.get());
    }
     
    CONSTANT uint64_t PortfolioManage::queryTotalToken(){
        u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
return totalToken.get();
    }

     
    CONSTANT uint64_t PortfolioManage::queryPortfolioBalance(char* _portfolioName){
        u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
return portfolioBalance.get()[_portfolioName];
    }

    
    CONSTANT bool PortfolioManage::queryPortfolioNameIfUsed(char* _portfolioName){
        u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
if(portfolioStorge.get()[_portfolioName] != ""){
            return true;
        } 
        return false;
    }

    
    CONSTANT uint64_t PortfolioManage::queryChangeRate(){
        u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
return changeRate.get();
    }

2019-12-19_15:14:55.626384: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:657] searchStr \s*EXPORT\s*void\s*PortfolioManage::revocationOrder

2019-12-19_15:14:55.631664: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:656] searchStr \s*EXPORT\s*void\s*PortfolioManage::withdrawPortfolio code_text #include "PortfolioManage.hpp"

    
    PAYABLE void PortfolioManage::init(){
        *owner = caller().toString();
        *changeRate = 10000;
        *userCanWithdraw = false;
        uint64_t tokenBalance = getTotalBalance();
        
        *ownerTotalToken = tokenBalance;
        *totalToken = ownerTotalToken.get();
        
        
        DIPC_EMIT_EVENT(initEvent, "ownerTotalToken" ,tokenBalance);
    }
    
     
    EXPORT void PortfolioManage::setChangeRate(uint64_t _changeRate){
        u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
isOwner();
        *changeRate = _changeRate;
    }
     
    EXPORT void PortfolioManage::setUserCanWithdraw(bool _canWithdraw){
        u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
isOwner();
        *userCanWithdraw = _canWithdraw;
    }

    
    PAYABLE void PortfolioManage::createPortfolio(char* _portfolioName, char* _portfolioDesc){
        if(portfolioStorge.get()[_portfolioName] != ""){
            DIPC_EMIT_EVENT(ErrEvent, "Current portfolio exist: ", _portfolioName);
            return;
        } 
        std::string callerAddr = caller().toString();
        uint64_t tokenBalance = getTotalBalance();
        
        PortfolioInfo info(_portfolioName, _portfolioDesc, &callerAddr[0]);
        std::string portfolioStr = info.toJson();
        
        
        

        (*portfolioStorge)[_portfolioName] = portfolioStr;
        DipcAssert(totalToken.get() + tokenBalance > totalToken);
        (*portfolioBalance)[_portfolioName] = tokenBalance;
        *totalToken = totalToken.get() + tokenBalance; 
        
        DIPC_EMIT_EVENT(portfolioInfo, _portfolioName, &portfolioStr[0], "portfolioBalance", tokenBalance);
    }

    
    PAYABLE void PortfolioManage::depositPortfolio(char* _portfolioName){
        uint64_t tokenBalance = getTotalBalance();
        
        uint64_t currentBalance = portfolioBalance.get()[_portfolioName];
        uint64_t finalBalance  = currentBalance + tokenBalance;
        DipcAssert(totalToken.get() + tokenBalance > totalToken);
        DipcAssert(finalBalance > currentBalance);
        (*portfolioBalance)[_portfolioName] = finalBalance;
        *totalToken = totalToken.get() + finalBalance; 
        DIPC_EMIT_EVENT(depositPortfolio, "portfolioName", _portfolioName, "portfolioBalance", finalBalance);
    }
    
    PAYABLE void PortfolioManage::createOrder(char* _portfolioName, char* _orderId, uint16_t _orderType, char* _stockCode, uint64_t _stockPrice, uint64_t _stockAmount, uint64_t _endTime){
        uint64_t tokenBalance = getTotalBalance();
        DIPC_EMIT_EVENT(createOrder, "portfolioName", _portfolioName, "OrderInfo", "ignore", "tokenBalance", tokenBalance);
        uint64_t spent = 0;
        if(_orderType == 1){
            spent = _stockPrice * _stockAmount;
            DipcAssert((portfolioBalance.get()[_portfolioName] + tokenBalance) > spent);
        }
        struct Order order{_orderId, _orderType, _stockCode, _stockPrice, _stockAmount, _endTime, 0};
        std::string pInfo = portfolioStorge.get()[_portfolioName];
        
        
        
        if(pInfo == "") {
            DIPC_EMIT_EVENT(ErrEvent, "Current portfolio  doesn't exist: ", _portfolioName);
            return;
        }
        PortfolioInfo info;
        info.parseJson(pInfo);
        if(info.getOrder(_orderId).orderId != ""){
            DIPC_EMIT_EVENT(ErrEvent, "Current order exist: ", _orderId);
            return;
        }
        info.addOrder(order);
        pInfo = info.toJson();

        uint64_t currentBalance = portfolioBalance.get()[_portfolioName] ;
        uint64_t finalBalance = currentBalance + tokenBalance - spent;
        DipcAssert(totalToken.get() + tokenBalance > totalToken);
        
        DipcAssert(ownerTotalToken.get() < ownerTotalToken.get() + spent);
        (*portfolioStorge)[_portfolioName] = &pInfo[0];
        
        
        
        


        (*portfolioBalance)[_portfolioName] = finalBalance;
        *totalToken = totalToken.get() + finalBalance; 
        *ownerTotalToken = ownerTotalToken.get() + spent;
        DIPC_EMIT_EVENT(createOrder, "portfolioName", _portfolioName, "OrderInfo", &order.toJson()[0], "portfolioBalance", finalBalance);
    }

    
    EXPORT void PortfolioManage::dealOrder(char* _portfolioName, char* _orderId){
        u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
isOwner();
        std::string pInfo = portfolioStorge.get()[_portfolioName];
        
        
        PortfolioInfo info;
        info.parseJson(pInfo);
        

        
         Order ord = info.getOrder(_orderId);
         
         
        if(ord.orderId != "" && ord.orderStatus == 0){
            
            uint64_t timenow = dipc::timestamp();
            if(ord.endTime > timenow){
                ord.orderStatus = 1;
            }else {
                ord.orderStatus = 3;
            }
        } else {
          

            return;
        }
        

        uint64_t sellValue = 0;
        if(ord.orderType == 0){
            sellValue = ord.stockAmount * ord.stockPrice;
        }
        uint64_t currentBalance =  portfolioBalance.get()[_portfolioName];
        

        DipcAssert(currentBalance + sellValue >= currentBalance);
        DipcAssert((ownerTotalToken.get() - sellValue) <= ownerTotalToken.get());
        


        (*portfolioBalance)[_portfolioName] = currentBalance + sellValue;
        *ownerTotalToken = ownerTotalToken.get() - sellValue;
        (*portfolioStorge)[_portfolioName] = &info.toJson()[0];
        
        
        
        

        DIPC_EMIT_EVENT(dealPortfolio, "orderId", _orderId, "orderInfo", &ord.toJson()[0]);
    }
    
    EXPORT void PortfolioManage::revocationOrder(char* _portfolioName, char* _orderId){
        u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
std::string pInfo = portfolioStorge.get()[_portfolioName];
        
        
        PortfolioInfo info;
        info.parseJson(pInfo);
        Order ord = info.getOrder(_orderId);
        
        
        if(ord.orderId != "" && ord.orderStatus == 0){
            std::string callerStr = caller().toString();
            
            
            
            DipcAssert(info.getOwnerAddress() == caller().toString());
            

            uint64_t timenow = dipc::timestamp();
            if(ord.endTime > timenow){
                ord.orderStatus = 2;
            }else {
                ord.orderStatus = 3;
            }
        } else {
            return;
        }
        uint64_t lockToken = 0;
        if(ord.orderType == 1){
            lockToken = ord.stockPrice * ord.stockAmount;
        }
        uint64_t currentBalance =  portfolioBalance.get()[_portfolioName];
        
        
        
        

        DipcAssert(currentBalance + lockToken >= currentBalance);
        DipcAssert(ownerTotalToken.get() - lockToken <= ownerTotalToken.get());

        
        (*portfolioBalance)[_portfolioName] = currentBalance + lockToken;
        *ownerTotalToken = ownerTotalToken.get() - lockToken;
        (*portfolioStorge)[_portfolioName] = &info.toJson()[0];
        DIPC_EMIT_EVENT(revocationPortfolio, "orderId", _orderId, "orderInfo", &ord.toJson()[0]);
    }
    
    EXPORT void PortfolioManage::withdrawPortfolio(char* _portfolioName, uint64_t _withdrawBalance){
         u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
if(!userCanWithdraw.get()){
             return;
         }
         uint64_t currentBalance =  portfolioBalance.get()[_portfolioName];
         DipcAssert(currentBalance - _withdrawBalance < currentBalance);
         auto coinBalance = changeUint64ToU256WithChangeRate(currentBalance, changeRate.get());
         (*portfolioBalance)[_portfolioName] = currentBalance - _withdrawBalance;
         callTransfer(caller(), coinBalance);
    }
    
    EXPORT void PortfolioManage::withdrawPool(uint64_t _balance){
        u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
isOwner();
        Address ownerAddr = Address(owner.get()); 
        callTransfer(ownerAddr, _balance);
        *ownerTotalToken = ownerTotalToken.get() - _balance * changeRate.get();
        *totalToken = totalToken.get() - _balance * changeRate.get();
        DIPC_EMIT_EVENT(tokenCount, "ownerTotalToken", ownerTotalToken.get(), "totalToken", totalToken.get());
    }
    
    PAYABLE void PortfolioManage::depositPool(uint64_t _depositValue){
        isOwner();
        
        uint64_t tokenBalance = changeU256ToUint64WithChangeRate(callValue(), changeRate.get()); 
        *ownerTotalToken = ownerTotalToken.get() + tokenBalance;
        *totalToken = totalToken.get() + tokenBalance;
        DIPC_EMIT_EVENT(tokenCount, "ownerTotalToken", ownerTotalToken.get(), "totalToken", totalToken.get());
    }
     
    CONSTANT uint64_t PortfolioManage::queryTotalToken(){
        u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
return totalToken.get();
    }

     
    CONSTANT uint64_t PortfolioManage::queryPortfolioBalance(char* _portfolioName){
        u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
return portfolioBalance.get()[_portfolioName];
    }

    
    CONSTANT bool PortfolioManage::queryPortfolioNameIfUsed(char* _portfolioName){
        u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
if(portfolioStorge.get()[_portfolioName] != ""){
            return true;
        } 
        return false;
    }

    
    CONSTANT uint64_t PortfolioManage::queryChangeRate(){
        u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
return changeRate.get();
    }

2019-12-19_15:14:55.631682: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:657] searchStr \s*EXPORT\s*void\s*PortfolioManage::withdrawPortfolio

2019-12-19_15:14:55.639036: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:656] searchStr \s*EXPORT\s*void\s*PortfolioManage::withdrawPool code_text #include "PortfolioManage.hpp"

    
    PAYABLE void PortfolioManage::init(){
        *owner = caller().toString();
        *changeRate = 10000;
        *userCanWithdraw = false;
        uint64_t tokenBalance = getTotalBalance();
        
        *ownerTotalToken = tokenBalance;
        *totalToken = ownerTotalToken.get();
        
        
        DIPC_EMIT_EVENT(initEvent, "ownerTotalToken" ,tokenBalance);
    }
    
     
    EXPORT void PortfolioManage::setChangeRate(uint64_t _changeRate){
        u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
isOwner();
        *changeRate = _changeRate;
    }
     
    EXPORT void PortfolioManage::setUserCanWithdraw(bool _canWithdraw){
        u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
isOwner();
        *userCanWithdraw = _canWithdraw;
    }

    
    PAYABLE void PortfolioManage::createPortfolio(char* _portfolioName, char* _portfolioDesc){
        if(portfolioStorge.get()[_portfolioName] != ""){
            DIPC_EMIT_EVENT(ErrEvent, "Current portfolio exist: ", _portfolioName);
            return;
        } 
        std::string callerAddr = caller().toString();
        uint64_t tokenBalance = getTotalBalance();
        
        PortfolioInfo info(_portfolioName, _portfolioDesc, &callerAddr[0]);
        std::string portfolioStr = info.toJson();
        
        
        

        (*portfolioStorge)[_portfolioName] = portfolioStr;
        DipcAssert(totalToken.get() + tokenBalance > totalToken);
        (*portfolioBalance)[_portfolioName] = tokenBalance;
        *totalToken = totalToken.get() + tokenBalance; 
        
        DIPC_EMIT_EVENT(portfolioInfo, _portfolioName, &portfolioStr[0], "portfolioBalance", tokenBalance);
    }

    
    PAYABLE void PortfolioManage::depositPortfolio(char* _portfolioName){
        uint64_t tokenBalance = getTotalBalance();
        
        uint64_t currentBalance = portfolioBalance.get()[_portfolioName];
        uint64_t finalBalance  = currentBalance + tokenBalance;
        DipcAssert(totalToken.get() + tokenBalance > totalToken);
        DipcAssert(finalBalance > currentBalance);
        (*portfolioBalance)[_portfolioName] = finalBalance;
        *totalToken = totalToken.get() + finalBalance; 
        DIPC_EMIT_EVENT(depositPortfolio, "portfolioName", _portfolioName, "portfolioBalance", finalBalance);
    }
    
    PAYABLE void PortfolioManage::createOrder(char* _portfolioName, char* _orderId, uint16_t _orderType, char* _stockCode, uint64_t _stockPrice, uint64_t _stockAmount, uint64_t _endTime){
        uint64_t tokenBalance = getTotalBalance();
        DIPC_EMIT_EVENT(createOrder, "portfolioName", _portfolioName, "OrderInfo", "ignore", "tokenBalance", tokenBalance);
        uint64_t spent = 0;
        if(_orderType == 1){
            spent = _stockPrice * _stockAmount;
            DipcAssert((portfolioBalance.get()[_portfolioName] + tokenBalance) > spent);
        }
        struct Order order{_orderId, _orderType, _stockCode, _stockPrice, _stockAmount, _endTime, 0};
        std::string pInfo = portfolioStorge.get()[_portfolioName];
        
        
        
        if(pInfo == "") {
            DIPC_EMIT_EVENT(ErrEvent, "Current portfolio  doesn't exist: ", _portfolioName);
            return;
        }
        PortfolioInfo info;
        info.parseJson(pInfo);
        if(info.getOrder(_orderId).orderId != ""){
            DIPC_EMIT_EVENT(ErrEvent, "Current order exist: ", _orderId);
            return;
        }
        info.addOrder(order);
        pInfo = info.toJson();

        uint64_t currentBalance = portfolioBalance.get()[_portfolioName] ;
        uint64_t finalBalance = currentBalance + tokenBalance - spent;
        DipcAssert(totalToken.get() + tokenBalance > totalToken);
        
        DipcAssert(ownerTotalToken.get() < ownerTotalToken.get() + spent);
        (*portfolioStorge)[_portfolioName] = &pInfo[0];
        
        
        
        


        (*portfolioBalance)[_portfolioName] = finalBalance;
        *totalToken = totalToken.get() + finalBalance; 
        *ownerTotalToken = ownerTotalToken.get() + spent;
        DIPC_EMIT_EVENT(createOrder, "portfolioName", _portfolioName, "OrderInfo", &order.toJson()[0], "portfolioBalance", finalBalance);
    }

    
    EXPORT void PortfolioManage::dealOrder(char* _portfolioName, char* _orderId){
        u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
isOwner();
        std::string pInfo = portfolioStorge.get()[_portfolioName];
        
        
        PortfolioInfo info;
        info.parseJson(pInfo);
        

        
         Order ord = info.getOrder(_orderId);
         
         
        if(ord.orderId != "" && ord.orderStatus == 0){
            
            uint64_t timenow = dipc::timestamp();
            if(ord.endTime > timenow){
                ord.orderStatus = 1;
            }else {
                ord.orderStatus = 3;
            }
        } else {
          

            return;
        }
        

        uint64_t sellValue = 0;
        if(ord.orderType == 0){
            sellValue = ord.stockAmount * ord.stockPrice;
        }
        uint64_t currentBalance =  portfolioBalance.get()[_portfolioName];
        

        DipcAssert(currentBalance + sellValue >= currentBalance);
        DipcAssert((ownerTotalToken.get() - sellValue) <= ownerTotalToken.get());
        


        (*portfolioBalance)[_portfolioName] = currentBalance + sellValue;
        *ownerTotalToken = ownerTotalToken.get() - sellValue;
        (*portfolioStorge)[_portfolioName] = &info.toJson()[0];
        
        
        
        

        DIPC_EMIT_EVENT(dealPortfolio, "orderId", _orderId, "orderInfo", &ord.toJson()[0]);
    }
    
    EXPORT void PortfolioManage::revocationOrder(char* _portfolioName, char* _orderId){
        u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
std::string pInfo = portfolioStorge.get()[_portfolioName];
        
        
        PortfolioInfo info;
        info.parseJson(pInfo);
        Order ord = info.getOrder(_orderId);
        
        
        if(ord.orderId != "" && ord.orderStatus == 0){
            std::string callerStr = caller().toString();
            
            
            
            DipcAssert(info.getOwnerAddress() == caller().toString());
            

            uint64_t timenow = dipc::timestamp();
            if(ord.endTime > timenow){
                ord.orderStatus = 2;
            }else {
                ord.orderStatus = 3;
            }
        } else {
            return;
        }
        uint64_t lockToken = 0;
        if(ord.orderType == 1){
            lockToken = ord.stockPrice * ord.stockAmount;
        }
        uint64_t currentBalance =  portfolioBalance.get()[_portfolioName];
        
        
        
        

        DipcAssert(currentBalance + lockToken >= currentBalance);
        DipcAssert(ownerTotalToken.get() - lockToken <= ownerTotalToken.get());

        
        (*portfolioBalance)[_portfolioName] = currentBalance + lockToken;
        *ownerTotalToken = ownerTotalToken.get() - lockToken;
        (*portfolioStorge)[_portfolioName] = &info.toJson()[0];
        DIPC_EMIT_EVENT(revocationPortfolio, "orderId", _orderId, "orderInfo", &ord.toJson()[0]);
    }
    
    EXPORT void PortfolioManage::withdrawPortfolio(char* _portfolioName, uint64_t _withdrawBalance){
         u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
if(!userCanWithdraw.get()){
             return;
         }
         uint64_t currentBalance =  portfolioBalance.get()[_portfolioName];
         DipcAssert(currentBalance - _withdrawBalance < currentBalance);
         auto coinBalance = changeUint64ToU256WithChangeRate(currentBalance, changeRate.get());
         (*portfolioBalance)[_portfolioName] = currentBalance - _withdrawBalance;
         callTransfer(caller(), coinBalance);
    }
    
    EXPORT void PortfolioManage::withdrawPool(uint64_t _balance){
        u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
isOwner();
        Address ownerAddr = Address(owner.get()); 
        callTransfer(ownerAddr, _balance);
        *ownerTotalToken = ownerTotalToken.get() - _balance * changeRate.get();
        *totalToken = totalToken.get() - _balance * changeRate.get();
        DIPC_EMIT_EVENT(tokenCount, "ownerTotalToken", ownerTotalToken.get(), "totalToken", totalToken.get());
    }
    
    PAYABLE void PortfolioManage::depositPool(uint64_t _depositValue){
        isOwner();
        
        uint64_t tokenBalance = changeU256ToUint64WithChangeRate(callValue(), changeRate.get()); 
        *ownerTotalToken = ownerTotalToken.get() + tokenBalance;
        *totalToken = totalToken.get() + tokenBalance;
        DIPC_EMIT_EVENT(tokenCount, "ownerTotalToken", ownerTotalToken.get(), "totalToken", totalToken.get());
    }
     
    CONSTANT uint64_t PortfolioManage::queryTotalToken(){
        u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
return totalToken.get();
    }

     
    CONSTANT uint64_t PortfolioManage::queryPortfolioBalance(char* _portfolioName){
        u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
return portfolioBalance.get()[_portfolioName];
    }

    
    CONSTANT bool PortfolioManage::queryPortfolioNameIfUsed(char* _portfolioName){
        u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
if(portfolioStorge.get()[_portfolioName] != ""){
            return true;
        } 
        return false;
    }

    
    CONSTANT uint64_t PortfolioManage::queryChangeRate(){
        u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
return changeRate.get();
    }

2019-12-19_15:14:55.639057: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:657] searchStr \s*EXPORT\s*void\s*PortfolioManage::withdrawPool

2019-12-19_15:14:55.646513: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:656] searchStr \s*PAYABLE\s*void\s*PortfolioManage::depositPool code_text #include "PortfolioManage.hpp"

    
    PAYABLE void PortfolioManage::init(){
        *owner = caller().toString();
        *changeRate = 10000;
        *userCanWithdraw = false;
        uint64_t tokenBalance = getTotalBalance();
        
        *ownerTotalToken = tokenBalance;
        *totalToken = ownerTotalToken.get();
        
        
        DIPC_EMIT_EVENT(initEvent, "ownerTotalToken" ,tokenBalance);
    }
    
     
    EXPORT void PortfolioManage::setChangeRate(uint64_t _changeRate){
        u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
isOwner();
        *changeRate = _changeRate;
    }
     
    EXPORT void PortfolioManage::setUserCanWithdraw(bool _canWithdraw){
        u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
isOwner();
        *userCanWithdraw = _canWithdraw;
    }

    
    PAYABLE void PortfolioManage::createPortfolio(char* _portfolioName, char* _portfolioDesc){
        if(portfolioStorge.get()[_portfolioName] != ""){
            DIPC_EMIT_EVENT(ErrEvent, "Current portfolio exist: ", _portfolioName);
            return;
        } 
        std::string callerAddr = caller().toString();
        uint64_t tokenBalance = getTotalBalance();
        
        PortfolioInfo info(_portfolioName, _portfolioDesc, &callerAddr[0]);
        std::string portfolioStr = info.toJson();
        
        
        

        (*portfolioStorge)[_portfolioName] = portfolioStr;
        DipcAssert(totalToken.get() + tokenBalance > totalToken);
        (*portfolioBalance)[_portfolioName] = tokenBalance;
        *totalToken = totalToken.get() + tokenBalance; 
        
        DIPC_EMIT_EVENT(portfolioInfo, _portfolioName, &portfolioStr[0], "portfolioBalance", tokenBalance);
    }

    
    PAYABLE void PortfolioManage::depositPortfolio(char* _portfolioName){
        uint64_t tokenBalance = getTotalBalance();
        
        uint64_t currentBalance = portfolioBalance.get()[_portfolioName];
        uint64_t finalBalance  = currentBalance + tokenBalance;
        DipcAssert(totalToken.get() + tokenBalance > totalToken);
        DipcAssert(finalBalance > currentBalance);
        (*portfolioBalance)[_portfolioName] = finalBalance;
        *totalToken = totalToken.get() + finalBalance; 
        DIPC_EMIT_EVENT(depositPortfolio, "portfolioName", _portfolioName, "portfolioBalance", finalBalance);
    }
    
    PAYABLE void PortfolioManage::createOrder(char* _portfolioName, char* _orderId, uint16_t _orderType, char* _stockCode, uint64_t _stockPrice, uint64_t _stockAmount, uint64_t _endTime){
        uint64_t tokenBalance = getTotalBalance();
        DIPC_EMIT_EVENT(createOrder, "portfolioName", _portfolioName, "OrderInfo", "ignore", "tokenBalance", tokenBalance);
        uint64_t spent = 0;
        if(_orderType == 1){
            spent = _stockPrice * _stockAmount;
            DipcAssert((portfolioBalance.get()[_portfolioName] + tokenBalance) > spent);
        }
        struct Order order{_orderId, _orderType, _stockCode, _stockPrice, _stockAmount, _endTime, 0};
        std::string pInfo = portfolioStorge.get()[_portfolioName];
        
        
        
        if(pInfo == "") {
            DIPC_EMIT_EVENT(ErrEvent, "Current portfolio  doesn't exist: ", _portfolioName);
            return;
        }
        PortfolioInfo info;
        info.parseJson(pInfo);
        if(info.getOrder(_orderId).orderId != ""){
            DIPC_EMIT_EVENT(ErrEvent, "Current order exist: ", _orderId);
            return;
        }
        info.addOrder(order);
        pInfo = info.toJson();

        uint64_t currentBalance = portfolioBalance.get()[_portfolioName] ;
        uint64_t finalBalance = currentBalance + tokenBalance - spent;
        DipcAssert(totalToken.get() + tokenBalance > totalToken);
        
        DipcAssert(ownerTotalToken.get() < ownerTotalToken.get() + spent);
        (*portfolioStorge)[_portfolioName] = &pInfo[0];
        
        
        
        


        (*portfolioBalance)[_portfolioName] = finalBalance;
        *totalToken = totalToken.get() + finalBalance; 
        *ownerTotalToken = ownerTotalToken.get() + spent;
        DIPC_EMIT_EVENT(createOrder, "portfolioName", _portfolioName, "OrderInfo", &order.toJson()[0], "portfolioBalance", finalBalance);
    }

    
    EXPORT void PortfolioManage::dealOrder(char* _portfolioName, char* _orderId){
        u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
isOwner();
        std::string pInfo = portfolioStorge.get()[_portfolioName];
        
        
        PortfolioInfo info;
        info.parseJson(pInfo);
        

        
         Order ord = info.getOrder(_orderId);
         
         
        if(ord.orderId != "" && ord.orderStatus == 0){
            
            uint64_t timenow = dipc::timestamp();
            if(ord.endTime > timenow){
                ord.orderStatus = 1;
            }else {
                ord.orderStatus = 3;
            }
        } else {
          

            return;
        }
        

        uint64_t sellValue = 0;
        if(ord.orderType == 0){
            sellValue = ord.stockAmount * ord.stockPrice;
        }
        uint64_t currentBalance =  portfolioBalance.get()[_portfolioName];
        

        DipcAssert(currentBalance + sellValue >= currentBalance);
        DipcAssert((ownerTotalToken.get() - sellValue) <= ownerTotalToken.get());
        


        (*portfolioBalance)[_portfolioName] = currentBalance + sellValue;
        *ownerTotalToken = ownerTotalToken.get() - sellValue;
        (*portfolioStorge)[_portfolioName] = &info.toJson()[0];
        
        
        
        

        DIPC_EMIT_EVENT(dealPortfolio, "orderId", _orderId, "orderInfo", &ord.toJson()[0]);
    }
    
    EXPORT void PortfolioManage::revocationOrder(char* _portfolioName, char* _orderId){
        u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
std::string pInfo = portfolioStorge.get()[_portfolioName];
        
        
        PortfolioInfo info;
        info.parseJson(pInfo);
        Order ord = info.getOrder(_orderId);
        
        
        if(ord.orderId != "" && ord.orderStatus == 0){
            std::string callerStr = caller().toString();
            
            
            
            DipcAssert(info.getOwnerAddress() == caller().toString());
            

            uint64_t timenow = dipc::timestamp();
            if(ord.endTime > timenow){
                ord.orderStatus = 2;
            }else {
                ord.orderStatus = 3;
            }
        } else {
            return;
        }
        uint64_t lockToken = 0;
        if(ord.orderType == 1){
            lockToken = ord.stockPrice * ord.stockAmount;
        }
        uint64_t currentBalance =  portfolioBalance.get()[_portfolioName];
        
        
        
        

        DipcAssert(currentBalance + lockToken >= currentBalance);
        DipcAssert(ownerTotalToken.get() - lockToken <= ownerTotalToken.get());

        
        (*portfolioBalance)[_portfolioName] = currentBalance + lockToken;
        *ownerTotalToken = ownerTotalToken.get() - lockToken;
        (*portfolioStorge)[_portfolioName] = &info.toJson()[0];
        DIPC_EMIT_EVENT(revocationPortfolio, "orderId", _orderId, "orderInfo", &ord.toJson()[0]);
    }
    
    EXPORT void PortfolioManage::withdrawPortfolio(char* _portfolioName, uint64_t _withdrawBalance){
         u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
if(!userCanWithdraw.get()){
             return;
         }
         uint64_t currentBalance =  portfolioBalance.get()[_portfolioName];
         DipcAssert(currentBalance - _withdrawBalance < currentBalance);
         auto coinBalance = changeUint64ToU256WithChangeRate(currentBalance, changeRate.get());
         (*portfolioBalance)[_portfolioName] = currentBalance - _withdrawBalance;
         callTransfer(caller(), coinBalance);
    }
    
    EXPORT void PortfolioManage::withdrawPool(uint64_t _balance){
        u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
isOwner();
        Address ownerAddr = Address(owner.get()); 
        callTransfer(ownerAddr, _balance);
        *ownerTotalToken = ownerTotalToken.get() - _balance * changeRate.get();
        *totalToken = totalToken.get() - _balance * changeRate.get();
        DIPC_EMIT_EVENT(tokenCount, "ownerTotalToken", ownerTotalToken.get(), "totalToken", totalToken.get());
    }
    
    PAYABLE void PortfolioManage::depositPool(uint64_t _depositValue){
        isOwner();
        
        uint64_t tokenBalance = changeU256ToUint64WithChangeRate(callValue(), changeRate.get()); 
        *ownerTotalToken = ownerTotalToken.get() + tokenBalance;
        *totalToken = totalToken.get() + tokenBalance;
        DIPC_EMIT_EVENT(tokenCount, "ownerTotalToken", ownerTotalToken.get(), "totalToken", totalToken.get());
    }
     
    CONSTANT uint64_t PortfolioManage::queryTotalToken(){
        u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
return totalToken.get();
    }

     
    CONSTANT uint64_t PortfolioManage::queryPortfolioBalance(char* _portfolioName){
        u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
return portfolioBalance.get()[_portfolioName];
    }

    
    CONSTANT bool PortfolioManage::queryPortfolioNameIfUsed(char* _portfolioName){
        u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
if(portfolioStorge.get()[_portfolioName] != ""){
            return true;
        } 
        return false;
    }

    
    CONSTANT uint64_t PortfolioManage::queryChangeRate(){
        u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
return changeRate.get();
    }

2019-12-19_15:14:55.646533: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:657] searchStr \s*PAYABLE\s*void\s*PortfolioManage::depositPool

2019-12-19_15:14:55.654301: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:656] searchStr \s*CONSTANT\s*uint64_t\s*PortfolioManage::queryTotalToken code_text #include "PortfolioManage.hpp"

    
    PAYABLE void PortfolioManage::init(){
        *owner = caller().toString();
        *changeRate = 10000;
        *userCanWithdraw = false;
        uint64_t tokenBalance = getTotalBalance();
        
        *ownerTotalToken = tokenBalance;
        *totalToken = ownerTotalToken.get();
        
        
        DIPC_EMIT_EVENT(initEvent, "ownerTotalToken" ,tokenBalance);
    }
    
     
    EXPORT void PortfolioManage::setChangeRate(uint64_t _changeRate){
        u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
isOwner();
        *changeRate = _changeRate;
    }
     
    EXPORT void PortfolioManage::setUserCanWithdraw(bool _canWithdraw){
        u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
isOwner();
        *userCanWithdraw = _canWithdraw;
    }

    
    PAYABLE void PortfolioManage::createPortfolio(char* _portfolioName, char* _portfolioDesc){
        if(portfolioStorge.get()[_portfolioName] != ""){
            DIPC_EMIT_EVENT(ErrEvent, "Current portfolio exist: ", _portfolioName);
            return;
        } 
        std::string callerAddr = caller().toString();
        uint64_t tokenBalance = getTotalBalance();
        
        PortfolioInfo info(_portfolioName, _portfolioDesc, &callerAddr[0]);
        std::string portfolioStr = info.toJson();
        
        
        

        (*portfolioStorge)[_portfolioName] = portfolioStr;
        DipcAssert(totalToken.get() + tokenBalance > totalToken);
        (*portfolioBalance)[_portfolioName] = tokenBalance;
        *totalToken = totalToken.get() + tokenBalance; 
        
        DIPC_EMIT_EVENT(portfolioInfo, _portfolioName, &portfolioStr[0], "portfolioBalance", tokenBalance);
    }

    
    PAYABLE void PortfolioManage::depositPortfolio(char* _portfolioName){
        uint64_t tokenBalance = getTotalBalance();
        
        uint64_t currentBalance = portfolioBalance.get()[_portfolioName];
        uint64_t finalBalance  = currentBalance + tokenBalance;
        DipcAssert(totalToken.get() + tokenBalance > totalToken);
        DipcAssert(finalBalance > currentBalance);
        (*portfolioBalance)[_portfolioName] = finalBalance;
        *totalToken = totalToken.get() + finalBalance; 
        DIPC_EMIT_EVENT(depositPortfolio, "portfolioName", _portfolioName, "portfolioBalance", finalBalance);
    }
    
    PAYABLE void PortfolioManage::createOrder(char* _portfolioName, char* _orderId, uint16_t _orderType, char* _stockCode, uint64_t _stockPrice, uint64_t _stockAmount, uint64_t _endTime){
        uint64_t tokenBalance = getTotalBalance();
        DIPC_EMIT_EVENT(createOrder, "portfolioName", _portfolioName, "OrderInfo", "ignore", "tokenBalance", tokenBalance);
        uint64_t spent = 0;
        if(_orderType == 1){
            spent = _stockPrice * _stockAmount;
            DipcAssert((portfolioBalance.get()[_portfolioName] + tokenBalance) > spent);
        }
        struct Order order{_orderId, _orderType, _stockCode, _stockPrice, _stockAmount, _endTime, 0};
        std::string pInfo = portfolioStorge.get()[_portfolioName];
        
        
        
        if(pInfo == "") {
            DIPC_EMIT_EVENT(ErrEvent, "Current portfolio  doesn't exist: ", _portfolioName);
            return;
        }
        PortfolioInfo info;
        info.parseJson(pInfo);
        if(info.getOrder(_orderId).orderId != ""){
            DIPC_EMIT_EVENT(ErrEvent, "Current order exist: ", _orderId);
            return;
        }
        info.addOrder(order);
        pInfo = info.toJson();

        uint64_t currentBalance = portfolioBalance.get()[_portfolioName] ;
        uint64_t finalBalance = currentBalance + tokenBalance - spent;
        DipcAssert(totalToken.get() + tokenBalance > totalToken);
        
        DipcAssert(ownerTotalToken.get() < ownerTotalToken.get() + spent);
        (*portfolioStorge)[_portfolioName] = &pInfo[0];
        
        
        
        


        (*portfolioBalance)[_portfolioName] = finalBalance;
        *totalToken = totalToken.get() + finalBalance; 
        *ownerTotalToken = ownerTotalToken.get() + spent;
        DIPC_EMIT_EVENT(createOrder, "portfolioName", _portfolioName, "OrderInfo", &order.toJson()[0], "portfolioBalance", finalBalance);
    }

    
    EXPORT void PortfolioManage::dealOrder(char* _portfolioName, char* _orderId){
        u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
isOwner();
        std::string pInfo = portfolioStorge.get()[_portfolioName];
        
        
        PortfolioInfo info;
        info.parseJson(pInfo);
        

        
         Order ord = info.getOrder(_orderId);
         
         
        if(ord.orderId != "" && ord.orderStatus == 0){
            
            uint64_t timenow = dipc::timestamp();
            if(ord.endTime > timenow){
                ord.orderStatus = 1;
            }else {
                ord.orderStatus = 3;
            }
        } else {
          

            return;
        }
        

        uint64_t sellValue = 0;
        if(ord.orderType == 0){
            sellValue = ord.stockAmount * ord.stockPrice;
        }
        uint64_t currentBalance =  portfolioBalance.get()[_portfolioName];
        

        DipcAssert(currentBalance + sellValue >= currentBalance);
        DipcAssert((ownerTotalToken.get() - sellValue) <= ownerTotalToken.get());
        


        (*portfolioBalance)[_portfolioName] = currentBalance + sellValue;
        *ownerTotalToken = ownerTotalToken.get() - sellValue;
        (*portfolioStorge)[_portfolioName] = &info.toJson()[0];
        
        
        
        

        DIPC_EMIT_EVENT(dealPortfolio, "orderId", _orderId, "orderInfo", &ord.toJson()[0]);
    }
    
    EXPORT void PortfolioManage::revocationOrder(char* _portfolioName, char* _orderId){
        u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
std::string pInfo = portfolioStorge.get()[_portfolioName];
        
        
        PortfolioInfo info;
        info.parseJson(pInfo);
        Order ord = info.getOrder(_orderId);
        
        
        if(ord.orderId != "" && ord.orderStatus == 0){
            std::string callerStr = caller().toString();
            
            
            
            DipcAssert(info.getOwnerAddress() == caller().toString());
            

            uint64_t timenow = dipc::timestamp();
            if(ord.endTime > timenow){
                ord.orderStatus = 2;
            }else {
                ord.orderStatus = 3;
            }
        } else {
            return;
        }
        uint64_t lockToken = 0;
        if(ord.orderType == 1){
            lockToken = ord.stockPrice * ord.stockAmount;
        }
        uint64_t currentBalance =  portfolioBalance.get()[_portfolioName];
        
        
        
        

        DipcAssert(currentBalance + lockToken >= currentBalance);
        DipcAssert(ownerTotalToken.get() - lockToken <= ownerTotalToken.get());

        
        (*portfolioBalance)[_portfolioName] = currentBalance + lockToken;
        *ownerTotalToken = ownerTotalToken.get() - lockToken;
        (*portfolioStorge)[_portfolioName] = &info.toJson()[0];
        DIPC_EMIT_EVENT(revocationPortfolio, "orderId", _orderId, "orderInfo", &ord.toJson()[0]);
    }
    
    EXPORT void PortfolioManage::withdrawPortfolio(char* _portfolioName, uint64_t _withdrawBalance){
         u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
if(!userCanWithdraw.get()){
             return;
         }
         uint64_t currentBalance =  portfolioBalance.get()[_portfolioName];
         DipcAssert(currentBalance - _withdrawBalance < currentBalance);
         auto coinBalance = changeUint64ToU256WithChangeRate(currentBalance, changeRate.get());
         (*portfolioBalance)[_portfolioName] = currentBalance - _withdrawBalance;
         callTransfer(caller(), coinBalance);
    }
    
    EXPORT void PortfolioManage::withdrawPool(uint64_t _balance){
        u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
isOwner();
        Address ownerAddr = Address(owner.get()); 
        callTransfer(ownerAddr, _balance);
        *ownerTotalToken = ownerTotalToken.get() - _balance * changeRate.get();
        *totalToken = totalToken.get() - _balance * changeRate.get();
        DIPC_EMIT_EVENT(tokenCount, "ownerTotalToken", ownerTotalToken.get(), "totalToken", totalToken.get());
    }
    
    PAYABLE void PortfolioManage::depositPool(uint64_t _depositValue){
        isOwner();
        
        uint64_t tokenBalance = changeU256ToUint64WithChangeRate(callValue(), changeRate.get()); 
        *ownerTotalToken = ownerTotalToken.get() + tokenBalance;
        *totalToken = totalToken.get() + tokenBalance;
        DIPC_EMIT_EVENT(tokenCount, "ownerTotalToken", ownerTotalToken.get(), "totalToken", totalToken.get());
    }
     
    CONSTANT uint64_t PortfolioManage::queryTotalToken(){
        u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
return totalToken.get();
    }

     
    CONSTANT uint64_t PortfolioManage::queryPortfolioBalance(char* _portfolioName){
        u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
return portfolioBalance.get()[_portfolioName];
    }

    
    CONSTANT bool PortfolioManage::queryPortfolioNameIfUsed(char* _portfolioName){
        u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
if(portfolioStorge.get()[_portfolioName] != ""){
            return true;
        } 
        return false;
    }

    
    CONSTANT uint64_t PortfolioManage::queryChangeRate(){
        u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
return changeRate.get();
    }

2019-12-19_15:14:55.654321: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:657] searchStr \s*CONSTANT\s*uint64_t\s*PortfolioManage::queryTotalToken

2019-12-19_15:14:55.662156: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:656] searchStr \s*CONSTANT\s*uint64_t\s*PortfolioManage::queryPortfolioBalance code_text #include "PortfolioManage.hpp"

    
    PAYABLE void PortfolioManage::init(){
        *owner = caller().toString();
        *changeRate = 10000;
        *userCanWithdraw = false;
        uint64_t tokenBalance = getTotalBalance();
        
        *ownerTotalToken = tokenBalance;
        *totalToken = ownerTotalToken.get();
        
        
        DIPC_EMIT_EVENT(initEvent, "ownerTotalToken" ,tokenBalance);
    }
    
     
    EXPORT void PortfolioManage::setChangeRate(uint64_t _changeRate){
        u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
isOwner();
        *changeRate = _changeRate;
    }
     
    EXPORT void PortfolioManage::setUserCanWithdraw(bool _canWithdraw){
        u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
isOwner();
        *userCanWithdraw = _canWithdraw;
    }

    
    PAYABLE void PortfolioManage::createPortfolio(char* _portfolioName, char* _portfolioDesc){
        if(portfolioStorge.get()[_portfolioName] != ""){
            DIPC_EMIT_EVENT(ErrEvent, "Current portfolio exist: ", _portfolioName);
            return;
        } 
        std::string callerAddr = caller().toString();
        uint64_t tokenBalance = getTotalBalance();
        
        PortfolioInfo info(_portfolioName, _portfolioDesc, &callerAddr[0]);
        std::string portfolioStr = info.toJson();
        
        
        

        (*portfolioStorge)[_portfolioName] = portfolioStr;
        DipcAssert(totalToken.get() + tokenBalance > totalToken);
        (*portfolioBalance)[_portfolioName] = tokenBalance;
        *totalToken = totalToken.get() + tokenBalance; 
        
        DIPC_EMIT_EVENT(portfolioInfo, _portfolioName, &portfolioStr[0], "portfolioBalance", tokenBalance);
    }

    
    PAYABLE void PortfolioManage::depositPortfolio(char* _portfolioName){
        uint64_t tokenBalance = getTotalBalance();
        
        uint64_t currentBalance = portfolioBalance.get()[_portfolioName];
        uint64_t finalBalance  = currentBalance + tokenBalance;
        DipcAssert(totalToken.get() + tokenBalance > totalToken);
        DipcAssert(finalBalance > currentBalance);
        (*portfolioBalance)[_portfolioName] = finalBalance;
        *totalToken = totalToken.get() + finalBalance; 
        DIPC_EMIT_EVENT(depositPortfolio, "portfolioName", _portfolioName, "portfolioBalance", finalBalance);
    }
    
    PAYABLE void PortfolioManage::createOrder(char* _portfolioName, char* _orderId, uint16_t _orderType, char* _stockCode, uint64_t _stockPrice, uint64_t _stockAmount, uint64_t _endTime){
        uint64_t tokenBalance = getTotalBalance();
        DIPC_EMIT_EVENT(createOrder, "portfolioName", _portfolioName, "OrderInfo", "ignore", "tokenBalance", tokenBalance);
        uint64_t spent = 0;
        if(_orderType == 1){
            spent = _stockPrice * _stockAmount;
            DipcAssert((portfolioBalance.get()[_portfolioName] + tokenBalance) > spent);
        }
        struct Order order{_orderId, _orderType, _stockCode, _stockPrice, _stockAmount, _endTime, 0};
        std::string pInfo = portfolioStorge.get()[_portfolioName];
        
        
        
        if(pInfo == "") {
            DIPC_EMIT_EVENT(ErrEvent, "Current portfolio  doesn't exist: ", _portfolioName);
            return;
        }
        PortfolioInfo info;
        info.parseJson(pInfo);
        if(info.getOrder(_orderId).orderId != ""){
            DIPC_EMIT_EVENT(ErrEvent, "Current order exist: ", _orderId);
            return;
        }
        info.addOrder(order);
        pInfo = info.toJson();

        uint64_t currentBalance = portfolioBalance.get()[_portfolioName] ;
        uint64_t finalBalance = currentBalance + tokenBalance - spent;
        DipcAssert(totalToken.get() + tokenBalance > totalToken);
        
        DipcAssert(ownerTotalToken.get() < ownerTotalToken.get() + spent);
        (*portfolioStorge)[_portfolioName] = &pInfo[0];
        
        
        
        


        (*portfolioBalance)[_portfolioName] = finalBalance;
        *totalToken = totalToken.get() + finalBalance; 
        *ownerTotalToken = ownerTotalToken.get() + spent;
        DIPC_EMIT_EVENT(createOrder, "portfolioName", _portfolioName, "OrderInfo", &order.toJson()[0], "portfolioBalance", finalBalance);
    }

    
    EXPORT void PortfolioManage::dealOrder(char* _portfolioName, char* _orderId){
        u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
isOwner();
        std::string pInfo = portfolioStorge.get()[_portfolioName];
        
        
        PortfolioInfo info;
        info.parseJson(pInfo);
        

        
         Order ord = info.getOrder(_orderId);
         
         
        if(ord.orderId != "" && ord.orderStatus == 0){
            
            uint64_t timenow = dipc::timestamp();
            if(ord.endTime > timenow){
                ord.orderStatus = 1;
            }else {
                ord.orderStatus = 3;
            }
        } else {
          

            return;
        }
        

        uint64_t sellValue = 0;
        if(ord.orderType == 0){
            sellValue = ord.stockAmount * ord.stockPrice;
        }
        uint64_t currentBalance =  portfolioBalance.get()[_portfolioName];
        

        DipcAssert(currentBalance + sellValue >= currentBalance);
        DipcAssert((ownerTotalToken.get() - sellValue) <= ownerTotalToken.get());
        


        (*portfolioBalance)[_portfolioName] = currentBalance + sellValue;
        *ownerTotalToken = ownerTotalToken.get() - sellValue;
        (*portfolioStorge)[_portfolioName] = &info.toJson()[0];
        
        
        
        

        DIPC_EMIT_EVENT(dealPortfolio, "orderId", _orderId, "orderInfo", &ord.toJson()[0]);
    }
    
    EXPORT void PortfolioManage::revocationOrder(char* _portfolioName, char* _orderId){
        u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
std::string pInfo = portfolioStorge.get()[_portfolioName];
        
        
        PortfolioInfo info;
        info.parseJson(pInfo);
        Order ord = info.getOrder(_orderId);
        
        
        if(ord.orderId != "" && ord.orderStatus == 0){
            std::string callerStr = caller().toString();
            
            
            
            DipcAssert(info.getOwnerAddress() == caller().toString());
            

            uint64_t timenow = dipc::timestamp();
            if(ord.endTime > timenow){
                ord.orderStatus = 2;
            }else {
                ord.orderStatus = 3;
            }
        } else {
            return;
        }
        uint64_t lockToken = 0;
        if(ord.orderType == 1){
            lockToken = ord.stockPrice * ord.stockAmount;
        }
        uint64_t currentBalance =  portfolioBalance.get()[_portfolioName];
        
        
        
        

        DipcAssert(currentBalance + lockToken >= currentBalance);
        DipcAssert(ownerTotalToken.get() - lockToken <= ownerTotalToken.get());

        
        (*portfolioBalance)[_portfolioName] = currentBalance + lockToken;
        *ownerTotalToken = ownerTotalToken.get() - lockToken;
        (*portfolioStorge)[_portfolioName] = &info.toJson()[0];
        DIPC_EMIT_EVENT(revocationPortfolio, "orderId", _orderId, "orderInfo", &ord.toJson()[0]);
    }
    
    EXPORT void PortfolioManage::withdrawPortfolio(char* _portfolioName, uint64_t _withdrawBalance){
         u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
if(!userCanWithdraw.get()){
             return;
         }
         uint64_t currentBalance =  portfolioBalance.get()[_portfolioName];
         DipcAssert(currentBalance - _withdrawBalance < currentBalance);
         auto coinBalance = changeUint64ToU256WithChangeRate(currentBalance, changeRate.get());
         (*portfolioBalance)[_portfolioName] = currentBalance - _withdrawBalance;
         callTransfer(caller(), coinBalance);
    }
    
    EXPORT void PortfolioManage::withdrawPool(uint64_t _balance){
        u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
isOwner();
        Address ownerAddr = Address(owner.get()); 
        callTransfer(ownerAddr, _balance);
        *ownerTotalToken = ownerTotalToken.get() - _balance * changeRate.get();
        *totalToken = totalToken.get() - _balance * changeRate.get();
        DIPC_EMIT_EVENT(tokenCount, "ownerTotalToken", ownerTotalToken.get(), "totalToken", totalToken.get());
    }
    
    PAYABLE void PortfolioManage::depositPool(uint64_t _depositValue){
        isOwner();
        
        uint64_t tokenBalance = changeU256ToUint64WithChangeRate(callValue(), changeRate.get()); 
        *ownerTotalToken = ownerTotalToken.get() + tokenBalance;
        *totalToken = totalToken.get() + tokenBalance;
        DIPC_EMIT_EVENT(tokenCount, "ownerTotalToken", ownerTotalToken.get(), "totalToken", totalToken.get());
    }
     
    CONSTANT uint64_t PortfolioManage::queryTotalToken(){
        u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
return totalToken.get();
    }

     
    CONSTANT uint64_t PortfolioManage::queryPortfolioBalance(char* _portfolioName){
        u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
return portfolioBalance.get()[_portfolioName];
    }

    
    CONSTANT bool PortfolioManage::queryPortfolioNameIfUsed(char* _portfolioName){
        u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
if(portfolioStorge.get()[_portfolioName] != ""){
            return true;
        } 
        return false;
    }

    
    CONSTANT uint64_t PortfolioManage::queryChangeRate(){
        u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
return changeRate.get();
    }

2019-12-19_15:14:55.662171: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:657] searchStr \s*CONSTANT\s*uint64_t\s*PortfolioManage::queryPortfolioBalance

2019-12-19_15:14:55.670950: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:656] searchStr \s*CONSTANT\s*bool\s*PortfolioManage::queryPortfolioNameIfUsed code_text #include "PortfolioManage.hpp"

    
    PAYABLE void PortfolioManage::init(){
        *owner = caller().toString();
        *changeRate = 10000;
        *userCanWithdraw = false;
        uint64_t tokenBalance = getTotalBalance();
        
        *ownerTotalToken = tokenBalance;
        *totalToken = ownerTotalToken.get();
        
        
        DIPC_EMIT_EVENT(initEvent, "ownerTotalToken" ,tokenBalance);
    }
    
     
    EXPORT void PortfolioManage::setChangeRate(uint64_t _changeRate){
        u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
isOwner();
        *changeRate = _changeRate;
    }
     
    EXPORT void PortfolioManage::setUserCanWithdraw(bool _canWithdraw){
        u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
isOwner();
        *userCanWithdraw = _canWithdraw;
    }

    
    PAYABLE void PortfolioManage::createPortfolio(char* _portfolioName, char* _portfolioDesc){
        if(portfolioStorge.get()[_portfolioName] != ""){
            DIPC_EMIT_EVENT(ErrEvent, "Current portfolio exist: ", _portfolioName);
            return;
        } 
        std::string callerAddr = caller().toString();
        uint64_t tokenBalance = getTotalBalance();
        
        PortfolioInfo info(_portfolioName, _portfolioDesc, &callerAddr[0]);
        std::string portfolioStr = info.toJson();
        
        
        

        (*portfolioStorge)[_portfolioName] = portfolioStr;
        DipcAssert(totalToken.get() + tokenBalance > totalToken);
        (*portfolioBalance)[_portfolioName] = tokenBalance;
        *totalToken = totalToken.get() + tokenBalance; 
        
        DIPC_EMIT_EVENT(portfolioInfo, _portfolioName, &portfolioStr[0], "portfolioBalance", tokenBalance);
    }

    
    PAYABLE void PortfolioManage::depositPortfolio(char* _portfolioName){
        uint64_t tokenBalance = getTotalBalance();
        
        uint64_t currentBalance = portfolioBalance.get()[_portfolioName];
        uint64_t finalBalance  = currentBalance + tokenBalance;
        DipcAssert(totalToken.get() + tokenBalance > totalToken);
        DipcAssert(finalBalance > currentBalance);
        (*portfolioBalance)[_portfolioName] = finalBalance;
        *totalToken = totalToken.get() + finalBalance; 
        DIPC_EMIT_EVENT(depositPortfolio, "portfolioName", _portfolioName, "portfolioBalance", finalBalance);
    }
    
    PAYABLE void PortfolioManage::createOrder(char* _portfolioName, char* _orderId, uint16_t _orderType, char* _stockCode, uint64_t _stockPrice, uint64_t _stockAmount, uint64_t _endTime){
        uint64_t tokenBalance = getTotalBalance();
        DIPC_EMIT_EVENT(createOrder, "portfolioName", _portfolioName, "OrderInfo", "ignore", "tokenBalance", tokenBalance);
        uint64_t spent = 0;
        if(_orderType == 1){
            spent = _stockPrice * _stockAmount;
            DipcAssert((portfolioBalance.get()[_portfolioName] + tokenBalance) > spent);
        }
        struct Order order{_orderId, _orderType, _stockCode, _stockPrice, _stockAmount, _endTime, 0};
        std::string pInfo = portfolioStorge.get()[_portfolioName];
        
        
        
        if(pInfo == "") {
            DIPC_EMIT_EVENT(ErrEvent, "Current portfolio  doesn't exist: ", _portfolioName);
            return;
        }
        PortfolioInfo info;
        info.parseJson(pInfo);
        if(info.getOrder(_orderId).orderId != ""){
            DIPC_EMIT_EVENT(ErrEvent, "Current order exist: ", _orderId);
            return;
        }
        info.addOrder(order);
        pInfo = info.toJson();

        uint64_t currentBalance = portfolioBalance.get()[_portfolioName] ;
        uint64_t finalBalance = currentBalance + tokenBalance - spent;
        DipcAssert(totalToken.get() + tokenBalance > totalToken);
        
        DipcAssert(ownerTotalToken.get() < ownerTotalToken.get() + spent);
        (*portfolioStorge)[_portfolioName] = &pInfo[0];
        
        
        
        


        (*portfolioBalance)[_portfolioName] = finalBalance;
        *totalToken = totalToken.get() + finalBalance; 
        *ownerTotalToken = ownerTotalToken.get() + spent;
        DIPC_EMIT_EVENT(createOrder, "portfolioName", _portfolioName, "OrderInfo", &order.toJson()[0], "portfolioBalance", finalBalance);
    }

    
    EXPORT void PortfolioManage::dealOrder(char* _portfolioName, char* _orderId){
        u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
isOwner();
        std::string pInfo = portfolioStorge.get()[_portfolioName];
        
        
        PortfolioInfo info;
        info.parseJson(pInfo);
        

        
         Order ord = info.getOrder(_orderId);
         
         
        if(ord.orderId != "" && ord.orderStatus == 0){
            
            uint64_t timenow = dipc::timestamp();
            if(ord.endTime > timenow){
                ord.orderStatus = 1;
            }else {
                ord.orderStatus = 3;
            }
        } else {
          

            return;
        }
        

        uint64_t sellValue = 0;
        if(ord.orderType == 0){
            sellValue = ord.stockAmount * ord.stockPrice;
        }
        uint64_t currentBalance =  portfolioBalance.get()[_portfolioName];
        

        DipcAssert(currentBalance + sellValue >= currentBalance);
        DipcAssert((ownerTotalToken.get() - sellValue) <= ownerTotalToken.get());
        


        (*portfolioBalance)[_portfolioName] = currentBalance + sellValue;
        *ownerTotalToken = ownerTotalToken.get() - sellValue;
        (*portfolioStorge)[_portfolioName] = &info.toJson()[0];
        
        
        
        

        DIPC_EMIT_EVENT(dealPortfolio, "orderId", _orderId, "orderInfo", &ord.toJson()[0]);
    }
    
    EXPORT void PortfolioManage::revocationOrder(char* _portfolioName, char* _orderId){
        u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
std::string pInfo = portfolioStorge.get()[_portfolioName];
        
        
        PortfolioInfo info;
        info.parseJson(pInfo);
        Order ord = info.getOrder(_orderId);
        
        
        if(ord.orderId != "" && ord.orderStatus == 0){
            std::string callerStr = caller().toString();
            
            
            
            DipcAssert(info.getOwnerAddress() == caller().toString());
            

            uint64_t timenow = dipc::timestamp();
            if(ord.endTime > timenow){
                ord.orderStatus = 2;
            }else {
                ord.orderStatus = 3;
            }
        } else {
            return;
        }
        uint64_t lockToken = 0;
        if(ord.orderType == 1){
            lockToken = ord.stockPrice * ord.stockAmount;
        }
        uint64_t currentBalance =  portfolioBalance.get()[_portfolioName];
        
        
        
        

        DipcAssert(currentBalance + lockToken >= currentBalance);
        DipcAssert(ownerTotalToken.get() - lockToken <= ownerTotalToken.get());

        
        (*portfolioBalance)[_portfolioName] = currentBalance + lockToken;
        *ownerTotalToken = ownerTotalToken.get() - lockToken;
        (*portfolioStorge)[_portfolioName] = &info.toJson()[0];
        DIPC_EMIT_EVENT(revocationPortfolio, "orderId", _orderId, "orderInfo", &ord.toJson()[0]);
    }
    
    EXPORT void PortfolioManage::withdrawPortfolio(char* _portfolioName, uint64_t _withdrawBalance){
         u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
if(!userCanWithdraw.get()){
             return;
         }
         uint64_t currentBalance =  portfolioBalance.get()[_portfolioName];
         DipcAssert(currentBalance - _withdrawBalance < currentBalance);
         auto coinBalance = changeUint64ToU256WithChangeRate(currentBalance, changeRate.get());
         (*portfolioBalance)[_portfolioName] = currentBalance - _withdrawBalance;
         callTransfer(caller(), coinBalance);
    }
    
    EXPORT void PortfolioManage::withdrawPool(uint64_t _balance){
        u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
isOwner();
        Address ownerAddr = Address(owner.get()); 
        callTransfer(ownerAddr, _balance);
        *ownerTotalToken = ownerTotalToken.get() - _balance * changeRate.get();
        *totalToken = totalToken.get() - _balance * changeRate.get();
        DIPC_EMIT_EVENT(tokenCount, "ownerTotalToken", ownerTotalToken.get(), "totalToken", totalToken.get());
    }
    
    PAYABLE void PortfolioManage::depositPool(uint64_t _depositValue){
        isOwner();
        
        uint64_t tokenBalance = changeU256ToUint64WithChangeRate(callValue(), changeRate.get()); 
        *ownerTotalToken = ownerTotalToken.get() + tokenBalance;
        *totalToken = totalToken.get() + tokenBalance;
        DIPC_EMIT_EVENT(tokenCount, "ownerTotalToken", ownerTotalToken.get(), "totalToken", totalToken.get());
    }
     
    CONSTANT uint64_t PortfolioManage::queryTotalToken(){
        u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
return totalToken.get();
    }

     
    CONSTANT uint64_t PortfolioManage::queryPortfolioBalance(char* _portfolioName){
        u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
return portfolioBalance.get()[_portfolioName];
    }

    
    CONSTANT bool PortfolioManage::queryPortfolioNameIfUsed(char* _portfolioName){
        u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
if(portfolioStorge.get()[_portfolioName] != ""){
            return true;
        } 
        return false;
    }

    
    CONSTANT uint64_t PortfolioManage::queryChangeRate(){
        u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
return changeRate.get();
    }

2019-12-19_15:14:55.671017: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:657] searchStr \s*CONSTANT\s*bool\s*PortfolioManage::queryPortfolioNameIfUsed

2019-12-19_15:14:55.679895: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:656] searchStr \s*CONSTANT\s*uint64_t\s*PortfolioManage::queryChangeRate code_text #include "PortfolioManage.hpp"

    
    PAYABLE void PortfolioManage::init(){
        *owner = caller().toString();
        *changeRate = 10000;
        *userCanWithdraw = false;
        uint64_t tokenBalance = getTotalBalance();
        
        *ownerTotalToken = tokenBalance;
        *totalToken = ownerTotalToken.get();
        
        
        DIPC_EMIT_EVENT(initEvent, "ownerTotalToken" ,tokenBalance);
    }
    
     
    EXPORT void PortfolioManage::setChangeRate(uint64_t _changeRate){
        u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
isOwner();
        *changeRate = _changeRate;
    }
     
    EXPORT void PortfolioManage::setUserCanWithdraw(bool _canWithdraw){
        u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
isOwner();
        *userCanWithdraw = _canWithdraw;
    }

    
    PAYABLE void PortfolioManage::createPortfolio(char* _portfolioName, char* _portfolioDesc){
        if(portfolioStorge.get()[_portfolioName] != ""){
            DIPC_EMIT_EVENT(ErrEvent, "Current portfolio exist: ", _portfolioName);
            return;
        } 
        std::string callerAddr = caller().toString();
        uint64_t tokenBalance = getTotalBalance();
        
        PortfolioInfo info(_portfolioName, _portfolioDesc, &callerAddr[0]);
        std::string portfolioStr = info.toJson();
        
        
        

        (*portfolioStorge)[_portfolioName] = portfolioStr;
        DipcAssert(totalToken.get() + tokenBalance > totalToken);
        (*portfolioBalance)[_portfolioName] = tokenBalance;
        *totalToken = totalToken.get() + tokenBalance; 
        
        DIPC_EMIT_EVENT(portfolioInfo, _portfolioName, &portfolioStr[0], "portfolioBalance", tokenBalance);
    }

    
    PAYABLE void PortfolioManage::depositPortfolio(char* _portfolioName){
        uint64_t tokenBalance = getTotalBalance();
        
        uint64_t currentBalance = portfolioBalance.get()[_portfolioName];
        uint64_t finalBalance  = currentBalance + tokenBalance;
        DipcAssert(totalToken.get() + tokenBalance > totalToken);
        DipcAssert(finalBalance > currentBalance);
        (*portfolioBalance)[_portfolioName] = finalBalance;
        *totalToken = totalToken.get() + finalBalance; 
        DIPC_EMIT_EVENT(depositPortfolio, "portfolioName", _portfolioName, "portfolioBalance", finalBalance);
    }
    
    PAYABLE void PortfolioManage::createOrder(char* _portfolioName, char* _orderId, uint16_t _orderType, char* _stockCode, uint64_t _stockPrice, uint64_t _stockAmount, uint64_t _endTime){
        uint64_t tokenBalance = getTotalBalance();
        DIPC_EMIT_EVENT(createOrder, "portfolioName", _portfolioName, "OrderInfo", "ignore", "tokenBalance", tokenBalance);
        uint64_t spent = 0;
        if(_orderType == 1){
            spent = _stockPrice * _stockAmount;
            DipcAssert((portfolioBalance.get()[_portfolioName] + tokenBalance) > spent);
        }
        struct Order order{_orderId, _orderType, _stockCode, _stockPrice, _stockAmount, _endTime, 0};
        std::string pInfo = portfolioStorge.get()[_portfolioName];
        
        
        
        if(pInfo == "") {
            DIPC_EMIT_EVENT(ErrEvent, "Current portfolio  doesn't exist: ", _portfolioName);
            return;
        }
        PortfolioInfo info;
        info.parseJson(pInfo);
        if(info.getOrder(_orderId).orderId != ""){
            DIPC_EMIT_EVENT(ErrEvent, "Current order exist: ", _orderId);
            return;
        }
        info.addOrder(order);
        pInfo = info.toJson();

        uint64_t currentBalance = portfolioBalance.get()[_portfolioName] ;
        uint64_t finalBalance = currentBalance + tokenBalance - spent;
        DipcAssert(totalToken.get() + tokenBalance > totalToken);
        
        DipcAssert(ownerTotalToken.get() < ownerTotalToken.get() + spent);
        (*portfolioStorge)[_portfolioName] = &pInfo[0];
        
        
        
        


        (*portfolioBalance)[_portfolioName] = finalBalance;
        *totalToken = totalToken.get() + finalBalance; 
        *ownerTotalToken = ownerTotalToken.get() + spent;
        DIPC_EMIT_EVENT(createOrder, "portfolioName", _portfolioName, "OrderInfo", &order.toJson()[0], "portfolioBalance", finalBalance);
    }

    
    EXPORT void PortfolioManage::dealOrder(char* _portfolioName, char* _orderId){
        u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
isOwner();
        std::string pInfo = portfolioStorge.get()[_portfolioName];
        
        
        PortfolioInfo info;
        info.parseJson(pInfo);
        

        
         Order ord = info.getOrder(_orderId);
         
         
        if(ord.orderId != "" && ord.orderStatus == 0){
            
            uint64_t timenow = dipc::timestamp();
            if(ord.endTime > timenow){
                ord.orderStatus = 1;
            }else {
                ord.orderStatus = 3;
            }
        } else {
          

            return;
        }
        

        uint64_t sellValue = 0;
        if(ord.orderType == 0){
            sellValue = ord.stockAmount * ord.stockPrice;
        }
        uint64_t currentBalance =  portfolioBalance.get()[_portfolioName];
        

        DipcAssert(currentBalance + sellValue >= currentBalance);
        DipcAssert((ownerTotalToken.get() - sellValue) <= ownerTotalToken.get());
        


        (*portfolioBalance)[_portfolioName] = currentBalance + sellValue;
        *ownerTotalToken = ownerTotalToken.get() - sellValue;
        (*portfolioStorge)[_portfolioName] = &info.toJson()[0];
        
        
        
        

        DIPC_EMIT_EVENT(dealPortfolio, "orderId", _orderId, "orderInfo", &ord.toJson()[0]);
    }
    
    EXPORT void PortfolioManage::revocationOrder(char* _portfolioName, char* _orderId){
        u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
std::string pInfo = portfolioStorge.get()[_portfolioName];
        
        
        PortfolioInfo info;
        info.parseJson(pInfo);
        Order ord = info.getOrder(_orderId);
        
        
        if(ord.orderId != "" && ord.orderStatus == 0){
            std::string callerStr = caller().toString();
            
            
            
            DipcAssert(info.getOwnerAddress() == caller().toString());
            

            uint64_t timenow = dipc::timestamp();
            if(ord.endTime > timenow){
                ord.orderStatus = 2;
            }else {
                ord.orderStatus = 3;
            }
        } else {
            return;
        }
        uint64_t lockToken = 0;
        if(ord.orderType == 1){
            lockToken = ord.stockPrice * ord.stockAmount;
        }
        uint64_t currentBalance =  portfolioBalance.get()[_portfolioName];
        
        
        
        

        DipcAssert(currentBalance + lockToken >= currentBalance);
        DipcAssert(ownerTotalToken.get() - lockToken <= ownerTotalToken.get());

        
        (*portfolioBalance)[_portfolioName] = currentBalance + lockToken;
        *ownerTotalToken = ownerTotalToken.get() - lockToken;
        (*portfolioStorge)[_portfolioName] = &info.toJson()[0];
        DIPC_EMIT_EVENT(revocationPortfolio, "orderId", _orderId, "orderInfo", &ord.toJson()[0]);
    }
    
    EXPORT void PortfolioManage::withdrawPortfolio(char* _portfolioName, uint64_t _withdrawBalance){
         u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
if(!userCanWithdraw.get()){
             return;
         }
         uint64_t currentBalance =  portfolioBalance.get()[_portfolioName];
         DipcAssert(currentBalance - _withdrawBalance < currentBalance);
         auto coinBalance = changeUint64ToU256WithChangeRate(currentBalance, changeRate.get());
         (*portfolioBalance)[_portfolioName] = currentBalance - _withdrawBalance;
         callTransfer(caller(), coinBalance);
    }
    
    EXPORT void PortfolioManage::withdrawPool(uint64_t _balance){
        u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
isOwner();
        Address ownerAddr = Address(owner.get()); 
        callTransfer(ownerAddr, _balance);
        *ownerTotalToken = ownerTotalToken.get() - _balance * changeRate.get();
        *totalToken = totalToken.get() - _balance * changeRate.get();
        DIPC_EMIT_EVENT(tokenCount, "ownerTotalToken", ownerTotalToken.get(), "totalToken", totalToken.get());
    }
    
    PAYABLE void PortfolioManage::depositPool(uint64_t _depositValue){
        isOwner();
        
        uint64_t tokenBalance = changeU256ToUint64WithChangeRate(callValue(), changeRate.get()); 
        *ownerTotalToken = ownerTotalToken.get() + tokenBalance;
        *totalToken = totalToken.get() + tokenBalance;
        DIPC_EMIT_EVENT(tokenCount, "ownerTotalToken", ownerTotalToken.get(), "totalToken", totalToken.get());
    }
     
    CONSTANT uint64_t PortfolioManage::queryTotalToken(){
        u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
return totalToken.get();
    }

     
    CONSTANT uint64_t PortfolioManage::queryPortfolioBalance(char* _portfolioName){
        u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
return portfolioBalance.get()[_portfolioName];
    }

    
    CONSTANT bool PortfolioManage::queryPortfolioNameIfUsed(char* _portfolioName){
        u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
if(portfolioStorge.get()[_portfolioName] != ""){
            return true;
        } 
        return false;
    }

    
    CONSTANT uint64_t PortfolioManage::queryChangeRate(){
        u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
return changeRate.get();
    }

2019-12-19_15:14:55.679916: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:657] searchStr \s*CONSTANT\s*uint64_t\s*PortfolioManage::queryChangeRate

2019-12-19_15:14:55.689728: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:668] CompareHeaderAndImplFileMacro end  

2019-12-19_15:14:55.689760: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:911] hppPath  :  PortfolioManage.hpp
2019-12-19_15:14:55.689802: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:915] hppOutPath  :  /var/folders/tt/8v4bb03x685c49jk_vkvr7s80000gp/T//PortfolioManagetemp.hpp
2019-12-19_15:14:55.689926: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:923] abaabaab ======== : 
2019-12-19_15:14:55.689933: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:924] contractName ======== : PortfolioManage
2019-12-19_15:14:55.689939: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:926] randomDir ======== : /var/folders/tt/8v4bb03x685c49jk_vkvr7s80000gp/T/3e3a6heh3g58dhgeb7a2
2019-12-19_15:14:55.689948: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:927] hppOutPath ======== : /var/folders/tt/8v4bb03x685c49jk_vkvr7s80000gp/T//PortfolioManagetemp.hpp
2019-12-19_15:14:55.689958: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:675] InsertFuncToHeaderFile start....

2019-12-19_15:14:55.689970: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:681] InsertFuncToHeaderFile new ....

2019-12-19_15:14:55.693427: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:683] InsertFuncToHeaderFile result ....true

2019-12-19_15:14:55.693443: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:690] claSma[0].str()  :    class PortfolioManage : public Contract {

2019-12-19_15:14:55.693454: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:692] pos2  :    9335

2019-12-19_15:14:55.693464: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:724] tempText   :  #include <dipc/dipc.hpp>
#include "rapidjson/stringbuffer.h"
#include "rapidjson/writer.h"
#include "rapidjson/document.h"
#include <map>

using namespace dipc;

struct Order {
        std::string orderId;
        uint16_t orderType;     // 1 means buy, 0 means sell
        std::string stockCode;
        uint64_t stockPrice;
        uint64_t stockAmount;
        uint64_t endTime;
        uint16_t orderStatus;   // 0 mean unsettled, 1 mean settled, 2 cancel, 3 expire
        std::string toJson(){
            std::string result = "{ \"orderId\":\"" + orderId + "\",\"orderType\":" 
                + std::to_string(orderType)+ ",\"stockCode\":\""
                + stockCode+"\",\"stockPrice\":"+ std::to_string(stockPrice)
                +",\"stockAmount\":"+ std::to_string(stockAmount)
                + ",\"endTime\":"+std::to_string(endTime)
                + ",\"orderStatus\":"+std::to_string(orderStatus)+"}";
            return result;
        }
};

 class PortfolioInfo {
        private:
        // char*  portfolioName;
        // char*  portfolioDesc;
        // char*  portfolioOwnerAddr;
        std::string portfolioName;
        std::string  portfolioDesc;
        std::string portfolioOwnerAddr;
        std::string portfolioResult;
        uint64_t portfolioBalance;
        //uint64_t orderRecordNum;
        //static uint64_t ordersLen;
        //std::map<char*, Order> orders;
        std::map<std::string, Order> orders;
        //Order orders[10];
        public:
        //PortfolioInfo(char* _portfolioName, char* _portfolioDesc, char* _portfolioOwnerAddr, uint64_t _portfolioBalance):portfolioName(_portfolioName),portfolioDesc(_portfolioDesc), portfolioOwnerAddr(_portfolioOwnerAddr), portfolioBalance(_portfolioBalance){
        PortfolioInfo(){};
        PortfolioInfo(char* _portfolioName, char* _portfolioDesc, char* _portfolioOwnerAddr):portfolioName(_portfolioName),portfolioDesc(_portfolioDesc), portfolioOwnerAddr(_portfolioOwnerAddr) {

        };
        // std::string toJson(){
        //     rapidjson::StringBuffer strBuf;
        //     rapidjson::Writer<rapidjson::StringBuffer> writer(strBuf);
        //     writer.StartObject();
        //     writer.Key("portfolioName");
        //     writer.String(portfolioName.data());
        //     writer.Key("portfolioDesc");
        //     writer.String(portfolioDesc.data());
        //     writer.Key("portfolioOwnerAddr");
        //     writer.String(portfolioOwnerAddr.data());
        //     writer.Key("portfolioBalance");
        //     writer.Uint64(portfolioBalance);
        //     writer.Key("orders");
        //     writer.StartArray();
        //     //std::map<char* , Order>::iterator iter;
        //     std::map<std::string , Order>::iterator iter;
        //     iter = orders.begin();
        //     while(iter != orders.end()){
        //         Order order = iter->second;
        //         writer.StartObject();
        //         writer.Key("orderId");
        //         writer.String(order.orderId.data());
        //         writer.EndObject();
        //     }
        //     writer.EndArray();
        //     writer.EndObject();

        //     print(strBuf.GetLength());
        //     //strBuf.Flush();
        //     std::string result = strBuf.GetString();
        //     auto ch = strBuf.GetString();
        //     print(*ch);
        //     if(*ch != '\0'){
        //         ch++;
        //         print(ch);
        //     }

        //     portfolioResult = strBuf.GetString();
        //     //strBuf.Flush();
        //     // char re[] = strBuf.GetString();
        //     // copy(strBuf.GetString(), result);
        //     print(result);
        //     print(portfolioResult);
        //     return result;
        // }

         std::string toJson(){
             std::string result;
            //result += "{ \"portfolioName\":" + portfolioName +  ",\"portfolioDesc\":" + portfolioDesc + ",\"portfolioOwnerAddr\":" + portfolioOwnerAddr+ ",\"orders\":[";
            result += "{ \"portfolioName\":\"" + portfolioName +  "\",\"portfolioDesc\":\"" + portfolioDesc + "\",\"portfolioOwnerAddr\":\"" + portfolioOwnerAddr+ "\",\"orders\":[";
            std::map<std::string , Order>::iterator iter;
            iter = orders.begin();
            bool hasOrder = false;
            while(iter != orders.end()){
                print("get order info");
                Order order = iter->second;
                result += "{ \"orderId\":\"" + order.orderId + "\",\"orderType\":" 
                + std::to_string(order.orderType)+ ",\"stockCode\":\""
                + order.stockCode+"\",\"stockPrice\":"+ std::to_string(order.stockPrice)
                +",\"stockAmount\":"+ std::to_string(order.stockAmount)
                + ",\"endTime\":"+std::to_string(order.endTime)
                + ",\"orderStatus\":"+std::to_string(order.orderStatus)+"},";
                hasOrder = true;
                iter++;
            }
            if(hasOrder){
                result = result.substr(0,result.size()-1);
            }
            print("get result info");
            result += "]}";
            print(result);
            //print(portfolioResult);
            return result;
        }
        void addOrder(Order order){
            orders.insert(std::pair<std::string, Order>(order.orderId, order));
        }
        void parseJson(std::string info){
            rapidjson::Document doc;
            print("parseJson start ");
            if(!doc.Parse(info.data()).HasParseError()){
   
                if(doc.HasMember("portfolioName") && doc["portfolioName"].IsString())
                {   
                    print("portfolioName");
                    portfolioName = doc["portfolioName"].GetString();
                }
      
                if(doc.HasMember("portfolioDesc") && doc["portfolioDesc"].IsString())
                {
                    portfolioDesc = doc["portfolioDesc"].GetString();
                }
                if(doc.HasMember("portfolioOwnerAddr") && doc["portfolioOwnerAddr"].IsString())
                {
                    portfolioOwnerAddr = doc["portfolioOwnerAddr"].GetString();
                }
    
                if(doc.HasMember("portfolioBalance") && doc["portfolioBalance"].IsUint64())
                {
                portfolioBalance = doc["portfolioBalance"].GetUint64();
                }
                print("start to parse orders");
                if(doc.HasMember("orders") && doc["orders"].IsArray()){
                    print("start to parse orders  one ");

                    const rapidjson::Value& ors = doc["orders"];
                    size_t len = ors.Size();
                    for(size_t i = 0; i < len; i++)
                    {
                    print("start to parse orders  two ");

                        Order orderPar;
                        const rapidjson::Value& ord = ors[i];
                        if(ord.HasMember("orderId") && ord["orderId"].IsString())
                        {
                            orderPar.orderId = ord["orderId"].GetString();
                        }

                        if(ord.HasMember("orderType") && ord["orderType"].IsUint())
                        {
                            orderPar.orderType = ord["orderType"].GetUint();
                        } 
                         if(ord.HasMember("stockCode") && ord["stockCode"].IsString())
                        {
                            orderPar.stockCode = ord["stockCode"].GetString();
                        } 
                         if(ord.HasMember("stockPrice") && ord["stockPrice"].IsUint64())
                        {
                            orderPar.stockPrice = ord["stockPrice"].GetUint64();
                        } 
                        if(ord.HasMember("stockAmount") && ord["stockAmount"].IsUint64())
                        {
                            orderPar.stockAmount = ord["stockAmount"].GetUint64();
                        } 
                        if(ord.HasMember("endTime") && ord["endTime"].IsUint64())
                        {
                            orderPar.endTime = ord["endTime"].GetUint64();
                        } 
                        if(ord.HasMember("orderStatus") && ord["orderStatus"].IsUint())
                        {
                            orderPar.orderStatus = ord["orderStatus"].GetUint();
                        }
                        addOrder(orderPar);
                        //orders.insert(std::pair<std::string, Order>(orderPar.orderId, orderPar));
                    }
                }
        
            } else {
                print("parseJson error ");
            }
        }
    

        Order getOrder(char * orderId){
            return orders[orderId];
        }

        std::string getOwnerAddress(){
        //char* getOwnerAddress(){
            return portfolioOwnerAddr;
        }

        std::string getPortfolioResult(){
        //char* getOwnerAddress(){
            return portfolioResult;
        }
      
};




char ownc[] = "own";
char ownerTotalTokenc[] = "ownTotal";
char changeRatec[] = "changeRate";
char userCanWithdrawc[] = "userWithdraw";
char totalTokenc[] = "totalToken";
char portfolioMapc[] = "portfolioMap";
char portfolioBalancec[] = "portfolioBalance";
class PortfolioManage : public Contract {
private:
    String<ownc> owner;
    Uint64<ownerTotalTokenc> ownerTotalToken;
    Uint64<changeRatec> changeRate;
    Bool<userCanWithdrawc> userCanWithdraw;
    Uint64<totalTokenc> totalToken; 
    //Map<portfolioMapc, char * , std::string> portfolioStorge;
    Map<portfolioMapc, std::string , std::string> portfolioStorge;
    Map<portfolioBalancec, std::string , uint64_t> portfolioBalance; 
    void isOwner(){
        std::string callerStr = caller().toString();
        DipcAssert(callerStr == owner.get());
    }
    
    inline uint64_t getTotalBalance(){
        print("callValueUDIP");
        print(dipc::callValueUDIP());
        print(changeRate.get());
        //print(uint64_t(std::pow(10.0,3)));
       return dipc::callValueUDIP() * changeRate.get() / 1000;
    }
   

public:
    PAYABLE void init();
    EXPORT void setChangeRate(uint64_t _changeRate);
    EXPORT void setUserCanWithdraw(bool _canWithdraw);
    PAYABLE void createPortfolio(char* _portfolioName, char* _portfolioDesc);
    PAYABLE void depositPortfolio(char* _portfolioName);
    PAYABLE void createOrder(char* _portfolioName, char* _orderId, uint16_t _orderType, char* _stockCode, uint64_t _stockPrice, uint64_t _stockAmount, uint64_t _endTime);
    EXPORT void dealOrder(char* _portfolioName, char* _orderId);
    EXPORT void revocationOrder(char* _portfolioName, char* _orderId);
    EXPORT void withdrawPortfolio(char* _portfolioName, uint64_t _withdrawBalance);
    EXPORT void withdrawPool(uint64_t _balance);
    PAYABLE void depositPool(uint64_t _depositValue);
    CONSTANT uint64_t queryTotalToken();
    CONSTANT uint64_t queryPortfolioBalance(char* _portfolioName);
    CONSTANT bool queryPortfolioNameIfUsed(char* _portfolioName);
    CONSTANT uint64_t queryChangeRate();


2019-12-19_15:14:55.693478: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:727] filename   :  PortfolioManage.cpp

2019-12-19_15:14:55.695580: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:747] tempText  end :  #include <dipc/dipc.hpp>
#include "rapidjson/stringbuffer.h"
#include "rapidjson/writer.h"
#include "rapidjson/document.h"
#include <map>

using namespace dipc;

struct Order {
        std::string orderId;
        uint16_t orderType;     // 1 means buy, 0 means sell
        std::string stockCode;
        uint64_t stockPrice;
        uint64_t stockAmount;
        uint64_t endTime;
        uint16_t orderStatus;   // 0 mean unsettled, 1 mean settled, 2 cancel, 3 expire
        std::string toJson(){
            std::string result = "{ \"orderId\":\"" + orderId + "\",\"orderType\":" 
                + std::to_string(orderType)+ ",\"stockCode\":\""
                + stockCode+"\",\"stockPrice\":"+ std::to_string(stockPrice)
                +",\"stockAmount\":"+ std::to_string(stockAmount)
                + ",\"endTime\":"+std::to_string(endTime)
                + ",\"orderStatus\":"+std::to_string(orderStatus)+"}";
            return result;
        }
};

 class PortfolioInfo {
        private:
        // char*  portfolioName;
        // char*  portfolioDesc;
        // char*  portfolioOwnerAddr;
        std::string portfolioName;
        std::string  portfolioDesc;
        std::string portfolioOwnerAddr;
        std::string portfolioResult;
        uint64_t portfolioBalance;
        //uint64_t orderRecordNum;
        //static uint64_t ordersLen;
        //std::map<char*, Order> orders;
        std::map<std::string, Order> orders;
        //Order orders[10];
        public:
        //PortfolioInfo(char* _portfolioName, char* _portfolioDesc, char* _portfolioOwnerAddr, uint64_t _portfolioBalance):portfolioName(_portfolioName),portfolioDesc(_portfolioDesc), portfolioOwnerAddr(_portfolioOwnerAddr), portfolioBalance(_portfolioBalance){
        PortfolioInfo(){};
        PortfolioInfo(char* _portfolioName, char* _portfolioDesc, char* _portfolioOwnerAddr):portfolioName(_portfolioName),portfolioDesc(_portfolioDesc), portfolioOwnerAddr(_portfolioOwnerAddr) {

        };
        // std::string toJson(){
        //     rapidjson::StringBuffer strBuf;
        //     rapidjson::Writer<rapidjson::StringBuffer> writer(strBuf);
        //     writer.StartObject();
        //     writer.Key("portfolioName");
        //     writer.String(portfolioName.data());
        //     writer.Key("portfolioDesc");
        //     writer.String(portfolioDesc.data());
        //     writer.Key("portfolioOwnerAddr");
        //     writer.String(portfolioOwnerAddr.data());
        //     writer.Key("portfolioBalance");
        //     writer.Uint64(portfolioBalance);
        //     writer.Key("orders");
        //     writer.StartArray();
        //     //std::map<char* , Order>::iterator iter;
        //     std::map<std::string , Order>::iterator iter;
        //     iter = orders.begin();
        //     while(iter != orders.end()){
        //         Order order = iter->second;
        //         writer.StartObject();
        //         writer.Key("orderId");
        //         writer.String(order.orderId.data());
        //         writer.EndObject();
        //     }
        //     writer.EndArray();
        //     writer.EndObject();

        //     print(strBuf.GetLength());
        //     //strBuf.Flush();
        //     std::string result = strBuf.GetString();
        //     auto ch = strBuf.GetString();
        //     print(*ch);
        //     if(*ch != '\0'){
        //         ch++;
        //         print(ch);
        //     }

        //     portfolioResult = strBuf.GetString();
        //     //strBuf.Flush();
        //     // char re[] = strBuf.GetString();
        //     // copy(strBuf.GetString(), result);
        //     print(result);
        //     print(portfolioResult);
        //     return result;
        // }

         std::string toJson(){
             std::string result;
            //result += "{ \"portfolioName\":" + portfolioName +  ",\"portfolioDesc\":" + portfolioDesc + ",\"portfolioOwnerAddr\":" + portfolioOwnerAddr+ ",\"orders\":[";
            result += "{ \"portfolioName\":\"" + portfolioName +  "\",\"portfolioDesc\":\"" + portfolioDesc + "\",\"portfolioOwnerAddr\":\"" + portfolioOwnerAddr+ "\",\"orders\":[";
            std::map<std::string , Order>::iterator iter;
            iter = orders.begin();
            bool hasOrder = false;
            while(iter != orders.end()){
                print("get order info");
                Order order = iter->second;
                result += "{ \"orderId\":\"" + order.orderId + "\",\"orderType\":" 
                + std::to_string(order.orderType)+ ",\"stockCode\":\""
                + order.stockCode+"\",\"stockPrice\":"+ std::to_string(order.stockPrice)
                +",\"stockAmount\":"+ std::to_string(order.stockAmount)
                + ",\"endTime\":"+std::to_string(order.endTime)
                + ",\"orderStatus\":"+std::to_string(order.orderStatus)+"},";
                hasOrder = true;
                iter++;
            }
            if(hasOrder){
                result = result.substr(0,result.size()-1);
            }
            print("get result info");
            result += "]}";
            print(result);
            //print(portfolioResult);
            return result;
        }
        void addOrder(Order order){
            orders.insert(std::pair<std::string, Order>(order.orderId, order));
        }
        void parseJson(std::string info){
            rapidjson::Document doc;
            print("parseJson start ");
            if(!doc.Parse(info.data()).HasParseError()){
   
                if(doc.HasMember("portfolioName") && doc["portfolioName"].IsString())
                {   
                    print("portfolioName");
                    portfolioName = doc["portfolioName"].GetString();
                }
      
                if(doc.HasMember("portfolioDesc") && doc["portfolioDesc"].IsString())
                {
                    portfolioDesc = doc["portfolioDesc"].GetString();
                }
                if(doc.HasMember("portfolioOwnerAddr") && doc["portfolioOwnerAddr"].IsString())
                {
                    portfolioOwnerAddr = doc["portfolioOwnerAddr"].GetString();
                }
    
                if(doc.HasMember("portfolioBalance") && doc["portfolioBalance"].IsUint64())
                {
                portfolioBalance = doc["portfolioBalance"].GetUint64();
                }
                print("start to parse orders");
                if(doc.HasMember("orders") && doc["orders"].IsArray()){
                    print("start to parse orders  one ");

                    const rapidjson::Value& ors = doc["orders"];
                    size_t len = ors.Size();
                    for(size_t i = 0; i < len; i++)
                    {
                    print("start to parse orders  two ");

                        Order orderPar;
                        const rapidjson::Value& ord = ors[i];
                        if(ord.HasMember("orderId") && ord["orderId"].IsString())
                        {
                            orderPar.orderId = ord["orderId"].GetString();
                        }

                        if(ord.HasMember("orderType") && ord["orderType"].IsUint())
                        {
                            orderPar.orderType = ord["orderType"].GetUint();
                        } 
                         if(ord.HasMember("stockCode") && ord["stockCode"].IsString())
                        {
                            orderPar.stockCode = ord["stockCode"].GetString();
                        } 
                         if(ord.HasMember("stockPrice") && ord["stockPrice"].IsUint64())
                        {
                            orderPar.stockPrice = ord["stockPrice"].GetUint64();
                        } 
                        if(ord.HasMember("stockAmount") && ord["stockAmount"].IsUint64())
                        {
                            orderPar.stockAmount = ord["stockAmount"].GetUint64();
                        } 
                        if(ord.HasMember("endTime") && ord["endTime"].IsUint64())
                        {
                            orderPar.endTime = ord["endTime"].GetUint64();
                        } 
                        if(ord.HasMember("orderStatus") && ord["orderStatus"].IsUint())
                        {
                            orderPar.orderStatus = ord["orderStatus"].GetUint();
                        }
                        addOrder(orderPar);
                        //orders.insert(std::pair<std::string, Order>(orderPar.orderId, orderPar));
                    }
                }
        
            } else {
                print("parseJson error ");
            }
        }
    

        Order getOrder(char * orderId){
            return orders[orderId];
        }

        std::string getOwnerAddress(){
        //char* getOwnerAddress(){
            return portfolioOwnerAddr;
        }

        std::string getPortfolioResult(){
        //char* getOwnerAddress(){
            return portfolioResult;
        }
      
};




char ownc[] = "own";
char ownerTotalTokenc[] = "ownTotal";
char changeRatec[] = "changeRate";
char userCanWithdrawc[] = "userWithdraw";
char totalTokenc[] = "totalToken";
char portfolioMapc[] = "portfolioMap";
char portfolioBalancec[] = "portfolioBalance";
class PortfolioManage : public Contract {
private:
    String<ownc> owner;
    Uint64<ownerTotalTokenc> ownerTotalToken;
    Uint64<changeRatec> changeRate;
    Bool<userCanWithdrawc> userCanWithdraw;
    Uint64<totalTokenc> totalToken; 
    //Map<portfolioMapc, char * , std::string> portfolioStorge;
    Map<portfolioMapc, std::string , std::string> portfolioStorge;
    Map<portfolioBalancec, std::string , uint64_t> portfolioBalance; 
    void isOwner(){
        std::string callerStr = caller().toString();
        DipcAssert(callerStr == owner.get());
    }
    
    inline uint64_t getTotalBalance(){
        print("callValueUDIP");
        print(dipc::callValueUDIP());
        print(changeRate.get());
        //print(uint64_t(std::pow(10.0,3)));
       return dipc::callValueUDIP() * changeRate.get() / 1000;
    }
   

public:
    PAYABLE void init();
    EXPORT void setChangeRate(uint64_t _changeRate);
    EXPORT void setUserCanWithdraw(bool _canWithdraw);
    PAYABLE void createPortfolio(char* _portfolioName, char* _portfolioDesc);
    PAYABLE void depositPortfolio(char* _portfolioName);
    PAYABLE void createOrder(char* _portfolioName, char* _orderId, uint16_t _orderType, char* _stockCode, uint64_t _stockPrice, uint64_t _stockAmount, uint64_t _endTime);
    EXPORT void dealOrder(char* _portfolioName, char* _orderId);
    EXPORT void revocationOrder(char* _portfolioName, char* _orderId);
    EXPORT void withdrawPortfolio(char* _portfolioName, uint64_t _withdrawBalance);
    EXPORT void withdrawPool(uint64_t _balance);
    PAYABLE void depositPool(uint64_t _depositValue);
    CONSTANT uint64_t queryTotalToken();
    CONSTANT uint64_t queryPortfolioBalance(char* _portfolioName);
    CONSTANT bool queryPortfolioNameIfUsed(char* _portfolioName);
    CONSTANT uint64_t queryChangeRate();
};
DIPC_EVENT(initEvent, const char* ,uint64_t);
DIPC_EVENT(tokenCount, const char* ,uint64_t, const char*, uint64_t);
DIPC_EVENT(portfolioInfo, const char*, const char* ,const char* , uint64_t);
DIPC_EVENT(createOrder, const char*, const char*, const char*, const char*, const char*, uint64_t);
DIPC_EVENT(depositPortfolio, const char*, const char*, const char*, uint64_t);
DIPC_EVENT(revocationPortfolio, const char*, const char*, const char*, const char*);
DIPC_EVENT(dealPortfolio, const char*, const char*, const char*, const char*);
DIPC_EVENT(ErrEvent, const char*, const char*);

2019-12-19_15:14:55.697787: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:936] headerStr removedComments  ======== : #include "PortfolioManagetemp.hpp"

    
    PAYABLE void PortfolioManage::init(){
        *owner = caller().toString();
        *changeRate = 10000;
        *userCanWithdraw = false;
        uint64_t tokenBalance = getTotalBalance();
        
        *ownerTotalToken = tokenBalance;
        *totalToken = ownerTotalToken.get();
        
        
        DIPC_EMIT_EVENT(initEvent, "ownerTotalToken" ,tokenBalance);
    }
    
     
    EXPORT void PortfolioManage::setChangeRate(uint64_t _changeRate){
        u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
isOwner();
        *changeRate = _changeRate;
    }
     
    EXPORT void PortfolioManage::setUserCanWithdraw(bool _canWithdraw){
        u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
isOwner();
        *userCanWithdraw = _canWithdraw;
    }

    
    PAYABLE void PortfolioManage::createPortfolio(char* _portfolioName, char* _portfolioDesc){
        if(portfolioStorge.get()[_portfolioName] != ""){
            DIPC_EMIT_EVENT(ErrEvent, "Current portfolio exist: ", _portfolioName);
            return;
        } 
        std::string callerAddr = caller().toString();
        uint64_t tokenBalance = getTotalBalance();
        
        PortfolioInfo info(_portfolioName, _portfolioDesc, &callerAddr[0]);
        std::string portfolioStr = info.toJson();
        
        
        

        (*portfolioStorge)[_portfolioName] = portfolioStr;
        DipcAssert(totalToken.get() + tokenBalance > totalToken);
        (*portfolioBalance)[_portfolioName] = tokenBalance;
        *totalToken = totalToken.get() + tokenBalance; 
        
        DIPC_EMIT_EVENT(portfolioInfo, _portfolioName, &portfolioStr[0], "portfolioBalance", tokenBalance);
    }

    
    PAYABLE void PortfolioManage::depositPortfolio(char* _portfolioName){
        uint64_t tokenBalance = getTotalBalance();
        
        uint64_t currentBalance = portfolioBalance.get()[_portfolioName];
        uint64_t finalBalance  = currentBalance + tokenBalance;
        DipcAssert(totalToken.get() + tokenBalance > totalToken);
        DipcAssert(finalBalance > currentBalance);
        (*portfolioBalance)[_portfolioName] = finalBalance;
        *totalToken = totalToken.get() + finalBalance; 
        DIPC_EMIT_EVENT(depositPortfolio, "portfolioName", _portfolioName, "portfolioBalance", finalBalance);
    }
    
    PAYABLE void PortfolioManage::createOrder(char* _portfolioName, char* _orderId, uint16_t _orderType, char* _stockCode, uint64_t _stockPrice, uint64_t _stockAmount, uint64_t _endTime){
        uint64_t tokenBalance = getTotalBalance();
        DIPC_EMIT_EVENT(createOrder, "portfolioName", _portfolioName, "OrderInfo", "ignore", "tokenBalance", tokenBalance);
        uint64_t spent = 0;
        if(_orderType == 1){
            spent = _stockPrice * _stockAmount;
            DipcAssert((portfolioBalance.get()[_portfolioName] + tokenBalance) > spent);
        }
        struct Order order{_orderId, _orderType, _stockCode, _stockPrice, _stockAmount, _endTime, 0};
        std::string pInfo = portfolioStorge.get()[_portfolioName];
        
        
        
        if(pInfo == "") {
            DIPC_EMIT_EVENT(ErrEvent, "Current portfolio  doesn't exist: ", _portfolioName);
            return;
        }
        PortfolioInfo info;
        info.parseJson(pInfo);
        if(info.getOrder(_orderId).orderId != ""){
            DIPC_EMIT_EVENT(ErrEvent, "Current order exist: ", _orderId);
            return;
        }
        info.addOrder(order);
        pInfo = info.toJson();

        uint64_t currentBalance = portfolioBalance.get()[_portfolioName] ;
        uint64_t finalBalance = currentBalance + tokenBalance - spent;
        DipcAssert(totalToken.get() + tokenBalance > totalToken);
        
        DipcAssert(ownerTotalToken.get() < ownerTotalToken.get() + spent);
        (*portfolioStorge)[_portfolioName] = &pInfo[0];
        
        
        
        


        (*portfolioBalance)[_portfolioName] = finalBalance;
        *totalToken = totalToken.get() + finalBalance; 
        *ownerTotalToken = ownerTotalToken.get() + spent;
        DIPC_EMIT_EVENT(createOrder, "portfolioName", _portfolioName, "OrderInfo", &order.toJson()[0], "portfolioBalance", finalBalance);
    }

    
    EXPORT void PortfolioManage::dealOrder(char* _portfolioName, char* _orderId){
        u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
isOwner();
        std::string pInfo = portfolioStorge.get()[_portfolioName];
        
        
        PortfolioInfo info;
        info.parseJson(pInfo);
        

        
         Order ord = info.getOrder(_orderId);
         
         
        if(ord.orderId != "" && ord.orderStatus == 0){
            
            uint64_t timenow = dipc::timestamp();
            if(ord.endTime > timenow){
                ord.orderStatus = 1;
            }else {
                ord.orderStatus = 3;
            }
        } else {
          

            return;
        }
        

        uint64_t sellValue = 0;
        if(ord.orderType == 0){
            sellValue = ord.stockAmount * ord.stockPrice;
        }
        uint64_t currentBalance =  portfolioBalance.get()[_portfolioName];
        

        DipcAssert(currentBalance + sellValue >= currentBalance);
        DipcAssert((ownerTotalToken.get() - sellValue) <= ownerTotalToken.get());
        


        (*portfolioBalance)[_portfolioName] = currentBalance + sellValue;
        *ownerTotalToken = ownerTotalToken.get() - sellValue;
        (*portfolioStorge)[_portfolioName] = &info.toJson()[0];
        
        
        
        

        DIPC_EMIT_EVENT(dealPortfolio, "orderId", _orderId, "orderInfo", &ord.toJson()[0]);
    }
    
    EXPORT void PortfolioManage::revocationOrder(char* _portfolioName, char* _orderId){
        u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
std::string pInfo = portfolioStorge.get()[_portfolioName];
        
        
        PortfolioInfo info;
        info.parseJson(pInfo);
        Order ord = info.getOrder(_orderId);
        
        
        if(ord.orderId != "" && ord.orderStatus == 0){
            std::string callerStr = caller().toString();
            
            
            
            DipcAssert(info.getOwnerAddress() == caller().toString());
            

            uint64_t timenow = dipc::timestamp();
            if(ord.endTime > timenow){
                ord.orderStatus = 2;
            }else {
                ord.orderStatus = 3;
            }
        } else {
            return;
        }
        uint64_t lockToken = 0;
        if(ord.orderType == 1){
            lockToken = ord.stockPrice * ord.stockAmount;
        }
        uint64_t currentBalance =  portfolioBalance.get()[_portfolioName];
        
        
        
        

        DipcAssert(currentBalance + lockToken >= currentBalance);
        DipcAssert(ownerTotalToken.get() - lockToken <= ownerTotalToken.get());

        
        (*portfolioBalance)[_portfolioName] = currentBalance + lockToken;
        *ownerTotalToken = ownerTotalToken.get() - lockToken;
        (*portfolioStorge)[_portfolioName] = &info.toJson()[0];
        DIPC_EMIT_EVENT(revocationPortfolio, "orderId", _orderId, "orderInfo", &ord.toJson()[0]);
    }
    
    EXPORT void PortfolioManage::withdrawPortfolio(char* _portfolioName, uint64_t _withdrawBalance){
         u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
if(!userCanWithdraw.get()){
             return;
         }
         uint64_t currentBalance =  portfolioBalance.get()[_portfolioName];
         DipcAssert(currentBalance - _withdrawBalance < currentBalance);
         auto coinBalance = changeUint64ToU256WithChangeRate(currentBalance, changeRate.get());
         (*portfolioBalance)[_portfolioName] = currentBalance - _withdrawBalance;
         callTransfer(caller(), coinBalance);
    }
    
    EXPORT void PortfolioManage::withdrawPool(uint64_t _balance){
        u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
isOwner();
        Address ownerAddr = Address(owner.get()); 
        callTransfer(ownerAddr, _balance);
        *ownerTotalToken = ownerTotalToken.get() - _balance * changeRate.get();
        *totalToken = totalToken.get() - _balance * changeRate.get();
        DIPC_EMIT_EVENT(tokenCount, "ownerTotalToken", ownerTotalToken.get(), "totalToken", totalToken.get());
    }
    
    PAYABLE void PortfolioManage::depositPool(uint64_t _depositValue){
        isOwner();
        
        uint64_t tokenBalance = changeU256ToUint64WithChangeRate(callValue(), changeRate.get()); 
        *ownerTotalToken = ownerTotalToken.get() + tokenBalance;
        *totalToken = totalToken.get() + tokenBalance;
        DIPC_EMIT_EVENT(tokenCount, "ownerTotalToken", ownerTotalToken.get(), "totalToken", totalToken.get());
    }
     
    CONSTANT uint64_t PortfolioManage::queryTotalToken(){
        u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
return totalToken.get();
    }

     
    CONSTANT uint64_t PortfolioManage::queryPortfolioBalance(char* _portfolioName){
        u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
return portfolioBalance.get()[_portfolioName];
    }

    
    CONSTANT bool PortfolioManage::queryPortfolioNameIfUsed(char* _portfolioName){
        u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
if(portfolioStorge.get()[_portfolioName] != ""){
            return true;
        } 
        return false;
    }

    
    CONSTANT uint64_t PortfolioManage::queryChangeRate(){
        u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
return changeRate.get();
    }

2019-12-19_15:14:55.698949: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:975] swap src::PortfolioManage.cpp tmp::/var/folders/tt/8v4bb03x685c49jk_vkvr7s80000gp/T/3e3a6heh3g58dhgeb7a2/PortfolioManage.cpp
2019-12-19_15:14:55.698963: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:979] std::string(res.c_str()) + "/" + abidef_filename      /var/folders/tt/8v4bb03x685c49jk_vkvr7s80000gp/T//PortfolioManage.cpp

