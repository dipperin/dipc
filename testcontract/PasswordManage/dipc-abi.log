2019-12-31_16:55:57.541118: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:1104] dipc-abi  verbose  true

2019-12-31_16:55:57.541523: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:1105] dipc-abi argv  start ....

2019-12-31_16:55:57.541533: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:1107]   /Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/bin/dipc-abigen
2019-12-31_16:55:57.541541: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:1107]   -extra-arg=-std=c++17
2019-12-31_16:55:57.541547: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:1107]   -extra-arg=--target=wasm32
2019-12-31_16:55:57.541553: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:1107]   -extra-arg=-w
2019-12-31_16:55:57.541559: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:1107]   -extra-arg=-I/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/testcontract/PasswordManage
2019-12-31_16:55:57.541565: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:1107]   -extra-arg=-I/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/bin/../include/libcxx
2019-12-31_16:55:57.541570: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:1107]   -extra-arg=-I/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/bin/../include/libc
2019-12-31_16:55:57.541576: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:1107]   -extra-arg=-I/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/bin/../include/rt
2019-12-31_16:55:57.541582: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:1107]   -extra-arg=-I/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/bin/../include/native/softfloat/include
2019-12-31_16:55:57.541588: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:1107]   -extra-arg=-I/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/bin/../include
2019-12-31_16:55:57.541594: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:1107]   PasswordManage.cpp
2019-12-31_16:55:57.541599: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:1107]   -abigen_output=./PasswordManage.cpp.abi.json
2019-12-31_16:55:57.541605: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:1107]   -exports_output=/var/folders/tt/8v4bb03x685c49jk_vkvr7s80000gp/T//PasswordManage.cpp.exports
2019-12-31_16:55:57.541611: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:1107]   -abidef_output=
2019-12-31_16:55:57.541616: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:1107]   -log_path=./
2019-12-31_16:55:57.541621: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:1107]   -log_level=debug
2019-12-31_16:55:57.541627: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:1107]   -verbose
2019-12-31_16:55:57.541632: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:1107]   --
2019-12-31_16:55:57.541638: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:1107]   -w
2019-12-31_16:55:57.541643: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:1109]   dipc-abi argv end 

2019-12-31_16:55:57.541649: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:1115] start run
2019-12-31_16:55:57.541657: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:99] start create_find_macro_factory
2019-12-31_16:55:58.188861: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/tools/abi/AbiMacro.cpp:149] get macro:PAYABLE
2019-12-31_16:55:58.189346: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/tools/abi/AbiMacro.cpp:67] file_name : /Users/konggan/workspace/chain/dipperin/github-dipc/dipc/testcontract/PasswordManage/PasswordManage.hpp

2019-12-31_16:55:58.189360: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/tools/abi/AbiMacro.cpp:68] Export macrostr:PAYABLE; long str :PAYABLE; longstr :PAYABLE void init();
   EXPORT void registerPassword(char* passwordName, char* passwordAddr, uint64_t _balance);
   CONSTANT char* queryExistPasswords();
   CONSTANT bool queryPasswordIsUsed(char* passwordName);
   PAYABLE void payByPassword(char* passwordName);
   PAYABLE void depositeContract();
   EXPORT void setExpireTime(uint64_t _expireTime);
};

DIPC_EVENT(expireTimeSetted,uint64_t);
DIPC_EVENT(depositingValue,uint64_t);
DIPC_EVENT(ErrEvent, const char*, const char*);
DIPC_EVENT(registerPasswordEvent, const char*, const char*, const char*);
DIPC_EVENT(payByPasswordEvent, const char*, uint64_t);



2019-12-31_16:55:58.189798: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/tools/abi/AbiMacro.cpp:82] smatch[2].str : init(; action : init

2019-12-31_16:55:58.189826: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/tools/abi/AbiMacro.cpp:149] get macro:EXPORT
2019-12-31_16:55:58.189835: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/tools/abi/AbiMacro.cpp:67] file_name : /Users/konggan/workspace/chain/dipperin/github-dipc/dipc/testcontract/PasswordManage/PasswordManage.hpp

2019-12-31_16:55:58.189842: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/tools/abi/AbiMacro.cpp:68] Export macrostr:EXPORT; long str :EXPORT; longstr :EXPORT void registerPassword(char* passwordName, char* passwordAddr, uint64_t _balance);
   CONSTANT char* queryExistPasswords();
   CONSTANT bool queryPasswordIsUsed(char* passwordName);
   PAYABLE void payByPassword(char* passwordName);
   PAYABLE void depositeContract();
   EXPORT void setExpireTime(uint64_t _expireTime);
};

DIPC_EVENT(expireTimeSetted,uint64_t);
DIPC_EVENT(depositingValue,uint64_t);
DIPC_EVENT(ErrEvent, const char*, const char*);
DIPC_EVENT(registerPasswordEvent, const char*, const char*, const char*);
DIPC_EVENT(payByPasswordEvent, const char*, uint64_t);



2019-12-31_16:55:58.189890: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/tools/abi/AbiMacro.cpp:82] smatch[2].str : registerPassword(; action : registerPassword

2019-12-31_16:55:58.189905: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/tools/abi/AbiMacro.cpp:149] get macro:CONSTANT
2019-12-31_16:55:58.189912: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/tools/abi/AbiMacro.cpp:67] file_name : /Users/konggan/workspace/chain/dipperin/github-dipc/dipc/testcontract/PasswordManage/PasswordManage.hpp

2019-12-31_16:55:58.189917: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/tools/abi/AbiMacro.cpp:68] Export macrostr:CONSTANT; long str :CONSTANT; longstr :CONSTANT char* queryExistPasswords();
   CONSTANT bool queryPasswordIsUsed(char* passwordName);
   PAYABLE void payByPassword(char* passwordName);
   PAYABLE void depositeContract();
   EXPORT void setExpireTime(uint64_t _expireTime);
};

DIPC_EVENT(expireTimeSetted,uint64_t);
DIPC_EVENT(depositingValue,uint64_t);
DIPC_EVENT(ErrEvent, const char*, const char*);
DIPC_EVENT(registerPasswordEvent, const char*, const char*, const char*);
DIPC_EVENT(payByPasswordEvent, const char*, uint64_t);



2019-12-31_16:55:58.189938: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/tools/abi/AbiMacro.cpp:82] smatch[2].str : queryExistPasswords(; action : queryExistPasswords

2019-12-31_16:55:58.189949: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/tools/abi/AbiMacro.cpp:149] get macro:CONSTANT
2019-12-31_16:55:58.189960: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/tools/abi/AbiMacro.cpp:67] file_name : /Users/konggan/workspace/chain/dipperin/github-dipc/dipc/testcontract/PasswordManage/PasswordManage.hpp

2019-12-31_16:55:58.189970: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/tools/abi/AbiMacro.cpp:68] Export macrostr:CONSTANT; long str :CONSTANT; longstr :CONSTANT bool queryPasswordIsUsed(char* passwordName);
   PAYABLE void payByPassword(char* passwordName);
   PAYABLE void depositeContract();
   EXPORT void setExpireTime(uint64_t _expireTime);
};

DIPC_EVENT(expireTimeSetted,uint64_t);
DIPC_EVENT(depositingValue,uint64_t);
DIPC_EVENT(ErrEvent, const char*, const char*);
DIPC_EVENT(registerPasswordEvent, const char*, const char*, const char*);
DIPC_EVENT(payByPasswordEvent, const char*, uint64_t);



2019-12-31_16:55:58.189996: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/tools/abi/AbiMacro.cpp:82] smatch[2].str : queryPasswordIsUsed(; action : queryPasswordIsUsed

2019-12-31_16:55:58.190007: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/tools/abi/AbiMacro.cpp:149] get macro:PAYABLE
2019-12-31_16:55:58.190013: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/tools/abi/AbiMacro.cpp:67] file_name : /Users/konggan/workspace/chain/dipperin/github-dipc/dipc/testcontract/PasswordManage/PasswordManage.hpp

2019-12-31_16:55:58.190019: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/tools/abi/AbiMacro.cpp:68] Export macrostr:PAYABLE; long str :PAYABLE; longstr :PAYABLE void payByPassword(char* passwordName);
   PAYABLE void depositeContract();
   EXPORT void setExpireTime(uint64_t _expireTime);
};

DIPC_EVENT(expireTimeSetted,uint64_t);
DIPC_EVENT(depositingValue,uint64_t);
DIPC_EVENT(ErrEvent, const char*, const char*);
DIPC_EVENT(registerPasswordEvent, const char*, const char*, const char*);
DIPC_EVENT(payByPasswordEvent, const char*, uint64_t);



2019-12-31_16:55:58.190042: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/tools/abi/AbiMacro.cpp:82] smatch[2].str : payByPassword(; action : payByPassword

2019-12-31_16:55:58.190052: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/tools/abi/AbiMacro.cpp:149] get macro:PAYABLE
2019-12-31_16:55:58.190058: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/tools/abi/AbiMacro.cpp:67] file_name : /Users/konggan/workspace/chain/dipperin/github-dipc/dipc/testcontract/PasswordManage/PasswordManage.hpp

2019-12-31_16:55:58.190064: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/tools/abi/AbiMacro.cpp:68] Export macrostr:PAYABLE; long str :PAYABLE; longstr :PAYABLE void depositeContract();
   EXPORT void setExpireTime(uint64_t _expireTime);
};

DIPC_EVENT(expireTimeSetted,uint64_t);
DIPC_EVENT(depositingValue,uint64_t);
DIPC_EVENT(ErrEvent, const char*, const char*);
DIPC_EVENT(registerPasswordEvent, const char*, const char*, const char*);
DIPC_EVENT(payByPasswordEvent, const char*, uint64_t);



2019-12-31_16:55:58.190082: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/tools/abi/AbiMacro.cpp:82] smatch[2].str : depositeContract(; action : depositeContract

2019-12-31_16:55:58.190091: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/tools/abi/AbiMacro.cpp:149] get macro:EXPORT
2019-12-31_16:55:58.190098: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/tools/abi/AbiMacro.cpp:67] file_name : /Users/konggan/workspace/chain/dipperin/github-dipc/dipc/testcontract/PasswordManage/PasswordManage.hpp

2019-12-31_16:55:58.190103: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/tools/abi/AbiMacro.cpp:68] Export macrostr:EXPORT; long str :EXPORT; longstr :EXPORT void setExpireTime(uint64_t _expireTime);
};

DIPC_EVENT(expireTimeSetted,uint64_t);
DIPC_EVENT(depositingValue,uint64_t);
DIPC_EVENT(ErrEvent, const char*, const char*);
DIPC_EVENT(registerPasswordEvent, const char*, const char*, const char*);
DIPC_EVENT(payByPasswordEvent, const char*, uint64_t);



2019-12-31_16:55:58.190132: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/tools/abi/AbiMacro.cpp:82] smatch[2].str : setExpireTime(; action : setExpireTime

2019-12-31_16:55:58.190147: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/tools/abi/AbiMacro.cpp:143] get EVENT:DIPC_EVENT
2019-12-31_16:55:58.190247: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/tools/abi/AbiMacro.cpp:143] get EVENT:DIPC_EVENT
2019-12-31_16:55:58.190324: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/tools/abi/AbiMacro.cpp:143] get EVENT:DIPC_EVENT
2019-12-31_16:55:58.190452: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/tools/abi/AbiMacro.cpp:143] get EVENT:DIPC_EVENT
2019-12-31_16:55:58.190633: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/tools/abi/AbiMacro.cpp:143] get EVENT:DIPC_EVENT
2019-12-31_16:55:58.190752: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/tools/abi/AbiMacro.cpp:149] get macro:PAYABLE
2019-12-31_16:55:58.190765: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/tools/abi/AbiMacro.cpp:67] file_name : /Users/konggan/workspace/chain/dipperin/github-dipc/dipc/testcontract/PasswordManage/PasswordManage.cpp

2019-12-31_16:55:58.190772: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/tools/abi/AbiMacro.cpp:68] Export macrostr:PAYABLE; long str :PAYABLE; longstr :PAYABLE void PasswordManage::init(){
    std::string ownerStr = caller().toString();
    *owner = ownerStr;
}
/**
 *  _balance: unit is DIP
 */ 
EXPORT void PasswordManage::registerPassword(char* passwordName, char* toAddr, uint64_t _balance){
    PasswordInfo info(passwordName, toAddr, _balance, dipc::timestamp());
    std::string pInfo = info.toJson();
    if (passwordStore.get()[passwordName] != "") {
        DIPC_EMIT_EVENT(ErrEvent, "registerPassword  password exist", passwordName);
        return;
    }
    (*passwordStore)[passwordName] = pInfo;
    print("registerPassword pInfo");
    print(pInfo);
    std::string callerStr = dipc::caller().toString();
    DIPC_EMIT_EVENT(registerPasswordEvent, &callerStr[0], passwordName, &pInfo[0]);
}
CONSTANT char* PasswordManage::queryExistPasswords(){
    std::map<std::string, std::string>::iterator iter;
    auto mapStore = passwordStore.get();
    iter = mapStore.begin();
    std::string result = "[";
    print("queryExistPasswords start");
    while(iter != mapStore.end()){
        result += iter->first + ","; 
        iter++;
    }
    print("queryExistPasswords end");

    result.substr(0,result.size()-1);
    result += "]";
    print("queryExistPasswords  result");
    print(result);
    return &result[0];
}
CONSTANT bool PasswordManage::queryPasswordIsUsed(char* passwordName){
     if (passwordStore.get()[passwordName] != "") {
        return true;
    }
    return false;
}
PAYABLE void PasswordManage::payByPassword(char* passwordName){
    std::string pInfo = passwordStore.get()[passwordName];
    PasswordInfo pwInfo;
    pwInfo.parseJson(pInfo);
    print("pwInfo");
    print(pwInfo.toJson());
    uint64_t transferValue = dipc::callValueUDIP();
    print("transferValue");
    print(transferValue);
    print(pwInfo.balance);
    if(dipc::timestamp() >=  expireTime.get() + pwInfo.timeRegistered){
        DipcAssert(transferValue / 1000 == pwInfo.balance);
        Address toAddr = Address(pwInfo.toAddr,22);
        callTransferUDIP(toAddr, transferValue);
        DIPC_EMIT_EVENT(payByPasswordEvent, passwordName,  transferValue * 1000);
    } else {
        DIPC_EMIT_EVENT(ErrEvent, "payByPassword  password exist", passwordName);
    }
    //DipcAssert( );
    (*passwordStore).erase(passwordName);
    (*passwordStoreHis)[std::string(passwordName)+"_"+pwInfo.toAddr+"_"+std::to_string(pwInfo.timeRegistered)] = pInfo;
}
/**
* @brief deposite dip to the contract addr, the deposite value shouldn't be less than 0.001DIP
*/ 
PAYABLE void PasswordManage::depositeContract(){
    uint64_t value = dipc::callValueUDIP() * 1000;
    DIPC_EMIT_EVENT(depositingValue,value);
}
/**
* @brief set the unification expire time of the password
* @param _expireTime: the expire time of the password,the unit is hour
*/ 
EXPORT void PasswordManage::setExpireTime(uint64_t _expireTime){
    // math.pow() function hasn't effort is vm, so ....
    *expireTime = _expireTime * 60 * 60 * 1000000000;
    DIPC_EMIT_EVENT(expireTimeSetted,expireTime.get());
}
2019-12-31_16:55:58.190799: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/tools/abi/AbiMacro.cpp:82] smatch[2].str : PasswordManage::init(; action : PasswordManage::init

2019-12-31_16:55:58.190806: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/tools/abi/AbiMacro.cpp:131] Export macrostr:PAYABLE  contract:void  actions_str:init

2019-12-31_16:55:58.190820: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/tools/abi/AbiMacro.cpp:149] get macro:EXPORT
2019-12-31_16:55:58.190826: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/tools/abi/AbiMacro.cpp:67] file_name : /Users/konggan/workspace/chain/dipperin/github-dipc/dipc/testcontract/PasswordManage/PasswordManage.cpp

2019-12-31_16:55:58.190832: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/tools/abi/AbiMacro.cpp:68] Export macrostr:EXPORT; long str :EXPORT; longstr :EXPORT void PasswordManage::registerPassword(char* passwordName, char* toAddr, uint64_t _balance){
    PasswordInfo info(passwordName, toAddr, _balance, dipc::timestamp());
    std::string pInfo = info.toJson();
    if (passwordStore.get()[passwordName] != "") {
        DIPC_EMIT_EVENT(ErrEvent, "registerPassword  password exist", passwordName);
        return;
    }
    (*passwordStore)[passwordName] = pInfo;
    print("registerPassword pInfo");
    print(pInfo);
    std::string callerStr = dipc::caller().toString();
    DIPC_EMIT_EVENT(registerPasswordEvent, &callerStr[0], passwordName, &pInfo[0]);
}
CONSTANT char* PasswordManage::queryExistPasswords(){
    std::map<std::string, std::string>::iterator iter;
    auto mapStore = passwordStore.get();
    iter = mapStore.begin();
    std::string result = "[";
    print("queryExistPasswords start");
    while(iter != mapStore.end()){
        result += iter->first + ","; 
        iter++;
    }
    print("queryExistPasswords end");

    result.substr(0,result.size()-1);
    result += "]";
    print("queryExistPasswords  result");
    print(result);
    return &result[0];
}
CONSTANT bool PasswordManage::queryPasswordIsUsed(char* passwordName){
     if (passwordStore.get()[passwordName] != "") {
        return true;
    }
    return false;
}
PAYABLE void PasswordManage::payByPassword(char* passwordName){
    std::string pInfo = passwordStore.get()[passwordName];
    PasswordInfo pwInfo;
    pwInfo.parseJson(pInfo);
    print("pwInfo");
    print(pwInfo.toJson());
    uint64_t transferValue = dipc::callValueUDIP();
    print("transferValue");
    print(transferValue);
    print(pwInfo.balance);
    if(dipc::timestamp() >=  expireTime.get() + pwInfo.timeRegistered){
        DipcAssert(transferValue / 1000 == pwInfo.balance);
        Address toAddr = Address(pwInfo.toAddr,22);
        callTransferUDIP(toAddr, transferValue);
        DIPC_EMIT_EVENT(payByPasswordEvent, passwordName,  transferValue * 1000);
    } else {
        DIPC_EMIT_EVENT(ErrEvent, "payByPassword  password exist", passwordName);
    }
    //DipcAssert( );
    (*passwordStore).erase(passwordName);
    (*passwordStoreHis)[std::string(passwordName)+"_"+pwInfo.toAddr+"_"+std::to_string(pwInfo.timeRegistered)] = pInfo;
}
/**
* @brief deposite dip to the contract addr, the deposite value shouldn't be less than 0.001DIP
*/ 
PAYABLE void PasswordManage::depositeContract(){
    uint64_t value = dipc::callValueUDIP() * 1000;
    DIPC_EMIT_EVENT(depositingValue,value);
}
/**
* @brief set the unification expire time of the password
* @param _expireTime: the expire time of the password,the unit is hour
*/ 
EXPORT void PasswordManage::setExpireTime(uint64_t _expireTime){
    // math.pow() function hasn't effort is vm, so ....
    *expireTime = _expireTime * 60 * 60 * 1000000000;
    DIPC_EMIT_EVENT(expireTimeSetted,expireTime.get());
}
2019-12-31_16:55:58.190879: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/tools/abi/AbiMacro.cpp:82] smatch[2].str : PasswordManage::registerPassword(; action : PasswordManage::registerPassword

2019-12-31_16:55:58.190888: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/tools/abi/AbiMacro.cpp:131] Export macrostr:EXPORT  contract:void  actions_str:registerPassword

2019-12-31_16:55:58.190914: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/tools/abi/AbiMacro.cpp:149] get macro:CONSTANT
2019-12-31_16:55:58.190921: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/tools/abi/AbiMacro.cpp:67] file_name : /Users/konggan/workspace/chain/dipperin/github-dipc/dipc/testcontract/PasswordManage/PasswordManage.cpp

2019-12-31_16:55:58.190927: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/tools/abi/AbiMacro.cpp:68] Export macrostr:CONSTANT; long str :CONSTANT; longstr :CONSTANT char* PasswordManage::queryExistPasswords(){
    std::map<std::string, std::string>::iterator iter;
    auto mapStore = passwordStore.get();
    iter = mapStore.begin();
    std::string result = "[";
    print("queryExistPasswords start");
    while(iter != mapStore.end()){
        result += iter->first + ","; 
        iter++;
    }
    print("queryExistPasswords end");

    result.substr(0,result.size()-1);
    result += "]";
    print("queryExistPasswords  result");
    print(result);
    return &result[0];
}
CONSTANT bool PasswordManage::queryPasswordIsUsed(char* passwordName){
     if (passwordStore.get()[passwordName] != "") {
        return true;
    }
    return false;
}
PAYABLE void PasswordManage::payByPassword(char* passwordName){
    std::string pInfo = passwordStore.get()[passwordName];
    PasswordInfo pwInfo;
    pwInfo.parseJson(pInfo);
    print("pwInfo");
    print(pwInfo.toJson());
    uint64_t transferValue = dipc::callValueUDIP();
    print("transferValue");
    print(transferValue);
    print(pwInfo.balance);
    if(dipc::timestamp() >=  expireTime.get() + pwInfo.timeRegistered){
        DipcAssert(transferValue / 1000 == pwInfo.balance);
        Address toAddr = Address(pwInfo.toAddr,22);
        callTransferUDIP(toAddr, transferValue);
        DIPC_EMIT_EVENT(payByPasswordEvent, passwordName,  transferValue * 1000);
    } else {
        DIPC_EMIT_EVENT(ErrEvent, "payByPassword  password exist", passwordName);
    }
    //DipcAssert( );
    (*passwordStore).erase(passwordName);
    (*passwordStoreHis)[std::string(passwordName)+"_"+pwInfo.toAddr+"_"+std::to_string(pwInfo.timeRegistered)] = pInfo;
}
/**
* @brief deposite dip to the contract addr, the deposite value shouldn't be less than 0.001DIP
*/ 
PAYABLE void PasswordManage::depositeContract(){
    uint64_t value = dipc::callValueUDIP() * 1000;
    DIPC_EMIT_EVENT(depositingValue,value);
}
/**
* @brief set the unification expire time of the password
* @param _expireTime: the expire time of the password,the unit is hour
*/ 
EXPORT void PasswordManage::setExpireTime(uint64_t _expireTime){
    // math.pow() function hasn't effort is vm, so ....
    *expireTime = _expireTime * 60 * 60 * 1000000000;
    DIPC_EMIT_EVENT(expireTimeSetted,expireTime.get());
}
2019-12-31_16:55:58.190952: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/tools/abi/AbiMacro.cpp:82] smatch[2].str : PasswordManage::queryExistPasswords(; action : PasswordManage::queryExistPasswords

2019-12-31_16:55:58.190960: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/tools/abi/AbiMacro.cpp:131] Export macrostr:CONSTANT  contract:char*  actions_str:queryExistPasswords

2019-12-31_16:55:58.190976: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/tools/abi/AbiMacro.cpp:149] get macro:CONSTANT
2019-12-31_16:55:58.190982: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/tools/abi/AbiMacro.cpp:67] file_name : /Users/konggan/workspace/chain/dipperin/github-dipc/dipc/testcontract/PasswordManage/PasswordManage.cpp

2019-12-31_16:55:58.190992: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/tools/abi/AbiMacro.cpp:68] Export macrostr:CONSTANT; long str :CONSTANT; longstr :CONSTANT bool PasswordManage::queryPasswordIsUsed(char* passwordName){
     if (passwordStore.get()[passwordName] != "") {
        return true;
    }
    return false;
}
PAYABLE void PasswordManage::payByPassword(char* passwordName){
    std::string pInfo = passwordStore.get()[passwordName];
    PasswordInfo pwInfo;
    pwInfo.parseJson(pInfo);
    print("pwInfo");
    print(pwInfo.toJson());
    uint64_t transferValue = dipc::callValueUDIP();
    print("transferValue");
    print(transferValue);
    print(pwInfo.balance);
    if(dipc::timestamp() >=  expireTime.get() + pwInfo.timeRegistered){
        DipcAssert(transferValue / 1000 == pwInfo.balance);
        Address toAddr = Address(pwInfo.toAddr,22);
        callTransferUDIP(toAddr, transferValue);
        DIPC_EMIT_EVENT(payByPasswordEvent, passwordName,  transferValue * 1000);
    } else {
        DIPC_EMIT_EVENT(ErrEvent, "payByPassword  password exist", passwordName);
    }
    //DipcAssert( );
    (*passwordStore).erase(passwordName);
    (*passwordStoreHis)[std::string(passwordName)+"_"+pwInfo.toAddr+"_"+std::to_string(pwInfo.timeRegistered)] = pInfo;
}
/**
* @brief deposite dip to the contract addr, the deposite value shouldn't be less than 0.001DIP
*/ 
PAYABLE void PasswordManage::depositeContract(){
    uint64_t value = dipc::callValueUDIP() * 1000;
    DIPC_EMIT_EVENT(depositingValue,value);
}
/**
* @brief set the unification expire time of the password
* @param _expireTime: the expire time of the password,the unit is hour
*/ 
EXPORT void PasswordManage::setExpireTime(uint64_t _expireTime){
    // math.pow() function hasn't effort is vm, so ....
    *expireTime = _expireTime * 60 * 60 * 1000000000;
    DIPC_EMIT_EVENT(expireTimeSetted,expireTime.get());
}
2019-12-31_16:55:58.191023: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/tools/abi/AbiMacro.cpp:82] smatch[2].str : PasswordManage::queryPasswordIsUsed(; action : PasswordManage::queryPasswordIsUsed

2019-12-31_16:55:58.191030: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/tools/abi/AbiMacro.cpp:131] Export macrostr:CONSTANT  contract:bool  actions_str:queryPasswordIsUsed

2019-12-31_16:55:58.191042: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/tools/abi/AbiMacro.cpp:149] get macro:PAYABLE
2019-12-31_16:55:58.191048: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/tools/abi/AbiMacro.cpp:67] file_name : /Users/konggan/workspace/chain/dipperin/github-dipc/dipc/testcontract/PasswordManage/PasswordManage.cpp

2019-12-31_16:55:58.191054: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/tools/abi/AbiMacro.cpp:68] Export macrostr:PAYABLE; long str :PAYABLE; longstr :PAYABLE void PasswordManage::payByPassword(char* passwordName){
    std::string pInfo = passwordStore.get()[passwordName];
    PasswordInfo pwInfo;
    pwInfo.parseJson(pInfo);
    print("pwInfo");
    print(pwInfo.toJson());
    uint64_t transferValue = dipc::callValueUDIP();
    print("transferValue");
    print(transferValue);
    print(pwInfo.balance);
    if(dipc::timestamp() >=  expireTime.get() + pwInfo.timeRegistered){
        DipcAssert(transferValue / 1000 == pwInfo.balance);
        Address toAddr = Address(pwInfo.toAddr,22);
        callTransferUDIP(toAddr, transferValue);
        DIPC_EMIT_EVENT(payByPasswordEvent, passwordName,  transferValue * 1000);
    } else {
        DIPC_EMIT_EVENT(ErrEvent, "payByPassword  password exist", passwordName);
    }
    //DipcAssert( );
    (*passwordStore).erase(passwordName);
    (*passwordStoreHis)[std::string(passwordName)+"_"+pwInfo.toAddr+"_"+std::to_string(pwInfo.timeRegistered)] = pInfo;
}
/**
* @brief deposite dip to the contract addr, the deposite value shouldn't be less than 0.001DIP
*/ 
PAYABLE void PasswordManage::depositeContract(){
    uint64_t value = dipc::callValueUDIP() * 1000;
    DIPC_EMIT_EVENT(depositingValue,value);
}
/**
* @brief set the unification expire time of the password
* @param _expireTime: the expire time of the password,the unit is hour
*/ 
EXPORT void PasswordManage::setExpireTime(uint64_t _expireTime){
    // math.pow() function hasn't effort is vm, so ....
    *expireTime = _expireTime * 60 * 60 * 1000000000;
    DIPC_EMIT_EVENT(expireTimeSetted,expireTime.get());
}
2019-12-31_16:55:58.191086: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/tools/abi/AbiMacro.cpp:82] smatch[2].str : PasswordManage::payByPassword(; action : PasswordManage::payByPassword

2019-12-31_16:55:58.191093: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/tools/abi/AbiMacro.cpp:131] Export macrostr:PAYABLE  contract:void  actions_str:payByPassword

2019-12-31_16:55:58.191131: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/tools/abi/AbiMacro.cpp:149] get macro:PAYABLE
2019-12-31_16:55:58.191138: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/tools/abi/AbiMacro.cpp:67] file_name : /Users/konggan/workspace/chain/dipperin/github-dipc/dipc/testcontract/PasswordManage/PasswordManage.cpp

2019-12-31_16:55:58.191144: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/tools/abi/AbiMacro.cpp:68] Export macrostr:PAYABLE; long str :PAYABLE; longstr :PAYABLE void PasswordManage::depositeContract(){
    uint64_t value = dipc::callValueUDIP() * 1000;
    DIPC_EMIT_EVENT(depositingValue,value);
}
/**
* @brief set the unification expire time of the password
* @param _expireTime: the expire time of the password,the unit is hour
*/ 
EXPORT void PasswordManage::setExpireTime(uint64_t _expireTime){
    // math.pow() function hasn't effort is vm, so ....
    *expireTime = _expireTime * 60 * 60 * 1000000000;
    DIPC_EMIT_EVENT(expireTimeSetted,expireTime.get());
}
2019-12-31_16:55:58.191168: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/tools/abi/AbiMacro.cpp:82] smatch[2].str : PasswordManage::depositeContract(; action : PasswordManage::depositeContract

2019-12-31_16:55:58.191175: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/tools/abi/AbiMacro.cpp:131] Export macrostr:PAYABLE  contract:void  actions_str:depositeContract

2019-12-31_16:55:58.191189: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/tools/abi/AbiMacro.cpp:149] get macro:EXPORT
2019-12-31_16:55:58.191196: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/tools/abi/AbiMacro.cpp:67] file_name : /Users/konggan/workspace/chain/dipperin/github-dipc/dipc/testcontract/PasswordManage/PasswordManage.cpp

2019-12-31_16:55:58.191202: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/tools/abi/AbiMacro.cpp:68] Export macrostr:EXPORT; long str :EXPORT; longstr :EXPORT void PasswordManage::setExpireTime(uint64_t _expireTime){
    // math.pow() function hasn't effort is vm, so ....
    *expireTime = _expireTime * 60 * 60 * 1000000000;
    DIPC_EMIT_EVENT(expireTimeSetted,expireTime.get());
}
2019-12-31_16:55:58.191231: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/tools/abi/AbiMacro.cpp:82] smatch[2].str : PasswordManage::setExpireTime(; action : PasswordManage::setExpireTime

2019-12-31_16:55:58.191237: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/tools/abi/AbiMacro.cpp:131] Export macrostr:EXPORT  contract:void  actions_str:setExpireTime

2019-12-31_16:55:58.194987: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:1125] result:0contract fullname:[PasswordManage]
2019-12-31_16:55:59.907586: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/tools/abi/AbiGenerator.cpp:109] contract != Token
2019-12-31_16:55:59.907609: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/tools/abi/AbiGenerator.cpp:111] decl name:[PasswordManage] contract:[PasswordManage]
2019-12-31_16:55:59.907621: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/tools/abi/AbiGenerator.cpp:119] funcEntire : void isOwner(){
        std::string callerStr = caller().toString();
        std::string ownerStr = owner.get();
        DipcAssert(callerStr == owner.get());
    ; funcEnd : }

public:
   PAYABLE void init();
   EXPORT void registerPassword(char* passwordName, char* passwordAddr, uint64_t _balance);
   CONSTANT char* queryExistPasswords();
   CONSTANT bool queryPasswordIsUsed(char* passwordName);
   PAYABLE void payByPassword(char* passwordName);
   PAYABLE void depositeContract();
   EXPORT void setExpireTime(uint64_t _expireTime);
};

DIPC_EVENT(expireTimeSetted,uint64_t);
DIPC_EVENT(depositingValue,uint64_t);
DIPC_EVENT(ErrEvent, const char*, const char*);
DIPC_EVENT(registerPasswordEvent, const char*, const char*, const char*);
DIPC_EVENT(payByPasswordEvent, const char*, uint64_t);



2019-12-31_16:55:59.907635: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/tools/abi/AbiGenerator.cpp:119] funcEntire : void init(; funcEnd : );
   EXPORT void registerPassword(char* passwordName, char* passwordAddr, uint64_t _balance);
   CONSTANT char* queryExistPasswords();
   CONSTANT bool queryPasswordIsUsed(char* passwordName);
   PAYABLE void payByPassword(char* passwordName);
   PAYABLE void depositeContract();
   EXPORT void setExpireTime(uint64_t _expireTime);
};

DIPC_EVENT(expireTimeSetted,uint64_t);
DIPC_EVENT(depositingValue,uint64_t);
DIPC_EVENT(ErrEvent, const char*, const char*);
DIPC_EVENT(registerPasswordEvent, const char*, const char*, const char*);
DIPC_EVENT(payByPasswordEvent, const char*, uint64_t);



2019-12-31_16:55:59.907643: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/tools/abi/AbiGenerator.cpp:124] method :init
2019-12-31_16:55:59.907649: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/tools/abi/AbiGenerator.cpp:145] abi.methodName : init; abi.isConst : false; abi.isPayable :true; abi.isExport :false
2019-12-31_16:55:59.907670: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/tools/abi/AbiGenerator.cpp:47] typeName:  realTypeName:void
2019-12-31_16:55:59.907679: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/tools/abi/AbiGenerator.cpp:119] funcEntire : void registerPassword(char* passwordName, char* passwordAddr, uint64_t _balance; funcEnd : );
   CONSTANT char* queryExistPasswords();
   CONSTANT bool queryPasswordIsUsed(char* passwordName);
   PAYABLE void payByPassword(char* passwordName);
   PAYABLE void depositeContract();
   EXPORT void setExpireTime(uint64_t _expireTime);
};

DIPC_EVENT(expireTimeSetted,uint64_t);
DIPC_EVENT(depositingValue,uint64_t);
DIPC_EVENT(ErrEvent, const char*, const char*);
DIPC_EVENT(registerPasswordEvent, const char*, const char*, const char*);
DIPC_EVENT(payByPasswordEvent, const char*, uint64_t);



2019-12-31_16:55:59.907685: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/tools/abi/AbiGenerator.cpp:124] method :registerPassword
2019-12-31_16:55:59.907692: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/tools/abi/AbiGenerator.cpp:145] abi.methodName : registerPassword; abi.isConst : false; abi.isPayable :false; abi.isExport :true
2019-12-31_16:55:59.907702: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/tools/abi/AbiGenerator.cpp:47] typeName:  realTypeName:void
2019-12-31_16:55:59.907708: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/tools/abi/AbiGenerator.cpp:160] parame name:passwordName
2019-12-31_16:55:59.907720: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/tools/abi/AbiGenerator.cpp:47] typeName:  realTypeName:char *
2019-12-31_16:55:59.907749: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/tools/abi/AbiGenerator.cpp:160] parame name:passwordAddr
2019-12-31_16:55:59.907760: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/tools/abi/AbiGenerator.cpp:47] typeName:  realTypeName:char *
2019-12-31_16:55:59.907783: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/tools/abi/AbiGenerator.cpp:160] parame name:_balance
2019-12-31_16:55:59.907793: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/tools/abi/AbiGenerator.cpp:26] xxx:uint64_t
2019-12-31_16:55:59.907799: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/tools/abi/AbiGenerator.cpp:28] set typeName
2019-12-31_16:55:59.907811: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/tools/abi/AbiGenerator.cpp:47] typeName:uint64_t  realTypeName:unsigned long long
2019-12-31_16:55:59.907835: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/tools/abi/AbiGenerator.cpp:119] funcEntire : char* queryExistPasswords(; funcEnd : );
   CONSTANT bool queryPasswordIsUsed(char* passwordName);
   PAYABLE void payByPassword(char* passwordName);
   PAYABLE void depositeContract();
   EXPORT void setExpireTime(uint64_t _expireTime);
};

DIPC_EVENT(expireTimeSetted,uint64_t);
DIPC_EVENT(depositingValue,uint64_t);
DIPC_EVENT(ErrEvent, const char*, const char*);
DIPC_EVENT(registerPasswordEvent, const char*, const char*, const char*);
DIPC_EVENT(payByPasswordEvent, const char*, uint64_t);



2019-12-31_16:55:59.907841: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/tools/abi/AbiGenerator.cpp:124] method :queryExistPasswords
2019-12-31_16:55:59.907847: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/tools/abi/AbiGenerator.cpp:145] abi.methodName : queryExistPasswords; abi.isConst : true; abi.isPayable :false; abi.isExport :false
2019-12-31_16:55:59.907859: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/tools/abi/AbiGenerator.cpp:47] typeName:  realTypeName:char *
2019-12-31_16:55:59.907866: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/tools/abi/AbiGenerator.cpp:119] funcEntire : bool queryPasswordIsUsed(char* passwordName; funcEnd : );
   PAYABLE void payByPassword(char* passwordName);
   PAYABLE void depositeContract();
   EXPORT void setExpireTime(uint64_t _expireTime);
};

DIPC_EVENT(expireTimeSetted,uint64_t);
DIPC_EVENT(depositingValue,uint64_t);
DIPC_EVENT(ErrEvent, const char*, const char*);
DIPC_EVENT(registerPasswordEvent, const char*, const char*, const char*);
DIPC_EVENT(payByPasswordEvent, const char*, uint64_t);



2019-12-31_16:55:59.907872: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/tools/abi/AbiGenerator.cpp:124] method :queryPasswordIsUsed
2019-12-31_16:55:59.907878: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/tools/abi/AbiGenerator.cpp:145] abi.methodName : queryPasswordIsUsed; abi.isConst : true; abi.isPayable :false; abi.isExport :false
2019-12-31_16:55:59.907888: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/tools/abi/AbiGenerator.cpp:47] typeName:  realTypeName:_Bool
2019-12-31_16:55:59.907894: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/tools/abi/AbiGenerator.cpp:160] parame name:passwordName
2019-12-31_16:55:59.907904: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/tools/abi/AbiGenerator.cpp:47] typeName:  realTypeName:char *
2019-12-31_16:55:59.907932: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/tools/abi/AbiGenerator.cpp:119] funcEntire : void payByPassword(char* passwordName; funcEnd : );
   PAYABLE void depositeContract();
   EXPORT void setExpireTime(uint64_t _expireTime);
};

DIPC_EVENT(expireTimeSetted,uint64_t);
DIPC_EVENT(depositingValue,uint64_t);
DIPC_EVENT(ErrEvent, const char*, const char*);
DIPC_EVENT(registerPasswordEvent, const char*, const char*, const char*);
DIPC_EVENT(payByPasswordEvent, const char*, uint64_t);



2019-12-31_16:55:59.907959: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/tools/abi/AbiGenerator.cpp:124] method :payByPassword
2019-12-31_16:55:59.907965: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/tools/abi/AbiGenerator.cpp:145] abi.methodName : payByPassword; abi.isConst : false; abi.isPayable :true; abi.isExport :false
2019-12-31_16:55:59.907975: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/tools/abi/AbiGenerator.cpp:47] typeName:  realTypeName:void
2019-12-31_16:55:59.907985: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/tools/abi/AbiGenerator.cpp:160] parame name:passwordName
2019-12-31_16:55:59.907997: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/tools/abi/AbiGenerator.cpp:47] typeName:  realTypeName:char *
2019-12-31_16:55:59.908022: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/tools/abi/AbiGenerator.cpp:119] funcEntire : void depositeContract(; funcEnd : );
   EXPORT void setExpireTime(uint64_t _expireTime);
};

DIPC_EVENT(expireTimeSetted,uint64_t);
DIPC_EVENT(depositingValue,uint64_t);
DIPC_EVENT(ErrEvent, const char*, const char*);
DIPC_EVENT(registerPasswordEvent, const char*, const char*, const char*);
DIPC_EVENT(payByPasswordEvent, const char*, uint64_t);



2019-12-31_16:55:59.908029: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/tools/abi/AbiGenerator.cpp:124] method :depositeContract
2019-12-31_16:55:59.908049: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/tools/abi/AbiGenerator.cpp:145] abi.methodName : depositeContract; abi.isConst : false; abi.isPayable :true; abi.isExport :false
2019-12-31_16:55:59.908059: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/tools/abi/AbiGenerator.cpp:47] typeName:  realTypeName:void
2019-12-31_16:55:59.908065: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/tools/abi/AbiGenerator.cpp:119] funcEntire : void setExpireTime(uint64_t _expireTime; funcEnd : );
};

DIPC_EVENT(expireTimeSetted,uint64_t);
DIPC_EVENT(depositingValue,uint64_t);
DIPC_EVENT(ErrEvent, const char*, const char*);
DIPC_EVENT(registerPasswordEvent, const char*, const char*, const char*);
DIPC_EVENT(payByPasswordEvent, const char*, uint64_t);



2019-12-31_16:55:59.908071: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/tools/abi/AbiGenerator.cpp:124] method :setExpireTime
2019-12-31_16:55:59.908077: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/tools/abi/AbiGenerator.cpp:145] abi.methodName : setExpireTime; abi.isConst : false; abi.isPayable :false; abi.isExport :true
2019-12-31_16:55:59.908086: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/tools/abi/AbiGenerator.cpp:47] typeName:  realTypeName:void
2019-12-31_16:55:59.908092: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/tools/abi/AbiGenerator.cpp:160] parame name:_expireTime
2019-12-31_16:55:59.908098: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/tools/abi/AbiGenerator.cpp:26] xxx:uint64_t
2019-12-31_16:55:59.908103: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/tools/abi/AbiGenerator.cpp:28] set typeName
2019-12-31_16:55:59.908115: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/tools/abi/AbiGenerator.cpp:47] typeName:uint64_t  realTypeName:unsigned long long
2019-12-31_16:55:59.908138: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/tools/abi/AbiGenerator.cpp:119] funcEntire : ; funcEnd : PasswordManage : public Contract {
private:
    Uint64<expireTimec> expireTime;
    Map<passwordStorec, std::string, std::string> passwordStore;
    Map<passwordStoreHisc, std::string, std::string> passwordStoreHis;
    String<ownerc> owner;

    void isOwner(){
        std::string callerStr = caller().toString();
        std::string ownerStr = owner.get();
        DipcAssert(callerStr == owner.get());
    }

public:
   PAYABLE void init();
   EXPORT void registerPassword(char* passwordName, char* passwordAddr, uint64_t _balance);
   CONSTANT char* queryExistPasswords();
   CONSTANT bool queryPasswordIsUsed(char* passwordName);
   PAYABLE void payByPassword(char* passwordName);
   PAYABLE void depositeContract();
   EXPORT void setExpireTime(uint64_t _expireTime);
};

DIPC_EVENT(expireTimeSetted,uint64_t);
DIPC_EVENT(depositingValue,uint64_t);
DIPC_EVENT(ErrEvent, const char*, const char*);
DIPC_EVENT(registerPasswordEvent, const char*, const char*, const char*);
DIPC_EVENT(payByPasswordEvent, const char*, uint64_t);



2019-12-31_16:55:59.908149: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/tools/abi/AbiGenerator.cpp:119] funcEntire : ; funcEnd : PasswordManage : public Contract {
private:
    Uint64<expireTimec> expireTime;
    Map<passwordStorec, std::string, std::string> passwordStore;
    Map<passwordStoreHisc, std::string, std::string> passwordStoreHis;
    String<ownerc> owner;

    void isOwner(){
        std::string callerStr = caller().toString();
        std::string ownerStr = owner.get();
        DipcAssert(callerStr == owner.get());
    }

public:
   PAYABLE void init();
   EXPORT void registerPassword(char* passwordName, char* passwordAddr, uint64_t _balance);
   CONSTANT char* queryExistPasswords();
   CONSTANT bool queryPasswordIsUsed(char* passwordName);
   PAYABLE void payByPassword(char* passwordName);
   PAYABLE void depositeContract();
   EXPORT void setExpireTime(uint64_t _expireTime);
};

DIPC_EVENT(expireTimeSetted,uint64_t);
DIPC_EVENT(depositingValue,uint64_t);
DIPC_EVENT(ErrEvent, const char*, const char*);
DIPC_EVENT(registerPasswordEvent, const char*, const char*, const char*);
DIPC_EVENT(payByPasswordEvent, const char*, uint64_t);



2019-12-31_16:55:59.908156: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/tools/abi/AbiGenerator.cpp:119] funcEntire : ; funcEnd : PasswordManage : public Contract {
private:
    Uint64<expireTimec> expireTime;
    Map<passwordStorec, std::string, std::string> passwordStore;
    Map<passwordStoreHisc, std::string, std::string> passwordStoreHis;
    String<ownerc> owner;

    void isOwner(){
        std::string callerStr = caller().toString();
        std::string ownerStr = owner.get();
        DipcAssert(callerStr == owner.get());
    }

public:
   PAYABLE void init();
   EXPORT void registerPassword(char* passwordName, char* passwordAddr, uint64_t _balance);
   CONSTANT char* queryExistPasswords();
   CONSTANT bool queryPasswordIsUsed(char* passwordName);
   PAYABLE void payByPassword(char* passwordName);
   PAYABLE void depositeContract();
   EXPORT void setExpireTime(uint64_t _expireTime);
};

DIPC_EVENT(expireTimeSetted,uint64_t);
DIPC_EVENT(depositingValue,uint64_t);
DIPC_EVENT(ErrEvent, const char*, const char*);
DIPC_EVENT(registerPasswordEvent, const char*, const char*, const char*);
DIPC_EVENT(payByPasswordEvent, const char*, uint64_t);



2019-12-31_16:55:59.908163: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/tools/abi/AbiGenerator.cpp:119] funcEntire : ; funcEnd : PasswordManage : public Contract {
private:
    Uint64<expireTimec> expireTime;
    Map<passwordStorec, std::string, std::string> passwordStore;
    Map<passwordStoreHisc, std::string, std::string> passwordStoreHis;
    String<ownerc> owner;

    void isOwner(){
        std::string callerStr = caller().toString();
        std::string ownerStr = owner.get();
        DipcAssert(callerStr == owner.get());
    }

public:
   PAYABLE void init();
   EXPORT void registerPassword(char* passwordName, char* passwordAddr, uint64_t _balance);
   CONSTANT char* queryExistPasswords();
   CONSTANT bool queryPasswordIsUsed(char* passwordName);
   PAYABLE void payByPassword(char* passwordName);
   PAYABLE void depositeContract();
   EXPORT void setExpireTime(uint64_t _expireTime);
};

DIPC_EVENT(expireTimeSetted,uint64_t);
DIPC_EVENT(depositingValue,uint64_t);
DIPC_EVENT(ErrEvent, const char*, const char*);
DIPC_EVENT(registerPasswordEvent, const char*, const char*, const char*);
DIPC_EVENT(payByPasswordEvent, const char*, uint64_t);



2019-12-31_16:55:59.908169: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/tools/abi/AbiGenerator.cpp:172] abis size:7
2019-12-31_16:56:02.278572: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:1156] find method successfind abi size:7
2019-12-31_16:56:02.278603: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:1161] methodName:init args:(
2019-12-31_16:56:02.278617: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:1172] )
2019-12-31_16:56:02.278630: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:1173] return typeName: realTypeName:void
2019-12-31_16:56:02.278637: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:1161] methodName:registerPassword args:(
2019-12-31_16:56:02.278642: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:1168] name:passwordName, typeName: realTypeName:char *
2019-12-31_16:56:02.278649: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:1168] name:passwordAddr, typeName: realTypeName:char *
2019-12-31_16:56:02.278654: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:1168] name:_balance, typeName:uint64_t realTypeName:unsigned long long
2019-12-31_16:56:02.278659: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:1172] )
2019-12-31_16:56:02.278665: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:1173] return typeName: realTypeName:void
2019-12-31_16:56:02.278670: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:1161] methodName:queryExistPasswords args:(
2019-12-31_16:56:02.278675: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:1172] )
2019-12-31_16:56:02.278680: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:1173] return typeName: realTypeName:char *
2019-12-31_16:56:02.278686: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:1161] methodName:queryPasswordIsUsed args:(
2019-12-31_16:56:02.278691: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:1168] name:passwordName, typeName: realTypeName:char *
2019-12-31_16:56:02.278696: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:1172] )
2019-12-31_16:56:02.278701: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:1173] return typeName: realTypeName:_Bool
2019-12-31_16:56:02.278706: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:1161] methodName:payByPassword args:(
2019-12-31_16:56:02.278712: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:1168] name:passwordName, typeName: realTypeName:char *
2019-12-31_16:56:02.278717: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:1172] )
2019-12-31_16:56:02.278722: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:1173] return typeName: realTypeName:void
2019-12-31_16:56:02.278727: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:1161] methodName:depositeContract args:(
2019-12-31_16:56:02.278732: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:1172] )
2019-12-31_16:56:02.278737: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:1173] return typeName: realTypeName:void
2019-12-31_16:56:02.278742: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:1161] methodName:setExpireTime args:(
2019-12-31_16:56:02.278748: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:1168] name:_expireTime, typeName:uint64_t realTypeName:unsigned long long
2019-12-31_16:56:02.278753: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:1172] )
2019-12-31_16:56:02.278758: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:1173] return typeName: realTypeName:void
2019-12-31_16:56:02.278763: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:1186] start create abi json
2019-12-31_16:56:02.278799: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:780] random:[/var/folders/tt/8v4bb03x685c49jk_vkvr7s80000gp/T/5h97327fgggg16af7dii] fileName:PasswordManage.cpp.abi.json
2019-12-31_16:56:02.278807: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:782] tmpFile:[/var/folders/tt/8v4bb03x685c49jk_vkvr7s80000gp/T/5h97327fgggg16af7dii/PasswordManage.cpp.abi.json]
2019-12-31_16:56:02.279574: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:793] copy ::/var/folders/tt/8v4bb03x685c49jk_vkvr7s80000gp/T/5h97327fgggg16af7dii/PasswordManage.cpp.abi.json to ::./PasswordManage.cpp.abi.json
2019-12-31_16:56:02.281115: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:814] random:[/var/folders/tt/8v4bb03x685c49jk_vkvr7s80000gp/T/5h97327fgggg16af7dii] fileName:PasswordManage.cpp.exports
2019-12-31_16:56:02.281128: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:816] tmpFile:[/var/folders/tt/8v4bb03x685c49jk_vkvr7s80000gp/T/5h97327fgggg16af7dii/PasswordManage.cpp.exports]
2019-12-31_16:56:02.281382: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:831] copy ::/var/folders/tt/8v4bb03x685c49jk_vkvr7s80000gp/T/5h97327fgggg16af7dii/PasswordManage.cpp.exports to ::/var/folders/tt/8v4bb03x685c49jk_vkvr7s80000gp/T//PasswordManage.cpp.exports
2019-12-31_16:56:02.282592: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:852] abidef_output  abidef_filename PasswordManage.cpp

2019-12-31_16:56:02.282723: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:880] macrostr  =======::#include "PasswordManage.hpp"

PAYABLE void PasswordManage::init(){
    std::string ownerStr = caller().toString();
    *owner = ownerStr;
}
/**
 *  _balance: unit is DIP
 */ 
EXPORT void PasswordManage::registerPassword(char* passwordName, char* toAddr, uint64_t _balance){
    PasswordInfo info(passwordName, toAddr, _balance, dipc::timestamp());
    std::string pInfo = info.toJson();
    if (passwordStore.get()[passwordName] != "") {
        DIPC_EMIT_EVENT(ErrEvent, "registerPassword  password exist", passwordName);
        return;
    }
    (*passwordStore)[passwordName] = pInfo;
    print("registerPassword pInfo");
    print(pInfo);
    std::string callerStr = dipc::caller().toString();
    DIPC_EMIT_EVENT(registerPasswordEvent, &callerStr[0], passwordName, &pInfo[0]);
}
CONSTANT char* PasswordManage::queryExistPasswords(){
    std::map<std::string, std::string>::iterator iter;
    auto mapStore = passwordStore.get();
    iter = mapStore.begin();
    std::string result = "[";
    print("queryExistPasswords start");
    while(iter != mapStore.end()){
        result += iter->first + ","; 
        iter++;
    }
    print("queryExistPasswords end");

    result.substr(0,result.size()-1);
    result += "]";
    print("queryExistPasswords  result");
    print(result);
    return &result[0];
}
CONSTANT bool PasswordManage::queryPasswordIsUsed(char* passwordName){
     if (passwordStore.get()[passwordName] != "") {
        return true;
    }
    return false;
}
PAYABLE void PasswordManage::payByPassword(char* passwordName){
    std::string pInfo = passwordStore.get()[passwordName];
    PasswordInfo pwInfo;
    pwInfo.parseJson(pInfo);
    print("pwInfo");
    print(pwInfo.toJson());
    uint64_t transferValue = dipc::callValueUDIP();
    print("transferValue");
    print(transferValue);
    print(pwInfo.balance);
    if(dipc::timestamp() >=  expireTime.get() + pwInfo.timeRegistered){
        DipcAssert(transferValue / 1000 == pwInfo.balance);
        Address toAddr = Address(pwInfo.toAddr,22);
        callTransferUDIP(toAddr, transferValue);
        DIPC_EMIT_EVENT(payByPasswordEvent, passwordName,  transferValue * 1000);
    } else {
        DIPC_EMIT_EVENT(ErrEvent, "payByPassword  password exist", passwordName);
    }
    //DipcAssert( );
    (*passwordStore).erase(passwordName);
    (*passwordStoreHis)[std::string(passwordName)+"_"+pwInfo.toAddr+"_"+std::to_string(pwInfo.timeRegistered)] = pInfo;
}
/**
* @brief deposite dip to the contract addr, the deposite value shouldn't be less than 0.001DIP
*/ 
PAYABLE void PasswordManage::depositeContract(){
    uint64_t value = dipc::callValueUDIP() * 1000;
    DIPC_EMIT_EVENT(depositingValue,value);
}
/**
* @brief set the unification expire time of the password
* @param _expireTime: the expire time of the password,the unit is hour
*/ 
EXPORT void PasswordManage::setExpireTime(uint64_t _expireTime){
    // math.pow() function hasn't effort is vm, so ....
    *expireTime = _expireTime * 60 * 60 * 1000000000;
    DIPC_EMIT_EVENT(expireTimeSetted,expireTime.get());
}

2019-12-31_16:56:02.282739: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:881] headerStr  =======::

2019-12-31_16:56:02.282770: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:884] removedComments  =======::#include "PasswordManage.hpp"

PAYABLE void PasswordManage::init(){
    std::string ownerStr = caller().toString();
    *owner = ownerStr;
}
 
EXPORT void PasswordManage::registerPassword(char* passwordName, char* toAddr, uint64_t _balance){
    PasswordInfo info(passwordName, toAddr, _balance, dipc::timestamp());
    std::string pInfo = info.toJson();
    if (passwordStore.get()[passwordName] != "") {
        DIPC_EMIT_EVENT(ErrEvent, "registerPassword  password exist", passwordName);
        return;
    }
    (*passwordStore)[passwordName] = pInfo;
    print("registerPassword pInfo");
    print(pInfo);
    std::string callerStr = dipc::caller().toString();
    DIPC_EMIT_EVENT(registerPasswordEvent, &callerStr[0], passwordName, &pInfo[0]);
}
CONSTANT char* PasswordManage::queryExistPasswords(){
    std::map<std::string, std::string>::iterator iter;
    auto mapStore = passwordStore.get();
    iter = mapStore.begin();
    std::string result = "[";
    print("queryExistPasswords start");
    while(iter != mapStore.end()){
        result += iter->first + ","; 
        iter++;
    }
    print("queryExistPasswords end");

    result.substr(0,result.size()-1);
    result += "]";
    print("queryExistPasswords  result");
    print(result);
    return &result[0];
}
CONSTANT bool PasswordManage::queryPasswordIsUsed(char* passwordName){
     if (passwordStore.get()[passwordName] != "") {
        return true;
    }
    return false;
}
PAYABLE void PasswordManage::payByPassword(char* passwordName){
    std::string pInfo = passwordStore.get()[passwordName];
    PasswordInfo pwInfo;
    pwInfo.parseJson(pInfo);
    print("pwInfo");
    print(pwInfo.toJson());
    uint64_t transferValue = dipc::callValueUDIP();
    print("transferValue");
    print(transferValue);
    print(pwInfo.balance);
    if(dipc::timestamp() >=  expireTime.get() + pwInfo.timeRegistered){
        DipcAssert(transferValue / 1000 == pwInfo.balance);
        Address toAddr = Address(pwInfo.toAddr,22);
        callTransferUDIP(toAddr, transferValue);
        DIPC_EMIT_EVENT(payByPasswordEvent, passwordName,  transferValue * 1000);
    } else {
        DIPC_EMIT_EVENT(ErrEvent, "payByPassword  password exist", passwordName);
    }
    
    (*passwordStore).erase(passwordName);
    (*passwordStoreHis)[std::string(passwordName)+"_"+pwInfo.toAddr+"_"+std::to_string(pwInfo.timeRegistered)] = pInfo;
}
 
PAYABLE void PasswordManage::depositeContract(){
    uint64_t value = dipc::callValueUDIP() * 1000;
    DIPC_EMIT_EVENT(depositingValue,value);
}
 
EXPORT void PasswordManage::setExpireTime(uint64_t _expireTime){
    
    *expireTime = _expireTime * 60 * 60 * 1000000000;
    DIPC_EMIT_EVENT(expireTimeSetted,expireTime.get());
}

2019-12-31_16:56:02.282795: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:401] abis.ispayable :true

2019-12-31_16:56:02.282817: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:424] finalContract  this height   codetext height #include "PasswordManage.hpp"

PAYABLE void PasswordManage::init(){
    std::string ownerStr = caller().toString();
    *owner = ownerStr;
}
 
EXPORT void PasswordManage::registerPassword(char* passwordName, char* toAddr, uint64_t _balance){
    PasswordInfo info(passwordName, toAddr, _balance, dipc::timestamp());
    std::string pInfo = info.toJson();
    if (passwordStore.get()[passwordName] != "") {
        DIPC_EMIT_EVENT(ErrEvent, "registerPassword  password exist", passwordName);
        return;
    }
    (*passwordStore)[passwordName] = pInfo;
    print("registerPassword pInfo");
    print(pInfo);
    std::string callerStr = dipc::caller().toString();
    DIPC_EMIT_EVENT(registerPasswordEvent, &callerStr[0], passwordName, &pInfo[0]);
}
CONSTANT char* PasswordManage::queryExistPasswords(){
    std::map<std::string, std::string>::iterator iter;
    auto mapStore = passwordStore.get();
    iter = mapStore.begin();
    std::string result = "[";
    print("queryExistPasswords start");
    while(iter != mapStore.end()){
        result += iter->first + ","; 
        iter++;
    }
    print("queryExistPasswords end");

    result.substr(0,result.size()-1);
    result += "]";
    print("queryExistPasswords  result");
    print(result);
    return &result[0];
}
CONSTANT bool PasswordManage::queryPasswordIsUsed(char* passwordName){
     if (passwordStore.get()[passwordName] != "") {
        return true;
    }
    return false;
}
PAYABLE void PasswordManage::payByPassword(char* passwordName){
    std::string pInfo = passwordStore.get()[passwordName];
    PasswordInfo pwInfo;
    pwInfo.parseJson(pInfo);
    print("pwInfo");
    print(pwInfo.toJson());
    uint64_t transferValue = dipc::callValueUDIP();
    print("transferValue");
    print(transferValue);
    print(pwInfo.balance);
    if(dipc::timestamp() >=  expireTime.get() + pwInfo.timeRegistered){
        DipcAssert(transferValue / 1000 == pwInfo.balance);
        Address toAddr = Address(pwInfo.toAddr,22);
        callTransferUDIP(toAddr, transferValue);
        DIPC_EMIT_EVENT(payByPasswordEvent, passwordName,  transferValue * 1000);
    } else {
        DIPC_EMIT_EVENT(ErrEvent, "payByPassword  password exist", passwordName);
    }
    
    (*passwordStore).erase(passwordName);
    (*passwordStoreHis)[std::string(passwordName)+"_"+pwInfo.toAddr+"_"+std::to_string(pwInfo.timeRegistered)] = pInfo;
}
 
PAYABLE void PasswordManage::depositeContract(){
    uint64_t value = dipc::callValueUDIP() * 1000;
    DIPC_EMIT_EVENT(depositingValue,value);
}
 
EXPORT void PasswordManage::setExpireTime(uint64_t _expireTime){
    
    *expireTime = _expireTime * 60 * 60 * 1000000000;
    DIPC_EMIT_EVENT(expireTimeSetted,expireTime.get());
}

2019-12-31_16:56:02.282825: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:427] searchContext  #include "PasswordManage.hpp"

PAYABLE void PasswordManage::init(){
    std::string ownerStr = caller().toString();
    *owner = ownerStr;
}
 
EXPORT void PasswordManage::registerPassword(char* passwordName, char* toAddr, uint64_t _balance){
    PasswordInfo info(passwordName, toAddr, _balance, dipc::timestamp());
    std::string pInfo = info.toJson();
    if (passwordStore.get()[passwordName] != "") {
        DIPC_EMIT_EVENT(ErrEvent, "registerPassword  password exist", passwordName);
        return;
    }
    (*passwordStore)[passwordName] = pInfo;
    print("registerPassword pInfo");
    print(pInfo);
    std::string callerStr = dipc::caller().toString();
    DIPC_EMIT_EVENT(registerPasswordEvent, &callerStr[0], passwordName, &pInfo[0]);
}
CONSTANT char* PasswordManage::queryExistPasswords(){
    std::map<std::string, std::string>::iterator iter;
    auto mapStore = passwordStore.get();
    iter = mapStore.begin();
    std::string result = "[";
    print("queryExistPasswords start");
    while(iter != mapStore.end()){
        result += iter->first + ","; 
        iter++;
    }
    print("queryExistPasswords end");

    result.substr(0,result.size()-1);
    result += "]";
    print("queryExistPasswords  result");
    print(result);
    return &result[0];
}
CONSTANT bool PasswordManage::queryPasswordIsUsed(char* passwordName){
     if (passwordStore.get()[passwordName] != "") {
        return true;
    }
    return false;
}
PAYABLE void PasswordManage::payByPassword(char* passwordName){
    std::string pInfo = passwordStore.get()[passwordName];
    PasswordInfo pwInfo;
    pwInfo.parseJson(pInfo);
    print("pwInfo");
    print(pwInfo.toJson());
    uint64_t transferValue = dipc::callValueUDIP();
    print("transferValue");
    print(transferValue);
    print(pwInfo.balance);
    if(dipc::timestamp() >=  expireTime.get() + pwInfo.timeRegistered){
        DipcAssert(transferValue / 1000 == pwInfo.balance);
        Address toAddr = Address(pwInfo.toAddr,22);
        callTransferUDIP(toAddr, transferValue);
        DIPC_EMIT_EVENT(payByPasswordEvent, passwordName,  transferValue * 1000);
    } else {
        DIPC_EMIT_EVENT(ErrEvent, "payByPassword  password exist", passwordName);
    }
    
    (*passwordStore).erase(passwordName);
    (*passwordStoreHis)[std::string(passwordName)+"_"+pwInfo.toAddr+"_"+std::to_string(pwInfo.timeRegistered)] = pInfo;
}
 
PAYABLE void PasswordManage::depositeContract(){
    uint64_t value = dipc::callValueUDIP() * 1000;
    DIPC_EMIT_EVENT(depositingValue,value);
}
 
EXPORT void PasswordManage::setExpireTime(uint64_t _expireTime){
    
    *expireTime = _expireTime * 60 * 60 * 1000000000;
    DIPC_EMIT_EVENT(expireTimeSetted,expireTime.get());
}

2019-12-31_16:56:02.283452: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:451] log out out payable : PAYABLE void PasswordManage::payByPassword(char* passwordName){
    

2019-12-31_16:56:02.283463: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:457] name : payByPassword   pos1  0

2019-12-31_16:56:02.283471: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:469] pos2  1449   pos1  1449

2019-12-31_16:56:02.283478: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:500] pos2 after 2392   pos1  1449

2019-12-31_16:56:02.283484: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:509] finalContract  first #include "PasswordManage.hpp"

PAYABLE void PasswordManage::init(){
    std::string ownerStr = caller().toString();
    *owner = ownerStr;
}
 
EXPORT void PasswordManage::registerPassword(char* passwordName, char* toAddr, uint64_t _balance){
    PasswordInfo info(passwordName, toAddr, _balance, dipc::timestamp());
    std::string pInfo = info.toJson();
    if (passwordStore.get()[passwordName] != "") {
        DIPC_EMIT_EVENT(ErrEvent, "registerPassword  password exist", passwordName);
        return;
    }
    (*passwordStore)[passwordName] = pInfo;
    print("registerPassword pInfo");
    print(pInfo);
    std::string callerStr = dipc::caller().toString();
    DIPC_EMIT_EVENT(registerPasswordEvent, &callerStr[0], passwordName, &pInfo[0]);
}
CONSTANT char* PasswordManage::queryExistPasswords(){
    std::map<std::string, std::string>::iterator iter;
    auto mapStore = passwordStore.get();
    iter = mapStore.begin();
    std::string result = "[";
    print("queryExistPasswords start");
    while(iter != mapStore.end()){
        result += iter->first + ","; 
        iter++;
    }
    print("queryExistPasswords end");

    result.substr(0,result.size()-1);
    result += "]";
    print("queryExistPasswords  result");
    print(result);
    return &result[0];
}
CONSTANT bool PasswordManage::queryPasswordIsUsed(char* passwordName){
     if (passwordStore.get()[passwordName] != "") {
        return true;
    }
    return false;
}


2019-12-31_16:56:02.283491: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:510] codetext  first #include "PasswordManage.hpp"

PAYABLE void PasswordManage::init(){
    std::string ownerStr = caller().toString();
    *owner = ownerStr;
}
 
EXPORT void PasswordManage::registerPassword(char* passwordName, char* toAddr, uint64_t _balance){
    PasswordInfo info(passwordName, toAddr, _balance, dipc::timestamp());
    std::string pInfo = info.toJson();
    if (passwordStore.get()[passwordName] != "") {
        DIPC_EMIT_EVENT(ErrEvent, "registerPassword  password exist", passwordName);
        return;
    }
    (*passwordStore)[passwordName] = pInfo;
    print("registerPassword pInfo");
    print(pInfo);
    std::string callerStr = dipc::caller().toString();
    DIPC_EMIT_EVENT(registerPasswordEvent, &callerStr[0], passwordName, &pInfo[0]);
}
CONSTANT char* PasswordManage::queryExistPasswords(){
    std::map<std::string, std::string>::iterator iter;
    auto mapStore = passwordStore.get();
    iter = mapStore.begin();
    std::string result = "[";
    print("queryExistPasswords start");
    while(iter != mapStore.end()){
        result += iter->first + ","; 
        iter++;
    }
    print("queryExistPasswords end");

    result.substr(0,result.size()-1);
    result += "]";
    print("queryExistPasswords  result");
    print(result);
    return &result[0];
}
CONSTANT bool PasswordManage::queryPasswordIsUsed(char* passwordName){
     if (passwordStore.get()[passwordName] != "") {
        return true;
    }
    return false;
}
PAYABLE void PasswordManage::payByPassword(char* passwordName){
    std::string pInfo = passwordStore.get()[passwordName];
    PasswordInfo pwInfo;
    pwInfo.parseJson(pInfo);
    print("pwInfo");
    print(pwInfo.toJson());
    uint64_t transferValue = dipc::callValueUDIP();
    print("transferValue");
    print(transferValue);
    print(pwInfo.balance);
    if(dipc::timestamp() >=  expireTime.get() + pwInfo.timeRegistered){
        DipcAssert(transferValue / 1000 == pwInfo.balance);
        Address toAddr = Address(pwInfo.toAddr,22);
        callTransferUDIP(toAddr, transferValue);
        DIPC_EMIT_EVENT(payByPasswordEvent, passwordName,  transferValue * 1000);
    } else {
        DIPC_EMIT_EVENT(ErrEvent, "payByPassword  password exist", passwordName);
    }
    
    (*passwordStore).erase(passwordName);
    (*passwordStoreHis)[std::string(passwordName)+"_"+pwInfo.toAddr+"_"+std::to_string(pwInfo.timeRegistered)] = pInfo;
}
 
PAYABLE void PasswordManage::depositeContract(){
    uint64_t value = dipc::callValueUDIP() * 1000;
    DIPC_EMIT_EVENT(depositingValue,value);
}
 
EXPORT void PasswordManage::setExpireTime(uint64_t _expireTime){
    
    *expireTime = _expireTime * 60 * 60 * 1000000000;
    DIPC_EMIT_EVENT(expireTimeSetted,expireTime.get());
}

2019-12-31_16:56:02.283497: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:513] s  first PAYABLE void PasswordManage::payByPassword(char* passwordName){
    std::string pInfo = passwordStore.get()[passwordName];
    PasswordInfo pwInfo;
    pwInfo.parseJson(pInfo);
    print("pwInfo");
    print(pwInfo.toJson());
    uint64_t transferValue = dipc::callValueUDIP();
    print("transferValue");
    print(transferValue);
    print(pwInfo.balance);
    if(dipc::timestamp() >=  expireTime.get() + pwInfo.timeRegistered){
        DipcAssert(transferValue / 1000 == pwInfo.balance);
        Address toAddr = Address(pwInfo.toAddr,22);
        callTransferUDIP(toAddr, transferValue);
        DIPC_EMIT_EVENT(payByPasswordEvent, passwordName,  transferValue * 1000);
    } else {
        DIPC_EMIT_EVENT(ErrEvent, "payByPassword  password exist", passwordName);
    }
    
    (*passwordStore).erase(passwordName);
    (*passwordStoreHis)[std::string(passwordName)+"_"+pwInfo.toAddr+"_"+std::to_string(pwInfo.timeRegistered)] = pInfo;
}

2019-12-31_16:56:02.286214: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:599] search func : PAYABLE void PasswordManage::payByPassword(char* passwordName){
    std::string pInfo = passwordStore.get()[passwordName];
    PasswordInfo pwInfo;
    pwInfo.parseJson(pInfo);
    print("pwInfo");
    print(pwInfo.toJson());
    uint64_t transferValue = dipc::callValueUDIP();
    print("transferValue");
    print(transferValue);
    print(pwInfo.balance);
    if(dipc::timestamp() >=  expireTime.get() + pwInfo.timeRegistered){
        DipcAssert(transferValue / 1000 == pwInfo.balance);
        Address toAddr = Address(pwInfo.toAddr,22);
        callTransferUDIP(toAddr, transferValue);
        DIPC_EMIT_EVENT(payByPasswordEvent, passwordName,  transferValue * 1000);
    } else {
        DIPC_EMIT_EVENT(ErrEvent, "payByPassword  password exist", passwordName);
    }
    
    (*passwordStore).erase(passwordName);
    (*passwordStoreHis)[std::string(passwordName)+"_"+pwInfo.toAddr+"_"+std::to_string(pwInfo.timeRegistered)] = pInfo;
}
2019-12-31_16:56:02.286233: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:424] finalContract  this height  #include "PasswordManage.hpp"

PAYABLE void PasswordManage::init(){
    std::string ownerStr = caller().toString();
    *owner = ownerStr;
}
 
EXPORT void PasswordManage::registerPassword(char* passwordName, char* toAddr, uint64_t _balance){
    PasswordInfo info(passwordName, toAddr, _balance, dipc::timestamp());
    std::string pInfo = info.toJson();
    if (passwordStore.get()[passwordName] != "") {
        DIPC_EMIT_EVENT(ErrEvent, "registerPassword  password exist", passwordName);
        return;
    }
    (*passwordStore)[passwordName] = pInfo;
    print("registerPassword pInfo");
    print(pInfo);
    std::string callerStr = dipc::caller().toString();
    DIPC_EMIT_EVENT(registerPasswordEvent, &callerStr[0], passwordName, &pInfo[0]);
}
CONSTANT char* PasswordManage::queryExistPasswords(){
    std::map<std::string, std::string>::iterator iter;
    auto mapStore = passwordStore.get();
    iter = mapStore.begin();
    std::string result = "[";
    print("queryExistPasswords start");
    while(iter != mapStore.end()){
        result += iter->first + ","; 
        iter++;
    }
    print("queryExistPasswords end");

    result.substr(0,result.size()-1);
    result += "]";
    print("queryExistPasswords  result");
    print(result);
    return &result[0];
}
CONSTANT bool PasswordManage::queryPasswordIsUsed(char* passwordName){
     if (passwordStore.get()[passwordName] != "") {
        return true;
    }
    return false;
}
PAYABLE void PasswordManage::payByPassword(char* passwordName){
    std::string pInfo = passwordStore.get()[passwordName];
    PasswordInfo pwInfo;
    pwInfo.parseJson(pInfo);
    print("pwInfo");
    print(pwInfo.toJson());
    uint64_t transferValue = dipc::callValueUDIP();
    print("transferValue");
    print(transferValue);
    print(pwInfo.balance);
    if(dipc::timestamp() >=  expireTime.get() + pwInfo.timeRegistered){
        DipcAssert(transferValue / 1000 == pwInfo.balance);
        Address toAddr = Address(pwInfo.toAddr,22);
        callTransferUDIP(toAddr, transferValue);
        DIPC_EMIT_EVENT(payByPasswordEvent, passwordName,  transferValue * 1000);
    } else {
        DIPC_EMIT_EVENT(ErrEvent, "payByPassword  password exist", passwordName);
    }
    
    (*passwordStore).erase(passwordName);
    (*passwordStoreHis)[std::string(passwordName)+"_"+pwInfo.toAddr+"_"+std::to_string(pwInfo.timeRegistered)] = pInfo;
} codetext height #include "PasswordManage.hpp"

PAYABLE void PasswordManage::init(){
    std::string ownerStr = caller().toString();
    *owner = ownerStr;
}
 
EXPORT void PasswordManage::registerPassword(char* passwordName, char* toAddr, uint64_t _balance){
    PasswordInfo info(passwordName, toAddr, _balance, dipc::timestamp());
    std::string pInfo = info.toJson();
    if (passwordStore.get()[passwordName] != "") {
        DIPC_EMIT_EVENT(ErrEvent, "registerPassword  password exist", passwordName);
        return;
    }
    (*passwordStore)[passwordName] = pInfo;
    print("registerPassword pInfo");
    print(pInfo);
    std::string callerStr = dipc::caller().toString();
    DIPC_EMIT_EVENT(registerPasswordEvent, &callerStr[0], passwordName, &pInfo[0]);
}
CONSTANT char* PasswordManage::queryExistPasswords(){
    std::map<std::string, std::string>::iterator iter;
    auto mapStore = passwordStore.get();
    iter = mapStore.begin();
    std::string result = "[";
    print("queryExistPasswords start");
    while(iter != mapStore.end()){
        result += iter->first + ","; 
        iter++;
    }
    print("queryExistPasswords end");

    result.substr(0,result.size()-1);
    result += "]";
    print("queryExistPasswords  result");
    print(result);
    return &result[0];
}
CONSTANT bool PasswordManage::queryPasswordIsUsed(char* passwordName){
     if (passwordStore.get()[passwordName] != "") {
        return true;
    }
    return false;
}
PAYABLE void PasswordManage::payByPassword(char* passwordName){
    std::string pInfo = passwordStore.get()[passwordName];
    PasswordInfo pwInfo;
    pwInfo.parseJson(pInfo);
    print("pwInfo");
    print(pwInfo.toJson());
    uint64_t transferValue = dipc::callValueUDIP();
    print("transferValue");
    print(transferValue);
    print(pwInfo.balance);
    if(dipc::timestamp() >=  expireTime.get() + pwInfo.timeRegistered){
        DipcAssert(transferValue / 1000 == pwInfo.balance);
        Address toAddr = Address(pwInfo.toAddr,22);
        callTransferUDIP(toAddr, transferValue);
        DIPC_EMIT_EVENT(payByPasswordEvent, passwordName,  transferValue * 1000);
    } else {
        DIPC_EMIT_EVENT(ErrEvent, "payByPassword  password exist", passwordName);
    }
    
    (*passwordStore).erase(passwordName);
    (*passwordStoreHis)[std::string(passwordName)+"_"+pwInfo.toAddr+"_"+std::to_string(pwInfo.timeRegistered)] = pInfo;
}
 
PAYABLE void PasswordManage::depositeContract(){
    uint64_t value = dipc::callValueUDIP() * 1000;
    DIPC_EMIT_EVENT(depositingValue,value);
}
 
EXPORT void PasswordManage::setExpireTime(uint64_t _expireTime){
    
    *expireTime = _expireTime * 60 * 60 * 1000000000;
    DIPC_EMIT_EVENT(expireTimeSetted,expireTime.get());
}

2019-12-31_16:56:02.286245: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:427] searchContext  
 
PAYABLE void PasswordManage::depositeContract(){
    uint64_t value = dipc::callValueUDIP() * 1000;
    DIPC_EMIT_EVENT(depositingValue,value);
}
 
EXPORT void PasswordManage::setExpireTime(uint64_t _expireTime){
    
    *expireTime = _expireTime * 60 * 60 * 1000000000;
    DIPC_EMIT_EVENT(expireTimeSetted,expireTime.get());
}

2019-12-31_16:56:02.286504: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:442] finalContract  this new  #include "PasswordManage.hpp"

PAYABLE void PasswordManage::init(){
    std::string ownerStr = caller().toString();
    *owner = ownerStr;
}
 
EXPORT void PasswordManage::registerPassword(char* passwordName, char* toAddr, uint64_t _balance){
    PasswordInfo info(passwordName, toAddr, _balance, dipc::timestamp());
    std::string pInfo = info.toJson();
    if (passwordStore.get()[passwordName] != "") {
        DIPC_EMIT_EVENT(ErrEvent, "registerPassword  password exist", passwordName);
        return;
    }
    (*passwordStore)[passwordName] = pInfo;
    print("registerPassword pInfo");
    print(pInfo);
    std::string callerStr = dipc::caller().toString();
    DIPC_EMIT_EVENT(registerPasswordEvent, &callerStr[0], passwordName, &pInfo[0]);
}
CONSTANT char* PasswordManage::queryExistPasswords(){
    std::map<std::string, std::string>::iterator iter;
    auto mapStore = passwordStore.get();
    iter = mapStore.begin();
    std::string result = "[";
    print("queryExistPasswords start");
    while(iter != mapStore.end()){
        result += iter->first + ","; 
        iter++;
    }
    print("queryExistPasswords end");

    result.substr(0,result.size()-1);
    result += "]";
    print("queryExistPasswords  result");
    print(result);
    return &result[0];
}
CONSTANT bool PasswordManage::queryPasswordIsUsed(char* passwordName){
     if (passwordStore.get()[passwordName] != "") {
        return true;
    }
    return false;
}
PAYABLE void PasswordManage::payByPassword(char* passwordName){
    std::string pInfo = passwordStore.get()[passwordName];
    PasswordInfo pwInfo;
    pwInfo.parseJson(pInfo);
    print("pwInfo");
    print(pwInfo.toJson());
    uint64_t transferValue = dipc::callValueUDIP();
    print("transferValue");
    print(transferValue);
    print(pwInfo.balance);
    if(dipc::timestamp() >=  expireTime.get() + pwInfo.timeRegistered){
        DipcAssert(transferValue / 1000 == pwInfo.balance);
        Address toAddr = Address(pwInfo.toAddr,22);
        callTransferUDIP(toAddr, transferValue);
        DIPC_EMIT_EVENT(payByPasswordEvent, passwordName,  transferValue * 1000);
    } else {
        DIPC_EMIT_EVENT(ErrEvent, "payByPassword  password exist", passwordName);
    }
    
    (*passwordStore).erase(passwordName);
    (*passwordStoreHis)[std::string(passwordName)+"_"+pwInfo.toAddr+"_"+std::to_string(pwInfo.timeRegistered)] = pInfo;
} codetext new #include "PasswordManage.hpp"

PAYABLE void PasswordManage::init(){
    std::string ownerStr = caller().toString();
    *owner = ownerStr;
}
 
EXPORT void PasswordManage::registerPassword(char* passwordName, char* toAddr, uint64_t _balance){
    PasswordInfo info(passwordName, toAddr, _balance, dipc::timestamp());
    std::string pInfo = info.toJson();
    if (passwordStore.get()[passwordName] != "") {
        DIPC_EMIT_EVENT(ErrEvent, "registerPassword  password exist", passwordName);
        return;
    }
    (*passwordStore)[passwordName] = pInfo;
    print("registerPassword pInfo");
    print(pInfo);
    std::string callerStr = dipc::caller().toString();
    DIPC_EMIT_EVENT(registerPasswordEvent, &callerStr[0], passwordName, &pInfo[0]);
}
CONSTANT char* PasswordManage::queryExistPasswords(){
    std::map<std::string, std::string>::iterator iter;
    auto mapStore = passwordStore.get();
    iter = mapStore.begin();
    std::string result = "[";
    print("queryExistPasswords start");
    while(iter != mapStore.end()){
        result += iter->first + ","; 
        iter++;
    }
    print("queryExistPasswords end");

    result.substr(0,result.size()-1);
    result += "]";
    print("queryExistPasswords  result");
    print(result);
    return &result[0];
}
CONSTANT bool PasswordManage::queryPasswordIsUsed(char* passwordName){
     if (passwordStore.get()[passwordName] != "") {
        return true;
    }
    return false;
}
PAYABLE void PasswordManage::payByPassword(char* passwordName){
    std::string pInfo = passwordStore.get()[passwordName];
    PasswordInfo pwInfo;
    pwInfo.parseJson(pInfo);
    print("pwInfo");
    print(pwInfo.toJson());
    uint64_t transferValue = dipc::callValueUDIP();
    print("transferValue");
    print(transferValue);
    print(pwInfo.balance);
    if(dipc::timestamp() >=  expireTime.get() + pwInfo.timeRegistered){
        DipcAssert(transferValue / 1000 == pwInfo.balance);
        Address toAddr = Address(pwInfo.toAddr,22);
        callTransferUDIP(toAddr, transferValue);
        DIPC_EMIT_EVENT(payByPasswordEvent, passwordName,  transferValue * 1000);
    } else {
        DIPC_EMIT_EVENT(ErrEvent, "payByPassword  password exist", passwordName);
    }
    
    (*passwordStore).erase(passwordName);
    (*passwordStoreHis)[std::string(passwordName)+"_"+pwInfo.toAddr+"_"+std::to_string(pwInfo.timeRegistered)] = pInfo;
}
 
PAYABLE void PasswordManage::depositeContract(){
    uint64_t value = dipc::callValueUDIP() * 1000;
    DIPC_EMIT_EVENT(depositingValue,value);
}
 
EXPORT void PasswordManage::setExpireTime(uint64_t _expireTime){
    
    *expireTime = _expireTime * 60 * 60 * 1000000000;
    DIPC_EMIT_EVENT(expireTimeSetted,expireTime.get());
}

2019-12-31_16:56:02.286517: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:604] finalContract  final content =======   : #include "PasswordManage.hpp"

PAYABLE void PasswordManage::init(){
    std::string ownerStr = caller().toString();
    *owner = ownerStr;
}
 
EXPORT void PasswordManage::registerPassword(char* passwordName, char* toAddr, uint64_t _balance){
    PasswordInfo info(passwordName, toAddr, _balance, dipc::timestamp());
    std::string pInfo = info.toJson();
    if (passwordStore.get()[passwordName] != "") {
        DIPC_EMIT_EVENT(ErrEvent, "registerPassword  password exist", passwordName);
        return;
    }
    (*passwordStore)[passwordName] = pInfo;
    print("registerPassword pInfo");
    print(pInfo);
    std::string callerStr = dipc::caller().toString();
    DIPC_EMIT_EVENT(registerPasswordEvent, &callerStr[0], passwordName, &pInfo[0]);
}
CONSTANT char* PasswordManage::queryExistPasswords(){
    std::map<std::string, std::string>::iterator iter;
    auto mapStore = passwordStore.get();
    iter = mapStore.begin();
    std::string result = "[";
    print("queryExistPasswords start");
    while(iter != mapStore.end()){
        result += iter->first + ","; 
        iter++;
    }
    print("queryExistPasswords end");

    result.substr(0,result.size()-1);
    result += "]";
    print("queryExistPasswords  result");
    print(result);
    return &result[0];
}
CONSTANT bool PasswordManage::queryPasswordIsUsed(char* passwordName){
     if (passwordStore.get()[passwordName] != "") {
        return true;
    }
    return false;
}
PAYABLE void PasswordManage::payByPassword(char* passwordName){
    std::string pInfo = passwordStore.get()[passwordName];
    PasswordInfo pwInfo;
    pwInfo.parseJson(pInfo);
    print("pwInfo");
    print(pwInfo.toJson());
    uint64_t transferValue = dipc::callValueUDIP();
    print("transferValue");
    print(transferValue);
    print(pwInfo.balance);
    if(dipc::timestamp() >=  expireTime.get() + pwInfo.timeRegistered){
        DipcAssert(transferValue / 1000 == pwInfo.balance);
        Address toAddr = Address(pwInfo.toAddr,22);
        callTransferUDIP(toAddr, transferValue);
        DIPC_EMIT_EVENT(payByPasswordEvent, passwordName,  transferValue * 1000);
    } else {
        DIPC_EMIT_EVENT(ErrEvent, "payByPassword  password exist", passwordName);
    }
    
    (*passwordStore).erase(passwordName);
    (*passwordStoreHis)[std::string(passwordName)+"_"+pwInfo.toAddr+"_"+std::to_string(pwInfo.timeRegistered)] = pInfo;
}
 
PAYABLE void PasswordManage::depositeContract(){
    uint64_t value = dipc::callValueUDIP() * 1000;
    DIPC_EMIT_EVENT(depositingValue,value);
}
 
EXPORT void PasswordManage::setExpireTime(uint64_t _expireTime){
    
    *expireTime = _expireTime * 60 * 60 * 1000000000;
    DIPC_EMIT_EVENT(expireTimeSetted,expireTime.get());
}

2019-12-31_16:56:02.286525: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:401] abis.ispayable :true

2019-12-31_16:56:02.286543: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:424] finalContract  this height  #include "PasswordManage.hpp"

PAYABLE void PasswordManage::init(){
    std::string ownerStr = caller().toString();
    *owner = ownerStr;
}
 
EXPORT void PasswordManage::registerPassword(char* passwordName, char* toAddr, uint64_t _balance){
    PasswordInfo info(passwordName, toAddr, _balance, dipc::timestamp());
    std::string pInfo = info.toJson();
    if (passwordStore.get()[passwordName] != "") {
        DIPC_EMIT_EVENT(ErrEvent, "registerPassword  password exist", passwordName);
        return;
    }
    (*passwordStore)[passwordName] = pInfo;
    print("registerPassword pInfo");
    print(pInfo);
    std::string callerStr = dipc::caller().toString();
    DIPC_EMIT_EVENT(registerPasswordEvent, &callerStr[0], passwordName, &pInfo[0]);
}
CONSTANT char* PasswordManage::queryExistPasswords(){
    std::map<std::string, std::string>::iterator iter;
    auto mapStore = passwordStore.get();
    iter = mapStore.begin();
    std::string result = "[";
    print("queryExistPasswords start");
    while(iter != mapStore.end()){
        result += iter->first + ","; 
        iter++;
    }
    print("queryExistPasswords end");

    result.substr(0,result.size()-1);
    result += "]";
    print("queryExistPasswords  result");
    print(result);
    return &result[0];
}
CONSTANT bool PasswordManage::queryPasswordIsUsed(char* passwordName){
     if (passwordStore.get()[passwordName] != "") {
        return true;
    }
    return false;
}
PAYABLE void PasswordManage::payByPassword(char* passwordName){
    std::string pInfo = passwordStore.get()[passwordName];
    PasswordInfo pwInfo;
    pwInfo.parseJson(pInfo);
    print("pwInfo");
    print(pwInfo.toJson());
    uint64_t transferValue = dipc::callValueUDIP();
    print("transferValue");
    print(transferValue);
    print(pwInfo.balance);
    if(dipc::timestamp() >=  expireTime.get() + pwInfo.timeRegistered){
        DipcAssert(transferValue / 1000 == pwInfo.balance);
        Address toAddr = Address(pwInfo.toAddr,22);
        callTransferUDIP(toAddr, transferValue);
        DIPC_EMIT_EVENT(payByPasswordEvent, passwordName,  transferValue * 1000);
    } else {
        DIPC_EMIT_EVENT(ErrEvent, "payByPassword  password exist", passwordName);
    }
    
    (*passwordStore).erase(passwordName);
    (*passwordStoreHis)[std::string(passwordName)+"_"+pwInfo.toAddr+"_"+std::to_string(pwInfo.timeRegistered)] = pInfo;
}
 
PAYABLE void PasswordManage::depositeContract(){
    uint64_t value = dipc::callValueUDIP() * 1000;
    DIPC_EMIT_EVENT(depositingValue,value);
}
 
EXPORT void PasswordManage::setExpireTime(uint64_t _expireTime){
    
    *expireTime = _expireTime * 60 * 60 * 1000000000;
    DIPC_EMIT_EVENT(expireTimeSetted,expireTime.get());
} codetext height #include "PasswordManage.hpp"

PAYABLE void PasswordManage::init(){
    std::string ownerStr = caller().toString();
    *owner = ownerStr;
}
 
EXPORT void PasswordManage::registerPassword(char* passwordName, char* toAddr, uint64_t _balance){
    PasswordInfo info(passwordName, toAddr, _balance, dipc::timestamp());
    std::string pInfo = info.toJson();
    if (passwordStore.get()[passwordName] != "") {
        DIPC_EMIT_EVENT(ErrEvent, "registerPassword  password exist", passwordName);
        return;
    }
    (*passwordStore)[passwordName] = pInfo;
    print("registerPassword pInfo");
    print(pInfo);
    std::string callerStr = dipc::caller().toString();
    DIPC_EMIT_EVENT(registerPasswordEvent, &callerStr[0], passwordName, &pInfo[0]);
}
CONSTANT char* PasswordManage::queryExistPasswords(){
    std::map<std::string, std::string>::iterator iter;
    auto mapStore = passwordStore.get();
    iter = mapStore.begin();
    std::string result = "[";
    print("queryExistPasswords start");
    while(iter != mapStore.end()){
        result += iter->first + ","; 
        iter++;
    }
    print("queryExistPasswords end");

    result.substr(0,result.size()-1);
    result += "]";
    print("queryExistPasswords  result");
    print(result);
    return &result[0];
}
CONSTANT bool PasswordManage::queryPasswordIsUsed(char* passwordName){
     if (passwordStore.get()[passwordName] != "") {
        return true;
    }
    return false;
}
PAYABLE void PasswordManage::payByPassword(char* passwordName){
    std::string pInfo = passwordStore.get()[passwordName];
    PasswordInfo pwInfo;
    pwInfo.parseJson(pInfo);
    print("pwInfo");
    print(pwInfo.toJson());
    uint64_t transferValue = dipc::callValueUDIP();
    print("transferValue");
    print(transferValue);
    print(pwInfo.balance);
    if(dipc::timestamp() >=  expireTime.get() + pwInfo.timeRegistered){
        DipcAssert(transferValue / 1000 == pwInfo.balance);
        Address toAddr = Address(pwInfo.toAddr,22);
        callTransferUDIP(toAddr, transferValue);
        DIPC_EMIT_EVENT(payByPasswordEvent, passwordName,  transferValue * 1000);
    } else {
        DIPC_EMIT_EVENT(ErrEvent, "payByPassword  password exist", passwordName);
    }
    
    (*passwordStore).erase(passwordName);
    (*passwordStoreHis)[std::string(passwordName)+"_"+pwInfo.toAddr+"_"+std::to_string(pwInfo.timeRegistered)] = pInfo;
}
 
PAYABLE void PasswordManage::depositeContract(){
    uint64_t value = dipc::callValueUDIP() * 1000;
    DIPC_EMIT_EVENT(depositingValue,value);
}
 
EXPORT void PasswordManage::setExpireTime(uint64_t _expireTime){
    
    *expireTime = _expireTime * 60 * 60 * 1000000000;
    DIPC_EMIT_EVENT(expireTimeSetted,expireTime.get());
}

2019-12-31_16:56:02.286551: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:427] searchContext  #include "PasswordManage.hpp"

PAYABLE void PasswordManage::init(){
    std::string ownerStr = caller().toString();
    *owner = ownerStr;
}
 
EXPORT void PasswordManage::registerPassword(char* passwordName, char* toAddr, uint64_t _balance){
    PasswordInfo info(passwordName, toAddr, _balance, dipc::timestamp());
    std::string pInfo = info.toJson();
    if (passwordStore.get()[passwordName] != "") {
        DIPC_EMIT_EVENT(ErrEvent, "registerPassword  password exist", passwordName);
        return;
    }
    (*passwordStore)[passwordName] = pInfo;
    print("registerPassword pInfo");
    print(pInfo);
    std::string callerStr = dipc::caller().toString();
    DIPC_EMIT_EVENT(registerPasswordEvent, &callerStr[0], passwordName, &pInfo[0]);
}
CONSTANT char* PasswordManage::queryExistPasswords(){
    std::map<std::string, std::string>::iterator iter;
    auto mapStore = passwordStore.get();
    iter = mapStore.begin();
    std::string result = "[";
    print("queryExistPasswords start");
    while(iter != mapStore.end()){
        result += iter->first + ","; 
        iter++;
    }
    print("queryExistPasswords end");

    result.substr(0,result.size()-1);
    result += "]";
    print("queryExistPasswords  result");
    print(result);
    return &result[0];
}
CONSTANT bool PasswordManage::queryPasswordIsUsed(char* passwordName){
     if (passwordStore.get()[passwordName] != "") {
        return true;
    }
    return false;
}
PAYABLE void PasswordManage::payByPassword(char* passwordName){
    std::string pInfo = passwordStore.get()[passwordName];
    PasswordInfo pwInfo;
    pwInfo.parseJson(pInfo);
    print("pwInfo");
    print(pwInfo.toJson());
    uint64_t transferValue = dipc::callValueUDIP();
    print("transferValue");
    print(transferValue);
    print(pwInfo.balance);
    if(dipc::timestamp() >=  expireTime.get() + pwInfo.timeRegistered){
        DipcAssert(transferValue / 1000 == pwInfo.balance);
        Address toAddr = Address(pwInfo.toAddr,22);
        callTransferUDIP(toAddr, transferValue);
        DIPC_EMIT_EVENT(payByPasswordEvent, passwordName,  transferValue * 1000);
    } else {
        DIPC_EMIT_EVENT(ErrEvent, "payByPassword  password exist", passwordName);
    }
    
    (*passwordStore).erase(passwordName);
    (*passwordStoreHis)[std::string(passwordName)+"_"+pwInfo.toAddr+"_"+std::to_string(pwInfo.timeRegistered)] = pInfo;
}
 
PAYABLE void PasswordManage::depositeContract(){
    uint64_t value = dipc::callValueUDIP() * 1000;
    DIPC_EMIT_EVENT(depositingValue,value);
}
 
EXPORT void PasswordManage::setExpireTime(uint64_t _expireTime){
    
    *expireTime = _expireTime * 60 * 60 * 1000000000;
    DIPC_EMIT_EVENT(expireTimeSetted,expireTime.get());
}

2019-12-31_16:56:02.287493: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:451] log out out payable : PAYABLE void PasswordManage::depositeContract(){
    

2019-12-31_16:56:02.287508: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:457] name : depositeContract   pos1  0

2019-12-31_16:56:02.287517: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:469] pos2  2395   pos1  2395

2019-12-31_16:56:02.287524: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:500] pos2 after 2540   pos1  2395

2019-12-31_16:56:02.287531: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:509] finalContract  first #include "PasswordManage.hpp"

PAYABLE void PasswordManage::init(){
    std::string ownerStr = caller().toString();
    *owner = ownerStr;
}
 
EXPORT void PasswordManage::registerPassword(char* passwordName, char* toAddr, uint64_t _balance){
    PasswordInfo info(passwordName, toAddr, _balance, dipc::timestamp());
    std::string pInfo = info.toJson();
    if (passwordStore.get()[passwordName] != "") {
        DIPC_EMIT_EVENT(ErrEvent, "registerPassword  password exist", passwordName);
        return;
    }
    (*passwordStore)[passwordName] = pInfo;
    print("registerPassword pInfo");
    print(pInfo);
    std::string callerStr = dipc::caller().toString();
    DIPC_EMIT_EVENT(registerPasswordEvent, &callerStr[0], passwordName, &pInfo[0]);
}
CONSTANT char* PasswordManage::queryExistPasswords(){
    std::map<std::string, std::string>::iterator iter;
    auto mapStore = passwordStore.get();
    iter = mapStore.begin();
    std::string result = "[";
    print("queryExistPasswords start");
    while(iter != mapStore.end()){
        result += iter->first + ","; 
        iter++;
    }
    print("queryExistPasswords end");

    result.substr(0,result.size()-1);
    result += "]";
    print("queryExistPasswords  result");
    print(result);
    return &result[0];
}
CONSTANT bool PasswordManage::queryPasswordIsUsed(char* passwordName){
     if (passwordStore.get()[passwordName] != "") {
        return true;
    }
    return false;
}
PAYABLE void PasswordManage::payByPassword(char* passwordName){
    std::string pInfo = passwordStore.get()[passwordName];
    PasswordInfo pwInfo;
    pwInfo.parseJson(pInfo);
    print("pwInfo");
    print(pwInfo.toJson());
    uint64_t transferValue = dipc::callValueUDIP();
    print("transferValue");
    print(transferValue);
    print(pwInfo.balance);
    if(dipc::timestamp() >=  expireTime.get() + pwInfo.timeRegistered){
        DipcAssert(transferValue / 1000 == pwInfo.balance);
        Address toAddr = Address(pwInfo.toAddr,22);
        callTransferUDIP(toAddr, transferValue);
        DIPC_EMIT_EVENT(payByPasswordEvent, passwordName,  transferValue * 1000);
    } else {
        DIPC_EMIT_EVENT(ErrEvent, "payByPassword  password exist", passwordName);
    }
    
    (*passwordStore).erase(passwordName);
    (*passwordStoreHis)[std::string(passwordName)+"_"+pwInfo.toAddr+"_"+std::to_string(pwInfo.timeRegistered)] = pInfo;
}
 


2019-12-31_16:56:02.287538: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:510] codetext  first #include "PasswordManage.hpp"

PAYABLE void PasswordManage::init(){
    std::string ownerStr = caller().toString();
    *owner = ownerStr;
}
 
EXPORT void PasswordManage::registerPassword(char* passwordName, char* toAddr, uint64_t _balance){
    PasswordInfo info(passwordName, toAddr, _balance, dipc::timestamp());
    std::string pInfo = info.toJson();
    if (passwordStore.get()[passwordName] != "") {
        DIPC_EMIT_EVENT(ErrEvent, "registerPassword  password exist", passwordName);
        return;
    }
    (*passwordStore)[passwordName] = pInfo;
    print("registerPassword pInfo");
    print(pInfo);
    std::string callerStr = dipc::caller().toString();
    DIPC_EMIT_EVENT(registerPasswordEvent, &callerStr[0], passwordName, &pInfo[0]);
}
CONSTANT char* PasswordManage::queryExistPasswords(){
    std::map<std::string, std::string>::iterator iter;
    auto mapStore = passwordStore.get();
    iter = mapStore.begin();
    std::string result = "[";
    print("queryExistPasswords start");
    while(iter != mapStore.end()){
        result += iter->first + ","; 
        iter++;
    }
    print("queryExistPasswords end");

    result.substr(0,result.size()-1);
    result += "]";
    print("queryExistPasswords  result");
    print(result);
    return &result[0];
}
CONSTANT bool PasswordManage::queryPasswordIsUsed(char* passwordName){
     if (passwordStore.get()[passwordName] != "") {
        return true;
    }
    return false;
}
PAYABLE void PasswordManage::payByPassword(char* passwordName){
    std::string pInfo = passwordStore.get()[passwordName];
    PasswordInfo pwInfo;
    pwInfo.parseJson(pInfo);
    print("pwInfo");
    print(pwInfo.toJson());
    uint64_t transferValue = dipc::callValueUDIP();
    print("transferValue");
    print(transferValue);
    print(pwInfo.balance);
    if(dipc::timestamp() >=  expireTime.get() + pwInfo.timeRegistered){
        DipcAssert(transferValue / 1000 == pwInfo.balance);
        Address toAddr = Address(pwInfo.toAddr,22);
        callTransferUDIP(toAddr, transferValue);
        DIPC_EMIT_EVENT(payByPasswordEvent, passwordName,  transferValue * 1000);
    } else {
        DIPC_EMIT_EVENT(ErrEvent, "payByPassword  password exist", passwordName);
    }
    
    (*passwordStore).erase(passwordName);
    (*passwordStoreHis)[std::string(passwordName)+"_"+pwInfo.toAddr+"_"+std::to_string(pwInfo.timeRegistered)] = pInfo;
}
 
PAYABLE void PasswordManage::depositeContract(){
    uint64_t value = dipc::callValueUDIP() * 1000;
    DIPC_EMIT_EVENT(depositingValue,value);
}
 
EXPORT void PasswordManage::setExpireTime(uint64_t _expireTime){
    
    *expireTime = _expireTime * 60 * 60 * 1000000000;
    DIPC_EMIT_EVENT(expireTimeSetted,expireTime.get());
}

2019-12-31_16:56:02.287546: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:513] s  first PAYABLE void PasswordManage::depositeContract(){
    uint64_t value = dipc::callValueUDIP() * 1000;
    DIPC_EMIT_EVENT(depositingValue,value);
}

2019-12-31_16:56:02.287893: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:599] search func : PAYABLE void PasswordManage::depositeContract(){
    uint64_t value = dipc::callValueUDIP() * 1000;
    DIPC_EMIT_EVENT(depositingValue,value);
}
2019-12-31_16:56:02.287901: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:424] finalContract  this height  #include "PasswordManage.hpp"

PAYABLE void PasswordManage::init(){
    std::string ownerStr = caller().toString();
    *owner = ownerStr;
}
 
EXPORT void PasswordManage::registerPassword(char* passwordName, char* toAddr, uint64_t _balance){
    PasswordInfo info(passwordName, toAddr, _balance, dipc::timestamp());
    std::string pInfo = info.toJson();
    if (passwordStore.get()[passwordName] != "") {
        DIPC_EMIT_EVENT(ErrEvent, "registerPassword  password exist", passwordName);
        return;
    }
    (*passwordStore)[passwordName] = pInfo;
    print("registerPassword pInfo");
    print(pInfo);
    std::string callerStr = dipc::caller().toString();
    DIPC_EMIT_EVENT(registerPasswordEvent, &callerStr[0], passwordName, &pInfo[0]);
}
CONSTANT char* PasswordManage::queryExistPasswords(){
    std::map<std::string, std::string>::iterator iter;
    auto mapStore = passwordStore.get();
    iter = mapStore.begin();
    std::string result = "[";
    print("queryExistPasswords start");
    while(iter != mapStore.end()){
        result += iter->first + ","; 
        iter++;
    }
    print("queryExistPasswords end");

    result.substr(0,result.size()-1);
    result += "]";
    print("queryExistPasswords  result");
    print(result);
    return &result[0];
}
CONSTANT bool PasswordManage::queryPasswordIsUsed(char* passwordName){
     if (passwordStore.get()[passwordName] != "") {
        return true;
    }
    return false;
}
PAYABLE void PasswordManage::payByPassword(char* passwordName){
    std::string pInfo = passwordStore.get()[passwordName];
    PasswordInfo pwInfo;
    pwInfo.parseJson(pInfo);
    print("pwInfo");
    print(pwInfo.toJson());
    uint64_t transferValue = dipc::callValueUDIP();
    print("transferValue");
    print(transferValue);
    print(pwInfo.balance);
    if(dipc::timestamp() >=  expireTime.get() + pwInfo.timeRegistered){
        DipcAssert(transferValue / 1000 == pwInfo.balance);
        Address toAddr = Address(pwInfo.toAddr,22);
        callTransferUDIP(toAddr, transferValue);
        DIPC_EMIT_EVENT(payByPasswordEvent, passwordName,  transferValue * 1000);
    } else {
        DIPC_EMIT_EVENT(ErrEvent, "payByPassword  password exist", passwordName);
    }
    
    (*passwordStore).erase(passwordName);
    (*passwordStoreHis)[std::string(passwordName)+"_"+pwInfo.toAddr+"_"+std::to_string(pwInfo.timeRegistered)] = pInfo;
}
 
PAYABLE void PasswordManage::depositeContract(){
    uint64_t value = dipc::callValueUDIP() * 1000;
    DIPC_EMIT_EVENT(depositingValue,value);
} codetext height #include "PasswordManage.hpp"

PAYABLE void PasswordManage::init(){
    std::string ownerStr = caller().toString();
    *owner = ownerStr;
}
 
EXPORT void PasswordManage::registerPassword(char* passwordName, char* toAddr, uint64_t _balance){
    PasswordInfo info(passwordName, toAddr, _balance, dipc::timestamp());
    std::string pInfo = info.toJson();
    if (passwordStore.get()[passwordName] != "") {
        DIPC_EMIT_EVENT(ErrEvent, "registerPassword  password exist", passwordName);
        return;
    }
    (*passwordStore)[passwordName] = pInfo;
    print("registerPassword pInfo");
    print(pInfo);
    std::string callerStr = dipc::caller().toString();
    DIPC_EMIT_EVENT(registerPasswordEvent, &callerStr[0], passwordName, &pInfo[0]);
}
CONSTANT char* PasswordManage::queryExistPasswords(){
    std::map<std::string, std::string>::iterator iter;
    auto mapStore = passwordStore.get();
    iter = mapStore.begin();
    std::string result = "[";
    print("queryExistPasswords start");
    while(iter != mapStore.end()){
        result += iter->first + ","; 
        iter++;
    }
    print("queryExistPasswords end");

    result.substr(0,result.size()-1);
    result += "]";
    print("queryExistPasswords  result");
    print(result);
    return &result[0];
}
CONSTANT bool PasswordManage::queryPasswordIsUsed(char* passwordName){
     if (passwordStore.get()[passwordName] != "") {
        return true;
    }
    return false;
}
PAYABLE void PasswordManage::payByPassword(char* passwordName){
    std::string pInfo = passwordStore.get()[passwordName];
    PasswordInfo pwInfo;
    pwInfo.parseJson(pInfo);
    print("pwInfo");
    print(pwInfo.toJson());
    uint64_t transferValue = dipc::callValueUDIP();
    print("transferValue");
    print(transferValue);
    print(pwInfo.balance);
    if(dipc::timestamp() >=  expireTime.get() + pwInfo.timeRegistered){
        DipcAssert(transferValue / 1000 == pwInfo.balance);
        Address toAddr = Address(pwInfo.toAddr,22);
        callTransferUDIP(toAddr, transferValue);
        DIPC_EMIT_EVENT(payByPasswordEvent, passwordName,  transferValue * 1000);
    } else {
        DIPC_EMIT_EVENT(ErrEvent, "payByPassword  password exist", passwordName);
    }
    
    (*passwordStore).erase(passwordName);
    (*passwordStoreHis)[std::string(passwordName)+"_"+pwInfo.toAddr+"_"+std::to_string(pwInfo.timeRegistered)] = pInfo;
}
 
PAYABLE void PasswordManage::depositeContract(){
    uint64_t value = dipc::callValueUDIP() * 1000;
    DIPC_EMIT_EVENT(depositingValue,value);
}
 
EXPORT void PasswordManage::setExpireTime(uint64_t _expireTime){
    
    *expireTime = _expireTime * 60 * 60 * 1000000000;
    DIPC_EMIT_EVENT(expireTimeSetted,expireTime.get());
}

2019-12-31_16:56:02.287909: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:427] searchContext  
 
EXPORT void PasswordManage::setExpireTime(uint64_t _expireTime){
    
    *expireTime = _expireTime * 60 * 60 * 1000000000;
    DIPC_EMIT_EVENT(expireTimeSetted,expireTime.get());
}

2019-12-31_16:56:02.287974: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:442] finalContract  this new  #include "PasswordManage.hpp"

PAYABLE void PasswordManage::init(){
    std::string ownerStr = caller().toString();
    *owner = ownerStr;
}
 
EXPORT void PasswordManage::registerPassword(char* passwordName, char* toAddr, uint64_t _balance){
    PasswordInfo info(passwordName, toAddr, _balance, dipc::timestamp());
    std::string pInfo = info.toJson();
    if (passwordStore.get()[passwordName] != "") {
        DIPC_EMIT_EVENT(ErrEvent, "registerPassword  password exist", passwordName);
        return;
    }
    (*passwordStore)[passwordName] = pInfo;
    print("registerPassword pInfo");
    print(pInfo);
    std::string callerStr = dipc::caller().toString();
    DIPC_EMIT_EVENT(registerPasswordEvent, &callerStr[0], passwordName, &pInfo[0]);
}
CONSTANT char* PasswordManage::queryExistPasswords(){
    std::map<std::string, std::string>::iterator iter;
    auto mapStore = passwordStore.get();
    iter = mapStore.begin();
    std::string result = "[";
    print("queryExistPasswords start");
    while(iter != mapStore.end()){
        result += iter->first + ","; 
        iter++;
    }
    print("queryExistPasswords end");

    result.substr(0,result.size()-1);
    result += "]";
    print("queryExistPasswords  result");
    print(result);
    return &result[0];
}
CONSTANT bool PasswordManage::queryPasswordIsUsed(char* passwordName){
     if (passwordStore.get()[passwordName] != "") {
        return true;
    }
    return false;
}
PAYABLE void PasswordManage::payByPassword(char* passwordName){
    std::string pInfo = passwordStore.get()[passwordName];
    PasswordInfo pwInfo;
    pwInfo.parseJson(pInfo);
    print("pwInfo");
    print(pwInfo.toJson());
    uint64_t transferValue = dipc::callValueUDIP();
    print("transferValue");
    print(transferValue);
    print(pwInfo.balance);
    if(dipc::timestamp() >=  expireTime.get() + pwInfo.timeRegistered){
        DipcAssert(transferValue / 1000 == pwInfo.balance);
        Address toAddr = Address(pwInfo.toAddr,22);
        callTransferUDIP(toAddr, transferValue);
        DIPC_EMIT_EVENT(payByPasswordEvent, passwordName,  transferValue * 1000);
    } else {
        DIPC_EMIT_EVENT(ErrEvent, "payByPassword  password exist", passwordName);
    }
    
    (*passwordStore).erase(passwordName);
    (*passwordStoreHis)[std::string(passwordName)+"_"+pwInfo.toAddr+"_"+std::to_string(pwInfo.timeRegistered)] = pInfo;
}
 
PAYABLE void PasswordManage::depositeContract(){
    uint64_t value = dipc::callValueUDIP() * 1000;
    DIPC_EMIT_EVENT(depositingValue,value);
} codetext new #include "PasswordManage.hpp"

PAYABLE void PasswordManage::init(){
    std::string ownerStr = caller().toString();
    *owner = ownerStr;
}
 
EXPORT void PasswordManage::registerPassword(char* passwordName, char* toAddr, uint64_t _balance){
    PasswordInfo info(passwordName, toAddr, _balance, dipc::timestamp());
    std::string pInfo = info.toJson();
    if (passwordStore.get()[passwordName] != "") {
        DIPC_EMIT_EVENT(ErrEvent, "registerPassword  password exist", passwordName);
        return;
    }
    (*passwordStore)[passwordName] = pInfo;
    print("registerPassword pInfo");
    print(pInfo);
    std::string callerStr = dipc::caller().toString();
    DIPC_EMIT_EVENT(registerPasswordEvent, &callerStr[0], passwordName, &pInfo[0]);
}
CONSTANT char* PasswordManage::queryExistPasswords(){
    std::map<std::string, std::string>::iterator iter;
    auto mapStore = passwordStore.get();
    iter = mapStore.begin();
    std::string result = "[";
    print("queryExistPasswords start");
    while(iter != mapStore.end()){
        result += iter->first + ","; 
        iter++;
    }
    print("queryExistPasswords end");

    result.substr(0,result.size()-1);
    result += "]";
    print("queryExistPasswords  result");
    print(result);
    return &result[0];
}
CONSTANT bool PasswordManage::queryPasswordIsUsed(char* passwordName){
     if (passwordStore.get()[passwordName] != "") {
        return true;
    }
    return false;
}
PAYABLE void PasswordManage::payByPassword(char* passwordName){
    std::string pInfo = passwordStore.get()[passwordName];
    PasswordInfo pwInfo;
    pwInfo.parseJson(pInfo);
    print("pwInfo");
    print(pwInfo.toJson());
    uint64_t transferValue = dipc::callValueUDIP();
    print("transferValue");
    print(transferValue);
    print(pwInfo.balance);
    if(dipc::timestamp() >=  expireTime.get() + pwInfo.timeRegistered){
        DipcAssert(transferValue / 1000 == pwInfo.balance);
        Address toAddr = Address(pwInfo.toAddr,22);
        callTransferUDIP(toAddr, transferValue);
        DIPC_EMIT_EVENT(payByPasswordEvent, passwordName,  transferValue * 1000);
    } else {
        DIPC_EMIT_EVENT(ErrEvent, "payByPassword  password exist", passwordName);
    }
    
    (*passwordStore).erase(passwordName);
    (*passwordStoreHis)[std::string(passwordName)+"_"+pwInfo.toAddr+"_"+std::to_string(pwInfo.timeRegistered)] = pInfo;
}
 
PAYABLE void PasswordManage::depositeContract(){
    uint64_t value = dipc::callValueUDIP() * 1000;
    DIPC_EMIT_EVENT(depositingValue,value);
}
 
EXPORT void PasswordManage::setExpireTime(uint64_t _expireTime){
    
    *expireTime = _expireTime * 60 * 60 * 1000000000;
    DIPC_EMIT_EVENT(expireTimeSetted,expireTime.get());
}

2019-12-31_16:56:02.287982: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:604] finalContract  final content =======   : #include "PasswordManage.hpp"

PAYABLE void PasswordManage::init(){
    std::string ownerStr = caller().toString();
    *owner = ownerStr;
}
 
EXPORT void PasswordManage::registerPassword(char* passwordName, char* toAddr, uint64_t _balance){
    PasswordInfo info(passwordName, toAddr, _balance, dipc::timestamp());
    std::string pInfo = info.toJson();
    if (passwordStore.get()[passwordName] != "") {
        DIPC_EMIT_EVENT(ErrEvent, "registerPassword  password exist", passwordName);
        return;
    }
    (*passwordStore)[passwordName] = pInfo;
    print("registerPassword pInfo");
    print(pInfo);
    std::string callerStr = dipc::caller().toString();
    DIPC_EMIT_EVENT(registerPasswordEvent, &callerStr[0], passwordName, &pInfo[0]);
}
CONSTANT char* PasswordManage::queryExistPasswords(){
    std::map<std::string, std::string>::iterator iter;
    auto mapStore = passwordStore.get();
    iter = mapStore.begin();
    std::string result = "[";
    print("queryExistPasswords start");
    while(iter != mapStore.end()){
        result += iter->first + ","; 
        iter++;
    }
    print("queryExistPasswords end");

    result.substr(0,result.size()-1);
    result += "]";
    print("queryExistPasswords  result");
    print(result);
    return &result[0];
}
CONSTANT bool PasswordManage::queryPasswordIsUsed(char* passwordName){
     if (passwordStore.get()[passwordName] != "") {
        return true;
    }
    return false;
}
PAYABLE void PasswordManage::payByPassword(char* passwordName){
    std::string pInfo = passwordStore.get()[passwordName];
    PasswordInfo pwInfo;
    pwInfo.parseJson(pInfo);
    print("pwInfo");
    print(pwInfo.toJson());
    uint64_t transferValue = dipc::callValueUDIP();
    print("transferValue");
    print(transferValue);
    print(pwInfo.balance);
    if(dipc::timestamp() >=  expireTime.get() + pwInfo.timeRegistered){
        DipcAssert(transferValue / 1000 == pwInfo.balance);
        Address toAddr = Address(pwInfo.toAddr,22);
        callTransferUDIP(toAddr, transferValue);
        DIPC_EMIT_EVENT(payByPasswordEvent, passwordName,  transferValue * 1000);
    } else {
        DIPC_EMIT_EVENT(ErrEvent, "payByPassword  password exist", passwordName);
    }
    
    (*passwordStore).erase(passwordName);
    (*passwordStoreHis)[std::string(passwordName)+"_"+pwInfo.toAddr+"_"+std::to_string(pwInfo.timeRegistered)] = pInfo;
}
 
PAYABLE void PasswordManage::depositeContract(){
    uint64_t value = dipc::callValueUDIP() * 1000;
    DIPC_EMIT_EVENT(depositingValue,value);
}
 
EXPORT void PasswordManage::setExpireTime(uint64_t _expireTime){
    
    *expireTime = _expireTime * 60 * 60 * 1000000000;
    DIPC_EMIT_EVENT(expireTimeSetted,expireTime.get());
}

2019-12-31_16:56:02.287989: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:401] abis.ispayable :true

2019-12-31_16:56:02.288004: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:424] finalContract  this height  #include "PasswordManage.hpp"

PAYABLE void PasswordManage::init(){
    std::string ownerStr = caller().toString();
    *owner = ownerStr;
}
 
EXPORT void PasswordManage::registerPassword(char* passwordName, char* toAddr, uint64_t _balance){
    PasswordInfo info(passwordName, toAddr, _balance, dipc::timestamp());
    std::string pInfo = info.toJson();
    if (passwordStore.get()[passwordName] != "") {
        DIPC_EMIT_EVENT(ErrEvent, "registerPassword  password exist", passwordName);
        return;
    }
    (*passwordStore)[passwordName] = pInfo;
    print("registerPassword pInfo");
    print(pInfo);
    std::string callerStr = dipc::caller().toString();
    DIPC_EMIT_EVENT(registerPasswordEvent, &callerStr[0], passwordName, &pInfo[0]);
}
CONSTANT char* PasswordManage::queryExistPasswords(){
    std::map<std::string, std::string>::iterator iter;
    auto mapStore = passwordStore.get();
    iter = mapStore.begin();
    std::string result = "[";
    print("queryExistPasswords start");
    while(iter != mapStore.end()){
        result += iter->first + ","; 
        iter++;
    }
    print("queryExistPasswords end");

    result.substr(0,result.size()-1);
    result += "]";
    print("queryExistPasswords  result");
    print(result);
    return &result[0];
}
CONSTANT bool PasswordManage::queryPasswordIsUsed(char* passwordName){
     if (passwordStore.get()[passwordName] != "") {
        return true;
    }
    return false;
}
PAYABLE void PasswordManage::payByPassword(char* passwordName){
    std::string pInfo = passwordStore.get()[passwordName];
    PasswordInfo pwInfo;
    pwInfo.parseJson(pInfo);
    print("pwInfo");
    print(pwInfo.toJson());
    uint64_t transferValue = dipc::callValueUDIP();
    print("transferValue");
    print(transferValue);
    print(pwInfo.balance);
    if(dipc::timestamp() >=  expireTime.get() + pwInfo.timeRegistered){
        DipcAssert(transferValue / 1000 == pwInfo.balance);
        Address toAddr = Address(pwInfo.toAddr,22);
        callTransferUDIP(toAddr, transferValue);
        DIPC_EMIT_EVENT(payByPasswordEvent, passwordName,  transferValue * 1000);
    } else {
        DIPC_EMIT_EVENT(ErrEvent, "payByPassword  password exist", passwordName);
    }
    
    (*passwordStore).erase(passwordName);
    (*passwordStoreHis)[std::string(passwordName)+"_"+pwInfo.toAddr+"_"+std::to_string(pwInfo.timeRegistered)] = pInfo;
}
 
PAYABLE void PasswordManage::depositeContract(){
    uint64_t value = dipc::callValueUDIP() * 1000;
    DIPC_EMIT_EVENT(depositingValue,value);
}
 
EXPORT void PasswordManage::setExpireTime(uint64_t _expireTime){
    
    *expireTime = _expireTime * 60 * 60 * 1000000000;
    DIPC_EMIT_EVENT(expireTimeSetted,expireTime.get());
} codetext height #include "PasswordManage.hpp"

PAYABLE void PasswordManage::init(){
    std::string ownerStr = caller().toString();
    *owner = ownerStr;
}
 
EXPORT void PasswordManage::registerPassword(char* passwordName, char* toAddr, uint64_t _balance){
    PasswordInfo info(passwordName, toAddr, _balance, dipc::timestamp());
    std::string pInfo = info.toJson();
    if (passwordStore.get()[passwordName] != "") {
        DIPC_EMIT_EVENT(ErrEvent, "registerPassword  password exist", passwordName);
        return;
    }
    (*passwordStore)[passwordName] = pInfo;
    print("registerPassword pInfo");
    print(pInfo);
    std::string callerStr = dipc::caller().toString();
    DIPC_EMIT_EVENT(registerPasswordEvent, &callerStr[0], passwordName, &pInfo[0]);
}
CONSTANT char* PasswordManage::queryExistPasswords(){
    std::map<std::string, std::string>::iterator iter;
    auto mapStore = passwordStore.get();
    iter = mapStore.begin();
    std::string result = "[";
    print("queryExistPasswords start");
    while(iter != mapStore.end()){
        result += iter->first + ","; 
        iter++;
    }
    print("queryExistPasswords end");

    result.substr(0,result.size()-1);
    result += "]";
    print("queryExistPasswords  result");
    print(result);
    return &result[0];
}
CONSTANT bool PasswordManage::queryPasswordIsUsed(char* passwordName){
     if (passwordStore.get()[passwordName] != "") {
        return true;
    }
    return false;
}
PAYABLE void PasswordManage::payByPassword(char* passwordName){
    std::string pInfo = passwordStore.get()[passwordName];
    PasswordInfo pwInfo;
    pwInfo.parseJson(pInfo);
    print("pwInfo");
    print(pwInfo.toJson());
    uint64_t transferValue = dipc::callValueUDIP();
    print("transferValue");
    print(transferValue);
    print(pwInfo.balance);
    if(dipc::timestamp() >=  expireTime.get() + pwInfo.timeRegistered){
        DipcAssert(transferValue / 1000 == pwInfo.balance);
        Address toAddr = Address(pwInfo.toAddr,22);
        callTransferUDIP(toAddr, transferValue);
        DIPC_EMIT_EVENT(payByPasswordEvent, passwordName,  transferValue * 1000);
    } else {
        DIPC_EMIT_EVENT(ErrEvent, "payByPassword  password exist", passwordName);
    }
    
    (*passwordStore).erase(passwordName);
    (*passwordStoreHis)[std::string(passwordName)+"_"+pwInfo.toAddr+"_"+std::to_string(pwInfo.timeRegistered)] = pInfo;
}
 
PAYABLE void PasswordManage::depositeContract(){
    uint64_t value = dipc::callValueUDIP() * 1000;
    DIPC_EMIT_EVENT(depositingValue,value);
}
 
EXPORT void PasswordManage::setExpireTime(uint64_t _expireTime){
    
    *expireTime = _expireTime * 60 * 60 * 1000000000;
    DIPC_EMIT_EVENT(expireTimeSetted,expireTime.get());
}

2019-12-31_16:56:02.288011: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:427] searchContext  #include "PasswordManage.hpp"

PAYABLE void PasswordManage::init(){
    std::string ownerStr = caller().toString();
    *owner = ownerStr;
}
 
EXPORT void PasswordManage::registerPassword(char* passwordName, char* toAddr, uint64_t _balance){
    PasswordInfo info(passwordName, toAddr, _balance, dipc::timestamp());
    std::string pInfo = info.toJson();
    if (passwordStore.get()[passwordName] != "") {
        DIPC_EMIT_EVENT(ErrEvent, "registerPassword  password exist", passwordName);
        return;
    }
    (*passwordStore)[passwordName] = pInfo;
    print("registerPassword pInfo");
    print(pInfo);
    std::string callerStr = dipc::caller().toString();
    DIPC_EMIT_EVENT(registerPasswordEvent, &callerStr[0], passwordName, &pInfo[0]);
}
CONSTANT char* PasswordManage::queryExistPasswords(){
    std::map<std::string, std::string>::iterator iter;
    auto mapStore = passwordStore.get();
    iter = mapStore.begin();
    std::string result = "[";
    print("queryExistPasswords start");
    while(iter != mapStore.end()){
        result += iter->first + ","; 
        iter++;
    }
    print("queryExistPasswords end");

    result.substr(0,result.size()-1);
    result += "]";
    print("queryExistPasswords  result");
    print(result);
    return &result[0];
}
CONSTANT bool PasswordManage::queryPasswordIsUsed(char* passwordName){
     if (passwordStore.get()[passwordName] != "") {
        return true;
    }
    return false;
}
PAYABLE void PasswordManage::payByPassword(char* passwordName){
    std::string pInfo = passwordStore.get()[passwordName];
    PasswordInfo pwInfo;
    pwInfo.parseJson(pInfo);
    print("pwInfo");
    print(pwInfo.toJson());
    uint64_t transferValue = dipc::callValueUDIP();
    print("transferValue");
    print(transferValue);
    print(pwInfo.balance);
    if(dipc::timestamp() >=  expireTime.get() + pwInfo.timeRegistered){
        DipcAssert(transferValue / 1000 == pwInfo.balance);
        Address toAddr = Address(pwInfo.toAddr,22);
        callTransferUDIP(toAddr, transferValue);
        DIPC_EMIT_EVENT(payByPasswordEvent, passwordName,  transferValue * 1000);
    } else {
        DIPC_EMIT_EVENT(ErrEvent, "payByPassword  password exist", passwordName);
    }
    
    (*passwordStore).erase(passwordName);
    (*passwordStoreHis)[std::string(passwordName)+"_"+pwInfo.toAddr+"_"+std::to_string(pwInfo.timeRegistered)] = pInfo;
}
 
PAYABLE void PasswordManage::depositeContract(){
    uint64_t value = dipc::callValueUDIP() * 1000;
    DIPC_EMIT_EVENT(depositingValue,value);
}
 
EXPORT void PasswordManage::setExpireTime(uint64_t _expireTime){
    
    *expireTime = _expireTime * 60 * 60 * 1000000000;
    DIPC_EMIT_EVENT(expireTimeSetted,expireTime.get());
}

2019-12-31_16:56:02.288045: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:451] log out out payable : PAYABLE void PasswordManage::init(){
    

2019-12-31_16:56:02.288052: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:457] name : init   pos1  0

2019-12-31_16:56:02.288058: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:469] pos2  31   pos1  31

2019-12-31_16:56:02.288065: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:500] pos2 after 140   pos1  31

2019-12-31_16:56:02.288071: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:509] finalContract  first #include "PasswordManage.hpp"



2019-12-31_16:56:02.288077: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:510] codetext  first #include "PasswordManage.hpp"

PAYABLE void PasswordManage::init(){
    std::string ownerStr = caller().toString();
    *owner = ownerStr;
}
 
EXPORT void PasswordManage::registerPassword(char* passwordName, char* toAddr, uint64_t _balance){
    PasswordInfo info(passwordName, toAddr, _balance, dipc::timestamp());
    std::string pInfo = info.toJson();
    if (passwordStore.get()[passwordName] != "") {
        DIPC_EMIT_EVENT(ErrEvent, "registerPassword  password exist", passwordName);
        return;
    }
    (*passwordStore)[passwordName] = pInfo;
    print("registerPassword pInfo");
    print(pInfo);
    std::string callerStr = dipc::caller().toString();
    DIPC_EMIT_EVENT(registerPasswordEvent, &callerStr[0], passwordName, &pInfo[0]);
}
CONSTANT char* PasswordManage::queryExistPasswords(){
    std::map<std::string, std::string>::iterator iter;
    auto mapStore = passwordStore.get();
    iter = mapStore.begin();
    std::string result = "[";
    print("queryExistPasswords start");
    while(iter != mapStore.end()){
        result += iter->first + ","; 
        iter++;
    }
    print("queryExistPasswords end");

    result.substr(0,result.size()-1);
    result += "]";
    print("queryExistPasswords  result");
    print(result);
    return &result[0];
}
CONSTANT bool PasswordManage::queryPasswordIsUsed(char* passwordName){
     if (passwordStore.get()[passwordName] != "") {
        return true;
    }
    return false;
}
PAYABLE void PasswordManage::payByPassword(char* passwordName){
    std::string pInfo = passwordStore.get()[passwordName];
    PasswordInfo pwInfo;
    pwInfo.parseJson(pInfo);
    print("pwInfo");
    print(pwInfo.toJson());
    uint64_t transferValue = dipc::callValueUDIP();
    print("transferValue");
    print(transferValue);
    print(pwInfo.balance);
    if(dipc::timestamp() >=  expireTime.get() + pwInfo.timeRegistered){
        DipcAssert(transferValue / 1000 == pwInfo.balance);
        Address toAddr = Address(pwInfo.toAddr,22);
        callTransferUDIP(toAddr, transferValue);
        DIPC_EMIT_EVENT(payByPasswordEvent, passwordName,  transferValue * 1000);
    } else {
        DIPC_EMIT_EVENT(ErrEvent, "payByPassword  password exist", passwordName);
    }
    
    (*passwordStore).erase(passwordName);
    (*passwordStoreHis)[std::string(passwordName)+"_"+pwInfo.toAddr+"_"+std::to_string(pwInfo.timeRegistered)] = pInfo;
}
 
PAYABLE void PasswordManage::depositeContract(){
    uint64_t value = dipc::callValueUDIP() * 1000;
    DIPC_EMIT_EVENT(depositingValue,value);
}
 
EXPORT void PasswordManage::setExpireTime(uint64_t _expireTime){
    
    *expireTime = _expireTime * 60 * 60 * 1000000000;
    DIPC_EMIT_EVENT(expireTimeSetted,expireTime.get());
}

2019-12-31_16:56:02.288087: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:513] s  first PAYABLE void PasswordManage::init(){
    std::string ownerStr = caller().toString();
    *owner = ownerStr;
}

2019-12-31_16:56:02.288403: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:599] search func : PAYABLE void PasswordManage::init(){
    std::string ownerStr = caller().toString();
    *owner = ownerStr;
}
2019-12-31_16:56:02.288410: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:424] finalContract  this height  #include "PasswordManage.hpp"

PAYABLE void PasswordManage::init(){
    std::string ownerStr = caller().toString();
    *owner = ownerStr;
} codetext height #include "PasswordManage.hpp"

PAYABLE void PasswordManage::init(){
    std::string ownerStr = caller().toString();
    *owner = ownerStr;
}
 
EXPORT void PasswordManage::registerPassword(char* passwordName, char* toAddr, uint64_t _balance){
    PasswordInfo info(passwordName, toAddr, _balance, dipc::timestamp());
    std::string pInfo = info.toJson();
    if (passwordStore.get()[passwordName] != "") {
        DIPC_EMIT_EVENT(ErrEvent, "registerPassword  password exist", passwordName);
        return;
    }
    (*passwordStore)[passwordName] = pInfo;
    print("registerPassword pInfo");
    print(pInfo);
    std::string callerStr = dipc::caller().toString();
    DIPC_EMIT_EVENT(registerPasswordEvent, &callerStr[0], passwordName, &pInfo[0]);
}
CONSTANT char* PasswordManage::queryExistPasswords(){
    std::map<std::string, std::string>::iterator iter;
    auto mapStore = passwordStore.get();
    iter = mapStore.begin();
    std::string result = "[";
    print("queryExistPasswords start");
    while(iter != mapStore.end()){
        result += iter->first + ","; 
        iter++;
    }
    print("queryExistPasswords end");

    result.substr(0,result.size()-1);
    result += "]";
    print("queryExistPasswords  result");
    print(result);
    return &result[0];
}
CONSTANT bool PasswordManage::queryPasswordIsUsed(char* passwordName){
     if (passwordStore.get()[passwordName] != "") {
        return true;
    }
    return false;
}
PAYABLE void PasswordManage::payByPassword(char* passwordName){
    std::string pInfo = passwordStore.get()[passwordName];
    PasswordInfo pwInfo;
    pwInfo.parseJson(pInfo);
    print("pwInfo");
    print(pwInfo.toJson());
    uint64_t transferValue = dipc::callValueUDIP();
    print("transferValue");
    print(transferValue);
    print(pwInfo.balance);
    if(dipc::timestamp() >=  expireTime.get() + pwInfo.timeRegistered){
        DipcAssert(transferValue / 1000 == pwInfo.balance);
        Address toAddr = Address(pwInfo.toAddr,22);
        callTransferUDIP(toAddr, transferValue);
        DIPC_EMIT_EVENT(payByPasswordEvent, passwordName,  transferValue * 1000);
    } else {
        DIPC_EMIT_EVENT(ErrEvent, "payByPassword  password exist", passwordName);
    }
    
    (*passwordStore).erase(passwordName);
    (*passwordStoreHis)[std::string(passwordName)+"_"+pwInfo.toAddr+"_"+std::to_string(pwInfo.timeRegistered)] = pInfo;
}
 
PAYABLE void PasswordManage::depositeContract(){
    uint64_t value = dipc::callValueUDIP() * 1000;
    DIPC_EMIT_EVENT(depositingValue,value);
}
 
EXPORT void PasswordManage::setExpireTime(uint64_t _expireTime){
    
    *expireTime = _expireTime * 60 * 60 * 1000000000;
    DIPC_EMIT_EVENT(expireTimeSetted,expireTime.get());
}

2019-12-31_16:56:02.288480: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:427] searchContext  
 
EXPORT void PasswordManage::registerPassword(char* passwordName, char* toAddr, uint64_t _balance){
    PasswordInfo info(passwordName, toAddr, _balance, dipc::timestamp());
    std::string pInfo = info.toJson();
    if (passwordStore.get()[passwordName] != "") {
        DIPC_EMIT_EVENT(ErrEvent, "registerPassword  password exist", passwordName);
        return;
    }
    (*passwordStore)[passwordName] = pInfo;
    print("registerPassword pInfo");
    print(pInfo);
    std::string callerStr = dipc::caller().toString();
    DIPC_EMIT_EVENT(registerPasswordEvent, &callerStr[0], passwordName, &pInfo[0]);
}
CONSTANT char* PasswordManage::queryExistPasswords(){
    std::map<std::string, std::string>::iterator iter;
    auto mapStore = passwordStore.get();
    iter = mapStore.begin();
    std::string result = "[";
    print("queryExistPasswords start");
    while(iter != mapStore.end()){
        result += iter->first + ","; 
        iter++;
    }
    print("queryExistPasswords end");

    result.substr(0,result.size()-1);
    result += "]";
    print("queryExistPasswords  result");
    print(result);
    return &result[0];
}
CONSTANT bool PasswordManage::queryPasswordIsUsed(char* passwordName){
     if (passwordStore.get()[passwordName] != "") {
        return true;
    }
    return false;
}
PAYABLE void PasswordManage::payByPassword(char* passwordName){
    std::string pInfo = passwordStore.get()[passwordName];
    PasswordInfo pwInfo;
    pwInfo.parseJson(pInfo);
    print("pwInfo");
    print(pwInfo.toJson());
    uint64_t transferValue = dipc::callValueUDIP();
    print("transferValue");
    print(transferValue);
    print(pwInfo.balance);
    if(dipc::timestamp() >=  expireTime.get() + pwInfo.timeRegistered){
        DipcAssert(transferValue / 1000 == pwInfo.balance);
        Address toAddr = Address(pwInfo.toAddr,22);
        callTransferUDIP(toAddr, transferValue);
        DIPC_EMIT_EVENT(payByPasswordEvent, passwordName,  transferValue * 1000);
    } else {
        DIPC_EMIT_EVENT(ErrEvent, "payByPassword  password exist", passwordName);
    }
    
    (*passwordStore).erase(passwordName);
    (*passwordStoreHis)[std::string(passwordName)+"_"+pwInfo.toAddr+"_"+std::to_string(pwInfo.timeRegistered)] = pInfo;
}
 
PAYABLE void PasswordManage::depositeContract(){
    uint64_t value = dipc::callValueUDIP() * 1000;
    DIPC_EMIT_EVENT(depositingValue,value);
}
 
EXPORT void PasswordManage::setExpireTime(uint64_t _expireTime){
    
    *expireTime = _expireTime * 60 * 60 * 1000000000;
    DIPC_EMIT_EVENT(expireTimeSetted,expireTime.get());
}

2019-12-31_16:56:02.289491: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:442] finalContract  this new  #include "PasswordManage.hpp"

PAYABLE void PasswordManage::init(){
    std::string ownerStr = caller().toString();
    *owner = ownerStr;
} codetext new #include "PasswordManage.hpp"

PAYABLE void PasswordManage::init(){
    std::string ownerStr = caller().toString();
    *owner = ownerStr;
}
 
EXPORT void PasswordManage::registerPassword(char* passwordName, char* toAddr, uint64_t _balance){
    PasswordInfo info(passwordName, toAddr, _balance, dipc::timestamp());
    std::string pInfo = info.toJson();
    if (passwordStore.get()[passwordName] != "") {
        DIPC_EMIT_EVENT(ErrEvent, "registerPassword  password exist", passwordName);
        return;
    }
    (*passwordStore)[passwordName] = pInfo;
    print("registerPassword pInfo");
    print(pInfo);
    std::string callerStr = dipc::caller().toString();
    DIPC_EMIT_EVENT(registerPasswordEvent, &callerStr[0], passwordName, &pInfo[0]);
}
CONSTANT char* PasswordManage::queryExistPasswords(){
    std::map<std::string, std::string>::iterator iter;
    auto mapStore = passwordStore.get();
    iter = mapStore.begin();
    std::string result = "[";
    print("queryExistPasswords start");
    while(iter != mapStore.end()){
        result += iter->first + ","; 
        iter++;
    }
    print("queryExistPasswords end");

    result.substr(0,result.size()-1);
    result += "]";
    print("queryExistPasswords  result");
    print(result);
    return &result[0];
}
CONSTANT bool PasswordManage::queryPasswordIsUsed(char* passwordName){
     if (passwordStore.get()[passwordName] != "") {
        return true;
    }
    return false;
}
PAYABLE void PasswordManage::payByPassword(char* passwordName){
    std::string pInfo = passwordStore.get()[passwordName];
    PasswordInfo pwInfo;
    pwInfo.parseJson(pInfo);
    print("pwInfo");
    print(pwInfo.toJson());
    uint64_t transferValue = dipc::callValueUDIP();
    print("transferValue");
    print(transferValue);
    print(pwInfo.balance);
    if(dipc::timestamp() >=  expireTime.get() + pwInfo.timeRegistered){
        DipcAssert(transferValue / 1000 == pwInfo.balance);
        Address toAddr = Address(pwInfo.toAddr,22);
        callTransferUDIP(toAddr, transferValue);
        DIPC_EMIT_EVENT(payByPasswordEvent, passwordName,  transferValue * 1000);
    } else {
        DIPC_EMIT_EVENT(ErrEvent, "payByPassword  password exist", passwordName);
    }
    
    (*passwordStore).erase(passwordName);
    (*passwordStoreHis)[std::string(passwordName)+"_"+pwInfo.toAddr+"_"+std::to_string(pwInfo.timeRegistered)] = pInfo;
}
 
PAYABLE void PasswordManage::depositeContract(){
    uint64_t value = dipc::callValueUDIP() * 1000;
    DIPC_EMIT_EVENT(depositingValue,value);
}
 
EXPORT void PasswordManage::setExpireTime(uint64_t _expireTime){
    
    *expireTime = _expireTime * 60 * 60 * 1000000000;
    DIPC_EMIT_EVENT(expireTimeSetted,expireTime.get());
}

2019-12-31_16:56:02.289501: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:604] finalContract  final content =======   : #include "PasswordManage.hpp"

PAYABLE void PasswordManage::init(){
    std::string ownerStr = caller().toString();
    *owner = ownerStr;
}
 
EXPORT void PasswordManage::registerPassword(char* passwordName, char* toAddr, uint64_t _balance){
    PasswordInfo info(passwordName, toAddr, _balance, dipc::timestamp());
    std::string pInfo = info.toJson();
    if (passwordStore.get()[passwordName] != "") {
        DIPC_EMIT_EVENT(ErrEvent, "registerPassword  password exist", passwordName);
        return;
    }
    (*passwordStore)[passwordName] = pInfo;
    print("registerPassword pInfo");
    print(pInfo);
    std::string callerStr = dipc::caller().toString();
    DIPC_EMIT_EVENT(registerPasswordEvent, &callerStr[0], passwordName, &pInfo[0]);
}
CONSTANT char* PasswordManage::queryExistPasswords(){
    std::map<std::string, std::string>::iterator iter;
    auto mapStore = passwordStore.get();
    iter = mapStore.begin();
    std::string result = "[";
    print("queryExistPasswords start");
    while(iter != mapStore.end()){
        result += iter->first + ","; 
        iter++;
    }
    print("queryExistPasswords end");

    result.substr(0,result.size()-1);
    result += "]";
    print("queryExistPasswords  result");
    print(result);
    return &result[0];
}
CONSTANT bool PasswordManage::queryPasswordIsUsed(char* passwordName){
     if (passwordStore.get()[passwordName] != "") {
        return true;
    }
    return false;
}
PAYABLE void PasswordManage::payByPassword(char* passwordName){
    std::string pInfo = passwordStore.get()[passwordName];
    PasswordInfo pwInfo;
    pwInfo.parseJson(pInfo);
    print("pwInfo");
    print(pwInfo.toJson());
    uint64_t transferValue = dipc::callValueUDIP();
    print("transferValue");
    print(transferValue);
    print(pwInfo.balance);
    if(dipc::timestamp() >=  expireTime.get() + pwInfo.timeRegistered){
        DipcAssert(transferValue / 1000 == pwInfo.balance);
        Address toAddr = Address(pwInfo.toAddr,22);
        callTransferUDIP(toAddr, transferValue);
        DIPC_EMIT_EVENT(payByPasswordEvent, passwordName,  transferValue * 1000);
    } else {
        DIPC_EMIT_EVENT(ErrEvent, "payByPassword  password exist", passwordName);
    }
    
    (*passwordStore).erase(passwordName);
    (*passwordStoreHis)[std::string(passwordName)+"_"+pwInfo.toAddr+"_"+std::to_string(pwInfo.timeRegistered)] = pInfo;
}
 
PAYABLE void PasswordManage::depositeContract(){
    uint64_t value = dipc::callValueUDIP() * 1000;
    DIPC_EMIT_EVENT(depositingValue,value);
}
 
EXPORT void PasswordManage::setExpireTime(uint64_t _expireTime){
    
    *expireTime = _expireTime * 60 * 60 * 1000000000;
    DIPC_EMIT_EVENT(expireTimeSetted,expireTime.get());
}

2019-12-31_16:56:02.289508: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:401] abis.ispayable :false

2019-12-31_16:56:02.289523: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:424] finalContract  this height  #include "PasswordManage.hpp"

PAYABLE void PasswordManage::init(){
    std::string ownerStr = caller().toString();
    *owner = ownerStr;
}
 
EXPORT void PasswordManage::registerPassword(char* passwordName, char* toAddr, uint64_t _balance){
    PasswordInfo info(passwordName, toAddr, _balance, dipc::timestamp());
    std::string pInfo = info.toJson();
    if (passwordStore.get()[passwordName] != "") {
        DIPC_EMIT_EVENT(ErrEvent, "registerPassword  password exist", passwordName);
        return;
    }
    (*passwordStore)[passwordName] = pInfo;
    print("registerPassword pInfo");
    print(pInfo);
    std::string callerStr = dipc::caller().toString();
    DIPC_EMIT_EVENT(registerPasswordEvent, &callerStr[0], passwordName, &pInfo[0]);
}
CONSTANT char* PasswordManage::queryExistPasswords(){
    std::map<std::string, std::string>::iterator iter;
    auto mapStore = passwordStore.get();
    iter = mapStore.begin();
    std::string result = "[";
    print("queryExistPasswords start");
    while(iter != mapStore.end()){
        result += iter->first + ","; 
        iter++;
    }
    print("queryExistPasswords end");

    result.substr(0,result.size()-1);
    result += "]";
    print("queryExistPasswords  result");
    print(result);
    return &result[0];
}
CONSTANT bool PasswordManage::queryPasswordIsUsed(char* passwordName){
     if (passwordStore.get()[passwordName] != "") {
        return true;
    }
    return false;
}
PAYABLE void PasswordManage::payByPassword(char* passwordName){
    std::string pInfo = passwordStore.get()[passwordName];
    PasswordInfo pwInfo;
    pwInfo.parseJson(pInfo);
    print("pwInfo");
    print(pwInfo.toJson());
    uint64_t transferValue = dipc::callValueUDIP();
    print("transferValue");
    print(transferValue);
    print(pwInfo.balance);
    if(dipc::timestamp() >=  expireTime.get() + pwInfo.timeRegistered){
        DipcAssert(transferValue / 1000 == pwInfo.balance);
        Address toAddr = Address(pwInfo.toAddr,22);
        callTransferUDIP(toAddr, transferValue);
        DIPC_EMIT_EVENT(payByPasswordEvent, passwordName,  transferValue * 1000);
    } else {
        DIPC_EMIT_EVENT(ErrEvent, "payByPassword  password exist", passwordName);
    }
    
    (*passwordStore).erase(passwordName);
    (*passwordStoreHis)[std::string(passwordName)+"_"+pwInfo.toAddr+"_"+std::to_string(pwInfo.timeRegistered)] = pInfo;
}
 
PAYABLE void PasswordManage::depositeContract(){
    uint64_t value = dipc::callValueUDIP() * 1000;
    DIPC_EMIT_EVENT(depositingValue,value);
}
 
EXPORT void PasswordManage::setExpireTime(uint64_t _expireTime){
    
    *expireTime = _expireTime * 60 * 60 * 1000000000;
    DIPC_EMIT_EVENT(expireTimeSetted,expireTime.get());
} codetext height #include "PasswordManage.hpp"

PAYABLE void PasswordManage::init(){
    std::string ownerStr = caller().toString();
    *owner = ownerStr;
}
 
EXPORT void PasswordManage::registerPassword(char* passwordName, char* toAddr, uint64_t _balance){
    PasswordInfo info(passwordName, toAddr, _balance, dipc::timestamp());
    std::string pInfo = info.toJson();
    if (passwordStore.get()[passwordName] != "") {
        DIPC_EMIT_EVENT(ErrEvent, "registerPassword  password exist", passwordName);
        return;
    }
    (*passwordStore)[passwordName] = pInfo;
    print("registerPassword pInfo");
    print(pInfo);
    std::string callerStr = dipc::caller().toString();
    DIPC_EMIT_EVENT(registerPasswordEvent, &callerStr[0], passwordName, &pInfo[0]);
}
CONSTANT char* PasswordManage::queryExistPasswords(){
    std::map<std::string, std::string>::iterator iter;
    auto mapStore = passwordStore.get();
    iter = mapStore.begin();
    std::string result = "[";
    print("queryExistPasswords start");
    while(iter != mapStore.end()){
        result += iter->first + ","; 
        iter++;
    }
    print("queryExistPasswords end");

    result.substr(0,result.size()-1);
    result += "]";
    print("queryExistPasswords  result");
    print(result);
    return &result[0];
}
CONSTANT bool PasswordManage::queryPasswordIsUsed(char* passwordName){
     if (passwordStore.get()[passwordName] != "") {
        return true;
    }
    return false;
}
PAYABLE void PasswordManage::payByPassword(char* passwordName){
    std::string pInfo = passwordStore.get()[passwordName];
    PasswordInfo pwInfo;
    pwInfo.parseJson(pInfo);
    print("pwInfo");
    print(pwInfo.toJson());
    uint64_t transferValue = dipc::callValueUDIP();
    print("transferValue");
    print(transferValue);
    print(pwInfo.balance);
    if(dipc::timestamp() >=  expireTime.get() + pwInfo.timeRegistered){
        DipcAssert(transferValue / 1000 == pwInfo.balance);
        Address toAddr = Address(pwInfo.toAddr,22);
        callTransferUDIP(toAddr, transferValue);
        DIPC_EMIT_EVENT(payByPasswordEvent, passwordName,  transferValue * 1000);
    } else {
        DIPC_EMIT_EVENT(ErrEvent, "payByPassword  password exist", passwordName);
    }
    
    (*passwordStore).erase(passwordName);
    (*passwordStoreHis)[std::string(passwordName)+"_"+pwInfo.toAddr+"_"+std::to_string(pwInfo.timeRegistered)] = pInfo;
}
 
PAYABLE void PasswordManage::depositeContract(){
    uint64_t value = dipc::callValueUDIP() * 1000;
    DIPC_EMIT_EVENT(depositingValue,value);
}
 
EXPORT void PasswordManage::setExpireTime(uint64_t _expireTime){
    
    *expireTime = _expireTime * 60 * 60 * 1000000000;
    DIPC_EMIT_EVENT(expireTimeSetted,expireTime.get());
}

2019-12-31_16:56:02.289531: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:427] searchContext  #include "PasswordManage.hpp"

PAYABLE void PasswordManage::init(){
    std::string ownerStr = caller().toString();
    *owner = ownerStr;
}
 
EXPORT void PasswordManage::registerPassword(char* passwordName, char* toAddr, uint64_t _balance){
    PasswordInfo info(passwordName, toAddr, _balance, dipc::timestamp());
    std::string pInfo = info.toJson();
    if (passwordStore.get()[passwordName] != "") {
        DIPC_EMIT_EVENT(ErrEvent, "registerPassword  password exist", passwordName);
        return;
    }
    (*passwordStore)[passwordName] = pInfo;
    print("registerPassword pInfo");
    print(pInfo);
    std::string callerStr = dipc::caller().toString();
    DIPC_EMIT_EVENT(registerPasswordEvent, &callerStr[0], passwordName, &pInfo[0]);
}
CONSTANT char* PasswordManage::queryExistPasswords(){
    std::map<std::string, std::string>::iterator iter;
    auto mapStore = passwordStore.get();
    iter = mapStore.begin();
    std::string result = "[";
    print("queryExistPasswords start");
    while(iter != mapStore.end()){
        result += iter->first + ","; 
        iter++;
    }
    print("queryExistPasswords end");

    result.substr(0,result.size()-1);
    result += "]";
    print("queryExistPasswords  result");
    print(result);
    return &result[0];
}
CONSTANT bool PasswordManage::queryPasswordIsUsed(char* passwordName){
     if (passwordStore.get()[passwordName] != "") {
        return true;
    }
    return false;
}
PAYABLE void PasswordManage::payByPassword(char* passwordName){
    std::string pInfo = passwordStore.get()[passwordName];
    PasswordInfo pwInfo;
    pwInfo.parseJson(pInfo);
    print("pwInfo");
    print(pwInfo.toJson());
    uint64_t transferValue = dipc::callValueUDIP();
    print("transferValue");
    print(transferValue);
    print(pwInfo.balance);
    if(dipc::timestamp() >=  expireTime.get() + pwInfo.timeRegistered){
        DipcAssert(transferValue / 1000 == pwInfo.balance);
        Address toAddr = Address(pwInfo.toAddr,22);
        callTransferUDIP(toAddr, transferValue);
        DIPC_EMIT_EVENT(payByPasswordEvent, passwordName,  transferValue * 1000);
    } else {
        DIPC_EMIT_EVENT(ErrEvent, "payByPassword  password exist", passwordName);
    }
    
    (*passwordStore).erase(passwordName);
    (*passwordStoreHis)[std::string(passwordName)+"_"+pwInfo.toAddr+"_"+std::to_string(pwInfo.timeRegistered)] = pInfo;
}
 
PAYABLE void PasswordManage::depositeContract(){
    uint64_t value = dipc::callValueUDIP() * 1000;
    DIPC_EMIT_EVENT(depositingValue,value);
}
 
EXPORT void PasswordManage::setExpireTime(uint64_t _expireTime){
    
    *expireTime = _expireTime * 60 * 60 * 1000000000;
    DIPC_EMIT_EVENT(expireTimeSetted,expireTime.get());
}

2019-12-31_16:56:02.302698: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:451] log out out  Export :
CONSTANT bool PasswordManage::queryPasswordIsUsed(char* passwordName){
     

2019-12-31_16:56:02.302718: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:457] name : queryPasswordIsUsed   pos1  0

2019-12-31_16:56:02.302727: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:469] pos2  1278   pos1  1278

2019-12-31_16:56:02.302735: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:500] pos2 after 1448   pos1  1278

2019-12-31_16:56:02.302742: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:509] finalContract  first #include "PasswordManage.hpp"

PAYABLE void PasswordManage::init(){
    std::string ownerStr = caller().toString();
    *owner = ownerStr;
}
 
EXPORT void PasswordManage::registerPassword(char* passwordName, char* toAddr, uint64_t _balance){
    PasswordInfo info(passwordName, toAddr, _balance, dipc::timestamp());
    std::string pInfo = info.toJson();
    if (passwordStore.get()[passwordName] != "") {
        DIPC_EMIT_EVENT(ErrEvent, "registerPassword  password exist", passwordName);
        return;
    }
    (*passwordStore)[passwordName] = pInfo;
    print("registerPassword pInfo");
    print(pInfo);
    std::string callerStr = dipc::caller().toString();
    DIPC_EMIT_EVENT(registerPasswordEvent, &callerStr[0], passwordName, &pInfo[0]);
}
CONSTANT char* PasswordManage::queryExistPasswords(){
    std::map<std::string, std::string>::iterator iter;
    auto mapStore = passwordStore.get();
    iter = mapStore.begin();
    std::string result = "[";
    print("queryExistPasswords start");
    while(iter != mapStore.end()){
        result += iter->first + ","; 
        iter++;
    }
    print("queryExistPasswords end");

    result.substr(0,result.size()-1);
    result += "]";
    print("queryExistPasswords  result");
    print(result);
    return &result[0];
}

2019-12-31_16:56:02.302748: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:510] codetext  first #include "PasswordManage.hpp"

PAYABLE void PasswordManage::init(){
    std::string ownerStr = caller().toString();
    *owner = ownerStr;
}
 
EXPORT void PasswordManage::registerPassword(char* passwordName, char* toAddr, uint64_t _balance){
    PasswordInfo info(passwordName, toAddr, _balance, dipc::timestamp());
    std::string pInfo = info.toJson();
    if (passwordStore.get()[passwordName] != "") {
        DIPC_EMIT_EVENT(ErrEvent, "registerPassword  password exist", passwordName);
        return;
    }
    (*passwordStore)[passwordName] = pInfo;
    print("registerPassword pInfo");
    print(pInfo);
    std::string callerStr = dipc::caller().toString();
    DIPC_EMIT_EVENT(registerPasswordEvent, &callerStr[0], passwordName, &pInfo[0]);
}
CONSTANT char* PasswordManage::queryExistPasswords(){
    std::map<std::string, std::string>::iterator iter;
    auto mapStore = passwordStore.get();
    iter = mapStore.begin();
    std::string result = "[";
    print("queryExistPasswords start");
    while(iter != mapStore.end()){
        result += iter->first + ","; 
        iter++;
    }
    print("queryExistPasswords end");

    result.substr(0,result.size()-1);
    result += "]";
    print("queryExistPasswords  result");
    print(result);
    return &result[0];
}
CONSTANT bool PasswordManage::queryPasswordIsUsed(char* passwordName){
     if (passwordStore.get()[passwordName] != "") {
        return true;
    }
    return false;
}
PAYABLE void PasswordManage::payByPassword(char* passwordName){
    std::string pInfo = passwordStore.get()[passwordName];
    PasswordInfo pwInfo;
    pwInfo.parseJson(pInfo);
    print("pwInfo");
    print(pwInfo.toJson());
    uint64_t transferValue = dipc::callValueUDIP();
    print("transferValue");
    print(transferValue);
    print(pwInfo.balance);
    if(dipc::timestamp() >=  expireTime.get() + pwInfo.timeRegistered){
        DipcAssert(transferValue / 1000 == pwInfo.balance);
        Address toAddr = Address(pwInfo.toAddr,22);
        callTransferUDIP(toAddr, transferValue);
        DIPC_EMIT_EVENT(payByPasswordEvent, passwordName,  transferValue * 1000);
    } else {
        DIPC_EMIT_EVENT(ErrEvent, "payByPassword  password exist", passwordName);
    }
    
    (*passwordStore).erase(passwordName);
    (*passwordStoreHis)[std::string(passwordName)+"_"+pwInfo.toAddr+"_"+std::to_string(pwInfo.timeRegistered)] = pInfo;
}
 
PAYABLE void PasswordManage::depositeContract(){
    uint64_t value = dipc::callValueUDIP() * 1000;
    DIPC_EMIT_EVENT(depositingValue,value);
}
 
EXPORT void PasswordManage::setExpireTime(uint64_t _expireTime){
    
    *expireTime = _expireTime * 60 * 60 * 1000000000;
    DIPC_EMIT_EVENT(expireTimeSetted,expireTime.get());
}

2019-12-31_16:56:02.302755: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:513] s  first 
CONSTANT bool PasswordManage::queryPasswordIsUsed(char* passwordName){
     if (passwordStore.get()[passwordName] != "") {
        return true;
    }
    return false;
}

2019-12-31_16:56:02.302763: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:593] calledFunc temp export: 
CONSTANT bool PasswordManage::queryPasswordIsUsed(char* passwordName){
     u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
if (passwordStore.get()[passwordName] != "") {
        return true;
    }
    return false;
}

2019-12-31_16:56:02.302770: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:599] search func : 
CONSTANT bool PasswordManage::queryPasswordIsUsed(char* passwordName){
     u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
if (passwordStore.get()[passwordName] != "") {
        return true;
    }
    return false;
}
2019-12-31_16:56:02.302777: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:424] finalContract  this height  #include "PasswordManage.hpp"

PAYABLE void PasswordManage::init(){
    std::string ownerStr = caller().toString();
    *owner = ownerStr;
}
 
EXPORT void PasswordManage::registerPassword(char* passwordName, char* toAddr, uint64_t _balance){
    PasswordInfo info(passwordName, toAddr, _balance, dipc::timestamp());
    std::string pInfo = info.toJson();
    if (passwordStore.get()[passwordName] != "") {
        DIPC_EMIT_EVENT(ErrEvent, "registerPassword  password exist", passwordName);
        return;
    }
    (*passwordStore)[passwordName] = pInfo;
    print("registerPassword pInfo");
    print(pInfo);
    std::string callerStr = dipc::caller().toString();
    DIPC_EMIT_EVENT(registerPasswordEvent, &callerStr[0], passwordName, &pInfo[0]);
}
CONSTANT char* PasswordManage::queryExistPasswords(){
    std::map<std::string, std::string>::iterator iter;
    auto mapStore = passwordStore.get();
    iter = mapStore.begin();
    std::string result = "[";
    print("queryExistPasswords start");
    while(iter != mapStore.end()){
        result += iter->first + ","; 
        iter++;
    }
    print("queryExistPasswords end");

    result.substr(0,result.size()-1);
    result += "]";
    print("queryExistPasswords  result");
    print(result);
    return &result[0];
}
CONSTANT bool PasswordManage::queryPasswordIsUsed(char* passwordName){
     u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
if (passwordStore.get()[passwordName] != "") {
        return true;
    }
    return false;
} codetext height #include "PasswordManage.hpp"

PAYABLE void PasswordManage::init(){
    std::string ownerStr = caller().toString();
    *owner = ownerStr;
}
 
EXPORT void PasswordManage::registerPassword(char* passwordName, char* toAddr, uint64_t _balance){
    PasswordInfo info(passwordName, toAddr, _balance, dipc::timestamp());
    std::string pInfo = info.toJson();
    if (passwordStore.get()[passwordName] != "") {
        DIPC_EMIT_EVENT(ErrEvent, "registerPassword  password exist", passwordName);
        return;
    }
    (*passwordStore)[passwordName] = pInfo;
    print("registerPassword pInfo");
    print(pInfo);
    std::string callerStr = dipc::caller().toString();
    DIPC_EMIT_EVENT(registerPasswordEvent, &callerStr[0], passwordName, &pInfo[0]);
}
CONSTANT char* PasswordManage::queryExistPasswords(){
    std::map<std::string, std::string>::iterator iter;
    auto mapStore = passwordStore.get();
    iter = mapStore.begin();
    std::string result = "[";
    print("queryExistPasswords start");
    while(iter != mapStore.end()){
        result += iter->first + ","; 
        iter++;
    }
    print("queryExistPasswords end");

    result.substr(0,result.size()-1);
    result += "]";
    print("queryExistPasswords  result");
    print(result);
    return &result[0];
}
CONSTANT bool PasswordManage::queryPasswordIsUsed(char* passwordName){
     if (passwordStore.get()[passwordName] != "") {
        return true;
    }
    return false;
}
PAYABLE void PasswordManage::payByPassword(char* passwordName){
    std::string pInfo = passwordStore.get()[passwordName];
    PasswordInfo pwInfo;
    pwInfo.parseJson(pInfo);
    print("pwInfo");
    print(pwInfo.toJson());
    uint64_t transferValue = dipc::callValueUDIP();
    print("transferValue");
    print(transferValue);
    print(pwInfo.balance);
    if(dipc::timestamp() >=  expireTime.get() + pwInfo.timeRegistered){
        DipcAssert(transferValue / 1000 == pwInfo.balance);
        Address toAddr = Address(pwInfo.toAddr,22);
        callTransferUDIP(toAddr, transferValue);
        DIPC_EMIT_EVENT(payByPasswordEvent, passwordName,  transferValue * 1000);
    } else {
        DIPC_EMIT_EVENT(ErrEvent, "payByPassword  password exist", passwordName);
    }
    
    (*passwordStore).erase(passwordName);
    (*passwordStoreHis)[std::string(passwordName)+"_"+pwInfo.toAddr+"_"+std::to_string(pwInfo.timeRegistered)] = pInfo;
}
 
PAYABLE void PasswordManage::depositeContract(){
    uint64_t value = dipc::callValueUDIP() * 1000;
    DIPC_EMIT_EVENT(depositingValue,value);
}
 
EXPORT void PasswordManage::setExpireTime(uint64_t _expireTime){
    
    *expireTime = _expireTime * 60 * 60 * 1000000000;
    DIPC_EMIT_EVENT(expireTimeSetted,expireTime.get());
}

2019-12-31_16:56:02.302784: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:427] searchContext  
PAYABLE void PasswordManage::payByPassword(char* passwordName){
    std::string pInfo = passwordStore.get()[passwordName];
    PasswordInfo pwInfo;
    pwInfo.parseJson(pInfo);
    print("pwInfo");
    print(pwInfo.toJson());
    uint64_t transferValue = dipc::callValueUDIP();
    print("transferValue");
    print(transferValue);
    print(pwInfo.balance);
    if(dipc::timestamp() >=  expireTime.get() + pwInfo.timeRegistered){
        DipcAssert(transferValue / 1000 == pwInfo.balance);
        Address toAddr = Address(pwInfo.toAddr,22);
        callTransferUDIP(toAddr, transferValue);
        DIPC_EMIT_EVENT(payByPasswordEvent, passwordName,  transferValue * 1000);
    } else {
        DIPC_EMIT_EVENT(ErrEvent, "payByPassword  password exist", passwordName);
    }
    
    (*passwordStore).erase(passwordName);
    (*passwordStoreHis)[std::string(passwordName)+"_"+pwInfo.toAddr+"_"+std::to_string(pwInfo.timeRegistered)] = pInfo;
}
 
PAYABLE void PasswordManage::depositeContract(){
    uint64_t value = dipc::callValueUDIP() * 1000;
    DIPC_EMIT_EVENT(depositingValue,value);
}
 
EXPORT void PasswordManage::setExpireTime(uint64_t _expireTime){
    
    *expireTime = _expireTime * 60 * 60 * 1000000000;
    DIPC_EMIT_EVENT(expireTimeSetted,expireTime.get());
}

2019-12-31_16:56:02.319807: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:442] finalContract  this new  #include "PasswordManage.hpp"

PAYABLE void PasswordManage::init(){
    std::string ownerStr = caller().toString();
    *owner = ownerStr;
}
 
EXPORT void PasswordManage::registerPassword(char* passwordName, char* toAddr, uint64_t _balance){
    PasswordInfo info(passwordName, toAddr, _balance, dipc::timestamp());
    std::string pInfo = info.toJson();
    if (passwordStore.get()[passwordName] != "") {
        DIPC_EMIT_EVENT(ErrEvent, "registerPassword  password exist", passwordName);
        return;
    }
    (*passwordStore)[passwordName] = pInfo;
    print("registerPassword pInfo");
    print(pInfo);
    std::string callerStr = dipc::caller().toString();
    DIPC_EMIT_EVENT(registerPasswordEvent, &callerStr[0], passwordName, &pInfo[0]);
}
CONSTANT char* PasswordManage::queryExistPasswords(){
    std::map<std::string, std::string>::iterator iter;
    auto mapStore = passwordStore.get();
    iter = mapStore.begin();
    std::string result = "[";
    print("queryExistPasswords start");
    while(iter != mapStore.end()){
        result += iter->first + ","; 
        iter++;
    }
    print("queryExistPasswords end");

    result.substr(0,result.size()-1);
    result += "]";
    print("queryExistPasswords  result");
    print(result);
    return &result[0];
}
CONSTANT bool PasswordManage::queryPasswordIsUsed(char* passwordName){
     u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
if (passwordStore.get()[passwordName] != "") {
        return true;
    }
    return false;
} codetext new #include "PasswordManage.hpp"

PAYABLE void PasswordManage::init(){
    std::string ownerStr = caller().toString();
    *owner = ownerStr;
}
 
EXPORT void PasswordManage::registerPassword(char* passwordName, char* toAddr, uint64_t _balance){
    PasswordInfo info(passwordName, toAddr, _balance, dipc::timestamp());
    std::string pInfo = info.toJson();
    if (passwordStore.get()[passwordName] != "") {
        DIPC_EMIT_EVENT(ErrEvent, "registerPassword  password exist", passwordName);
        return;
    }
    (*passwordStore)[passwordName] = pInfo;
    print("registerPassword pInfo");
    print(pInfo);
    std::string callerStr = dipc::caller().toString();
    DIPC_EMIT_EVENT(registerPasswordEvent, &callerStr[0], passwordName, &pInfo[0]);
}
CONSTANT char* PasswordManage::queryExistPasswords(){
    std::map<std::string, std::string>::iterator iter;
    auto mapStore = passwordStore.get();
    iter = mapStore.begin();
    std::string result = "[";
    print("queryExistPasswords start");
    while(iter != mapStore.end()){
        result += iter->first + ","; 
        iter++;
    }
    print("queryExistPasswords end");

    result.substr(0,result.size()-1);
    result += "]";
    print("queryExistPasswords  result");
    print(result);
    return &result[0];
}
CONSTANT bool PasswordManage::queryPasswordIsUsed(char* passwordName){
     if (passwordStore.get()[passwordName] != "") {
        return true;
    }
    return false;
}
PAYABLE void PasswordManage::payByPassword(char* passwordName){
    std::string pInfo = passwordStore.get()[passwordName];
    PasswordInfo pwInfo;
    pwInfo.parseJson(pInfo);
    print("pwInfo");
    print(pwInfo.toJson());
    uint64_t transferValue = dipc::callValueUDIP();
    print("transferValue");
    print(transferValue);
    print(pwInfo.balance);
    if(dipc::timestamp() >=  expireTime.get() + pwInfo.timeRegistered){
        DipcAssert(transferValue / 1000 == pwInfo.balance);
        Address toAddr = Address(pwInfo.toAddr,22);
        callTransferUDIP(toAddr, transferValue);
        DIPC_EMIT_EVENT(payByPasswordEvent, passwordName,  transferValue * 1000);
    } else {
        DIPC_EMIT_EVENT(ErrEvent, "payByPassword  password exist", passwordName);
    }
    
    (*passwordStore).erase(passwordName);
    (*passwordStoreHis)[std::string(passwordName)+"_"+pwInfo.toAddr+"_"+std::to_string(pwInfo.timeRegistered)] = pInfo;
}
 
PAYABLE void PasswordManage::depositeContract(){
    uint64_t value = dipc::callValueUDIP() * 1000;
    DIPC_EMIT_EVENT(depositingValue,value);
}
 
EXPORT void PasswordManage::setExpireTime(uint64_t _expireTime){
    
    *expireTime = _expireTime * 60 * 60 * 1000000000;
    DIPC_EMIT_EVENT(expireTimeSetted,expireTime.get());
}

2019-12-31_16:56:02.319830: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:604] finalContract  final content =======   : #include "PasswordManage.hpp"

PAYABLE void PasswordManage::init(){
    std::string ownerStr = caller().toString();
    *owner = ownerStr;
}
 
EXPORT void PasswordManage::registerPassword(char* passwordName, char* toAddr, uint64_t _balance){
    PasswordInfo info(passwordName, toAddr, _balance, dipc::timestamp());
    std::string pInfo = info.toJson();
    if (passwordStore.get()[passwordName] != "") {
        DIPC_EMIT_EVENT(ErrEvent, "registerPassword  password exist", passwordName);
        return;
    }
    (*passwordStore)[passwordName] = pInfo;
    print("registerPassword pInfo");
    print(pInfo);
    std::string callerStr = dipc::caller().toString();
    DIPC_EMIT_EVENT(registerPasswordEvent, &callerStr[0], passwordName, &pInfo[0]);
}
CONSTANT char* PasswordManage::queryExistPasswords(){
    std::map<std::string, std::string>::iterator iter;
    auto mapStore = passwordStore.get();
    iter = mapStore.begin();
    std::string result = "[";
    print("queryExistPasswords start");
    while(iter != mapStore.end()){
        result += iter->first + ","; 
        iter++;
    }
    print("queryExistPasswords end");

    result.substr(0,result.size()-1);
    result += "]";
    print("queryExistPasswords  result");
    print(result);
    return &result[0];
}
CONSTANT bool PasswordManage::queryPasswordIsUsed(char* passwordName){
     u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
if (passwordStore.get()[passwordName] != "") {
        return true;
    }
    return false;
}
PAYABLE void PasswordManage::payByPassword(char* passwordName){
    std::string pInfo = passwordStore.get()[passwordName];
    PasswordInfo pwInfo;
    pwInfo.parseJson(pInfo);
    print("pwInfo");
    print(pwInfo.toJson());
    uint64_t transferValue = dipc::callValueUDIP();
    print("transferValue");
    print(transferValue);
    print(pwInfo.balance);
    if(dipc::timestamp() >=  expireTime.get() + pwInfo.timeRegistered){
        DipcAssert(transferValue / 1000 == pwInfo.balance);
        Address toAddr = Address(pwInfo.toAddr,22);
        callTransferUDIP(toAddr, transferValue);
        DIPC_EMIT_EVENT(payByPasswordEvent, passwordName,  transferValue * 1000);
    } else {
        DIPC_EMIT_EVENT(ErrEvent, "payByPassword  password exist", passwordName);
    }
    
    (*passwordStore).erase(passwordName);
    (*passwordStoreHis)[std::string(passwordName)+"_"+pwInfo.toAddr+"_"+std::to_string(pwInfo.timeRegistered)] = pInfo;
}
 
PAYABLE void PasswordManage::depositeContract(){
    uint64_t value = dipc::callValueUDIP() * 1000;
    DIPC_EMIT_EVENT(depositingValue,value);
}
 
EXPORT void PasswordManage::setExpireTime(uint64_t _expireTime){
    
    *expireTime = _expireTime * 60 * 60 * 1000000000;
    DIPC_EMIT_EVENT(expireTimeSetted,expireTime.get());
}

2019-12-31_16:56:02.319840: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:401] abis.ispayable :false

2019-12-31_16:56:02.319857: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:424] finalContract  this height  #include "PasswordManage.hpp"

PAYABLE void PasswordManage::init(){
    std::string ownerStr = caller().toString();
    *owner = ownerStr;
}
 
EXPORT void PasswordManage::registerPassword(char* passwordName, char* toAddr, uint64_t _balance){
    PasswordInfo info(passwordName, toAddr, _balance, dipc::timestamp());
    std::string pInfo = info.toJson();
    if (passwordStore.get()[passwordName] != "") {
        DIPC_EMIT_EVENT(ErrEvent, "registerPassword  password exist", passwordName);
        return;
    }
    (*passwordStore)[passwordName] = pInfo;
    print("registerPassword pInfo");
    print(pInfo);
    std::string callerStr = dipc::caller().toString();
    DIPC_EMIT_EVENT(registerPasswordEvent, &callerStr[0], passwordName, &pInfo[0]);
}
CONSTANT char* PasswordManage::queryExistPasswords(){
    std::map<std::string, std::string>::iterator iter;
    auto mapStore = passwordStore.get();
    iter = mapStore.begin();
    std::string result = "[";
    print("queryExistPasswords start");
    while(iter != mapStore.end()){
        result += iter->first + ","; 
        iter++;
    }
    print("queryExistPasswords end");

    result.substr(0,result.size()-1);
    result += "]";
    print("queryExistPasswords  result");
    print(result);
    return &result[0];
}
CONSTANT bool PasswordManage::queryPasswordIsUsed(char* passwordName){
     u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
if (passwordStore.get()[passwordName] != "") {
        return true;
    }
    return false;
}
PAYABLE void PasswordManage::payByPassword(char* passwordName){
    std::string pInfo = passwordStore.get()[passwordName];
    PasswordInfo pwInfo;
    pwInfo.parseJson(pInfo);
    print("pwInfo");
    print(pwInfo.toJson());
    uint64_t transferValue = dipc::callValueUDIP();
    print("transferValue");
    print(transferValue);
    print(pwInfo.balance);
    if(dipc::timestamp() >=  expireTime.get() + pwInfo.timeRegistered){
        DipcAssert(transferValue / 1000 == pwInfo.balance);
        Address toAddr = Address(pwInfo.toAddr,22);
        callTransferUDIP(toAddr, transferValue);
        DIPC_EMIT_EVENT(payByPasswordEvent, passwordName,  transferValue * 1000);
    } else {
        DIPC_EMIT_EVENT(ErrEvent, "payByPassword  password exist", passwordName);
    }
    
    (*passwordStore).erase(passwordName);
    (*passwordStoreHis)[std::string(passwordName)+"_"+pwInfo.toAddr+"_"+std::to_string(pwInfo.timeRegistered)] = pInfo;
}
 
PAYABLE void PasswordManage::depositeContract(){
    uint64_t value = dipc::callValueUDIP() * 1000;
    DIPC_EMIT_EVENT(depositingValue,value);
}
 
EXPORT void PasswordManage::setExpireTime(uint64_t _expireTime){
    
    *expireTime = _expireTime * 60 * 60 * 1000000000;
    DIPC_EMIT_EVENT(expireTimeSetted,expireTime.get());
} codetext height #include "PasswordManage.hpp"

PAYABLE void PasswordManage::init(){
    std::string ownerStr = caller().toString();
    *owner = ownerStr;
}
 
EXPORT void PasswordManage::registerPassword(char* passwordName, char* toAddr, uint64_t _balance){
    PasswordInfo info(passwordName, toAddr, _balance, dipc::timestamp());
    std::string pInfo = info.toJson();
    if (passwordStore.get()[passwordName] != "") {
        DIPC_EMIT_EVENT(ErrEvent, "registerPassword  password exist", passwordName);
        return;
    }
    (*passwordStore)[passwordName] = pInfo;
    print("registerPassword pInfo");
    print(pInfo);
    std::string callerStr = dipc::caller().toString();
    DIPC_EMIT_EVENT(registerPasswordEvent, &callerStr[0], passwordName, &pInfo[0]);
}
CONSTANT char* PasswordManage::queryExistPasswords(){
    std::map<std::string, std::string>::iterator iter;
    auto mapStore = passwordStore.get();
    iter = mapStore.begin();
    std::string result = "[";
    print("queryExistPasswords start");
    while(iter != mapStore.end()){
        result += iter->first + ","; 
        iter++;
    }
    print("queryExistPasswords end");

    result.substr(0,result.size()-1);
    result += "]";
    print("queryExistPasswords  result");
    print(result);
    return &result[0];
}
CONSTANT bool PasswordManage::queryPasswordIsUsed(char* passwordName){
     u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
if (passwordStore.get()[passwordName] != "") {
        return true;
    }
    return false;
}
PAYABLE void PasswordManage::payByPassword(char* passwordName){
    std::string pInfo = passwordStore.get()[passwordName];
    PasswordInfo pwInfo;
    pwInfo.parseJson(pInfo);
    print("pwInfo");
    print(pwInfo.toJson());
    uint64_t transferValue = dipc::callValueUDIP();
    print("transferValue");
    print(transferValue);
    print(pwInfo.balance);
    if(dipc::timestamp() >=  expireTime.get() + pwInfo.timeRegistered){
        DipcAssert(transferValue / 1000 == pwInfo.balance);
        Address toAddr = Address(pwInfo.toAddr,22);
        callTransferUDIP(toAddr, transferValue);
        DIPC_EMIT_EVENT(payByPasswordEvent, passwordName,  transferValue * 1000);
    } else {
        DIPC_EMIT_EVENT(ErrEvent, "payByPassword  password exist", passwordName);
    }
    
    (*passwordStore).erase(passwordName);
    (*passwordStoreHis)[std::string(passwordName)+"_"+pwInfo.toAddr+"_"+std::to_string(pwInfo.timeRegistered)] = pInfo;
}
 
PAYABLE void PasswordManage::depositeContract(){
    uint64_t value = dipc::callValueUDIP() * 1000;
    DIPC_EMIT_EVENT(depositingValue,value);
}
 
EXPORT void PasswordManage::setExpireTime(uint64_t _expireTime){
    
    *expireTime = _expireTime * 60 * 60 * 1000000000;
    DIPC_EMIT_EVENT(expireTimeSetted,expireTime.get());
}

2019-12-31_16:56:02.319866: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:427] searchContext  #include "PasswordManage.hpp"

PAYABLE void PasswordManage::init(){
    std::string ownerStr = caller().toString();
    *owner = ownerStr;
}
 
EXPORT void PasswordManage::registerPassword(char* passwordName, char* toAddr, uint64_t _balance){
    PasswordInfo info(passwordName, toAddr, _balance, dipc::timestamp());
    std::string pInfo = info.toJson();
    if (passwordStore.get()[passwordName] != "") {
        DIPC_EMIT_EVENT(ErrEvent, "registerPassword  password exist", passwordName);
        return;
    }
    (*passwordStore)[passwordName] = pInfo;
    print("registerPassword pInfo");
    print(pInfo);
    std::string callerStr = dipc::caller().toString();
    DIPC_EMIT_EVENT(registerPasswordEvent, &callerStr[0], passwordName, &pInfo[0]);
}
CONSTANT char* PasswordManage::queryExistPasswords(){
    std::map<std::string, std::string>::iterator iter;
    auto mapStore = passwordStore.get();
    iter = mapStore.begin();
    std::string result = "[";
    print("queryExistPasswords start");
    while(iter != mapStore.end()){
        result += iter->first + ","; 
        iter++;
    }
    print("queryExistPasswords end");

    result.substr(0,result.size()-1);
    result += "]";
    print("queryExistPasswords  result");
    print(result);
    return &result[0];
}
CONSTANT bool PasswordManage::queryPasswordIsUsed(char* passwordName){
     u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
if (passwordStore.get()[passwordName] != "") {
        return true;
    }
    return false;
}
PAYABLE void PasswordManage::payByPassword(char* passwordName){
    std::string pInfo = passwordStore.get()[passwordName];
    PasswordInfo pwInfo;
    pwInfo.parseJson(pInfo);
    print("pwInfo");
    print(pwInfo.toJson());
    uint64_t transferValue = dipc::callValueUDIP();
    print("transferValue");
    print(transferValue);
    print(pwInfo.balance);
    if(dipc::timestamp() >=  expireTime.get() + pwInfo.timeRegistered){
        DipcAssert(transferValue / 1000 == pwInfo.balance);
        Address toAddr = Address(pwInfo.toAddr,22);
        callTransferUDIP(toAddr, transferValue);
        DIPC_EMIT_EVENT(payByPasswordEvent, passwordName,  transferValue * 1000);
    } else {
        DIPC_EMIT_EVENT(ErrEvent, "payByPassword  password exist", passwordName);
    }
    
    (*passwordStore).erase(passwordName);
    (*passwordStoreHis)[std::string(passwordName)+"_"+pwInfo.toAddr+"_"+std::to_string(pwInfo.timeRegistered)] = pInfo;
}
 
PAYABLE void PasswordManage::depositeContract(){
    uint64_t value = dipc::callValueUDIP() * 1000;
    DIPC_EMIT_EVENT(depositingValue,value);
}
 
EXPORT void PasswordManage::setExpireTime(uint64_t _expireTime){
    
    *expireTime = _expireTime * 60 * 60 * 1000000000;
    DIPC_EMIT_EVENT(expireTimeSetted,expireTime.get());
}

2019-12-31_16:56:02.329993: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:451] log out out  Export :
CONSTANT char* PasswordManage::queryExistPasswords(){
    

2019-12-31_16:56:02.330012: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:457] name : queryExistPasswords   pos1  0

2019-12-31_16:56:02.330020: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:469] pos2  752   pos1  752

2019-12-31_16:56:02.330028: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:500] pos2 after 1278   pos1  752

2019-12-31_16:56:02.330035: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:509] finalContract  first #include "PasswordManage.hpp"

PAYABLE void PasswordManage::init(){
    std::string ownerStr = caller().toString();
    *owner = ownerStr;
}
 
EXPORT void PasswordManage::registerPassword(char* passwordName, char* toAddr, uint64_t _balance){
    PasswordInfo info(passwordName, toAddr, _balance, dipc::timestamp());
    std::string pInfo = info.toJson();
    if (passwordStore.get()[passwordName] != "") {
        DIPC_EMIT_EVENT(ErrEvent, "registerPassword  password exist", passwordName);
        return;
    }
    (*passwordStore)[passwordName] = pInfo;
    print("registerPassword pInfo");
    print(pInfo);
    std::string callerStr = dipc::caller().toString();
    DIPC_EMIT_EVENT(registerPasswordEvent, &callerStr[0], passwordName, &pInfo[0]);
}

2019-12-31_16:56:02.330042: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:510] codetext  first #include "PasswordManage.hpp"

PAYABLE void PasswordManage::init(){
    std::string ownerStr = caller().toString();
    *owner = ownerStr;
}
 
EXPORT void PasswordManage::registerPassword(char* passwordName, char* toAddr, uint64_t _balance){
    PasswordInfo info(passwordName, toAddr, _balance, dipc::timestamp());
    std::string pInfo = info.toJson();
    if (passwordStore.get()[passwordName] != "") {
        DIPC_EMIT_EVENT(ErrEvent, "registerPassword  password exist", passwordName);
        return;
    }
    (*passwordStore)[passwordName] = pInfo;
    print("registerPassword pInfo");
    print(pInfo);
    std::string callerStr = dipc::caller().toString();
    DIPC_EMIT_EVENT(registerPasswordEvent, &callerStr[0], passwordName, &pInfo[0]);
}
CONSTANT char* PasswordManage::queryExistPasswords(){
    std::map<std::string, std::string>::iterator iter;
    auto mapStore = passwordStore.get();
    iter = mapStore.begin();
    std::string result = "[";
    print("queryExistPasswords start");
    while(iter != mapStore.end()){
        result += iter->first + ","; 
        iter++;
    }
    print("queryExistPasswords end");

    result.substr(0,result.size()-1);
    result += "]";
    print("queryExistPasswords  result");
    print(result);
    return &result[0];
}
CONSTANT bool PasswordManage::queryPasswordIsUsed(char* passwordName){
     u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
if (passwordStore.get()[passwordName] != "") {
        return true;
    }
    return false;
}
PAYABLE void PasswordManage::payByPassword(char* passwordName){
    std::string pInfo = passwordStore.get()[passwordName];
    PasswordInfo pwInfo;
    pwInfo.parseJson(pInfo);
    print("pwInfo");
    print(pwInfo.toJson());
    uint64_t transferValue = dipc::callValueUDIP();
    print("transferValue");
    print(transferValue);
    print(pwInfo.balance);
    if(dipc::timestamp() >=  expireTime.get() + pwInfo.timeRegistered){
        DipcAssert(transferValue / 1000 == pwInfo.balance);
        Address toAddr = Address(pwInfo.toAddr,22);
        callTransferUDIP(toAddr, transferValue);
        DIPC_EMIT_EVENT(payByPasswordEvent, passwordName,  transferValue * 1000);
    } else {
        DIPC_EMIT_EVENT(ErrEvent, "payByPassword  password exist", passwordName);
    }
    
    (*passwordStore).erase(passwordName);
    (*passwordStoreHis)[std::string(passwordName)+"_"+pwInfo.toAddr+"_"+std::to_string(pwInfo.timeRegistered)] = pInfo;
}
 
PAYABLE void PasswordManage::depositeContract(){
    uint64_t value = dipc::callValueUDIP() * 1000;
    DIPC_EMIT_EVENT(depositingValue,value);
}
 
EXPORT void PasswordManage::setExpireTime(uint64_t _expireTime){
    
    *expireTime = _expireTime * 60 * 60 * 1000000000;
    DIPC_EMIT_EVENT(expireTimeSetted,expireTime.get());
}

2019-12-31_16:56:02.330054: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:513] s  first 
CONSTANT char* PasswordManage::queryExistPasswords(){
    std::map<std::string, std::string>::iterator iter;
    auto mapStore = passwordStore.get();
    iter = mapStore.begin();
    std::string result = "[";
    print("queryExistPasswords start");
    while(iter != mapStore.end()){
        result += iter->first + ","; 
        iter++;
    }
    print("queryExistPasswords end");

    result.substr(0,result.size()-1);
    result += "]";
    print("queryExistPasswords  result");
    print(result);
    return &result[0];
}

2019-12-31_16:56:02.330062: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:593] calledFunc temp export: 
CONSTANT char* PasswordManage::queryExistPasswords(){
    u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
std::map<std::string, std::string>::iterator iter;
    auto mapStore = passwordStore.get();
    iter = mapStore.begin();
    std::string result = "[";
    print("queryExistPasswords start");
    while(iter != mapStore.end()){
        result += iter->first + ","; 
        iter++;
    }
    print("queryExistPasswords end");

    result.substr(0,result.size()-1);
    result += "]";
    print("queryExistPasswords  result");
    print(result);
    return &result[0];
}

2019-12-31_16:56:02.330069: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:599] search func : 
CONSTANT char* PasswordManage::queryExistPasswords(){
    u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
std::map<std::string, std::string>::iterator iter;
    auto mapStore = passwordStore.get();
    iter = mapStore.begin();
    std::string result = "[";
    print("queryExistPasswords start");
    while(iter != mapStore.end()){
        result += iter->first + ","; 
        iter++;
    }
    print("queryExistPasswords end");

    result.substr(0,result.size()-1);
    result += "]";
    print("queryExistPasswords  result");
    print(result);
    return &result[0];
}
2019-12-31_16:56:02.330076: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:424] finalContract  this height  #include "PasswordManage.hpp"

PAYABLE void PasswordManage::init(){
    std::string ownerStr = caller().toString();
    *owner = ownerStr;
}
 
EXPORT void PasswordManage::registerPassword(char* passwordName, char* toAddr, uint64_t _balance){
    PasswordInfo info(passwordName, toAddr, _balance, dipc::timestamp());
    std::string pInfo = info.toJson();
    if (passwordStore.get()[passwordName] != "") {
        DIPC_EMIT_EVENT(ErrEvent, "registerPassword  password exist", passwordName);
        return;
    }
    (*passwordStore)[passwordName] = pInfo;
    print("registerPassword pInfo");
    print(pInfo);
    std::string callerStr = dipc::caller().toString();
    DIPC_EMIT_EVENT(registerPasswordEvent, &callerStr[0], passwordName, &pInfo[0]);
}
CONSTANT char* PasswordManage::queryExistPasswords(){
    u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
std::map<std::string, std::string>::iterator iter;
    auto mapStore = passwordStore.get();
    iter = mapStore.begin();
    std::string result = "[";
    print("queryExistPasswords start");
    while(iter != mapStore.end()){
        result += iter->first + ","; 
        iter++;
    }
    print("queryExistPasswords end");

    result.substr(0,result.size()-1);
    result += "]";
    print("queryExistPasswords  result");
    print(result);
    return &result[0];
} codetext height #include "PasswordManage.hpp"

PAYABLE void PasswordManage::init(){
    std::string ownerStr = caller().toString();
    *owner = ownerStr;
}
 
EXPORT void PasswordManage::registerPassword(char* passwordName, char* toAddr, uint64_t _balance){
    PasswordInfo info(passwordName, toAddr, _balance, dipc::timestamp());
    std::string pInfo = info.toJson();
    if (passwordStore.get()[passwordName] != "") {
        DIPC_EMIT_EVENT(ErrEvent, "registerPassword  password exist", passwordName);
        return;
    }
    (*passwordStore)[passwordName] = pInfo;
    print("registerPassword pInfo");
    print(pInfo);
    std::string callerStr = dipc::caller().toString();
    DIPC_EMIT_EVENT(registerPasswordEvent, &callerStr[0], passwordName, &pInfo[0]);
}
CONSTANT char* PasswordManage::queryExistPasswords(){
    std::map<std::string, std::string>::iterator iter;
    auto mapStore = passwordStore.get();
    iter = mapStore.begin();
    std::string result = "[";
    print("queryExistPasswords start");
    while(iter != mapStore.end()){
        result += iter->first + ","; 
        iter++;
    }
    print("queryExistPasswords end");

    result.substr(0,result.size()-1);
    result += "]";
    print("queryExistPasswords  result");
    print(result);
    return &result[0];
}
CONSTANT bool PasswordManage::queryPasswordIsUsed(char* passwordName){
     u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
if (passwordStore.get()[passwordName] != "") {
        return true;
    }
    return false;
}
PAYABLE void PasswordManage::payByPassword(char* passwordName){
    std::string pInfo = passwordStore.get()[passwordName];
    PasswordInfo pwInfo;
    pwInfo.parseJson(pInfo);
    print("pwInfo");
    print(pwInfo.toJson());
    uint64_t transferValue = dipc::callValueUDIP();
    print("transferValue");
    print(transferValue);
    print(pwInfo.balance);
    if(dipc::timestamp() >=  expireTime.get() + pwInfo.timeRegistered){
        DipcAssert(transferValue / 1000 == pwInfo.balance);
        Address toAddr = Address(pwInfo.toAddr,22);
        callTransferUDIP(toAddr, transferValue);
        DIPC_EMIT_EVENT(payByPasswordEvent, passwordName,  transferValue * 1000);
    } else {
        DIPC_EMIT_EVENT(ErrEvent, "payByPassword  password exist", passwordName);
    }
    
    (*passwordStore).erase(passwordName);
    (*passwordStoreHis)[std::string(passwordName)+"_"+pwInfo.toAddr+"_"+std::to_string(pwInfo.timeRegistered)] = pInfo;
}
 
PAYABLE void PasswordManage::depositeContract(){
    uint64_t value = dipc::callValueUDIP() * 1000;
    DIPC_EMIT_EVENT(depositingValue,value);
}
 
EXPORT void PasswordManage::setExpireTime(uint64_t _expireTime){
    
    *expireTime = _expireTime * 60 * 60 * 1000000000;
    DIPC_EMIT_EVENT(expireTimeSetted,expireTime.get());
}

2019-12-31_16:56:02.330084: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:427] searchContext  
CONSTANT bool PasswordManage::queryPasswordIsUsed(char* passwordName){
     u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
if (passwordStore.get()[passwordName] != "") {
        return true;
    }
    return false;
}
PAYABLE void PasswordManage::payByPassword(char* passwordName){
    std::string pInfo = passwordStore.get()[passwordName];
    PasswordInfo pwInfo;
    pwInfo.parseJson(pInfo);
    print("pwInfo");
    print(pwInfo.toJson());
    uint64_t transferValue = dipc::callValueUDIP();
    print("transferValue");
    print(transferValue);
    print(pwInfo.balance);
    if(dipc::timestamp() >=  expireTime.get() + pwInfo.timeRegistered){
        DipcAssert(transferValue / 1000 == pwInfo.balance);
        Address toAddr = Address(pwInfo.toAddr,22);
        callTransferUDIP(toAddr, transferValue);
        DIPC_EMIT_EVENT(payByPasswordEvent, passwordName,  transferValue * 1000);
    } else {
        DIPC_EMIT_EVENT(ErrEvent, "payByPassword  password exist", passwordName);
    }
    
    (*passwordStore).erase(passwordName);
    (*passwordStoreHis)[std::string(passwordName)+"_"+pwInfo.toAddr+"_"+std::to_string(pwInfo.timeRegistered)] = pInfo;
}
 
PAYABLE void PasswordManage::depositeContract(){
    uint64_t value = dipc::callValueUDIP() * 1000;
    DIPC_EMIT_EVENT(depositingValue,value);
}
 
EXPORT void PasswordManage::setExpireTime(uint64_t _expireTime){
    
    *expireTime = _expireTime * 60 * 60 * 1000000000;
    DIPC_EMIT_EVENT(expireTimeSetted,expireTime.get());
}

2019-12-31_16:56:02.348809: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:442] finalContract  this new  #include "PasswordManage.hpp"

PAYABLE void PasswordManage::init(){
    std::string ownerStr = caller().toString();
    *owner = ownerStr;
}
 
EXPORT void PasswordManage::registerPassword(char* passwordName, char* toAddr, uint64_t _balance){
    PasswordInfo info(passwordName, toAddr, _balance, dipc::timestamp());
    std::string pInfo = info.toJson();
    if (passwordStore.get()[passwordName] != "") {
        DIPC_EMIT_EVENT(ErrEvent, "registerPassword  password exist", passwordName);
        return;
    }
    (*passwordStore)[passwordName] = pInfo;
    print("registerPassword pInfo");
    print(pInfo);
    std::string callerStr = dipc::caller().toString();
    DIPC_EMIT_EVENT(registerPasswordEvent, &callerStr[0], passwordName, &pInfo[0]);
}
CONSTANT char* PasswordManage::queryExistPasswords(){
    u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
std::map<std::string, std::string>::iterator iter;
    auto mapStore = passwordStore.get();
    iter = mapStore.begin();
    std::string result = "[";
    print("queryExistPasswords start");
    while(iter != mapStore.end()){
        result += iter->first + ","; 
        iter++;
    }
    print("queryExistPasswords end");

    result.substr(0,result.size()-1);
    result += "]";
    print("queryExistPasswords  result");
    print(result);
    return &result[0];
} codetext new #include "PasswordManage.hpp"

PAYABLE void PasswordManage::init(){
    std::string ownerStr = caller().toString();
    *owner = ownerStr;
}
 
EXPORT void PasswordManage::registerPassword(char* passwordName, char* toAddr, uint64_t _balance){
    PasswordInfo info(passwordName, toAddr, _balance, dipc::timestamp());
    std::string pInfo = info.toJson();
    if (passwordStore.get()[passwordName] != "") {
        DIPC_EMIT_EVENT(ErrEvent, "registerPassword  password exist", passwordName);
        return;
    }
    (*passwordStore)[passwordName] = pInfo;
    print("registerPassword pInfo");
    print(pInfo);
    std::string callerStr = dipc::caller().toString();
    DIPC_EMIT_EVENT(registerPasswordEvent, &callerStr[0], passwordName, &pInfo[0]);
}
CONSTANT char* PasswordManage::queryExistPasswords(){
    std::map<std::string, std::string>::iterator iter;
    auto mapStore = passwordStore.get();
    iter = mapStore.begin();
    std::string result = "[";
    print("queryExistPasswords start");
    while(iter != mapStore.end()){
        result += iter->first + ","; 
        iter++;
    }
    print("queryExistPasswords end");

    result.substr(0,result.size()-1);
    result += "]";
    print("queryExistPasswords  result");
    print(result);
    return &result[0];
}
CONSTANT bool PasswordManage::queryPasswordIsUsed(char* passwordName){
     u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
if (passwordStore.get()[passwordName] != "") {
        return true;
    }
    return false;
}
PAYABLE void PasswordManage::payByPassword(char* passwordName){
    std::string pInfo = passwordStore.get()[passwordName];
    PasswordInfo pwInfo;
    pwInfo.parseJson(pInfo);
    print("pwInfo");
    print(pwInfo.toJson());
    uint64_t transferValue = dipc::callValueUDIP();
    print("transferValue");
    print(transferValue);
    print(pwInfo.balance);
    if(dipc::timestamp() >=  expireTime.get() + pwInfo.timeRegistered){
        DipcAssert(transferValue / 1000 == pwInfo.balance);
        Address toAddr = Address(pwInfo.toAddr,22);
        callTransferUDIP(toAddr, transferValue);
        DIPC_EMIT_EVENT(payByPasswordEvent, passwordName,  transferValue * 1000);
    } else {
        DIPC_EMIT_EVENT(ErrEvent, "payByPassword  password exist", passwordName);
    }
    
    (*passwordStore).erase(passwordName);
    (*passwordStoreHis)[std::string(passwordName)+"_"+pwInfo.toAddr+"_"+std::to_string(pwInfo.timeRegistered)] = pInfo;
}
 
PAYABLE void PasswordManage::depositeContract(){
    uint64_t value = dipc::callValueUDIP() * 1000;
    DIPC_EMIT_EVENT(depositingValue,value);
}
 
EXPORT void PasswordManage::setExpireTime(uint64_t _expireTime){
    
    *expireTime = _expireTime * 60 * 60 * 1000000000;
    DIPC_EMIT_EVENT(expireTimeSetted,expireTime.get());
}

2019-12-31_16:56:02.348834: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:604] finalContract  final content =======   : #include "PasswordManage.hpp"

PAYABLE void PasswordManage::init(){
    std::string ownerStr = caller().toString();
    *owner = ownerStr;
}
 
EXPORT void PasswordManage::registerPassword(char* passwordName, char* toAddr, uint64_t _balance){
    PasswordInfo info(passwordName, toAddr, _balance, dipc::timestamp());
    std::string pInfo = info.toJson();
    if (passwordStore.get()[passwordName] != "") {
        DIPC_EMIT_EVENT(ErrEvent, "registerPassword  password exist", passwordName);
        return;
    }
    (*passwordStore)[passwordName] = pInfo;
    print("registerPassword pInfo");
    print(pInfo);
    std::string callerStr = dipc::caller().toString();
    DIPC_EMIT_EVENT(registerPasswordEvent, &callerStr[0], passwordName, &pInfo[0]);
}
CONSTANT char* PasswordManage::queryExistPasswords(){
    u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
std::map<std::string, std::string>::iterator iter;
    auto mapStore = passwordStore.get();
    iter = mapStore.begin();
    std::string result = "[";
    print("queryExistPasswords start");
    while(iter != mapStore.end()){
        result += iter->first + ","; 
        iter++;
    }
    print("queryExistPasswords end");

    result.substr(0,result.size()-1);
    result += "]";
    print("queryExistPasswords  result");
    print(result);
    return &result[0];
}
CONSTANT bool PasswordManage::queryPasswordIsUsed(char* passwordName){
     u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
if (passwordStore.get()[passwordName] != "") {
        return true;
    }
    return false;
}
PAYABLE void PasswordManage::payByPassword(char* passwordName){
    std::string pInfo = passwordStore.get()[passwordName];
    PasswordInfo pwInfo;
    pwInfo.parseJson(pInfo);
    print("pwInfo");
    print(pwInfo.toJson());
    uint64_t transferValue = dipc::callValueUDIP();
    print("transferValue");
    print(transferValue);
    print(pwInfo.balance);
    if(dipc::timestamp() >=  expireTime.get() + pwInfo.timeRegistered){
        DipcAssert(transferValue / 1000 == pwInfo.balance);
        Address toAddr = Address(pwInfo.toAddr,22);
        callTransferUDIP(toAddr, transferValue);
        DIPC_EMIT_EVENT(payByPasswordEvent, passwordName,  transferValue * 1000);
    } else {
        DIPC_EMIT_EVENT(ErrEvent, "payByPassword  password exist", passwordName);
    }
    
    (*passwordStore).erase(passwordName);
    (*passwordStoreHis)[std::string(passwordName)+"_"+pwInfo.toAddr+"_"+std::to_string(pwInfo.timeRegistered)] = pInfo;
}
 
PAYABLE void PasswordManage::depositeContract(){
    uint64_t value = dipc::callValueUDIP() * 1000;
    DIPC_EMIT_EVENT(depositingValue,value);
}
 
EXPORT void PasswordManage::setExpireTime(uint64_t _expireTime){
    
    *expireTime = _expireTime * 60 * 60 * 1000000000;
    DIPC_EMIT_EVENT(expireTimeSetted,expireTime.get());
}

2019-12-31_16:56:02.348918: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:401] abis.ispayable :false

2019-12-31_16:56:02.348937: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:424] finalContract  this height  #include "PasswordManage.hpp"

PAYABLE void PasswordManage::init(){
    std::string ownerStr = caller().toString();
    *owner = ownerStr;
}
 
EXPORT void PasswordManage::registerPassword(char* passwordName, char* toAddr, uint64_t _balance){
    PasswordInfo info(passwordName, toAddr, _balance, dipc::timestamp());
    std::string pInfo = info.toJson();
    if (passwordStore.get()[passwordName] != "") {
        DIPC_EMIT_EVENT(ErrEvent, "registerPassword  password exist", passwordName);
        return;
    }
    (*passwordStore)[passwordName] = pInfo;
    print("registerPassword pInfo");
    print(pInfo);
    std::string callerStr = dipc::caller().toString();
    DIPC_EMIT_EVENT(registerPasswordEvent, &callerStr[0], passwordName, &pInfo[0]);
}
CONSTANT char* PasswordManage::queryExistPasswords(){
    u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
std::map<std::string, std::string>::iterator iter;
    auto mapStore = passwordStore.get();
    iter = mapStore.begin();
    std::string result = "[";
    print("queryExistPasswords start");
    while(iter != mapStore.end()){
        result += iter->first + ","; 
        iter++;
    }
    print("queryExistPasswords end");

    result.substr(0,result.size()-1);
    result += "]";
    print("queryExistPasswords  result");
    print(result);
    return &result[0];
}
CONSTANT bool PasswordManage::queryPasswordIsUsed(char* passwordName){
     u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
if (passwordStore.get()[passwordName] != "") {
        return true;
    }
    return false;
}
PAYABLE void PasswordManage::payByPassword(char* passwordName){
    std::string pInfo = passwordStore.get()[passwordName];
    PasswordInfo pwInfo;
    pwInfo.parseJson(pInfo);
    print("pwInfo");
    print(pwInfo.toJson());
    uint64_t transferValue = dipc::callValueUDIP();
    print("transferValue");
    print(transferValue);
    print(pwInfo.balance);
    if(dipc::timestamp() >=  expireTime.get() + pwInfo.timeRegistered){
        DipcAssert(transferValue / 1000 == pwInfo.balance);
        Address toAddr = Address(pwInfo.toAddr,22);
        callTransferUDIP(toAddr, transferValue);
        DIPC_EMIT_EVENT(payByPasswordEvent, passwordName,  transferValue * 1000);
    } else {
        DIPC_EMIT_EVENT(ErrEvent, "payByPassword  password exist", passwordName);
    }
    
    (*passwordStore).erase(passwordName);
    (*passwordStoreHis)[std::string(passwordName)+"_"+pwInfo.toAddr+"_"+std::to_string(pwInfo.timeRegistered)] = pInfo;
}
 
PAYABLE void PasswordManage::depositeContract(){
    uint64_t value = dipc::callValueUDIP() * 1000;
    DIPC_EMIT_EVENT(depositingValue,value);
}
 
EXPORT void PasswordManage::setExpireTime(uint64_t _expireTime){
    
    *expireTime = _expireTime * 60 * 60 * 1000000000;
    DIPC_EMIT_EVENT(expireTimeSetted,expireTime.get());
} codetext height #include "PasswordManage.hpp"

PAYABLE void PasswordManage::init(){
    std::string ownerStr = caller().toString();
    *owner = ownerStr;
}
 
EXPORT void PasswordManage::registerPassword(char* passwordName, char* toAddr, uint64_t _balance){
    PasswordInfo info(passwordName, toAddr, _balance, dipc::timestamp());
    std::string pInfo = info.toJson();
    if (passwordStore.get()[passwordName] != "") {
        DIPC_EMIT_EVENT(ErrEvent, "registerPassword  password exist", passwordName);
        return;
    }
    (*passwordStore)[passwordName] = pInfo;
    print("registerPassword pInfo");
    print(pInfo);
    std::string callerStr = dipc::caller().toString();
    DIPC_EMIT_EVENT(registerPasswordEvent, &callerStr[0], passwordName, &pInfo[0]);
}
CONSTANT char* PasswordManage::queryExistPasswords(){
    u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
std::map<std::string, std::string>::iterator iter;
    auto mapStore = passwordStore.get();
    iter = mapStore.begin();
    std::string result = "[";
    print("queryExistPasswords start");
    while(iter != mapStore.end()){
        result += iter->first + ","; 
        iter++;
    }
    print("queryExistPasswords end");

    result.substr(0,result.size()-1);
    result += "]";
    print("queryExistPasswords  result");
    print(result);
    return &result[0];
}
CONSTANT bool PasswordManage::queryPasswordIsUsed(char* passwordName){
     u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
if (passwordStore.get()[passwordName] != "") {
        return true;
    }
    return false;
}
PAYABLE void PasswordManage::payByPassword(char* passwordName){
    std::string pInfo = passwordStore.get()[passwordName];
    PasswordInfo pwInfo;
    pwInfo.parseJson(pInfo);
    print("pwInfo");
    print(pwInfo.toJson());
    uint64_t transferValue = dipc::callValueUDIP();
    print("transferValue");
    print(transferValue);
    print(pwInfo.balance);
    if(dipc::timestamp() >=  expireTime.get() + pwInfo.timeRegistered){
        DipcAssert(transferValue / 1000 == pwInfo.balance);
        Address toAddr = Address(pwInfo.toAddr,22);
        callTransferUDIP(toAddr, transferValue);
        DIPC_EMIT_EVENT(payByPasswordEvent, passwordName,  transferValue * 1000);
    } else {
        DIPC_EMIT_EVENT(ErrEvent, "payByPassword  password exist", passwordName);
    }
    
    (*passwordStore).erase(passwordName);
    (*passwordStoreHis)[std::string(passwordName)+"_"+pwInfo.toAddr+"_"+std::to_string(pwInfo.timeRegistered)] = pInfo;
}
 
PAYABLE void PasswordManage::depositeContract(){
    uint64_t value = dipc::callValueUDIP() * 1000;
    DIPC_EMIT_EVENT(depositingValue,value);
}
 
EXPORT void PasswordManage::setExpireTime(uint64_t _expireTime){
    
    *expireTime = _expireTime * 60 * 60 * 1000000000;
    DIPC_EMIT_EVENT(expireTimeSetted,expireTime.get());
}

2019-12-31_16:56:02.348946: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:427] searchContext  #include "PasswordManage.hpp"

PAYABLE void PasswordManage::init(){
    std::string ownerStr = caller().toString();
    *owner = ownerStr;
}
 
EXPORT void PasswordManage::registerPassword(char* passwordName, char* toAddr, uint64_t _balance){
    PasswordInfo info(passwordName, toAddr, _balance, dipc::timestamp());
    std::string pInfo = info.toJson();
    if (passwordStore.get()[passwordName] != "") {
        DIPC_EMIT_EVENT(ErrEvent, "registerPassword  password exist", passwordName);
        return;
    }
    (*passwordStore)[passwordName] = pInfo;
    print("registerPassword pInfo");
    print(pInfo);
    std::string callerStr = dipc::caller().toString();
    DIPC_EMIT_EVENT(registerPasswordEvent, &callerStr[0], passwordName, &pInfo[0]);
}
CONSTANT char* PasswordManage::queryExistPasswords(){
    u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
std::map<std::string, std::string>::iterator iter;
    auto mapStore = passwordStore.get();
    iter = mapStore.begin();
    std::string result = "[";
    print("queryExistPasswords start");
    while(iter != mapStore.end()){
        result += iter->first + ","; 
        iter++;
    }
    print("queryExistPasswords end");

    result.substr(0,result.size()-1);
    result += "]";
    print("queryExistPasswords  result");
    print(result);
    return &result[0];
}
CONSTANT bool PasswordManage::queryPasswordIsUsed(char* passwordName){
     u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
if (passwordStore.get()[passwordName] != "") {
        return true;
    }
    return false;
}
PAYABLE void PasswordManage::payByPassword(char* passwordName){
    std::string pInfo = passwordStore.get()[passwordName];
    PasswordInfo pwInfo;
    pwInfo.parseJson(pInfo);
    print("pwInfo");
    print(pwInfo.toJson());
    uint64_t transferValue = dipc::callValueUDIP();
    print("transferValue");
    print(transferValue);
    print(pwInfo.balance);
    if(dipc::timestamp() >=  expireTime.get() + pwInfo.timeRegistered){
        DipcAssert(transferValue / 1000 == pwInfo.balance);
        Address toAddr = Address(pwInfo.toAddr,22);
        callTransferUDIP(toAddr, transferValue);
        DIPC_EMIT_EVENT(payByPasswordEvent, passwordName,  transferValue * 1000);
    } else {
        DIPC_EMIT_EVENT(ErrEvent, "payByPassword  password exist", passwordName);
    }
    
    (*passwordStore).erase(passwordName);
    (*passwordStoreHis)[std::string(passwordName)+"_"+pwInfo.toAddr+"_"+std::to_string(pwInfo.timeRegistered)] = pInfo;
}
 
PAYABLE void PasswordManage::depositeContract(){
    uint64_t value = dipc::callValueUDIP() * 1000;
    DIPC_EMIT_EVENT(depositingValue,value);
}
 
EXPORT void PasswordManage::setExpireTime(uint64_t _expireTime){
    
    *expireTime = _expireTime * 60 * 60 * 1000000000;
    DIPC_EMIT_EVENT(expireTimeSetted,expireTime.get());
}

2019-12-31_16:56:02.349895: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:451] log out out  Export :
 
EXPORT void PasswordManage::registerPassword(char* passwordName, char* toAddr, uint64_t _balance){
    

2019-12-31_16:56:02.349904: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:457] name : registerPassword   pos1  0

2019-12-31_16:56:02.349912: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:469] pos2  140   pos1  140

2019-12-31_16:56:02.349919: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:500] pos2 after 752   pos1  140

2019-12-31_16:56:02.349925: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:509] finalContract  first #include "PasswordManage.hpp"

PAYABLE void PasswordManage::init(){
    std::string ownerStr = caller().toString();
    *owner = ownerStr;
}

2019-12-31_16:56:02.349932: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:510] codetext  first #include "PasswordManage.hpp"

PAYABLE void PasswordManage::init(){
    std::string ownerStr = caller().toString();
    *owner = ownerStr;
}
 
EXPORT void PasswordManage::registerPassword(char* passwordName, char* toAddr, uint64_t _balance){
    PasswordInfo info(passwordName, toAddr, _balance, dipc::timestamp());
    std::string pInfo = info.toJson();
    if (passwordStore.get()[passwordName] != "") {
        DIPC_EMIT_EVENT(ErrEvent, "registerPassword  password exist", passwordName);
        return;
    }
    (*passwordStore)[passwordName] = pInfo;
    print("registerPassword pInfo");
    print(pInfo);
    std::string callerStr = dipc::caller().toString();
    DIPC_EMIT_EVENT(registerPasswordEvent, &callerStr[0], passwordName, &pInfo[0]);
}
CONSTANT char* PasswordManage::queryExistPasswords(){
    u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
std::map<std::string, std::string>::iterator iter;
    auto mapStore = passwordStore.get();
    iter = mapStore.begin();
    std::string result = "[";
    print("queryExistPasswords start");
    while(iter != mapStore.end()){
        result += iter->first + ","; 
        iter++;
    }
    print("queryExistPasswords end");

    result.substr(0,result.size()-1);
    result += "]";
    print("queryExistPasswords  result");
    print(result);
    return &result[0];
}
CONSTANT bool PasswordManage::queryPasswordIsUsed(char* passwordName){
     u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
if (passwordStore.get()[passwordName] != "") {
        return true;
    }
    return false;
}
PAYABLE void PasswordManage::payByPassword(char* passwordName){
    std::string pInfo = passwordStore.get()[passwordName];
    PasswordInfo pwInfo;
    pwInfo.parseJson(pInfo);
    print("pwInfo");
    print(pwInfo.toJson());
    uint64_t transferValue = dipc::callValueUDIP();
    print("transferValue");
    print(transferValue);
    print(pwInfo.balance);
    if(dipc::timestamp() >=  expireTime.get() + pwInfo.timeRegistered){
        DipcAssert(transferValue / 1000 == pwInfo.balance);
        Address toAddr = Address(pwInfo.toAddr,22);
        callTransferUDIP(toAddr, transferValue);
        DIPC_EMIT_EVENT(payByPasswordEvent, passwordName,  transferValue * 1000);
    } else {
        DIPC_EMIT_EVENT(ErrEvent, "payByPassword  password exist", passwordName);
    }
    
    (*passwordStore).erase(passwordName);
    (*passwordStoreHis)[std::string(passwordName)+"_"+pwInfo.toAddr+"_"+std::to_string(pwInfo.timeRegistered)] = pInfo;
}
 
PAYABLE void PasswordManage::depositeContract(){
    uint64_t value = dipc::callValueUDIP() * 1000;
    DIPC_EMIT_EVENT(depositingValue,value);
}
 
EXPORT void PasswordManage::setExpireTime(uint64_t _expireTime){
    
    *expireTime = _expireTime * 60 * 60 * 1000000000;
    DIPC_EMIT_EVENT(expireTimeSetted,expireTime.get());
}

2019-12-31_16:56:02.349938: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:513] s  first 
 
EXPORT void PasswordManage::registerPassword(char* passwordName, char* toAddr, uint64_t _balance){
    PasswordInfo info(passwordName, toAddr, _balance, dipc::timestamp());
    std::string pInfo = info.toJson();
    if (passwordStore.get()[passwordName] != "") {
        DIPC_EMIT_EVENT(ErrEvent, "registerPassword  password exist", passwordName);
        return;
    }
    (*passwordStore)[passwordName] = pInfo;
    print("registerPassword pInfo");
    print(pInfo);
    std::string callerStr = dipc::caller().toString();
    DIPC_EMIT_EVENT(registerPasswordEvent, &callerStr[0], passwordName, &pInfo[0]);
}

2019-12-31_16:56:02.349945: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:593] calledFunc temp export: 
 
EXPORT void PasswordManage::registerPassword(char* passwordName, char* toAddr, uint64_t _balance){
    u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
PasswordInfo info(passwordName, toAddr, _balance, dipc::timestamp());
    std::string pInfo = info.toJson();
    if (passwordStore.get()[passwordName] != "") {
        DIPC_EMIT_EVENT(ErrEvent, "registerPassword  password exist", passwordName);
        return;
    }
    (*passwordStore)[passwordName] = pInfo;
    print("registerPassword pInfo");
    print(pInfo);
    std::string callerStr = dipc::caller().toString();
    DIPC_EMIT_EVENT(registerPasswordEvent, &callerStr[0], passwordName, &pInfo[0]);
}

2019-12-31_16:56:02.349952: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:599] search func : 
 
EXPORT void PasswordManage::registerPassword(char* passwordName, char* toAddr, uint64_t _balance){
    u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
PasswordInfo info(passwordName, toAddr, _balance, dipc::timestamp());
    std::string pInfo = info.toJson();
    if (passwordStore.get()[passwordName] != "") {
        DIPC_EMIT_EVENT(ErrEvent, "registerPassword  password exist", passwordName);
        return;
    }
    (*passwordStore)[passwordName] = pInfo;
    print("registerPassword pInfo");
    print(pInfo);
    std::string callerStr = dipc::caller().toString();
    DIPC_EMIT_EVENT(registerPasswordEvent, &callerStr[0], passwordName, &pInfo[0]);
}
2019-12-31_16:56:02.349959: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:424] finalContract  this height  #include "PasswordManage.hpp"

PAYABLE void PasswordManage::init(){
    std::string ownerStr = caller().toString();
    *owner = ownerStr;
}
 
EXPORT void PasswordManage::registerPassword(char* passwordName, char* toAddr, uint64_t _balance){
    u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
PasswordInfo info(passwordName, toAddr, _balance, dipc::timestamp());
    std::string pInfo = info.toJson();
    if (passwordStore.get()[passwordName] != "") {
        DIPC_EMIT_EVENT(ErrEvent, "registerPassword  password exist", passwordName);
        return;
    }
    (*passwordStore)[passwordName] = pInfo;
    print("registerPassword pInfo");
    print(pInfo);
    std::string callerStr = dipc::caller().toString();
    DIPC_EMIT_EVENT(registerPasswordEvent, &callerStr[0], passwordName, &pInfo[0]);
} codetext height #include "PasswordManage.hpp"

PAYABLE void PasswordManage::init(){
    std::string ownerStr = caller().toString();
    *owner = ownerStr;
}
 
EXPORT void PasswordManage::registerPassword(char* passwordName, char* toAddr, uint64_t _balance){
    PasswordInfo info(passwordName, toAddr, _balance, dipc::timestamp());
    std::string pInfo = info.toJson();
    if (passwordStore.get()[passwordName] != "") {
        DIPC_EMIT_EVENT(ErrEvent, "registerPassword  password exist", passwordName);
        return;
    }
    (*passwordStore)[passwordName] = pInfo;
    print("registerPassword pInfo");
    print(pInfo);
    std::string callerStr = dipc::caller().toString();
    DIPC_EMIT_EVENT(registerPasswordEvent, &callerStr[0], passwordName, &pInfo[0]);
}
CONSTANT char* PasswordManage::queryExistPasswords(){
    u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
std::map<std::string, std::string>::iterator iter;
    auto mapStore = passwordStore.get();
    iter = mapStore.begin();
    std::string result = "[";
    print("queryExistPasswords start");
    while(iter != mapStore.end()){
        result += iter->first + ","; 
        iter++;
    }
    print("queryExistPasswords end");

    result.substr(0,result.size()-1);
    result += "]";
    print("queryExistPasswords  result");
    print(result);
    return &result[0];
}
CONSTANT bool PasswordManage::queryPasswordIsUsed(char* passwordName){
     u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
if (passwordStore.get()[passwordName] != "") {
        return true;
    }
    return false;
}
PAYABLE void PasswordManage::payByPassword(char* passwordName){
    std::string pInfo = passwordStore.get()[passwordName];
    PasswordInfo pwInfo;
    pwInfo.parseJson(pInfo);
    print("pwInfo");
    print(pwInfo.toJson());
    uint64_t transferValue = dipc::callValueUDIP();
    print("transferValue");
    print(transferValue);
    print(pwInfo.balance);
    if(dipc::timestamp() >=  expireTime.get() + pwInfo.timeRegistered){
        DipcAssert(transferValue / 1000 == pwInfo.balance);
        Address toAddr = Address(pwInfo.toAddr,22);
        callTransferUDIP(toAddr, transferValue);
        DIPC_EMIT_EVENT(payByPasswordEvent, passwordName,  transferValue * 1000);
    } else {
        DIPC_EMIT_EVENT(ErrEvent, "payByPassword  password exist", passwordName);
    }
    
    (*passwordStore).erase(passwordName);
    (*passwordStoreHis)[std::string(passwordName)+"_"+pwInfo.toAddr+"_"+std::to_string(pwInfo.timeRegistered)] = pInfo;
}
 
PAYABLE void PasswordManage::depositeContract(){
    uint64_t value = dipc::callValueUDIP() * 1000;
    DIPC_EMIT_EVENT(depositingValue,value);
}
 
EXPORT void PasswordManage::setExpireTime(uint64_t _expireTime){
    
    *expireTime = _expireTime * 60 * 60 * 1000000000;
    DIPC_EMIT_EVENT(expireTimeSetted,expireTime.get());
}

2019-12-31_16:56:02.349967: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:427] searchContext  
CONSTANT char* PasswordManage::queryExistPasswords(){
    u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
std::map<std::string, std::string>::iterator iter;
    auto mapStore = passwordStore.get();
    iter = mapStore.begin();
    std::string result = "[";
    print("queryExistPasswords start");
    while(iter != mapStore.end()){
        result += iter->first + ","; 
        iter++;
    }
    print("queryExistPasswords end");

    result.substr(0,result.size()-1);
    result += "]";
    print("queryExistPasswords  result");
    print(result);
    return &result[0];
}
CONSTANT bool PasswordManage::queryPasswordIsUsed(char* passwordName){
     u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
if (passwordStore.get()[passwordName] != "") {
        return true;
    }
    return false;
}
PAYABLE void PasswordManage::payByPassword(char* passwordName){
    std::string pInfo = passwordStore.get()[passwordName];
    PasswordInfo pwInfo;
    pwInfo.parseJson(pInfo);
    print("pwInfo");
    print(pwInfo.toJson());
    uint64_t transferValue = dipc::callValueUDIP();
    print("transferValue");
    print(transferValue);
    print(pwInfo.balance);
    if(dipc::timestamp() >=  expireTime.get() + pwInfo.timeRegistered){
        DipcAssert(transferValue / 1000 == pwInfo.balance);
        Address toAddr = Address(pwInfo.toAddr,22);
        callTransferUDIP(toAddr, transferValue);
        DIPC_EMIT_EVENT(payByPasswordEvent, passwordName,  transferValue * 1000);
    } else {
        DIPC_EMIT_EVENT(ErrEvent, "payByPassword  password exist", passwordName);
    }
    
    (*passwordStore).erase(passwordName);
    (*passwordStoreHis)[std::string(passwordName)+"_"+pwInfo.toAddr+"_"+std::to_string(pwInfo.timeRegistered)] = pInfo;
}
 
PAYABLE void PasswordManage::depositeContract(){
    uint64_t value = dipc::callValueUDIP() * 1000;
    DIPC_EMIT_EVENT(depositingValue,value);
}
 
EXPORT void PasswordManage::setExpireTime(uint64_t _expireTime){
    
    *expireTime = _expireTime * 60 * 60 * 1000000000;
    DIPC_EMIT_EVENT(expireTimeSetted,expireTime.get());
}

2019-12-31_16:56:02.373543: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:442] finalContract  this new  #include "PasswordManage.hpp"

PAYABLE void PasswordManage::init(){
    std::string ownerStr = caller().toString();
    *owner = ownerStr;
}
 
EXPORT void PasswordManage::registerPassword(char* passwordName, char* toAddr, uint64_t _balance){
    u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
PasswordInfo info(passwordName, toAddr, _balance, dipc::timestamp());
    std::string pInfo = info.toJson();
    if (passwordStore.get()[passwordName] != "") {
        DIPC_EMIT_EVENT(ErrEvent, "registerPassword  password exist", passwordName);
        return;
    }
    (*passwordStore)[passwordName] = pInfo;
    print("registerPassword pInfo");
    print(pInfo);
    std::string callerStr = dipc::caller().toString();
    DIPC_EMIT_EVENT(registerPasswordEvent, &callerStr[0], passwordName, &pInfo[0]);
} codetext new #include "PasswordManage.hpp"

PAYABLE void PasswordManage::init(){
    std::string ownerStr = caller().toString();
    *owner = ownerStr;
}
 
EXPORT void PasswordManage::registerPassword(char* passwordName, char* toAddr, uint64_t _balance){
    PasswordInfo info(passwordName, toAddr, _balance, dipc::timestamp());
    std::string pInfo = info.toJson();
    if (passwordStore.get()[passwordName] != "") {
        DIPC_EMIT_EVENT(ErrEvent, "registerPassword  password exist", passwordName);
        return;
    }
    (*passwordStore)[passwordName] = pInfo;
    print("registerPassword pInfo");
    print(pInfo);
    std::string callerStr = dipc::caller().toString();
    DIPC_EMIT_EVENT(registerPasswordEvent, &callerStr[0], passwordName, &pInfo[0]);
}
CONSTANT char* PasswordManage::queryExistPasswords(){
    u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
std::map<std::string, std::string>::iterator iter;
    auto mapStore = passwordStore.get();
    iter = mapStore.begin();
    std::string result = "[";
    print("queryExistPasswords start");
    while(iter != mapStore.end()){
        result += iter->first + ","; 
        iter++;
    }
    print("queryExistPasswords end");

    result.substr(0,result.size()-1);
    result += "]";
    print("queryExistPasswords  result");
    print(result);
    return &result[0];
}
CONSTANT bool PasswordManage::queryPasswordIsUsed(char* passwordName){
     u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
if (passwordStore.get()[passwordName] != "") {
        return true;
    }
    return false;
}
PAYABLE void PasswordManage::payByPassword(char* passwordName){
    std::string pInfo = passwordStore.get()[passwordName];
    PasswordInfo pwInfo;
    pwInfo.parseJson(pInfo);
    print("pwInfo");
    print(pwInfo.toJson());
    uint64_t transferValue = dipc::callValueUDIP();
    print("transferValue");
    print(transferValue);
    print(pwInfo.balance);
    if(dipc::timestamp() >=  expireTime.get() + pwInfo.timeRegistered){
        DipcAssert(transferValue / 1000 == pwInfo.balance);
        Address toAddr = Address(pwInfo.toAddr,22);
        callTransferUDIP(toAddr, transferValue);
        DIPC_EMIT_EVENT(payByPasswordEvent, passwordName,  transferValue * 1000);
    } else {
        DIPC_EMIT_EVENT(ErrEvent, "payByPassword  password exist", passwordName);
    }
    
    (*passwordStore).erase(passwordName);
    (*passwordStoreHis)[std::string(passwordName)+"_"+pwInfo.toAddr+"_"+std::to_string(pwInfo.timeRegistered)] = pInfo;
}
 
PAYABLE void PasswordManage::depositeContract(){
    uint64_t value = dipc::callValueUDIP() * 1000;
    DIPC_EMIT_EVENT(depositingValue,value);
}
 
EXPORT void PasswordManage::setExpireTime(uint64_t _expireTime){
    
    *expireTime = _expireTime * 60 * 60 * 1000000000;
    DIPC_EMIT_EVENT(expireTimeSetted,expireTime.get());
}

2019-12-31_16:56:02.373576: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:604] finalContract  final content =======   : #include "PasswordManage.hpp"

PAYABLE void PasswordManage::init(){
    std::string ownerStr = caller().toString();
    *owner = ownerStr;
}
 
EXPORT void PasswordManage::registerPassword(char* passwordName, char* toAddr, uint64_t _balance){
    u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
PasswordInfo info(passwordName, toAddr, _balance, dipc::timestamp());
    std::string pInfo = info.toJson();
    if (passwordStore.get()[passwordName] != "") {
        DIPC_EMIT_EVENT(ErrEvent, "registerPassword  password exist", passwordName);
        return;
    }
    (*passwordStore)[passwordName] = pInfo;
    print("registerPassword pInfo");
    print(pInfo);
    std::string callerStr = dipc::caller().toString();
    DIPC_EMIT_EVENT(registerPasswordEvent, &callerStr[0], passwordName, &pInfo[0]);
}
CONSTANT char* PasswordManage::queryExistPasswords(){
    u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
std::map<std::string, std::string>::iterator iter;
    auto mapStore = passwordStore.get();
    iter = mapStore.begin();
    std::string result = "[";
    print("queryExistPasswords start");
    while(iter != mapStore.end()){
        result += iter->first + ","; 
        iter++;
    }
    print("queryExistPasswords end");

    result.substr(0,result.size()-1);
    result += "]";
    print("queryExistPasswords  result");
    print(result);
    return &result[0];
}
CONSTANT bool PasswordManage::queryPasswordIsUsed(char* passwordName){
     u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
if (passwordStore.get()[passwordName] != "") {
        return true;
    }
    return false;
}
PAYABLE void PasswordManage::payByPassword(char* passwordName){
    std::string pInfo = passwordStore.get()[passwordName];
    PasswordInfo pwInfo;
    pwInfo.parseJson(pInfo);
    print("pwInfo");
    print(pwInfo.toJson());
    uint64_t transferValue = dipc::callValueUDIP();
    print("transferValue");
    print(transferValue);
    print(pwInfo.balance);
    if(dipc::timestamp() >=  expireTime.get() + pwInfo.timeRegistered){
        DipcAssert(transferValue / 1000 == pwInfo.balance);
        Address toAddr = Address(pwInfo.toAddr,22);
        callTransferUDIP(toAddr, transferValue);
        DIPC_EMIT_EVENT(payByPasswordEvent, passwordName,  transferValue * 1000);
    } else {
        DIPC_EMIT_EVENT(ErrEvent, "payByPassword  password exist", passwordName);
    }
    
    (*passwordStore).erase(passwordName);
    (*passwordStoreHis)[std::string(passwordName)+"_"+pwInfo.toAddr+"_"+std::to_string(pwInfo.timeRegistered)] = pInfo;
}
 
PAYABLE void PasswordManage::depositeContract(){
    uint64_t value = dipc::callValueUDIP() * 1000;
    DIPC_EMIT_EVENT(depositingValue,value);
}
 
EXPORT void PasswordManage::setExpireTime(uint64_t _expireTime){
    
    *expireTime = _expireTime * 60 * 60 * 1000000000;
    DIPC_EMIT_EVENT(expireTimeSetted,expireTime.get());
}

2019-12-31_16:56:02.373595: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:401] abis.ispayable :false

2019-12-31_16:56:02.373621: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:424] finalContract  this height  #include "PasswordManage.hpp"

PAYABLE void PasswordManage::init(){
    std::string ownerStr = caller().toString();
    *owner = ownerStr;
}
 
EXPORT void PasswordManage::registerPassword(char* passwordName, char* toAddr, uint64_t _balance){
    u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
PasswordInfo info(passwordName, toAddr, _balance, dipc::timestamp());
    std::string pInfo = info.toJson();
    if (passwordStore.get()[passwordName] != "") {
        DIPC_EMIT_EVENT(ErrEvent, "registerPassword  password exist", passwordName);
        return;
    }
    (*passwordStore)[passwordName] = pInfo;
    print("registerPassword pInfo");
    print(pInfo);
    std::string callerStr = dipc::caller().toString();
    DIPC_EMIT_EVENT(registerPasswordEvent, &callerStr[0], passwordName, &pInfo[0]);
}
CONSTANT char* PasswordManage::queryExistPasswords(){
    u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
std::map<std::string, std::string>::iterator iter;
    auto mapStore = passwordStore.get();
    iter = mapStore.begin();
    std::string result = "[";
    print("queryExistPasswords start");
    while(iter != mapStore.end()){
        result += iter->first + ","; 
        iter++;
    }
    print("queryExistPasswords end");

    result.substr(0,result.size()-1);
    result += "]";
    print("queryExistPasswords  result");
    print(result);
    return &result[0];
}
CONSTANT bool PasswordManage::queryPasswordIsUsed(char* passwordName){
     u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
if (passwordStore.get()[passwordName] != "") {
        return true;
    }
    return false;
}
PAYABLE void PasswordManage::payByPassword(char* passwordName){
    std::string pInfo = passwordStore.get()[passwordName];
    PasswordInfo pwInfo;
    pwInfo.parseJson(pInfo);
    print("pwInfo");
    print(pwInfo.toJson());
    uint64_t transferValue = dipc::callValueUDIP();
    print("transferValue");
    print(transferValue);
    print(pwInfo.balance);
    if(dipc::timestamp() >=  expireTime.get() + pwInfo.timeRegistered){
        DipcAssert(transferValue / 1000 == pwInfo.balance);
        Address toAddr = Address(pwInfo.toAddr,22);
        callTransferUDIP(toAddr, transferValue);
        DIPC_EMIT_EVENT(payByPasswordEvent, passwordName,  transferValue * 1000);
    } else {
        DIPC_EMIT_EVENT(ErrEvent, "payByPassword  password exist", passwordName);
    }
    
    (*passwordStore).erase(passwordName);
    (*passwordStoreHis)[std::string(passwordName)+"_"+pwInfo.toAddr+"_"+std::to_string(pwInfo.timeRegistered)] = pInfo;
}
 
PAYABLE void PasswordManage::depositeContract(){
    uint64_t value = dipc::callValueUDIP() * 1000;
    DIPC_EMIT_EVENT(depositingValue,value);
}
 
EXPORT void PasswordManage::setExpireTime(uint64_t _expireTime){
    
    *expireTime = _expireTime * 60 * 60 * 1000000000;
    DIPC_EMIT_EVENT(expireTimeSetted,expireTime.get());
} codetext height #include "PasswordManage.hpp"

PAYABLE void PasswordManage::init(){
    std::string ownerStr = caller().toString();
    *owner = ownerStr;
}
 
EXPORT void PasswordManage::registerPassword(char* passwordName, char* toAddr, uint64_t _balance){
    u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
PasswordInfo info(passwordName, toAddr, _balance, dipc::timestamp());
    std::string pInfo = info.toJson();
    if (passwordStore.get()[passwordName] != "") {
        DIPC_EMIT_EVENT(ErrEvent, "registerPassword  password exist", passwordName);
        return;
    }
    (*passwordStore)[passwordName] = pInfo;
    print("registerPassword pInfo");
    print(pInfo);
    std::string callerStr = dipc::caller().toString();
    DIPC_EMIT_EVENT(registerPasswordEvent, &callerStr[0], passwordName, &pInfo[0]);
}
CONSTANT char* PasswordManage::queryExistPasswords(){
    u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
std::map<std::string, std::string>::iterator iter;
    auto mapStore = passwordStore.get();
    iter = mapStore.begin();
    std::string result = "[";
    print("queryExistPasswords start");
    while(iter != mapStore.end()){
        result += iter->first + ","; 
        iter++;
    }
    print("queryExistPasswords end");

    result.substr(0,result.size()-1);
    result += "]";
    print("queryExistPasswords  result");
    print(result);
    return &result[0];
}
CONSTANT bool PasswordManage::queryPasswordIsUsed(char* passwordName){
     u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
if (passwordStore.get()[passwordName] != "") {
        return true;
    }
    return false;
}
PAYABLE void PasswordManage::payByPassword(char* passwordName){
    std::string pInfo = passwordStore.get()[passwordName];
    PasswordInfo pwInfo;
    pwInfo.parseJson(pInfo);
    print("pwInfo");
    print(pwInfo.toJson());
    uint64_t transferValue = dipc::callValueUDIP();
    print("transferValue");
    print(transferValue);
    print(pwInfo.balance);
    if(dipc::timestamp() >=  expireTime.get() + pwInfo.timeRegistered){
        DipcAssert(transferValue / 1000 == pwInfo.balance);
        Address toAddr = Address(pwInfo.toAddr,22);
        callTransferUDIP(toAddr, transferValue);
        DIPC_EMIT_EVENT(payByPasswordEvent, passwordName,  transferValue * 1000);
    } else {
        DIPC_EMIT_EVENT(ErrEvent, "payByPassword  password exist", passwordName);
    }
    
    (*passwordStore).erase(passwordName);
    (*passwordStoreHis)[std::string(passwordName)+"_"+pwInfo.toAddr+"_"+std::to_string(pwInfo.timeRegistered)] = pInfo;
}
 
PAYABLE void PasswordManage::depositeContract(){
    uint64_t value = dipc::callValueUDIP() * 1000;
    DIPC_EMIT_EVENT(depositingValue,value);
}
 
EXPORT void PasswordManage::setExpireTime(uint64_t _expireTime){
    
    *expireTime = _expireTime * 60 * 60 * 1000000000;
    DIPC_EMIT_EVENT(expireTimeSetted,expireTime.get());
}

2019-12-31_16:56:02.373638: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:427] searchContext  #include "PasswordManage.hpp"

PAYABLE void PasswordManage::init(){
    std::string ownerStr = caller().toString();
    *owner = ownerStr;
}
 
EXPORT void PasswordManage::registerPassword(char* passwordName, char* toAddr, uint64_t _balance){
    u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
PasswordInfo info(passwordName, toAddr, _balance, dipc::timestamp());
    std::string pInfo = info.toJson();
    if (passwordStore.get()[passwordName] != "") {
        DIPC_EMIT_EVENT(ErrEvent, "registerPassword  password exist", passwordName);
        return;
    }
    (*passwordStore)[passwordName] = pInfo;
    print("registerPassword pInfo");
    print(pInfo);
    std::string callerStr = dipc::caller().toString();
    DIPC_EMIT_EVENT(registerPasswordEvent, &callerStr[0], passwordName, &pInfo[0]);
}
CONSTANT char* PasswordManage::queryExistPasswords(){
    u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
std::map<std::string, std::string>::iterator iter;
    auto mapStore = passwordStore.get();
    iter = mapStore.begin();
    std::string result = "[";
    print("queryExistPasswords start");
    while(iter != mapStore.end()){
        result += iter->first + ","; 
        iter++;
    }
    print("queryExistPasswords end");

    result.substr(0,result.size()-1);
    result += "]";
    print("queryExistPasswords  result");
    print(result);
    return &result[0];
}
CONSTANT bool PasswordManage::queryPasswordIsUsed(char* passwordName){
     u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
if (passwordStore.get()[passwordName] != "") {
        return true;
    }
    return false;
}
PAYABLE void PasswordManage::payByPassword(char* passwordName){
    std::string pInfo = passwordStore.get()[passwordName];
    PasswordInfo pwInfo;
    pwInfo.parseJson(pInfo);
    print("pwInfo");
    print(pwInfo.toJson());
    uint64_t transferValue = dipc::callValueUDIP();
    print("transferValue");
    print(transferValue);
    print(pwInfo.balance);
    if(dipc::timestamp() >=  expireTime.get() + pwInfo.timeRegistered){
        DipcAssert(transferValue / 1000 == pwInfo.balance);
        Address toAddr = Address(pwInfo.toAddr,22);
        callTransferUDIP(toAddr, transferValue);
        DIPC_EMIT_EVENT(payByPasswordEvent, passwordName,  transferValue * 1000);
    } else {
        DIPC_EMIT_EVENT(ErrEvent, "payByPassword  password exist", passwordName);
    }
    
    (*passwordStore).erase(passwordName);
    (*passwordStoreHis)[std::string(passwordName)+"_"+pwInfo.toAddr+"_"+std::to_string(pwInfo.timeRegistered)] = pInfo;
}
 
PAYABLE void PasswordManage::depositeContract(){
    uint64_t value = dipc::callValueUDIP() * 1000;
    DIPC_EMIT_EVENT(depositingValue,value);
}
 
EXPORT void PasswordManage::setExpireTime(uint64_t _expireTime){
    
    *expireTime = _expireTime * 60 * 60 * 1000000000;
    DIPC_EMIT_EVENT(expireTimeSetted,expireTime.get());
}

2019-12-31_16:56:02.406317: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:451] log out out  Export :
 
EXPORT void PasswordManage::setExpireTime(uint64_t _expireTime){
    
    

2019-12-31_16:56:02.406339: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:457] name : setExpireTime   pos1  0

2019-12-31_16:56:02.406349: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:469] pos2  2717   pos1  2717

2019-12-31_16:56:02.406356: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:500] pos2 after 2901   pos1  2717

2019-12-31_16:56:02.406363: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:509] finalContract  first #include "PasswordManage.hpp"

PAYABLE void PasswordManage::init(){
    std::string ownerStr = caller().toString();
    *owner = ownerStr;
}
 
EXPORT void PasswordManage::registerPassword(char* passwordName, char* toAddr, uint64_t _balance){
    u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
PasswordInfo info(passwordName, toAddr, _balance, dipc::timestamp());
    std::string pInfo = info.toJson();
    if (passwordStore.get()[passwordName] != "") {
        DIPC_EMIT_EVENT(ErrEvent, "registerPassword  password exist", passwordName);
        return;
    }
    (*passwordStore)[passwordName] = pInfo;
    print("registerPassword pInfo");
    print(pInfo);
    std::string callerStr = dipc::caller().toString();
    DIPC_EMIT_EVENT(registerPasswordEvent, &callerStr[0], passwordName, &pInfo[0]);
}
CONSTANT char* PasswordManage::queryExistPasswords(){
    u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
std::map<std::string, std::string>::iterator iter;
    auto mapStore = passwordStore.get();
    iter = mapStore.begin();
    std::string result = "[";
    print("queryExistPasswords start");
    while(iter != mapStore.end()){
        result += iter->first + ","; 
        iter++;
    }
    print("queryExistPasswords end");

    result.substr(0,result.size()-1);
    result += "]";
    print("queryExistPasswords  result");
    print(result);
    return &result[0];
}
CONSTANT bool PasswordManage::queryPasswordIsUsed(char* passwordName){
     u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
if (passwordStore.get()[passwordName] != "") {
        return true;
    }
    return false;
}
PAYABLE void PasswordManage::payByPassword(char* passwordName){
    std::string pInfo = passwordStore.get()[passwordName];
    PasswordInfo pwInfo;
    pwInfo.parseJson(pInfo);
    print("pwInfo");
    print(pwInfo.toJson());
    uint64_t transferValue = dipc::callValueUDIP();
    print("transferValue");
    print(transferValue);
    print(pwInfo.balance);
    if(dipc::timestamp() >=  expireTime.get() + pwInfo.timeRegistered){
        DipcAssert(transferValue / 1000 == pwInfo.balance);
        Address toAddr = Address(pwInfo.toAddr,22);
        callTransferUDIP(toAddr, transferValue);
        DIPC_EMIT_EVENT(payByPasswordEvent, passwordName,  transferValue * 1000);
    } else {
        DIPC_EMIT_EVENT(ErrEvent, "payByPassword  password exist", passwordName);
    }
    
    (*passwordStore).erase(passwordName);
    (*passwordStoreHis)[std::string(passwordName)+"_"+pwInfo.toAddr+"_"+std::to_string(pwInfo.timeRegistered)] = pInfo;
}
 
PAYABLE void PasswordManage::depositeContract(){
    uint64_t value = dipc::callValueUDIP() * 1000;
    DIPC_EMIT_EVENT(depositingValue,value);
}

2019-12-31_16:56:02.406371: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:510] codetext  first #include "PasswordManage.hpp"

PAYABLE void PasswordManage::init(){
    std::string ownerStr = caller().toString();
    *owner = ownerStr;
}
 
EXPORT void PasswordManage::registerPassword(char* passwordName, char* toAddr, uint64_t _balance){
    u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
PasswordInfo info(passwordName, toAddr, _balance, dipc::timestamp());
    std::string pInfo = info.toJson();
    if (passwordStore.get()[passwordName] != "") {
        DIPC_EMIT_EVENT(ErrEvent, "registerPassword  password exist", passwordName);
        return;
    }
    (*passwordStore)[passwordName] = pInfo;
    print("registerPassword pInfo");
    print(pInfo);
    std::string callerStr = dipc::caller().toString();
    DIPC_EMIT_EVENT(registerPasswordEvent, &callerStr[0], passwordName, &pInfo[0]);
}
CONSTANT char* PasswordManage::queryExistPasswords(){
    u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
std::map<std::string, std::string>::iterator iter;
    auto mapStore = passwordStore.get();
    iter = mapStore.begin();
    std::string result = "[";
    print("queryExistPasswords start");
    while(iter != mapStore.end()){
        result += iter->first + ","; 
        iter++;
    }
    print("queryExistPasswords end");

    result.substr(0,result.size()-1);
    result += "]";
    print("queryExistPasswords  result");
    print(result);
    return &result[0];
}
CONSTANT bool PasswordManage::queryPasswordIsUsed(char* passwordName){
     u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
if (passwordStore.get()[passwordName] != "") {
        return true;
    }
    return false;
}
PAYABLE void PasswordManage::payByPassword(char* passwordName){
    std::string pInfo = passwordStore.get()[passwordName];
    PasswordInfo pwInfo;
    pwInfo.parseJson(pInfo);
    print("pwInfo");
    print(pwInfo.toJson());
    uint64_t transferValue = dipc::callValueUDIP();
    print("transferValue");
    print(transferValue);
    print(pwInfo.balance);
    if(dipc::timestamp() >=  expireTime.get() + pwInfo.timeRegistered){
        DipcAssert(transferValue / 1000 == pwInfo.balance);
        Address toAddr = Address(pwInfo.toAddr,22);
        callTransferUDIP(toAddr, transferValue);
        DIPC_EMIT_EVENT(payByPasswordEvent, passwordName,  transferValue * 1000);
    } else {
        DIPC_EMIT_EVENT(ErrEvent, "payByPassword  password exist", passwordName);
    }
    
    (*passwordStore).erase(passwordName);
    (*passwordStoreHis)[std::string(passwordName)+"_"+pwInfo.toAddr+"_"+std::to_string(pwInfo.timeRegistered)] = pInfo;
}
 
PAYABLE void PasswordManage::depositeContract(){
    uint64_t value = dipc::callValueUDIP() * 1000;
    DIPC_EMIT_EVENT(depositingValue,value);
}
 
EXPORT void PasswordManage::setExpireTime(uint64_t _expireTime){
    
    *expireTime = _expireTime * 60 * 60 * 1000000000;
    DIPC_EMIT_EVENT(expireTimeSetted,expireTime.get());
}

2019-12-31_16:56:02.406378: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:513] s  first 
 
EXPORT void PasswordManage::setExpireTime(uint64_t _expireTime){
    
    *expireTime = _expireTime * 60 * 60 * 1000000000;
    DIPC_EMIT_EVENT(expireTimeSetted,expireTime.get());
}

2019-12-31_16:56:02.406386: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:593] calledFunc temp export: 
 
EXPORT void PasswordManage::setExpireTime(uint64_t _expireTime){
    
    u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
*expireTime = _expireTime * 60 * 60 * 1000000000;
    DIPC_EMIT_EVENT(expireTimeSetted,expireTime.get());
}

2019-12-31_16:56:02.406393: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:599] search func : 
 
EXPORT void PasswordManage::setExpireTime(uint64_t _expireTime){
    
    u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
*expireTime = _expireTime * 60 * 60 * 1000000000;
    DIPC_EMIT_EVENT(expireTimeSetted,expireTime.get());
}
2019-12-31_16:56:02.406400: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:424] finalContract  this height  #include "PasswordManage.hpp"

PAYABLE void PasswordManage::init(){
    std::string ownerStr = caller().toString();
    *owner = ownerStr;
}
 
EXPORT void PasswordManage::registerPassword(char* passwordName, char* toAddr, uint64_t _balance){
    u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
PasswordInfo info(passwordName, toAddr, _balance, dipc::timestamp());
    std::string pInfo = info.toJson();
    if (passwordStore.get()[passwordName] != "") {
        DIPC_EMIT_EVENT(ErrEvent, "registerPassword  password exist", passwordName);
        return;
    }
    (*passwordStore)[passwordName] = pInfo;
    print("registerPassword pInfo");
    print(pInfo);
    std::string callerStr = dipc::caller().toString();
    DIPC_EMIT_EVENT(registerPasswordEvent, &callerStr[0], passwordName, &pInfo[0]);
}
CONSTANT char* PasswordManage::queryExistPasswords(){
    u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
std::map<std::string, std::string>::iterator iter;
    auto mapStore = passwordStore.get();
    iter = mapStore.begin();
    std::string result = "[";
    print("queryExistPasswords start");
    while(iter != mapStore.end()){
        result += iter->first + ","; 
        iter++;
    }
    print("queryExistPasswords end");

    result.substr(0,result.size()-1);
    result += "]";
    print("queryExistPasswords  result");
    print(result);
    return &result[0];
}
CONSTANT bool PasswordManage::queryPasswordIsUsed(char* passwordName){
     u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
if (passwordStore.get()[passwordName] != "") {
        return true;
    }
    return false;
}
PAYABLE void PasswordManage::payByPassword(char* passwordName){
    std::string pInfo = passwordStore.get()[passwordName];
    PasswordInfo pwInfo;
    pwInfo.parseJson(pInfo);
    print("pwInfo");
    print(pwInfo.toJson());
    uint64_t transferValue = dipc::callValueUDIP();
    print("transferValue");
    print(transferValue);
    print(pwInfo.balance);
    if(dipc::timestamp() >=  expireTime.get() + pwInfo.timeRegistered){
        DipcAssert(transferValue / 1000 == pwInfo.balance);
        Address toAddr = Address(pwInfo.toAddr,22);
        callTransferUDIP(toAddr, transferValue);
        DIPC_EMIT_EVENT(payByPasswordEvent, passwordName,  transferValue * 1000);
    } else {
        DIPC_EMIT_EVENT(ErrEvent, "payByPassword  password exist", passwordName);
    }
    
    (*passwordStore).erase(passwordName);
    (*passwordStoreHis)[std::string(passwordName)+"_"+pwInfo.toAddr+"_"+std::to_string(pwInfo.timeRegistered)] = pInfo;
}
 
PAYABLE void PasswordManage::depositeContract(){
    uint64_t value = dipc::callValueUDIP() * 1000;
    DIPC_EMIT_EVENT(depositingValue,value);
}
 
EXPORT void PasswordManage::setExpireTime(uint64_t _expireTime){
    
    u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
*expireTime = _expireTime * 60 * 60 * 1000000000;
    DIPC_EMIT_EVENT(expireTimeSetted,expireTime.get());
} codetext height #include "PasswordManage.hpp"

PAYABLE void PasswordManage::init(){
    std::string ownerStr = caller().toString();
    *owner = ownerStr;
}
 
EXPORT void PasswordManage::registerPassword(char* passwordName, char* toAddr, uint64_t _balance){
    u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
PasswordInfo info(passwordName, toAddr, _balance, dipc::timestamp());
    std::string pInfo = info.toJson();
    if (passwordStore.get()[passwordName] != "") {
        DIPC_EMIT_EVENT(ErrEvent, "registerPassword  password exist", passwordName);
        return;
    }
    (*passwordStore)[passwordName] = pInfo;
    print("registerPassword pInfo");
    print(pInfo);
    std::string callerStr = dipc::caller().toString();
    DIPC_EMIT_EVENT(registerPasswordEvent, &callerStr[0], passwordName, &pInfo[0]);
}
CONSTANT char* PasswordManage::queryExistPasswords(){
    u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
std::map<std::string, std::string>::iterator iter;
    auto mapStore = passwordStore.get();
    iter = mapStore.begin();
    std::string result = "[";
    print("queryExistPasswords start");
    while(iter != mapStore.end()){
        result += iter->first + ","; 
        iter++;
    }
    print("queryExistPasswords end");

    result.substr(0,result.size()-1);
    result += "]";
    print("queryExistPasswords  result");
    print(result);
    return &result[0];
}
CONSTANT bool PasswordManage::queryPasswordIsUsed(char* passwordName){
     u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
if (passwordStore.get()[passwordName] != "") {
        return true;
    }
    return false;
}
PAYABLE void PasswordManage::payByPassword(char* passwordName){
    std::string pInfo = passwordStore.get()[passwordName];
    PasswordInfo pwInfo;
    pwInfo.parseJson(pInfo);
    print("pwInfo");
    print(pwInfo.toJson());
    uint64_t transferValue = dipc::callValueUDIP();
    print("transferValue");
    print(transferValue);
    print(pwInfo.balance);
    if(dipc::timestamp() >=  expireTime.get() + pwInfo.timeRegistered){
        DipcAssert(transferValue / 1000 == pwInfo.balance);
        Address toAddr = Address(pwInfo.toAddr,22);
        callTransferUDIP(toAddr, transferValue);
        DIPC_EMIT_EVENT(payByPasswordEvent, passwordName,  transferValue * 1000);
    } else {
        DIPC_EMIT_EVENT(ErrEvent, "payByPassword  password exist", passwordName);
    }
    
    (*passwordStore).erase(passwordName);
    (*passwordStoreHis)[std::string(passwordName)+"_"+pwInfo.toAddr+"_"+std::to_string(pwInfo.timeRegistered)] = pInfo;
}
 
PAYABLE void PasswordManage::depositeContract(){
    uint64_t value = dipc::callValueUDIP() * 1000;
    DIPC_EMIT_EVENT(depositingValue,value);
}
 
EXPORT void PasswordManage::setExpireTime(uint64_t _expireTime){
    
    *expireTime = _expireTime * 60 * 60 * 1000000000;
    DIPC_EMIT_EVENT(expireTimeSetted,expireTime.get());
}

2019-12-31_16:56:02.406408: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:427] searchContext  

2019-12-31_16:56:02.406416: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:442] finalContract  this new  #include "PasswordManage.hpp"

PAYABLE void PasswordManage::init(){
    std::string ownerStr = caller().toString();
    *owner = ownerStr;
}
 
EXPORT void PasswordManage::registerPassword(char* passwordName, char* toAddr, uint64_t _balance){
    u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
PasswordInfo info(passwordName, toAddr, _balance, dipc::timestamp());
    std::string pInfo = info.toJson();
    if (passwordStore.get()[passwordName] != "") {
        DIPC_EMIT_EVENT(ErrEvent, "registerPassword  password exist", passwordName);
        return;
    }
    (*passwordStore)[passwordName] = pInfo;
    print("registerPassword pInfo");
    print(pInfo);
    std::string callerStr = dipc::caller().toString();
    DIPC_EMIT_EVENT(registerPasswordEvent, &callerStr[0], passwordName, &pInfo[0]);
}
CONSTANT char* PasswordManage::queryExistPasswords(){
    u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
std::map<std::string, std::string>::iterator iter;
    auto mapStore = passwordStore.get();
    iter = mapStore.begin();
    std::string result = "[";
    print("queryExistPasswords start");
    while(iter != mapStore.end()){
        result += iter->first + ","; 
        iter++;
    }
    print("queryExistPasswords end");

    result.substr(0,result.size()-1);
    result += "]";
    print("queryExistPasswords  result");
    print(result);
    return &result[0];
}
CONSTANT bool PasswordManage::queryPasswordIsUsed(char* passwordName){
     u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
if (passwordStore.get()[passwordName] != "") {
        return true;
    }
    return false;
}
PAYABLE void PasswordManage::payByPassword(char* passwordName){
    std::string pInfo = passwordStore.get()[passwordName];
    PasswordInfo pwInfo;
    pwInfo.parseJson(pInfo);
    print("pwInfo");
    print(pwInfo.toJson());
    uint64_t transferValue = dipc::callValueUDIP();
    print("transferValue");
    print(transferValue);
    print(pwInfo.balance);
    if(dipc::timestamp() >=  expireTime.get() + pwInfo.timeRegistered){
        DipcAssert(transferValue / 1000 == pwInfo.balance);
        Address toAddr = Address(pwInfo.toAddr,22);
        callTransferUDIP(toAddr, transferValue);
        DIPC_EMIT_EVENT(payByPasswordEvent, passwordName,  transferValue * 1000);
    } else {
        DIPC_EMIT_EVENT(ErrEvent, "payByPassword  password exist", passwordName);
    }
    
    (*passwordStore).erase(passwordName);
    (*passwordStoreHis)[std::string(passwordName)+"_"+pwInfo.toAddr+"_"+std::to_string(pwInfo.timeRegistered)] = pInfo;
}
 
PAYABLE void PasswordManage::depositeContract(){
    uint64_t value = dipc::callValueUDIP() * 1000;
    DIPC_EMIT_EVENT(depositingValue,value);
}
 
EXPORT void PasswordManage::setExpireTime(uint64_t _expireTime){
    
    u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
*expireTime = _expireTime * 60 * 60 * 1000000000;
    DIPC_EMIT_EVENT(expireTimeSetted,expireTime.get());
} codetext new #include "PasswordManage.hpp"

PAYABLE void PasswordManage::init(){
    std::string ownerStr = caller().toString();
    *owner = ownerStr;
}
 
EXPORT void PasswordManage::registerPassword(char* passwordName, char* toAddr, uint64_t _balance){
    u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
PasswordInfo info(passwordName, toAddr, _balance, dipc::timestamp());
    std::string pInfo = info.toJson();
    if (passwordStore.get()[passwordName] != "") {
        DIPC_EMIT_EVENT(ErrEvent, "registerPassword  password exist", passwordName);
        return;
    }
    (*passwordStore)[passwordName] = pInfo;
    print("registerPassword pInfo");
    print(pInfo);
    std::string callerStr = dipc::caller().toString();
    DIPC_EMIT_EVENT(registerPasswordEvent, &callerStr[0], passwordName, &pInfo[0]);
}
CONSTANT char* PasswordManage::queryExistPasswords(){
    u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
std::map<std::string, std::string>::iterator iter;
    auto mapStore = passwordStore.get();
    iter = mapStore.begin();
    std::string result = "[";
    print("queryExistPasswords start");
    while(iter != mapStore.end()){
        result += iter->first + ","; 
        iter++;
    }
    print("queryExistPasswords end");

    result.substr(0,result.size()-1);
    result += "]";
    print("queryExistPasswords  result");
    print(result);
    return &result[0];
}
CONSTANT bool PasswordManage::queryPasswordIsUsed(char* passwordName){
     u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
if (passwordStore.get()[passwordName] != "") {
        return true;
    }
    return false;
}
PAYABLE void PasswordManage::payByPassword(char* passwordName){
    std::string pInfo = passwordStore.get()[passwordName];
    PasswordInfo pwInfo;
    pwInfo.parseJson(pInfo);
    print("pwInfo");
    print(pwInfo.toJson());
    uint64_t transferValue = dipc::callValueUDIP();
    print("transferValue");
    print(transferValue);
    print(pwInfo.balance);
    if(dipc::timestamp() >=  expireTime.get() + pwInfo.timeRegistered){
        DipcAssert(transferValue / 1000 == pwInfo.balance);
        Address toAddr = Address(pwInfo.toAddr,22);
        callTransferUDIP(toAddr, transferValue);
        DIPC_EMIT_EVENT(payByPasswordEvent, passwordName,  transferValue * 1000);
    } else {
        DIPC_EMIT_EVENT(ErrEvent, "payByPassword  password exist", passwordName);
    }
    
    (*passwordStore).erase(passwordName);
    (*passwordStoreHis)[std::string(passwordName)+"_"+pwInfo.toAddr+"_"+std::to_string(pwInfo.timeRegistered)] = pInfo;
}
 
PAYABLE void PasswordManage::depositeContract(){
    uint64_t value = dipc::callValueUDIP() * 1000;
    DIPC_EMIT_EVENT(depositingValue,value);
}
 
EXPORT void PasswordManage::setExpireTime(uint64_t _expireTime){
    
    *expireTime = _expireTime * 60 * 60 * 1000000000;
    DIPC_EMIT_EVENT(expireTimeSetted,expireTime.get());
}

2019-12-31_16:56:02.406424: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:604] finalContract  final content =======   : #include "PasswordManage.hpp"

PAYABLE void PasswordManage::init(){
    std::string ownerStr = caller().toString();
    *owner = ownerStr;
}
 
EXPORT void PasswordManage::registerPassword(char* passwordName, char* toAddr, uint64_t _balance){
    u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
PasswordInfo info(passwordName, toAddr, _balance, dipc::timestamp());
    std::string pInfo = info.toJson();
    if (passwordStore.get()[passwordName] != "") {
        DIPC_EMIT_EVENT(ErrEvent, "registerPassword  password exist", passwordName);
        return;
    }
    (*passwordStore)[passwordName] = pInfo;
    print("registerPassword pInfo");
    print(pInfo);
    std::string callerStr = dipc::caller().toString();
    DIPC_EMIT_EVENT(registerPasswordEvent, &callerStr[0], passwordName, &pInfo[0]);
}
CONSTANT char* PasswordManage::queryExistPasswords(){
    u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
std::map<std::string, std::string>::iterator iter;
    auto mapStore = passwordStore.get();
    iter = mapStore.begin();
    std::string result = "[";
    print("queryExistPasswords start");
    while(iter != mapStore.end()){
        result += iter->first + ","; 
        iter++;
    }
    print("queryExistPasswords end");

    result.substr(0,result.size()-1);
    result += "]";
    print("queryExistPasswords  result");
    print(result);
    return &result[0];
}
CONSTANT bool PasswordManage::queryPasswordIsUsed(char* passwordName){
     u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
if (passwordStore.get()[passwordName] != "") {
        return true;
    }
    return false;
}
PAYABLE void PasswordManage::payByPassword(char* passwordName){
    std::string pInfo = passwordStore.get()[passwordName];
    PasswordInfo pwInfo;
    pwInfo.parseJson(pInfo);
    print("pwInfo");
    print(pwInfo.toJson());
    uint64_t transferValue = dipc::callValueUDIP();
    print("transferValue");
    print(transferValue);
    print(pwInfo.balance);
    if(dipc::timestamp() >=  expireTime.get() + pwInfo.timeRegistered){
        DipcAssert(transferValue / 1000 == pwInfo.balance);
        Address toAddr = Address(pwInfo.toAddr,22);
        callTransferUDIP(toAddr, transferValue);
        DIPC_EMIT_EVENT(payByPasswordEvent, passwordName,  transferValue * 1000);
    } else {
        DIPC_EMIT_EVENT(ErrEvent, "payByPassword  password exist", passwordName);
    }
    
    (*passwordStore).erase(passwordName);
    (*passwordStoreHis)[std::string(passwordName)+"_"+pwInfo.toAddr+"_"+std::to_string(pwInfo.timeRegistered)] = pInfo;
}
 
PAYABLE void PasswordManage::depositeContract(){
    uint64_t value = dipc::callValueUDIP() * 1000;
    DIPC_EMIT_EVENT(depositingValue,value);
}
 
EXPORT void PasswordManage::setExpireTime(uint64_t _expireTime){
    
    u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
*expireTime = _expireTime * 60 * 60 * 1000000000;
    DIPC_EMIT_EVENT(expireTimeSetted,expireTime.get());
}

2019-12-31_16:56:02.406440: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:613] finalContract  final content  last =======   : #include "PasswordManage.hpp"

PAYABLE void PasswordManage::init(){
    std::string ownerStr = caller().toString();
    *owner = ownerStr;
}
 
EXPORT void PasswordManage::registerPassword(char* passwordName, char* toAddr, uint64_t _balance){
    u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
PasswordInfo info(passwordName, toAddr, _balance, dipc::timestamp());
    std::string pInfo = info.toJson();
    if (passwordStore.get()[passwordName] != "") {
        DIPC_EMIT_EVENT(ErrEvent, "registerPassword  password exist", passwordName);
        return;
    }
    (*passwordStore)[passwordName] = pInfo;
    print("registerPassword pInfo");
    print(pInfo);
    std::string callerStr = dipc::caller().toString();
    DIPC_EMIT_EVENT(registerPasswordEvent, &callerStr[0], passwordName, &pInfo[0]);
}
CONSTANT char* PasswordManage::queryExistPasswords(){
    u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
std::map<std::string, std::string>::iterator iter;
    auto mapStore = passwordStore.get();
    iter = mapStore.begin();
    std::string result = "[";
    print("queryExistPasswords start");
    while(iter != mapStore.end()){
        result += iter->first + ","; 
        iter++;
    }
    print("queryExistPasswords end");

    result.substr(0,result.size()-1);
    result += "]";
    print("queryExistPasswords  result");
    print(result);
    return &result[0];
}
CONSTANT bool PasswordManage::queryPasswordIsUsed(char* passwordName){
     u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
if (passwordStore.get()[passwordName] != "") {
        return true;
    }
    return false;
}
PAYABLE void PasswordManage::payByPassword(char* passwordName){
    std::string pInfo = passwordStore.get()[passwordName];
    PasswordInfo pwInfo;
    pwInfo.parseJson(pInfo);
    print("pwInfo");
    print(pwInfo.toJson());
    uint64_t transferValue = dipc::callValueUDIP();
    print("transferValue");
    print(transferValue);
    print(pwInfo.balance);
    if(dipc::timestamp() >=  expireTime.get() + pwInfo.timeRegistered){
        DipcAssert(transferValue / 1000 == pwInfo.balance);
        Address toAddr = Address(pwInfo.toAddr,22);
        callTransferUDIP(toAddr, transferValue);
        DIPC_EMIT_EVENT(payByPasswordEvent, passwordName,  transferValue * 1000);
    } else {
        DIPC_EMIT_EVENT(ErrEvent, "payByPassword  password exist", passwordName);
    }
    
    (*passwordStore).erase(passwordName);
    (*passwordStoreHis)[std::string(passwordName)+"_"+pwInfo.toAddr+"_"+std::to_string(pwInfo.timeRegistered)] = pInfo;
}
 
PAYABLE void PasswordManage::depositeContract(){
    uint64_t value = dipc::callValueUDIP() * 1000;
    DIPC_EMIT_EVENT(depositingValue,value);
}
 
EXPORT void PasswordManage::setExpireTime(uint64_t _expireTime){
    
    u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
*expireTime = _expireTime * 60 * 60 * 1000000000;
    DIPC_EMIT_EVENT(expireTimeSetted,expireTime.get());
}

2019-12-31_16:56:02.406535: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:886] removedComments end  =======::#include "PasswordManage.hpp"

PAYABLE void PasswordManage::init(){
    std::string ownerStr = caller().toString();
    *owner = ownerStr;
}
 
EXPORT void PasswordManage::registerPassword(char* passwordName, char* toAddr, uint64_t _balance){
    u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
PasswordInfo info(passwordName, toAddr, _balance, dipc::timestamp());
    std::string pInfo = info.toJson();
    if (passwordStore.get()[passwordName] != "") {
        DIPC_EMIT_EVENT(ErrEvent, "registerPassword  password exist", passwordName);
        return;
    }
    (*passwordStore)[passwordName] = pInfo;
    print("registerPassword pInfo");
    print(pInfo);
    std::string callerStr = dipc::caller().toString();
    DIPC_EMIT_EVENT(registerPasswordEvent, &callerStr[0], passwordName, &pInfo[0]);
}
CONSTANT char* PasswordManage::queryExistPasswords(){
    u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
std::map<std::string, std::string>::iterator iter;
    auto mapStore = passwordStore.get();
    iter = mapStore.begin();
    std::string result = "[";
    print("queryExistPasswords start");
    while(iter != mapStore.end()){
        result += iter->first + ","; 
        iter++;
    }
    print("queryExistPasswords end");

    result.substr(0,result.size()-1);
    result += "]";
    print("queryExistPasswords  result");
    print(result);
    return &result[0];
}
CONSTANT bool PasswordManage::queryPasswordIsUsed(char* passwordName){
     u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
if (passwordStore.get()[passwordName] != "") {
        return true;
    }
    return false;
}
PAYABLE void PasswordManage::payByPassword(char* passwordName){
    std::string pInfo = passwordStore.get()[passwordName];
    PasswordInfo pwInfo;
    pwInfo.parseJson(pInfo);
    print("pwInfo");
    print(pwInfo.toJson());
    uint64_t transferValue = dipc::callValueUDIP();
    print("transferValue");
    print(transferValue);
    print(pwInfo.balance);
    if(dipc::timestamp() >=  expireTime.get() + pwInfo.timeRegistered){
        DipcAssert(transferValue / 1000 == pwInfo.balance);
        Address toAddr = Address(pwInfo.toAddr,22);
        callTransferUDIP(toAddr, transferValue);
        DIPC_EMIT_EVENT(payByPasswordEvent, passwordName,  transferValue * 1000);
    } else {
        DIPC_EMIT_EVENT(ErrEvent, "payByPassword  password exist", passwordName);
    }
    
    (*passwordStore).erase(passwordName);
    (*passwordStoreHis)[std::string(passwordName)+"_"+pwInfo.toAddr+"_"+std::to_string(pwInfo.timeRegistered)] = pInfo;
}
 
PAYABLE void PasswordManage::depositeContract(){
    uint64_t value = dipc::callValueUDIP() * 1000;
    DIPC_EMIT_EVENT(depositingValue,value);
}
 
EXPORT void PasswordManage::setExpireTime(uint64_t _expireTime){
    
    u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
*expireTime = _expireTime * 60 * 60 * 1000000000;
    DIPC_EMIT_EVENT(expireTimeSetted,expireTime.get());
}

2019-12-31_16:56:02.406545: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:890] str ============
2019-12-31_16:56:02.406551: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:891] str ============class\s*PasswordManage\s*\{
2019-12-31_16:56:02.406565: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:896] findClass end  =======::

2019-12-31_16:56:02.406572: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:899] claSma end  =======::

2019-12-31_16:56:02.407790: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:619] CompareHeaderAndImplFileMacro  start 

2019-12-31_16:56:02.407806: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:650] get codeText content #include "PasswordManage.hpp"

PAYABLE void PasswordManage::init(){
    std::string ownerStr = caller().toString();
    *owner = ownerStr;
}
 
EXPORT void PasswordManage::registerPassword(char* passwordName, char* toAddr, uint64_t _balance){
    u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
PasswordInfo info(passwordName, toAddr, _balance, dipc::timestamp());
    std::string pInfo = info.toJson();
    if (passwordStore.get()[passwordName] != "") {
        DIPC_EMIT_EVENT(ErrEvent, "registerPassword  password exist", passwordName);
        return;
    }
    (*passwordStore)[passwordName] = pInfo;
    print("registerPassword pInfo");
    print(pInfo);
    std::string callerStr = dipc::caller().toString();
    DIPC_EMIT_EVENT(registerPasswordEvent, &callerStr[0], passwordName, &pInfo[0]);
}
CONSTANT char* PasswordManage::queryExistPasswords(){
    u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
std::map<std::string, std::string>::iterator iter;
    auto mapStore = passwordStore.get();
    iter = mapStore.begin();
    std::string result = "[";
    print("queryExistPasswords start");
    while(iter != mapStore.end()){
        result += iter->first + ","; 
        iter++;
    }
    print("queryExistPasswords end");

    result.substr(0,result.size()-1);
    result += "]";
    print("queryExistPasswords  result");
    print(result);
    return &result[0];
}
CONSTANT bool PasswordManage::queryPasswordIsUsed(char* passwordName){
     u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
if (passwordStore.get()[passwordName] != "") {
        return true;
    }
    return false;
}
PAYABLE void PasswordManage::payByPassword(char* passwordName){
    std::string pInfo = passwordStore.get()[passwordName];
    PasswordInfo pwInfo;
    pwInfo.parseJson(pInfo);
    print("pwInfo");
    print(pwInfo.toJson());
    uint64_t transferValue = dipc::callValueUDIP();
    print("transferValue");
    print(transferValue);
    print(pwInfo.balance);
    if(dipc::timestamp() >=  expireTime.get() + pwInfo.timeRegistered){
        DipcAssert(transferValue / 1000 == pwInfo.balance);
        Address toAddr = Address(pwInfo.toAddr,22);
        callTransferUDIP(toAddr, transferValue);
        DIPC_EMIT_EVENT(payByPasswordEvent, passwordName,  transferValue * 1000);
    } else {
        DIPC_EMIT_EVENT(ErrEvent, "payByPassword  password exist", passwordName);
    }
    
    (*passwordStore).erase(passwordName);
    (*passwordStoreHis)[std::string(passwordName)+"_"+pwInfo.toAddr+"_"+std::to_string(pwInfo.timeRegistered)] = pInfo;
}
 
PAYABLE void PasswordManage::depositeContract(){
    uint64_t value = dipc::callValueUDIP() * 1000;
    DIPC_EMIT_EVENT(depositingValue,value);
}
 
EXPORT void PasswordManage::setExpireTime(uint64_t _expireTime){
    
    u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
*expireTime = _expireTime * 60 * 60 * 1000000000;
    DIPC_EMIT_EVENT(expireTimeSetted,expireTime.get());
}

2019-12-31_16:56:02.407814: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:659] searchStr \s*PAYABLE\s*void\s*PasswordManage::init code_text #include "PasswordManage.hpp"

PAYABLE void PasswordManage::init(){
    std::string ownerStr = caller().toString();
    *owner = ownerStr;
}
 
EXPORT void PasswordManage::registerPassword(char* passwordName, char* toAddr, uint64_t _balance){
    u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
PasswordInfo info(passwordName, toAddr, _balance, dipc::timestamp());
    std::string pInfo = info.toJson();
    if (passwordStore.get()[passwordName] != "") {
        DIPC_EMIT_EVENT(ErrEvent, "registerPassword  password exist", passwordName);
        return;
    }
    (*passwordStore)[passwordName] = pInfo;
    print("registerPassword pInfo");
    print(pInfo);
    std::string callerStr = dipc::caller().toString();
    DIPC_EMIT_EVENT(registerPasswordEvent, &callerStr[0], passwordName, &pInfo[0]);
}
CONSTANT char* PasswordManage::queryExistPasswords(){
    u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
std::map<std::string, std::string>::iterator iter;
    auto mapStore = passwordStore.get();
    iter = mapStore.begin();
    std::string result = "[";
    print("queryExistPasswords start");
    while(iter != mapStore.end()){
        result += iter->first + ","; 
        iter++;
    }
    print("queryExistPasswords end");

    result.substr(0,result.size()-1);
    result += "]";
    print("queryExistPasswords  result");
    print(result);
    return &result[0];
}
CONSTANT bool PasswordManage::queryPasswordIsUsed(char* passwordName){
     u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
if (passwordStore.get()[passwordName] != "") {
        return true;
    }
    return false;
}
PAYABLE void PasswordManage::payByPassword(char* passwordName){
    std::string pInfo = passwordStore.get()[passwordName];
    PasswordInfo pwInfo;
    pwInfo.parseJson(pInfo);
    print("pwInfo");
    print(pwInfo.toJson());
    uint64_t transferValue = dipc::callValueUDIP();
    print("transferValue");
    print(transferValue);
    print(pwInfo.balance);
    if(dipc::timestamp() >=  expireTime.get() + pwInfo.timeRegistered){
        DipcAssert(transferValue / 1000 == pwInfo.balance);
        Address toAddr = Address(pwInfo.toAddr,22);
        callTransferUDIP(toAddr, transferValue);
        DIPC_EMIT_EVENT(payByPasswordEvent, passwordName,  transferValue * 1000);
    } else {
        DIPC_EMIT_EVENT(ErrEvent, "payByPassword  password exist", passwordName);
    }
    
    (*passwordStore).erase(passwordName);
    (*passwordStoreHis)[std::string(passwordName)+"_"+pwInfo.toAddr+"_"+std::to_string(pwInfo.timeRegistered)] = pInfo;
}
 
PAYABLE void PasswordManage::depositeContract(){
    uint64_t value = dipc::callValueUDIP() * 1000;
    DIPC_EMIT_EVENT(depositingValue,value);
}
 
EXPORT void PasswordManage::setExpireTime(uint64_t _expireTime){
    
    u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
*expireTime = _expireTime * 60 * 60 * 1000000000;
    DIPC_EMIT_EVENT(expireTimeSetted,expireTime.get());
}

2019-12-31_16:56:02.407822: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:660] searchStr \s*PAYABLE\s*void\s*PasswordManage::init

2019-12-31_16:56:02.407856: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:659] searchStr \s*EXPORT\s*void\s*PasswordManage::registerPassword code_text #include "PasswordManage.hpp"

PAYABLE void PasswordManage::init(){
    std::string ownerStr = caller().toString();
    *owner = ownerStr;
}
 
EXPORT void PasswordManage::registerPassword(char* passwordName, char* toAddr, uint64_t _balance){
    u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
PasswordInfo info(passwordName, toAddr, _balance, dipc::timestamp());
    std::string pInfo = info.toJson();
    if (passwordStore.get()[passwordName] != "") {
        DIPC_EMIT_EVENT(ErrEvent, "registerPassword  password exist", passwordName);
        return;
    }
    (*passwordStore)[passwordName] = pInfo;
    print("registerPassword pInfo");
    print(pInfo);
    std::string callerStr = dipc::caller().toString();
    DIPC_EMIT_EVENT(registerPasswordEvent, &callerStr[0], passwordName, &pInfo[0]);
}
CONSTANT char* PasswordManage::queryExistPasswords(){
    u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
std::map<std::string, std::string>::iterator iter;
    auto mapStore = passwordStore.get();
    iter = mapStore.begin();
    std::string result = "[";
    print("queryExistPasswords start");
    while(iter != mapStore.end()){
        result += iter->first + ","; 
        iter++;
    }
    print("queryExistPasswords end");

    result.substr(0,result.size()-1);
    result += "]";
    print("queryExistPasswords  result");
    print(result);
    return &result[0];
}
CONSTANT bool PasswordManage::queryPasswordIsUsed(char* passwordName){
     u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
if (passwordStore.get()[passwordName] != "") {
        return true;
    }
    return false;
}
PAYABLE void PasswordManage::payByPassword(char* passwordName){
    std::string pInfo = passwordStore.get()[passwordName];
    PasswordInfo pwInfo;
    pwInfo.parseJson(pInfo);
    print("pwInfo");
    print(pwInfo.toJson());
    uint64_t transferValue = dipc::callValueUDIP();
    print("transferValue");
    print(transferValue);
    print(pwInfo.balance);
    if(dipc::timestamp() >=  expireTime.get() + pwInfo.timeRegistered){
        DipcAssert(transferValue / 1000 == pwInfo.balance);
        Address toAddr = Address(pwInfo.toAddr,22);
        callTransferUDIP(toAddr, transferValue);
        DIPC_EMIT_EVENT(payByPasswordEvent, passwordName,  transferValue * 1000);
    } else {
        DIPC_EMIT_EVENT(ErrEvent, "payByPassword  password exist", passwordName);
    }
    
    (*passwordStore).erase(passwordName);
    (*passwordStoreHis)[std::string(passwordName)+"_"+pwInfo.toAddr+"_"+std::to_string(pwInfo.timeRegistered)] = pInfo;
}
 
PAYABLE void PasswordManage::depositeContract(){
    uint64_t value = dipc::callValueUDIP() * 1000;
    DIPC_EMIT_EVENT(depositingValue,value);
}
 
EXPORT void PasswordManage::setExpireTime(uint64_t _expireTime){
    
    u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
*expireTime = _expireTime * 60 * 60 * 1000000000;
    DIPC_EMIT_EVENT(expireTimeSetted,expireTime.get());
}

2019-12-31_16:56:02.407864: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:660] searchStr \s*EXPORT\s*void\s*PasswordManage::registerPassword

2019-12-31_16:56:02.407955: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:659] searchStr \s*CONSTANT\s*char\*\s*PasswordManage::queryExistPasswords code_text #include "PasswordManage.hpp"

PAYABLE void PasswordManage::init(){
    std::string ownerStr = caller().toString();
    *owner = ownerStr;
}
 
EXPORT void PasswordManage::registerPassword(char* passwordName, char* toAddr, uint64_t _balance){
    u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
PasswordInfo info(passwordName, toAddr, _balance, dipc::timestamp());
    std::string pInfo = info.toJson();
    if (passwordStore.get()[passwordName] != "") {
        DIPC_EMIT_EVENT(ErrEvent, "registerPassword  password exist", passwordName);
        return;
    }
    (*passwordStore)[passwordName] = pInfo;
    print("registerPassword pInfo");
    print(pInfo);
    std::string callerStr = dipc::caller().toString();
    DIPC_EMIT_EVENT(registerPasswordEvent, &callerStr[0], passwordName, &pInfo[0]);
}
CONSTANT char* PasswordManage::queryExistPasswords(){
    u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
std::map<std::string, std::string>::iterator iter;
    auto mapStore = passwordStore.get();
    iter = mapStore.begin();
    std::string result = "[";
    print("queryExistPasswords start");
    while(iter != mapStore.end()){
        result += iter->first + ","; 
        iter++;
    }
    print("queryExistPasswords end");

    result.substr(0,result.size()-1);
    result += "]";
    print("queryExistPasswords  result");
    print(result);
    return &result[0];
}
CONSTANT bool PasswordManage::queryPasswordIsUsed(char* passwordName){
     u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
if (passwordStore.get()[passwordName] != "") {
        return true;
    }
    return false;
}
PAYABLE void PasswordManage::payByPassword(char* passwordName){
    std::string pInfo = passwordStore.get()[passwordName];
    PasswordInfo pwInfo;
    pwInfo.parseJson(pInfo);
    print("pwInfo");
    print(pwInfo.toJson());
    uint64_t transferValue = dipc::callValueUDIP();
    print("transferValue");
    print(transferValue);
    print(pwInfo.balance);
    if(dipc::timestamp() >=  expireTime.get() + pwInfo.timeRegistered){
        DipcAssert(transferValue / 1000 == pwInfo.balance);
        Address toAddr = Address(pwInfo.toAddr,22);
        callTransferUDIP(toAddr, transferValue);
        DIPC_EMIT_EVENT(payByPasswordEvent, passwordName,  transferValue * 1000);
    } else {
        DIPC_EMIT_EVENT(ErrEvent, "payByPassword  password exist", passwordName);
    }
    
    (*passwordStore).erase(passwordName);
    (*passwordStoreHis)[std::string(passwordName)+"_"+pwInfo.toAddr+"_"+std::to_string(pwInfo.timeRegistered)] = pInfo;
}
 
PAYABLE void PasswordManage::depositeContract(){
    uint64_t value = dipc::callValueUDIP() * 1000;
    DIPC_EMIT_EVENT(depositingValue,value);
}
 
EXPORT void PasswordManage::setExpireTime(uint64_t _expireTime){
    
    u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
*expireTime = _expireTime * 60 * 60 * 1000000000;
    DIPC_EMIT_EVENT(expireTimeSetted,expireTime.get());
}

2019-12-31_16:56:02.407962: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:660] searchStr \s*CONSTANT\s*char\*\s*PasswordManage::queryExistPasswords

2019-12-31_16:56:02.408495: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:659] searchStr \s*CONSTANT\s*bool\s*PasswordManage::queryPasswordIsUsed code_text #include "PasswordManage.hpp"

PAYABLE void PasswordManage::init(){
    std::string ownerStr = caller().toString();
    *owner = ownerStr;
}
 
EXPORT void PasswordManage::registerPassword(char* passwordName, char* toAddr, uint64_t _balance){
    u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
PasswordInfo info(passwordName, toAddr, _balance, dipc::timestamp());
    std::string pInfo = info.toJson();
    if (passwordStore.get()[passwordName] != "") {
        DIPC_EMIT_EVENT(ErrEvent, "registerPassword  password exist", passwordName);
        return;
    }
    (*passwordStore)[passwordName] = pInfo;
    print("registerPassword pInfo");
    print(pInfo);
    std::string callerStr = dipc::caller().toString();
    DIPC_EMIT_EVENT(registerPasswordEvent, &callerStr[0], passwordName, &pInfo[0]);
}
CONSTANT char* PasswordManage::queryExistPasswords(){
    u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
std::map<std::string, std::string>::iterator iter;
    auto mapStore = passwordStore.get();
    iter = mapStore.begin();
    std::string result = "[";
    print("queryExistPasswords start");
    while(iter != mapStore.end()){
        result += iter->first + ","; 
        iter++;
    }
    print("queryExistPasswords end");

    result.substr(0,result.size()-1);
    result += "]";
    print("queryExistPasswords  result");
    print(result);
    return &result[0];
}
CONSTANT bool PasswordManage::queryPasswordIsUsed(char* passwordName){
     u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
if (passwordStore.get()[passwordName] != "") {
        return true;
    }
    return false;
}
PAYABLE void PasswordManage::payByPassword(char* passwordName){
    std::string pInfo = passwordStore.get()[passwordName];
    PasswordInfo pwInfo;
    pwInfo.parseJson(pInfo);
    print("pwInfo");
    print(pwInfo.toJson());
    uint64_t transferValue = dipc::callValueUDIP();
    print("transferValue");
    print(transferValue);
    print(pwInfo.balance);
    if(dipc::timestamp() >=  expireTime.get() + pwInfo.timeRegistered){
        DipcAssert(transferValue / 1000 == pwInfo.balance);
        Address toAddr = Address(pwInfo.toAddr,22);
        callTransferUDIP(toAddr, transferValue);
        DIPC_EMIT_EVENT(payByPasswordEvent, passwordName,  transferValue * 1000);
    } else {
        DIPC_EMIT_EVENT(ErrEvent, "payByPassword  password exist", passwordName);
    }
    
    (*passwordStore).erase(passwordName);
    (*passwordStoreHis)[std::string(passwordName)+"_"+pwInfo.toAddr+"_"+std::to_string(pwInfo.timeRegistered)] = pInfo;
}
 
PAYABLE void PasswordManage::depositeContract(){
    uint64_t value = dipc::callValueUDIP() * 1000;
    DIPC_EMIT_EVENT(depositingValue,value);
}
 
EXPORT void PasswordManage::setExpireTime(uint64_t _expireTime){
    
    u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
*expireTime = _expireTime * 60 * 60 * 1000000000;
    DIPC_EMIT_EVENT(expireTimeSetted,expireTime.get());
}

2019-12-31_16:56:02.408510: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:660] searchStr \s*CONSTANT\s*bool\s*PasswordManage::queryPasswordIsUsed

2019-12-31_16:56:02.409347: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:659] searchStr \s*PAYABLE\s*void\s*PasswordManage::payByPassword code_text #include "PasswordManage.hpp"

PAYABLE void PasswordManage::init(){
    std::string ownerStr = caller().toString();
    *owner = ownerStr;
}
 
EXPORT void PasswordManage::registerPassword(char* passwordName, char* toAddr, uint64_t _balance){
    u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
PasswordInfo info(passwordName, toAddr, _balance, dipc::timestamp());
    std::string pInfo = info.toJson();
    if (passwordStore.get()[passwordName] != "") {
        DIPC_EMIT_EVENT(ErrEvent, "registerPassword  password exist", passwordName);
        return;
    }
    (*passwordStore)[passwordName] = pInfo;
    print("registerPassword pInfo");
    print(pInfo);
    std::string callerStr = dipc::caller().toString();
    DIPC_EMIT_EVENT(registerPasswordEvent, &callerStr[0], passwordName, &pInfo[0]);
}
CONSTANT char* PasswordManage::queryExistPasswords(){
    u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
std::map<std::string, std::string>::iterator iter;
    auto mapStore = passwordStore.get();
    iter = mapStore.begin();
    std::string result = "[";
    print("queryExistPasswords start");
    while(iter != mapStore.end()){
        result += iter->first + ","; 
        iter++;
    }
    print("queryExistPasswords end");

    result.substr(0,result.size()-1);
    result += "]";
    print("queryExistPasswords  result");
    print(result);
    return &result[0];
}
CONSTANT bool PasswordManage::queryPasswordIsUsed(char* passwordName){
     u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
if (passwordStore.get()[passwordName] != "") {
        return true;
    }
    return false;
}
PAYABLE void PasswordManage::payByPassword(char* passwordName){
    std::string pInfo = passwordStore.get()[passwordName];
    PasswordInfo pwInfo;
    pwInfo.parseJson(pInfo);
    print("pwInfo");
    print(pwInfo.toJson());
    uint64_t transferValue = dipc::callValueUDIP();
    print("transferValue");
    print(transferValue);
    print(pwInfo.balance);
    if(dipc::timestamp() >=  expireTime.get() + pwInfo.timeRegistered){
        DipcAssert(transferValue / 1000 == pwInfo.balance);
        Address toAddr = Address(pwInfo.toAddr,22);
        callTransferUDIP(toAddr, transferValue);
        DIPC_EMIT_EVENT(payByPasswordEvent, passwordName,  transferValue * 1000);
    } else {
        DIPC_EMIT_EVENT(ErrEvent, "payByPassword  password exist", passwordName);
    }
    
    (*passwordStore).erase(passwordName);
    (*passwordStoreHis)[std::string(passwordName)+"_"+pwInfo.toAddr+"_"+std::to_string(pwInfo.timeRegistered)] = pInfo;
}
 
PAYABLE void PasswordManage::depositeContract(){
    uint64_t value = dipc::callValueUDIP() * 1000;
    DIPC_EMIT_EVENT(depositingValue,value);
}
 
EXPORT void PasswordManage::setExpireTime(uint64_t _expireTime){
    
    u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
*expireTime = _expireTime * 60 * 60 * 1000000000;
    DIPC_EMIT_EVENT(expireTimeSetted,expireTime.get());
}

2019-12-31_16:56:02.409357: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:660] searchStr \s*PAYABLE\s*void\s*PasswordManage::payByPassword

2019-12-31_16:56:02.410427: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:659] searchStr \s*PAYABLE\s*void\s*PasswordManage::depositeContract code_text #include "PasswordManage.hpp"

PAYABLE void PasswordManage::init(){
    std::string ownerStr = caller().toString();
    *owner = ownerStr;
}
 
EXPORT void PasswordManage::registerPassword(char* passwordName, char* toAddr, uint64_t _balance){
    u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
PasswordInfo info(passwordName, toAddr, _balance, dipc::timestamp());
    std::string pInfo = info.toJson();
    if (passwordStore.get()[passwordName] != "") {
        DIPC_EMIT_EVENT(ErrEvent, "registerPassword  password exist", passwordName);
        return;
    }
    (*passwordStore)[passwordName] = pInfo;
    print("registerPassword pInfo");
    print(pInfo);
    std::string callerStr = dipc::caller().toString();
    DIPC_EMIT_EVENT(registerPasswordEvent, &callerStr[0], passwordName, &pInfo[0]);
}
CONSTANT char* PasswordManage::queryExistPasswords(){
    u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
std::map<std::string, std::string>::iterator iter;
    auto mapStore = passwordStore.get();
    iter = mapStore.begin();
    std::string result = "[";
    print("queryExistPasswords start");
    while(iter != mapStore.end()){
        result += iter->first + ","; 
        iter++;
    }
    print("queryExistPasswords end");

    result.substr(0,result.size()-1);
    result += "]";
    print("queryExistPasswords  result");
    print(result);
    return &result[0];
}
CONSTANT bool PasswordManage::queryPasswordIsUsed(char* passwordName){
     u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
if (passwordStore.get()[passwordName] != "") {
        return true;
    }
    return false;
}
PAYABLE void PasswordManage::payByPassword(char* passwordName){
    std::string pInfo = passwordStore.get()[passwordName];
    PasswordInfo pwInfo;
    pwInfo.parseJson(pInfo);
    print("pwInfo");
    print(pwInfo.toJson());
    uint64_t transferValue = dipc::callValueUDIP();
    print("transferValue");
    print(transferValue);
    print(pwInfo.balance);
    if(dipc::timestamp() >=  expireTime.get() + pwInfo.timeRegistered){
        DipcAssert(transferValue / 1000 == pwInfo.balance);
        Address toAddr = Address(pwInfo.toAddr,22);
        callTransferUDIP(toAddr, transferValue);
        DIPC_EMIT_EVENT(payByPasswordEvent, passwordName,  transferValue * 1000);
    } else {
        DIPC_EMIT_EVENT(ErrEvent, "payByPassword  password exist", passwordName);
    }
    
    (*passwordStore).erase(passwordName);
    (*passwordStoreHis)[std::string(passwordName)+"_"+pwInfo.toAddr+"_"+std::to_string(pwInfo.timeRegistered)] = pInfo;
}
 
PAYABLE void PasswordManage::depositeContract(){
    uint64_t value = dipc::callValueUDIP() * 1000;
    DIPC_EMIT_EVENT(depositingValue,value);
}
 
EXPORT void PasswordManage::setExpireTime(uint64_t _expireTime){
    
    u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
*expireTime = _expireTime * 60 * 60 * 1000000000;
    DIPC_EMIT_EVENT(expireTimeSetted,expireTime.get());
}

2019-12-31_16:56:02.410439: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:660] searchStr \s*PAYABLE\s*void\s*PasswordManage::depositeContract

2019-12-31_16:56:02.411970: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:659] searchStr \s*EXPORT\s*void\s*PasswordManage::setExpireTime code_text #include "PasswordManage.hpp"

PAYABLE void PasswordManage::init(){
    std::string ownerStr = caller().toString();
    *owner = ownerStr;
}
 
EXPORT void PasswordManage::registerPassword(char* passwordName, char* toAddr, uint64_t _balance){
    u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
PasswordInfo info(passwordName, toAddr, _balance, dipc::timestamp());
    std::string pInfo = info.toJson();
    if (passwordStore.get()[passwordName] != "") {
        DIPC_EMIT_EVENT(ErrEvent, "registerPassword  password exist", passwordName);
        return;
    }
    (*passwordStore)[passwordName] = pInfo;
    print("registerPassword pInfo");
    print(pInfo);
    std::string callerStr = dipc::caller().toString();
    DIPC_EMIT_EVENT(registerPasswordEvent, &callerStr[0], passwordName, &pInfo[0]);
}
CONSTANT char* PasswordManage::queryExistPasswords(){
    u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
std::map<std::string, std::string>::iterator iter;
    auto mapStore = passwordStore.get();
    iter = mapStore.begin();
    std::string result = "[";
    print("queryExistPasswords start");
    while(iter != mapStore.end()){
        result += iter->first + ","; 
        iter++;
    }
    print("queryExistPasswords end");

    result.substr(0,result.size()-1);
    result += "]";
    print("queryExistPasswords  result");
    print(result);
    return &result[0];
}
CONSTANT bool PasswordManage::queryPasswordIsUsed(char* passwordName){
     u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
if (passwordStore.get()[passwordName] != "") {
        return true;
    }
    return false;
}
PAYABLE void PasswordManage::payByPassword(char* passwordName){
    std::string pInfo = passwordStore.get()[passwordName];
    PasswordInfo pwInfo;
    pwInfo.parseJson(pInfo);
    print("pwInfo");
    print(pwInfo.toJson());
    uint64_t transferValue = dipc::callValueUDIP();
    print("transferValue");
    print(transferValue);
    print(pwInfo.balance);
    if(dipc::timestamp() >=  expireTime.get() + pwInfo.timeRegistered){
        DipcAssert(transferValue / 1000 == pwInfo.balance);
        Address toAddr = Address(pwInfo.toAddr,22);
        callTransferUDIP(toAddr, transferValue);
        DIPC_EMIT_EVENT(payByPasswordEvent, passwordName,  transferValue * 1000);
    } else {
        DIPC_EMIT_EVENT(ErrEvent, "payByPassword  password exist", passwordName);
    }
    
    (*passwordStore).erase(passwordName);
    (*passwordStoreHis)[std::string(passwordName)+"_"+pwInfo.toAddr+"_"+std::to_string(pwInfo.timeRegistered)] = pInfo;
}
 
PAYABLE void PasswordManage::depositeContract(){
    uint64_t value = dipc::callValueUDIP() * 1000;
    DIPC_EMIT_EVENT(depositingValue,value);
}
 
EXPORT void PasswordManage::setExpireTime(uint64_t _expireTime){
    
    u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
*expireTime = _expireTime * 60 * 60 * 1000000000;
    DIPC_EMIT_EVENT(expireTimeSetted,expireTime.get());
}

2019-12-31_16:56:02.411983: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:660] searchStr \s*EXPORT\s*void\s*PasswordManage::setExpireTime

2019-12-31_16:56:02.413636: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:672] CompareHeaderAndImplFileMacro end  

2019-12-31_16:56:02.413663: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:915] hppPath  :  PasswordManage.hpp
2019-12-31_16:56:02.413706: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:919] hppOutPath  :  /var/folders/tt/8v4bb03x685c49jk_vkvr7s80000gp/T//PasswordManagetemp.hpp
2019-12-31_16:56:02.413747: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:927] abaabaab ======== : 
2019-12-31_16:56:02.413754: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:928] contractName ======== : PasswordManage
2019-12-31_16:56:02.413759: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:930] randomDir ======== : /var/folders/tt/8v4bb03x685c49jk_vkvr7s80000gp/T/5h97327fgggg16af7dii
2019-12-31_16:56:02.413768: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:931] hppOutPath ======== : /var/folders/tt/8v4bb03x685c49jk_vkvr7s80000gp/T//PasswordManagetemp.hpp
2019-12-31_16:56:02.413777: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:679] InsertFuncToHeaderFile start....

2019-12-31_16:56:02.413788: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:685] InsertFuncToHeaderFile new ....

2019-12-31_16:56:02.414787: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:687] InsertFuncToHeaderFile result ....true

2019-12-31_16:56:02.414801: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:694] claSma[0].str()  :    class PasswordManage : public Contract {

2019-12-31_16:56:02.414810: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:696] pos2  :    2673

2019-12-31_16:56:02.414819: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:728] tempText   :  #include "dipc/dipc.hpp"
#include "rapidjson/stringbuffer.h"
#include "rapidjson/writer.h"
#include "rapidjson/document.h"
using namespace dipc;

class PasswordInfo {
public:
    std::string passwordName;
    std::string toAddr;
    uint64_t balance;
    uint64_t timeRegistered;
    PasswordInfo(){};
    PasswordInfo(char* _passwordName, char* _toAddr, uint64_t _balance, uint64_t _timeRegistered):passwordName(_passwordName), 
        toAddr(_toAddr),balance(_balance), timeRegistered(_timeRegistered){ }
    std::string toJson(){
        // neb::CJsonObject oJson;
        // oJson.Add("passwordName", passwordName );
        // oJson.Add("toAddr", toAddr);
        // oJson.Add("balance", balance);
        // return oJson.ToString();
            print("timestamp");
            print(std::to_string(timeRegistered));
            std::string result = "{ \"passwordName\":\"" + passwordName + "\",\"toAddr\":\"" 
                + toAddr+ "\",\"balance\":" + std::to_string(balance)
                +",\"timeRegistered\":"+ std::to_string(timeRegistered) + "}";
            return result;
    }

    void parseJson(std::string info){
        // neb::CJsonObject oJson;
        // std::string pwName;
        // std::string toAddrStr;
        // if(oJson.Parse(pInfo)){
        //     oJson.Get("passwordName", pwName);
        //     oJson.Get("toAddr", toAddrStr);
        //     oJson.Get("balance", balance);
        // }
        // passwordName = &pwName[0];
        // toAddr = &toAddrStr[0];
            rapidjson::Document doc;
            print("parseJson start ");
            if(!doc.Parse(info.data()).HasParseError()){
   
                if(doc.HasMember("passwordName") && doc["passwordName"].IsString())
                {   
                    print("passwordName");
                    passwordName = &(doc["passwordName"].GetString()[0]);
                }
      
                if(doc.HasMember("toAddr") && doc["toAddr"].IsString())
                {
                    toAddr = &(doc["toAddr"].GetString()[0]);
                }
    
                if(doc.HasMember("balance") && doc["balance"].IsUint64())
                {
                     balance = doc["balance"].GetUint64();
                }

                if(doc.HasMember("timeRegistered") && doc["timeRegistered"].IsUint64())
                {
                     timeRegistered = doc["timeRegistered"].GetUint64();
                }
        
            } else {
                print("parseJson error ");
            }
    }
};

char expireTimec[] = "expireTime";
char passwordStorec[] = "passwordStore";
char passwordStoreHisc[] = "passwordStoreHis";
char ownerc[] = "owner";
class PasswordManage : public Contract {
private:
    Uint64<expireTimec> expireTime;
    Map<passwordStorec, std::string, std::string> passwordStore;
    Map<passwordStoreHisc, std::string, std::string> passwordStoreHis;
    String<ownerc> owner;

    void isOwner(){
        std::string callerStr = caller().toString();
        std::string ownerStr = owner.get();
        DipcAssert(callerStr == owner.get());
    }

public:
   PAYABLE void init();
   EXPORT void registerPassword(char* passwordName, char* passwordAddr, uint64_t _balance);
   CONSTANT char* queryExistPasswords();
   CONSTANT bool queryPasswordIsUsed(char* passwordName);
   PAYABLE void payByPassword(char* passwordName);
   PAYABLE void depositeContract();
   EXPORT void setExpireTime(uint64_t _expireTime);


2019-12-31_16:56:02.414827: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:731] filename   :  PasswordManage.cpp

2019-12-31_16:56:02.415460: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:751] tempText  end :  #include "dipc/dipc.hpp"
#include "rapidjson/stringbuffer.h"
#include "rapidjson/writer.h"
#include "rapidjson/document.h"
using namespace dipc;

class PasswordInfo {
public:
    std::string passwordName;
    std::string toAddr;
    uint64_t balance;
    uint64_t timeRegistered;
    PasswordInfo(){};
    PasswordInfo(char* _passwordName, char* _toAddr, uint64_t _balance, uint64_t _timeRegistered):passwordName(_passwordName), 
        toAddr(_toAddr),balance(_balance), timeRegistered(_timeRegistered){ }
    std::string toJson(){
        // neb::CJsonObject oJson;
        // oJson.Add("passwordName", passwordName );
        // oJson.Add("toAddr", toAddr);
        // oJson.Add("balance", balance);
        // return oJson.ToString();
            print("timestamp");
            print(std::to_string(timeRegistered));
            std::string result = "{ \"passwordName\":\"" + passwordName + "\",\"toAddr\":\"" 
                + toAddr+ "\",\"balance\":" + std::to_string(balance)
                +",\"timeRegistered\":"+ std::to_string(timeRegistered) + "}";
            return result;
    }

    void parseJson(std::string info){
        // neb::CJsonObject oJson;
        // std::string pwName;
        // std::string toAddrStr;
        // if(oJson.Parse(pInfo)){
        //     oJson.Get("passwordName", pwName);
        //     oJson.Get("toAddr", toAddrStr);
        //     oJson.Get("balance", balance);
        // }
        // passwordName = &pwName[0];
        // toAddr = &toAddrStr[0];
            rapidjson::Document doc;
            print("parseJson start ");
            if(!doc.Parse(info.data()).HasParseError()){
   
                if(doc.HasMember("passwordName") && doc["passwordName"].IsString())
                {   
                    print("passwordName");
                    passwordName = &(doc["passwordName"].GetString()[0]);
                }
      
                if(doc.HasMember("toAddr") && doc["toAddr"].IsString())
                {
                    toAddr = &(doc["toAddr"].GetString()[0]);
                }
    
                if(doc.HasMember("balance") && doc["balance"].IsUint64())
                {
                     balance = doc["balance"].GetUint64();
                }

                if(doc.HasMember("timeRegistered") && doc["timeRegistered"].IsUint64())
                {
                     timeRegistered = doc["timeRegistered"].GetUint64();
                }
        
            } else {
                print("parseJson error ");
            }
    }
};

char expireTimec[] = "expireTime";
char passwordStorec[] = "passwordStore";
char passwordStoreHisc[] = "passwordStoreHis";
char ownerc[] = "owner";
class PasswordManage : public Contract {
private:
    Uint64<expireTimec> expireTime;
    Map<passwordStorec, std::string, std::string> passwordStore;
    Map<passwordStoreHisc, std::string, std::string> passwordStoreHis;
    String<ownerc> owner;

    void isOwner(){
        std::string callerStr = caller().toString();
        std::string ownerStr = owner.get();
        DipcAssert(callerStr == owner.get());
    }

public:
   PAYABLE void init();
   EXPORT void registerPassword(char* passwordName, char* passwordAddr, uint64_t _balance);
   CONSTANT char* queryExistPasswords();
   CONSTANT bool queryPasswordIsUsed(char* passwordName);
   PAYABLE void payByPassword(char* passwordName);
   PAYABLE void depositeContract();
   EXPORT void setExpireTime(uint64_t _expireTime);
};

DIPC_EVENT(expireTimeSetted,uint64_t);
DIPC_EVENT(depositingValue,uint64_t);
DIPC_EVENT(ErrEvent, const char*, const char*);
DIPC_EVENT(registerPasswordEvent, const char*, const char*, const char*);
DIPC_EVENT(payByPasswordEvent, const char*, uint64_t);




2019-12-31_16:56:02.416224: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:940] headerStr removedComments  ======== : #include "PasswordManagetemp.hpp"

PAYABLE void PasswordManage::init(){
    std::string ownerStr = caller().toString();
    *owner = ownerStr;
}
 
EXPORT void PasswordManage::registerPassword(char* passwordName, char* toAddr, uint64_t _balance){
    u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
PasswordInfo info(passwordName, toAddr, _balance, dipc::timestamp());
    std::string pInfo = info.toJson();
    if (passwordStore.get()[passwordName] != "") {
        DIPC_EMIT_EVENT(ErrEvent, "registerPassword  password exist", passwordName);
        return;
    }
    (*passwordStore)[passwordName] = pInfo;
    print("registerPassword pInfo");
    print(pInfo);
    std::string callerStr = dipc::caller().toString();
    DIPC_EMIT_EVENT(registerPasswordEvent, &callerStr[0], passwordName, &pInfo[0]);
}
CONSTANT char* PasswordManage::queryExistPasswords(){
    u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
std::map<std::string, std::string>::iterator iter;
    auto mapStore = passwordStore.get();
    iter = mapStore.begin();
    std::string result = "[";
    print("queryExistPasswords start");
    while(iter != mapStore.end()){
        result += iter->first + ","; 
        iter++;
    }
    print("queryExistPasswords end");

    result.substr(0,result.size()-1);
    result += "]";
    print("queryExistPasswords  result");
    print(result);
    return &result[0];
}
CONSTANT bool PasswordManage::queryPasswordIsUsed(char* passwordName){
     u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
if (passwordStore.get()[passwordName] != "") {
        return true;
    }
    return false;
}
PAYABLE void PasswordManage::payByPassword(char* passwordName){
    std::string pInfo = passwordStore.get()[passwordName];
    PasswordInfo pwInfo;
    pwInfo.parseJson(pInfo);
    print("pwInfo");
    print(pwInfo.toJson());
    uint64_t transferValue = dipc::callValueUDIP();
    print("transferValue");
    print(transferValue);
    print(pwInfo.balance);
    if(dipc::timestamp() >=  expireTime.get() + pwInfo.timeRegistered){
        DipcAssert(transferValue / 1000 == pwInfo.balance);
        Address toAddr = Address(pwInfo.toAddr,22);
        callTransferUDIP(toAddr, transferValue);
        DIPC_EMIT_EVENT(payByPasswordEvent, passwordName,  transferValue * 1000);
    } else {
        DIPC_EMIT_EVENT(ErrEvent, "payByPassword  password exist", passwordName);
    }
    
    (*passwordStore).erase(passwordName);
    (*passwordStoreHis)[std::string(passwordName)+"_"+pwInfo.toAddr+"_"+std::to_string(pwInfo.timeRegistered)] = pInfo;
}
 
PAYABLE void PasswordManage::depositeContract(){
    uint64_t value = dipc::callValueUDIP() * 1000;
    DIPC_EMIT_EVENT(depositingValue,value);
}
 
EXPORT void PasswordManage::setExpireTime(uint64_t _expireTime){
    
    u256 tempv = dipc::callValue(); 
 DipcAssert( tempv == 0);
*expireTime = _expireTime * 60 * 60 * 1000000000;
    DIPC_EMIT_EVENT(expireTimeSetted,expireTime.get());
}

2019-12-31_16:56:02.416446: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:979] swap src::PasswordManage.cpp tmp::/var/folders/tt/8v4bb03x685c49jk_vkvr7s80000gp/T/5h97327fgggg16af7dii/PasswordManage.cpp
2019-12-31_16:56:02.416457: <debug> [/Users/konggan/workspace/chain/dipperin/github-dipc/dipc/build/tools/dipc-abigen.cpp:983] std::string(res.c_str()) + "/" + abidef_filename      /var/folders/tt/8v4bb03x685c49jk_vkvr7s80000gp/T//PasswordManage.cpp

